// Decompiled with JetBrains decompiler
// Type: Terraria.WorldGen
// Assembly: Terraria, Version=1.4.0.5, Culture=neutral, PublicKeyToken=null
// MVID: 67F9E73E-0A81-4937-A22C-5515CD405A83
// Assembly location: C:\Program Files (x86)\Steam\steamapps\common\Terraria\Terraria.exe

using Microsoft.Xna.Framework;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Threading;
using System.Threading.Tasks;
using Terraria.Audio;
using Terraria.Chat;
using Terraria.DataStructures;
using Terraria.Enums;
using Terraria.GameContent;
using Terraria.GameContent.Achievements;
using Terraria.GameContent.Biomes;
using Terraria.GameContent.Creative;
using Terraria.GameContent.Events;
using Terraria.GameContent.Generation;
using Terraria.GameContent.Tile_Entities;
using Terraria.GameContent.UI.States;
using Terraria.Graphics.Capture;
using Terraria.ID;
using Terraria.IO;
using Terraria.Localization;
using Terraria.Map;
using Terraria.ObjectData;
using Terraria.UI;
using Terraria.Utilities;
using Terraria.WorldBuilding;

namespace Terraria
{
  public class WorldGen
  {
    public static TownRoomManager TownManager = new TownRoomManager();
    private static Queue<Action<StructureMap>> _postGenActions = new Queue<Action<StructureMap>>();
    public static int[] mossType = new int[3];
    public static int copperBar = 20;
    public static int ironBar = 22;
    public static int silverBar = 21;
    public static int goldBar = 19;
    private static ushort crackedType = 481;
    public static int oceanDistance = 250;
    public static int beachDistance = 380;
    public static bool skipDesertTileCheck = false;
    public static ushort mossTile = 179;
    public static ushort mossWall = 54;
    public static bool[] gem = new bool[6];
    public static int[] tileCounts = new int[623];
    public static bool dungeonLake = false;
    private static Vector2[] heartPos = new Vector2[100];
    public static int maxTreeShakes = 200;
    public static int numTreeShakes = 0;
    public static int[] treeShakeX = new int[WorldGen.maxTreeShakes];
    public static int[] treeShakeY = new int[WorldGen.maxTreeShakes];
    public static int[] larvaX = new int[100];
    public static int[] larvaY = new int[100];
    public static bool loadFailed = false;
    public static bool loadSuccess = false;
    public static bool loadBackup = false;
    public static bool AllowedToSpreadInfections = true;
    [ThreadStatic]
    public static int _genRandSeed = -2;
    public static string statusText = "";
    public static int maxTileCount = 3500;
    public static int maxWallOut2 = 5000;
    public static Dictionary<Point, bool> CountedTiles = new Dictionary<Point, bool>(WorldGen.maxTileCount);
    public static int maxRoomTiles = 750;
    public static int[] roomX = new int[WorldGen.maxRoomTiles];
    public static int[] roomY = new int[WorldGen.maxRoomTiles];
    public static int[] roomCeilingX = new int[WorldGen.maxRoomTiles];
    public static int[] roomCeilingY = new int[WorldGen.maxRoomTiles];
    public static bool[] houseTile = new bool[623];
    public static Vector2 lastDungeonHall = Vector2.Zero;
    public static int maxDRooms = 100;
    public static int[] dRoomX = new int[WorldGen.maxDRooms];
    public static int[] dRoomY = new int[WorldGen.maxDRooms];
    public static int[] dRoomSize = new int[WorldGen.maxDRooms];
    private static bool[] dRoomTreasure = new bool[WorldGen.maxDRooms];
    private static int[] dRoomL = new int[WorldGen.maxDRooms];
    private static int[] dRoomR = new int[WorldGen.maxDRooms];
    private static int[] dRoomT = new int[WorldGen.maxDRooms];
    private static int[] dRoomB = new int[WorldGen.maxDRooms];
    private static int[] DDoorX = new int[500];
    private static int[] DDoorY = new int[500];
    private static int[] DDoorPos = new int[500];
    private static int[] dungeonPlatformX = new int[500];
    private static int[] dungeonPlatformY = new int[500];
    private static int[] JChestX = new int[100];
    private static int[] JChestY = new int[100];
    private static bool[] skyLake = new bool[30];
    private static int[] floatingIslandHouseX = new int[30];
    private static int[] floatingIslandHouseY = new int[30];
    private static int[] floatingIslandStyle = new int[30];
    private static int[] mCaveX = new int[30];
    private static int[] mCaveY = new int[30];
    public static int WorldGenParam_Evil = -1;
    private static int maxTunnels = 50;
    private static int[] tunnelX = new int[WorldGen.maxTunnels];
    private static int maxOrePatch = 50;
    private static int[] orePatchX = new int[WorldGen.maxOrePatch];
    private static int maxOasis = 20;
    private static int numOasis = 0;
    private static Vector2[] oasisPosition = new Vector2[WorldGen.maxOasis];
    private static int[] oasisWidth = new int[WorldGen.maxOasis];
    private static int oasisHeight = 20;
    private static int maxMushroomBiomes = 50;
    private static int numMushroomBiomes = 0;
    private static Vector2[] mushroomBiomesPosition = new Vector2[WorldGen.maxMushroomBiomes];
    private static int maxLakes = 50;
    private static int numLakes = 0;
    private static int[] LakeX = new int[WorldGen.maxLakes];
    private static int maxOceanCaveTreasure = 2;
    private static int numOceanCaveTreasure = 0;
    private static Point[] oceanCaveTreasure = new Point[WorldGen.maxOceanCaveTreasure];
    private static int cactusWaterWidth = 50;
    private static int cactusWaterHeight = 25;
    private static int cactusWaterLimit = 25;
    private static int[] hellChestItem = new int[7];
    public static List<int> StatuesWithTraps = new List<int>((IEnumerable<int>) new int[4]
    {
      4,
      7,
      10,
      18
    });
    public static Microsoft.Xna.Framework.Rectangle UndergroundDesertLocation = Microsoft.Xna.Framework.Rectangle.Empty;
    public static Microsoft.Xna.Framework.Rectangle UndergroundDesertHiveLocation = Microsoft.Xna.Framework.Rectangle.Empty;
    public static MysticLogFairiesEvent mysticLogsEvent = new MysticLogFairiesEvent();
    public static TownNPCRoomCheckFailureReason roomCheckFailureReason = TownNPCRoomCheckFailureReason.None;
    public static bool generatingWorld = false;
    private static int[,] trapDiag = new int[4, 2];
    private static int tileCounterMax = 20;
    private static int[] tileCounterX = new int[WorldGen.tileCounterMax];
    private static int[] tileCounterY = new int[WorldGen.tileCounterMax];
    public static int SmallConsecutivesFound = 0;
    public static int SmallConsecutivesEliminated = 0;
    public static bool drunkWorldGen = false;
    public static bool getGoodWorldGen = false;
    public static bool drunkWorldGenText = false;
    public static bool placingTraps = false;
    public static bool notTheBees = false;
    private static int catTailDistance = 8;
    public static TreeTopsInfo TreeTops = new TreeTopsInfo();
    public static BackgroundChangeFlashInfo BackgroundsCache = new BackgroundChangeFlashInfo();
    private static bool fossilBreak = false;
    private static bool skipFramingDuringGen = false;
    private static int lAltarX;
    private static int lAltarY;
    public static int tileReframeCount;
    public static bool noMapUpdate;
    public static double worldSurfaceLow;
    public static int tLeft;
    public static int tRight;
    public static int tTop;
    public static int tBottom;
    public static int tRooms;
    public static ushort neonMossType;
    private const int NUM_SEASHELL_STYLES = 2;
    public static int treeBG1;
    public static int treeBG2;
    public static int treeBG3;
    public static int treeBG4;
    public static int corruptBG;
    public static int jungleBG;
    public static int snowBG;
    public static int hallowBG;
    public static int crimsonBG;
    public static int desertBG;
    public static int oceanBG;
    public static int mushroomBG;
    public static int underworldBG;
    public static bool crimson;
    public static int totalEvil;
    public static int totalBlood;
    public static int totalGood;
    public static int totalSolid;
    public static int totalEvil2;
    public static int totalBlood2;
    public static int totalGood2;
    public static int totalSolid2;
    public static byte tEvil;
    public static byte tBlood;
    public static byte tGood;
    public static string currentWorldSeed;
    public static int totalX;
    public static int totalD;
    public static bool IsGeneratingHardMode;
    private static int heartCount;
    public static int lavaLine;
    public static int waterLine;
    public static bool noTileActions;
    public static bool spawnEye;
    public static int spawnHardBoss;
    public static int numLarva;
    public static volatile bool gen;
    public static bool shadowOrbSmashed;
    public static int shadowOrbCount;
    public static int altarCount;
    public static bool spawnMeteor;
    public static bool worldCleared;
    public static bool worldBackup;
    private static int lastMaxTilesX;
    private static int lastMaxTilesY;
    private static bool mergeUp;
    private static bool mergeDown;
    private static bool mergeLeft;
    private static bool mergeRight;
    private static bool stopDrops;
    public static bool mudWall;
    private static int grassSpread;
    public static bool noLiquidCheck;
    [ThreadStatic]
    public static UnifiedRandom _genRand;
    public static int _lastSeed;
    public static bool destroyObject;
    public static int spawnDelay;
    public static int prioritizedTownNPCType;
    public static int numTileCount;
    public static int lavaCount;
    public static int iceCount;
    public static int rockCount;
    public static int shroomCount;
    public static int numRoomTiles;
    public static int roomCeilingsCount;
    public static int roomX1;
    public static int roomX2;
    public static int roomY1;
    public static int roomY2;
    public static bool canSpawn;
    public static int bestX;
    public static int bestY;
    public static int hiScore;
    public static int dungeonX;
    public static int dungeonY;
    public static int numDRooms;
    private static int numDDoors;
    private static int numDungeonPlatforms;
    private static bool generatedShadowKey;
    private static int JungleItemCount;
    private static int numJChests;
    public static int dEnteranceX;
    public static bool dSurface;
    private static double dxStrength1;
    private static double dyStrength1;
    private static double dxStrength2;
    private static double dyStrength2;
    private static int dMinX;
    private static int dMaxX;
    private static int dMinY;
    private static int dMaxY;
    private static int numIslandHouses;
    private static int houseCount;
    private static int numMCaves;
    private static int numTunnels;
    private static int numOrePatch;
    private static int JungleX;
    private static int hellChest;
    private static bool roomTorch;
    private static bool roomDoor;
    private static bool roomChair;
    private static bool roomTable;
    private static bool roomOccupied;
    private static bool roomEvil;
    public static Point16[] statueList;
    private static bool currentlyTryingToUseAlternateHousingSpot;
    private static int sharedRoomX;
    private static int tileCounterNum;
    private static WorldGenerator _generator;
    public const bool USE_FRAMING_SKIP_FOR_UNIMPORTANT_TILES_IN_WORLDGEN = false;
    private const bool BUBBLES_SOLID_STATE_FOR_HOUSING = true;

    public static UnifiedRandom genRand
    {
      get
      {
        if (WorldGen._lastSeed != WorldGen._genRandSeed)
        {
          WorldGen._genRand = new UnifiedRandom(WorldGen._lastSeed);
          WorldGen._genRandSeed = WorldGen._lastSeed;
        }
        if (WorldGen._genRand == null)
        {
          WorldGen._genRand = new UnifiedRandom(WorldGen._lastSeed);
          WorldGen._genRandSeed = WorldGen._lastSeed;
        }
        return WorldGen._genRand;
      }
    }

    public static void SetupStatueList()
    {
      List<Point16> point16List = new List<Point16>();
      for (int Y = 0; Y < 44; ++Y)
        point16List.Add(new Point16(105, Y));
      point16List[34] = new Point16(349, 0);
      point16List[43] = new Point16(105, 50);
      point16List.Add(new Point16(105, 63));
      point16List.Add(new Point16(105, 64));
      point16List.Add(new Point16(105, 65));
      point16List.Add(new Point16(105, 66));
      point16List.Add(new Point16(105, 68));
      point16List.Add(new Point16(105, 69));
      point16List.Add(new Point16(105, 70));
      point16List.Add(new Point16(105, 71));
      point16List.Add(new Point16(105, 72));
      point16List.Add(new Point16(105, 73));
      point16List.Add(new Point16(105, 75));
      point16List.Add(new Point16(105, 51));
      point16List.Add(new Point16(105, 52));
      point16List.Add(new Point16(105, 53));
      point16List.Add(new Point16(105, 54));
      point16List.Add(new Point16(105, 55));
      point16List.Add(new Point16(105, 56));
      point16List.Add(new Point16(105, 57));
      point16List.Add(new Point16(105, 58));
      point16List.Add(new Point16(105, 59));
      point16List.Add(new Point16(105, 60));
      point16List.Add(new Point16(105, 61));
      point16List.Add(new Point16(105, 62));
      point16List.Add(new Point16(105, 77));
      point16List.Add(new Point16(105, 78));
      if (Main.expertMode)
      {
        point16List.Add(new Point16(105, 67));
        point16List.Add(new Point16(105, 74));
      }
      WorldGen.statueList = point16List.ToArray();
    }

    public static void PlaceStatueTrap(int x, int y)
    {
      for (int index1 = -10; index1 <= 10; ++index1)
      {
        for (int index2 = -10; index2 <= 10; ++index2)
        {
          Tile testTile = Main.tile[x + index1, y + index2 + 1];
          Tile tile = Main.tile[x + index1, y + index2];
          if (!tile.active() && WorldGen.SolidTile2(testTile))
          {
            WorldGen.PlaceTile(x + index1, y + index2, 135, true, false, -1, 0);
            if (tile.active() && tile.type == (ushort) 135)
            {
              WorldUtils.WireLine(new Point(x, y), new Point(x + index1, y + index2));
              return;
            }
          }
        }
      }
    }

    public static bool EmptyLiquid(int x, int y)
    {
      if (!WorldGen.InWorld(x, y, 0))
        return false;
      Tile tile = Main.tile[x, y];
      if (tile == null)
        return false;
      int num = (int) tile.liquidType();
      if (tile.nactive() && Main.tileSolid[(int) tile.type] && !Main.tileSolidTop[(int) tile.type])
        return false;
      tile.Clear(TileDataType.Liquid);
      WorldGen.SquareTileFrame(x, y, false);
      if (Main.netMode == 1)
        NetMessage.sendWater(x, y);
      else
        Liquid.AddWater(x, y);
      return true;
    }

    public static bool PlaceLiquid(int x, int y, byte liquidType, byte amount)
    {
      if (!WorldGen.InWorld(x, y, 0))
        return false;
      Tile tile = Main.tile[x, y];
      if (tile == null)
        return false;
      byte num1 = tile.liquidType();
      if (tile.nactive() && Main.tileSolid[(int) tile.type] && !Main.tileSolidTop[(int) tile.type])
        return false;
      if (tile.liquid == (byte) 0 || (int) liquidType == (int) num1)
      {
        tile.liquidType((int) liquidType);
        if ((int) amount + (int) tile.liquid > (int) byte.MaxValue)
          amount = (byte) ((uint) byte.MaxValue - (uint) tile.liquid);
        tile.liquid += amount;
        WorldGen.SquareTileFrame(x, y, true);
        if (Main.netMode != 0)
          NetMessage.sendWater(x, y);
        return true;
      }
      ushort num2 = 0;
      if (liquidType == (byte) 0 && num1 == (byte) 1 || liquidType == (byte) 1 && num1 == (byte) 0)
        num2 = (ushort) 56;
      else if (liquidType == (byte) 0 && num1 == (byte) 2 || liquidType == (byte) 2 && num1 == (byte) 0)
        num2 = (ushort) 229;
      else if (liquidType == (byte) 1 && num1 == (byte) 2 || liquidType == (byte) 2 && num1 == (byte) 1)
        num2 = (ushort) 230;
      if (num2 == (ushort) 0)
        return false;
      tile.liquid = (byte) 0;
      tile.liquidType(0);
      WorldGen.PlaceTile(x, y, (int) num2, true, false, -1, 0);
      WorldGen.SquareTileFrame(x, y, true);
      if (Main.netMode != 0)
        NetMessage.SendTileSquare(-1, x - 1, y - 1, 3, num2 == (ushort) 56 ? TileChangeType.LavaWater : TileChangeType.HoneyLava);
      return true;
    }

    public static bool MoveTownNPC(int x, int y, int n)
    {
      if (!WorldGen.StartRoomCheck(x, y))
      {
        string textValue = Lang.inter[40].Value;
        switch (WorldGen.roomCheckFailureReason)
        {
          case TownNPCRoomCheckFailureReason.TooCloseToWorldEdge:
            textValue = Language.GetTextValue("TownNPCHousingFailureReasons.TooCloseToWorldEdge");
            break;
          case TownNPCRoomCheckFailureReason.RoomIsTooBig:
            textValue = Language.GetTextValue("TownNPCHousingFailureReasons.RoomIsTooBig");
            break;
          case TownNPCRoomCheckFailureReason.RoomIsTooSmall:
            textValue = Language.GetTextValue("TownNPCHousingFailureReasons.RoomIsTooSmall");
            break;
          case TownNPCRoomCheckFailureReason.HoleInWallIsTooBig:
            textValue = Language.GetTextValue("TownNPCHousingFailureReasons.HoleInWallIsTooBig");
            break;
          case TownNPCRoomCheckFailureReason.RoomCheckStartedInASolidTile:
            textValue = Language.GetTextValue("TownNPCHousingFailureReasons.RoomCheckStartedInASolidTile");
            break;
        }
        Main.NewText(textValue, byte.MaxValue, (byte) 240, (byte) 20);
        return false;
      }
      if (!WorldGen.RoomNeeds(WorldGen.prioritizedTownNPCType))
      {
        int index = 0;
        int length = (WorldGen.roomTorch ? 0 : 1) + (WorldGen.roomDoor ? 0 : 1) + (WorldGen.roomTable ? 0 : 1) + (WorldGen.roomChair ? 0 : 1);
        string[] strArray = new string[length];
        if (!WorldGen.roomTorch)
        {
          strArray[index] = Language.GetTextValue("Game.HouseLightSource");
          ++index;
        }
        if (!WorldGen.roomDoor)
        {
          strArray[index] = Language.GetTextValue("Game.HouseDoor");
          ++index;
        }
        if (!WorldGen.roomTable)
        {
          strArray[index] = Language.GetTextValue("Game.HouseTable");
          ++index;
        }
        if (!WorldGen.roomChair)
        {
          strArray[index] = Language.GetTextValue("Game.HouseChair");
          int num = index + 1;
        }
        Main.NewText(Language.GetTextValue("Game.HouseMissing_" + (object) length, (object[]) strArray), byte.MaxValue, (byte) 240, (byte) 20);
        return false;
      }
      int npcTypeAskingToScoreRoom = WorldGen.prioritizedTownNPCType;
      if (n >= 0)
        npcTypeAskingToScoreRoom = Main.npc[n].type;
      WorldGen.ScoreRoom(-1, npcTypeAskingToScoreRoom);
      if (WorldGen.hiScore <= 0)
      {
        if (WorldGen.roomOccupied)
          Main.NewText(Lang.inter[41].Value, byte.MaxValue, (byte) 240, (byte) 20);
        else if (WorldGen.roomEvil)
          Main.NewText(Lang.inter[42].Value, byte.MaxValue, (byte) 240, (byte) 20);
        else
          Main.NewText(Lang.inter[40].Value, byte.MaxValue, (byte) 240, (byte) 20);
        return false;
      }
      if (n < 0 || WorldGen.CheckSpecialTownNPCSpawningConditions(Main.npc[n].type))
        return true;
      Main.NewText(Lang.inter[55].Value + " " + Main.npc[n].TypeName, byte.MaxValue, (byte) 240, (byte) 20);
      return false;
    }

    public static void moveRoom(int x, int y, int n)
    {
      if (Main.netMode == 1)
      {
        NetMessage.SendData(60, -1, -1, (NetworkText) null, n, (float) x, (float) y, 0.0f, 0, 0, 0);
      }
      else
      {
        WorldGen.prioritizedTownNPCType = Main.npc[n].type;
        Main.npc[n].homeless = true;
        int num = (int) WorldGen.SpawnTownNPC(x, y);
        WorldGen.TownManager.SetRoom(Main.npc[n].type, Main.npc[n].homeTileX, Main.npc[n].homeTileY);
      }
    }

    public static bool IsNPCEvictable(int n)
    {
      if (n < 0)
        return false;
      Microsoft.Xna.Framework.Rectangle hitbox = Main.LocalPlayer.Hitbox;
      hitbox.Inflate(Main.LogicCheckScreenWidth / 2, Main.LogicCheckScreenHeight / 2);
      NPC npc = Main.npc[n];
      Microsoft.Xna.Framework.Rectangle rectangle = new Microsoft.Xna.Framework.Rectangle(npc.homeTileX * 16, npc.homeTileY * 16, 16, 16);
      return hitbox.Intersects(rectangle);
    }

    public static void kickOut(int n)
    {
      if (Main.netMode == 1)
      {
        NetMessage.SendData(60, -1, -1, (NetworkText) null, n, 0.0f, 0.0f, 1f, 0, 0, 0);
      }
      else
      {
        Main.npc[n].homeless = true;
        WorldGen.TownManager.KickOut(Main.npc[n]);
      }
    }

    public static bool IsThereASpawnablePrioritizedTownNPC(
      int x,
      int y,
      ref bool canSpawnNewTownNPC)
    {
      if (WorldGen.CheckSpecialTownNPCSpawningConditions(WorldGen.prioritizedTownNPCType) && NPC.AnyNPCs(WorldGen.prioritizedTownNPCType))
      {
        canSpawnNewTownNPC = false;
        return true;
      }
      List<int> occupantsList = new List<int>();
      WorldGen.TownManager.AddOccupantsToList(x, y, occupantsList);
      for (int index1 = 0; index1 < occupantsList.Count; ++index1)
      {
        int index2 = occupantsList[index1];
        if (Main.townNPCCanSpawn[index2] && !NPC.AnyNPCs(index2) && WorldGen.CheckSpecialTownNPCSpawningConditions(index2))
        {
          WorldGen.prioritizedTownNPCType = index2;
          canSpawnNewTownNPC = true;
          return true;
        }
      }
      for (int index = 0; index < 663; ++index)
      {
        if (Main.townNPCCanSpawn[index] && WorldGen.CheckSpecialTownNPCSpawningConditions(index))
        {
          if (NPC.AnyNPCs(index))
          {
            Main.townNPCCanSpawn[index] = false;
          }
          else
          {
            if (WorldGen.TownManager.HasRoomQuick(index))
            {
              WorldGen.prioritizedTownNPCType = index;
              canSpawnNewTownNPC = true;
              return true;
            }
            if (!NPCID.Sets.IsTownPet[WorldGen.prioritizedTownNPCType] || NPCID.Sets.IsTownPet[index])
            {
              WorldGen.prioritizedTownNPCType = index;
              canSpawnNewTownNPC = true;
              return true;
            }
          }
        }
      }
      return false;
    }

    public static bool IsThereASpawnablePrioritizedTownNPC_Old(int x, int y)
    {
      if (WorldGen.CheckSpecialTownNPCSpawningConditions(WorldGen.prioritizedTownNPCType) && NPC.AnyNPCs(WorldGen.prioritizedTownNPCType))
        return true;
      List<int> occupantsList = new List<int>();
      WorldGen.TownManager.AddOccupantsToList(x, y, occupantsList);
      for (int index1 = 0; index1 < occupantsList.Count; ++index1)
      {
        int index2 = occupantsList[index1];
        if (Main.townNPCCanSpawn[index2] && !NPC.AnyNPCs(index2) && WorldGen.CheckSpecialTownNPCSpawningConditions(index2))
        {
          WorldGen.prioritizedTownNPCType = index2;
          return true;
        }
      }
      int num = -1;
      for (int index = 0; index < 663; ++index)
      {
        if (Main.townNPCCanSpawn[index] && WorldGen.CheckSpecialTownNPCSpawningConditions(index))
        {
          if (NPC.AnyNPCs(index))
            Main.townNPCCanSpawn[index] = false;
          else if (WorldGen.TownManager.HasRoomQuick(index))
          {
            if (num == -1)
              num = index;
          }
          else if (!NPCID.Sets.IsTownPet[WorldGen.prioritizedTownNPCType] || NPCID.Sets.IsTownPet[index])
          {
            WorldGen.prioritizedTownNPCType = index;
            return true;
          }
        }
      }
      if (num == -1)
        return false;
      WorldGen.prioritizedTownNPCType = num;
      return true;
    }

    public static bool CheckSpecialTownNPCSpawningConditions(int type)
    {
      if (type != 160)
        return true;
      if ((double) WorldGen.roomY2 > Main.worldSurface)
        return false;
      int num1 = 0;
      int num2 = WorldGen.roomX1 - Main.buffScanAreaWidth / 2 / 16 - 1 - Lighting.OffScreenTiles;
      int num3 = WorldGen.roomX2 + Main.buffScanAreaWidth / 2 / 16 + 1 + Lighting.OffScreenTiles;
      int num4 = WorldGen.roomY1 - Main.buffScanAreaHeight / 2 / 16 - 1 - Lighting.OffScreenTiles;
      int num5 = WorldGen.roomY2 + Main.buffScanAreaHeight / 2 / 16 + 1 + Lighting.OffScreenTiles;
      if (num2 < 0)
        num2 = 0;
      if (num3 >= Main.maxTilesX)
        num3 = Main.maxTilesX - 1;
      if (num4 < 0)
        num4 = 0;
      if (num5 >= Main.maxTilesY)
        num5 = Main.maxTilesY - 1;
      for (int index1 = num2 + 1; index1 < num3; ++index1)
      {
        for (int index2 = num4 + 2; index2 < num5 + 2; ++index2)
        {
          Tile tile = Main.tile[index1, index2];
          if (tile.active() && (tile.type == (ushort) 70 || tile.type == (ushort) 71 || (tile.type == (ushort) 72 || tile.type == (ushort) 528)))
            ++num1;
        }
      }
      return num1 >= SceneMetrics.MushroomTileThreshold;
    }

    public static void UnspawnTravelNPC()
    {
      int number = -1;
      for (int index = 0; index < 200; ++index)
      {
        if (Main.npc[index].active && Main.npc[index].type == 368)
        {
          number = index;
          break;
        }
      }
      if (number < 0)
        return;
      int num1 = (int) ((double) Main.npc[number].Center.X / 16.0);
      int num2 = (int) ((double) Main.npc[number].Center.Y / 16.0);
      bool flag = true;
      Microsoft.Xna.Framework.Rectangle rectangle = new Microsoft.Xna.Framework.Rectangle(num1 * 16 + 8 - NPC.sWidth / 2 - NPC.safeRangeX, num2 * 16 + 8 - NPC.sHeight / 2 - NPC.safeRangeY, NPC.sWidth + NPC.safeRangeX * 2, NPC.sHeight + NPC.safeRangeY * 2);
      for (int index = 0; index < (int) byte.MaxValue; ++index)
      {
        if (Main.player[index].active && new Microsoft.Xna.Framework.Rectangle((int) Main.player[index].position.X, (int) Main.player[index].position.Y, Main.player[index].width, Main.player[index].height).Intersects(rectangle))
        {
          flag = false;
          break;
        }
      }
      if (!flag)
        return;
      string fullName = Main.npc[number].FullName;
      switch (Main.netMode)
      {
        case 0:
          Main.NewText(Lang.misc[35].Format((object) fullName), (byte) 50, (byte) 125, byte.MaxValue);
          break;
        case 2:
          ChatHelper.BroadcastChatMessage(NetworkText.FromKey(Lang.misc[35].Key, (object) Main.npc[number].GetFullNetName()), new Color(50, 125, (int) byte.MaxValue), -1);
          break;
      }
      Main.npc[number].active = false;
      Main.npc[number].netSkip = -1;
      Main.npc[number].life = 0;
      NetMessage.SendData(23, -1, -1, (NetworkText) null, number, 0.0f, 0.0f, 0.0f, 0, 0, 0);
    }

    public static void SpawnTravelNPC()
    {
      if (Main.eclipse || !Main.dayTime || Main.invasionType > 0 && Main.invasionDelay == 0 && Main.invasionSize > 0)
        return;
      for (int index = 0; index < 200; ++index)
      {
        if (Main.npc[index].active && Main.npc[index].type == 368)
          return;
      }
      Chest.SetupTravelShop();
      NetMessage.SendTravelShop(-1);
      int[] numArray = new int[200];
      int maxValue = 0;
      for (int index = 0; index < 200; ++index)
      {
        if (Main.npc[index].active && Main.npc[index].townNPC && (Main.npc[index].type != 37 && !Main.npc[index].homeless))
        {
          numArray[maxValue] = index;
          ++maxValue;
        }
      }
      if (maxValue == 0)
        return;
      int index1 = numArray[Main.rand.Next(maxValue)];
      WorldGen.bestX = Main.npc[index1].homeTileX;
      WorldGen.bestY = Main.npc[index1].homeTileY;
      int minValue = WorldGen.bestX;
      int num1 = WorldGen.bestX;
      int bestY = WorldGen.bestY;
      for (int bestX = WorldGen.bestX; bestX > WorldGen.bestX - 10 && (WorldGen.SolidTile(bestX, bestY, false) || Main.tileSolidTop[(int) Main.tile[bestX, bestY].type]) && (!Main.tile[bestX, bestY - 1].active() || !Main.tileSolid[(int) Main.tile[bestX, bestY - 1].type] || Main.tileSolidTop[(int) Main.tile[bestX, bestY - 1].type]) && ((!Main.tile[bestX, bestY - 2].active() || !Main.tileSolid[(int) Main.tile[bestX, bestY - 2].type] || Main.tileSolidTop[(int) Main.tile[bestX, bestY - 2].type]) && (!Main.tile[bestX, bestY - 3].active() || !Main.tileSolid[(int) Main.tile[bestX, bestY - 3].type] || Main.tileSolidTop[(int) Main.tile[bestX, bestY - 3].type])); --bestX)
        minValue = bestX;
      for (int bestX = WorldGen.bestX; bestX < WorldGen.bestX + 10 && (WorldGen.SolidTile(bestX, bestY, false) || Main.tileSolidTop[(int) Main.tile[bestX, bestY].type]) && (!Main.tile[bestX, bestY - 1].active() || !Main.tileSolid[(int) Main.tile[bestX, bestY - 1].type] || Main.tileSolidTop[(int) Main.tile[bestX, bestY - 1].type]) && ((!Main.tile[bestX, bestY - 2].active() || !Main.tileSolid[(int) Main.tile[bestX, bestY - 2].type] || Main.tileSolidTop[(int) Main.tile[bestX, bestY - 2].type]) && (!Main.tile[bestX, bestY - 3].active() || !Main.tileSolid[(int) Main.tile[bestX, bestY - 3].type] || Main.tileSolidTop[(int) Main.tile[bestX, bestY - 3].type])); ++bestX)
        num1 = bestX;
      for (int index2 = 0; index2 < 30; ++index2)
      {
        int num2 = Main.rand.Next(minValue, num1 + 1);
        if (index2 < 20)
        {
          if (num2 < WorldGen.bestX - 1 || num2 > WorldGen.bestX + 1)
          {
            WorldGen.bestX = num2;
            break;
          }
        }
        else if (num2 != WorldGen.bestX)
        {
          WorldGen.bestX = num2;
          break;
        }
      }
      int index3 = WorldGen.bestX;
      int index4 = WorldGen.bestY;
      bool flag = false;
      if (!flag && (double) index4 <= Main.worldSurface)
      {
        for (int index2 = 20; index2 < 500; ++index2)
        {
          for (int index5 = 0; index5 < 2; ++index5)
          {
            index3 = index5 != 0 ? WorldGen.bestX - index2 * 2 : WorldGen.bestX + index2 * 2;
            if (index3 > 10 && index3 < Main.maxTilesX - 10)
            {
              int num2 = WorldGen.bestY - index2;
              double num3 = (double) (WorldGen.bestY + index2);
              if (num2 < 10)
                num2 = 10;
              if (num3 > Main.worldSurface)
                num3 = Main.worldSurface;
              for (int index6 = num2; (double) index6 < num3; ++index6)
              {
                index4 = index6;
                if (Main.tile[index3, index4].nactive() && Main.tileSolid[(int) Main.tile[index3, index4].type])
                {
                  if (Main.tile[index3, index4 - 3].liquid == (byte) 0 && Main.tile[index3, index4 - 2].liquid == (byte) 0 && (Main.tile[index3, index4 - 1].liquid == (byte) 0 && !Collision.SolidTiles(index3 - 1, index3 + 1, index4 - 3, index4 - 1)))
                  {
                    flag = true;
                    Microsoft.Xna.Framework.Rectangle rectangle = new Microsoft.Xna.Framework.Rectangle(index3 * 16 + 8 - NPC.sWidth / 2 - NPC.safeRangeX, index4 * 16 + 8 - NPC.sHeight / 2 - NPC.safeRangeY, NPC.sWidth + NPC.safeRangeX * 2, NPC.sHeight + NPC.safeRangeY * 2);
                    for (int index7 = 0; index7 < (int) byte.MaxValue; ++index7)
                    {
                      if (Main.player[index7].active && new Microsoft.Xna.Framework.Rectangle((int) Main.player[index7].position.X, (int) Main.player[index7].position.Y, Main.player[index7].width, Main.player[index7].height).Intersects(rectangle))
                      {
                        flag = false;
                        break;
                      }
                    }
                    break;
                  }
                  break;
                }
              }
            }
            if (flag)
              break;
          }
          if (flag)
            break;
        }
      }
      int index8 = NPC.NewNPC(index3 * 16, index4 * 16, 368, 1, 0.0f, 0.0f, 0.0f, 0.0f, (int) byte.MaxValue);
      Main.npc[index8].homeTileX = WorldGen.bestX;
      Main.npc[index8].homeTileY = WorldGen.bestY;
      Main.npc[index8].homeless = true;
      if (index3 < WorldGen.bestX)
        Main.npc[index8].direction = 1;
      else if (index3 > WorldGen.bestX)
        Main.npc[index8].direction = -1;
      Main.npc[index8].netUpdate = true;
      string fullName = Main.npc[index8].FullName;
      if (Main.netMode == 0)
      {
        Main.NewText(Language.GetTextValue("Announcement.HasArrived", (object) fullName), (byte) 50, (byte) 125, byte.MaxValue);
      }
      else
      {
        if (Main.netMode != 2)
          return;
        ChatHelper.BroadcastChatMessage(NetworkText.FromKey("Announcement.HasArrived", (object) Main.npc[index8].GetFullNetName()), new Color(50, 125, (int) byte.MaxValue), -1);
      }
    }

    public static TownNPCSpawnResult SpawnTownNPC(int x, int y)
    {
      if (Main.wallHouse[(int) Main.tile[x, y].wall])
        WorldGen.canSpawn = true;
      if (!WorldGen.canSpawn || !WorldGen.StartRoomCheck(x, y) || !WorldGen.RoomNeeds(WorldGen.prioritizedTownNPCType))
        return TownNPCSpawnResult.Blocked;
      int ahomelessNpc = WorldGen.FindAHomelessNPC();
      int npcTypeAskingToScoreRoom = WorldGen.prioritizedTownNPCType;
      if (ahomelessNpc != -1)
        npcTypeAskingToScoreRoom = Main.npc[ahomelessNpc].type;
      WorldGen.ScoreRoom(-1, npcTypeAskingToScoreRoom);
      if (WorldGen.hiScore <= 0)
        return TownNPCSpawnResult.Blocked;
      bool canSpawnNewTownNPC = true;
      if (!WorldGen.IsThereASpawnablePrioritizedTownNPC(WorldGen.bestX, WorldGen.bestY, ref canSpawnNewTownNPC))
        return TownNPCSpawnResult.Blocked;
      int prioritizedTownNpcType1 = WorldGen.prioritizedTownNPCType;
      if (ahomelessNpc != -1)
      {
        Main.townNPCCanSpawn[WorldGen.prioritizedTownNPCType] = false;
        Main.npc[ahomelessNpc].homeTileX = WorldGen.bestX;
        Main.npc[ahomelessNpc].homeTileY = WorldGen.bestY;
        Main.npc[ahomelessNpc].homeless = false;
        AchievementsHelper.NotifyProgressionEvent(8);
        WorldGen.prioritizedTownNPCType = 0;
        return TownNPCSpawnResult.RelocatedHomeless;
      }
      if (canSpawnNewTownNPC && ahomelessNpc == -1)
      {
        Point roomPosition;
        if (WorldGen.TownManager.HasRoom(prioritizedTownNpcType1, out roomPosition) && !WorldGen.currentlyTryingToUseAlternateHousingSpot)
        {
          int bestX = WorldGen.bestX;
          int bestY = WorldGen.bestY;
          WorldGen.currentlyTryingToUseAlternateHousingSpot = true;
          TownNPCSpawnResult townNpcSpawnResult = WorldGen.SpawnTownNPC(roomPosition.X, roomPosition.Y - 2);
          WorldGen.currentlyTryingToUseAlternateHousingSpot = false;
          WorldGen.bestX = bestX;
          WorldGen.bestY = bestY;
          if (townNpcSpawnResult == TownNPCSpawnResult.Successful)
            return townNpcSpawnResult;
        }
        int spawnTileX = WorldGen.bestX;
        int spawnTileY = WorldGen.bestY;
        int prioritizedTownNpcType2 = WorldGen.prioritizedTownNPCType;
        if (WorldGen.IsRoomConsideredAlreadyOccupied(spawnTileX, spawnTileY, prioritizedTownNpcType2))
          return TownNPCSpawnResult.BlockedInfiHousing;
        bool flag = false;
        if (!flag)
        {
          flag = true;
          Microsoft.Xna.Framework.Rectangle rectangle = new Microsoft.Xna.Framework.Rectangle(spawnTileX * 16 + 8 - NPC.sWidth / 2 - NPC.safeRangeX, spawnTileY * 16 + 8 - NPC.sHeight / 2 - NPC.safeRangeY, NPC.sWidth + NPC.safeRangeX * 2, NPC.sHeight + NPC.safeRangeY * 2);
          for (int index = 0; index < (int) byte.MaxValue; ++index)
          {
            if (Main.player[index].active && new Microsoft.Xna.Framework.Rectangle((int) Main.player[index].position.X, (int) Main.player[index].position.Y, Main.player[index].width, Main.player[index].height).Intersects(rectangle))
            {
              flag = false;
              break;
            }
          }
        }
        if (!flag && (double) spawnTileY <= Main.worldSurface)
        {
          for (int index1 = 1; index1 < 500; ++index1)
          {
            for (int index2 = 0; index2 < 2; ++index2)
            {
              spawnTileX = index2 != 0 ? WorldGen.bestX - index1 : WorldGen.bestX + index1;
              if (spawnTileX > 10 && spawnTileX < Main.maxTilesX - 10)
              {
                int num1 = WorldGen.bestY - index1;
                double num2 = (double) (WorldGen.bestY + index1);
                if (num1 < 10)
                  num1 = 10;
                if (num2 > Main.worldSurface)
                  num2 = Main.worldSurface;
                for (int index3 = num1; (double) index3 < num2; ++index3)
                {
                  spawnTileY = index3;
                  if (Main.tile[spawnTileX, spawnTileY].nactive() && Main.tileSolid[(int) Main.tile[spawnTileX, spawnTileY].type])
                  {
                    if (!Collision.SolidTiles(spawnTileX - 1, spawnTileX + 1, spawnTileY - 3, spawnTileY - 1))
                    {
                      flag = true;
                      Microsoft.Xna.Framework.Rectangle rectangle = new Microsoft.Xna.Framework.Rectangle(spawnTileX * 16 + 8 - NPC.sWidth / 2 - NPC.safeRangeX, spawnTileY * 16 + 8 - NPC.sHeight / 2 - NPC.safeRangeY, NPC.sWidth + NPC.safeRangeX * 2, NPC.sHeight + NPC.safeRangeY * 2);
                      for (int index4 = 0; index4 < (int) byte.MaxValue; ++index4)
                      {
                        if (Main.player[index4].active && new Microsoft.Xna.Framework.Rectangle((int) Main.player[index4].position.X, (int) Main.player[index4].position.Y, Main.player[index4].width, Main.player[index4].height).Intersects(rectangle))
                        {
                          flag = false;
                          break;
                        }
                      }
                      break;
                    }
                    break;
                  }
                }
              }
              if (flag)
                break;
            }
            if (flag)
              break;
          }
        }
        int index5 = NPC.NewNPC(spawnTileX * 16, spawnTileY * 16, prioritizedTownNpcType1, 1, 0.0f, 0.0f, 0.0f, 0.0f, (int) byte.MaxValue);
        Main.townNPCCanSpawn[prioritizedTownNpcType1] = false;
        Main.npc[index5].homeTileX = WorldGen.bestX;
        Main.npc[index5].homeTileY = WorldGen.bestY;
        if (spawnTileX < WorldGen.bestX)
          Main.npc[index5].direction = 1;
        else if (spawnTileX > WorldGen.bestX)
          Main.npc[index5].direction = -1;
        Main.npc[index5].netUpdate = true;
        string fullName = Main.npc[index5].FullName;
        switch (Main.netMode)
        {
          case 0:
            Main.NewText(Language.GetTextValue("Announcement.HasArrived", (object) fullName), (byte) 50, (byte) 125, byte.MaxValue);
            break;
          case 2:
            ChatHelper.BroadcastChatMessage(NetworkText.FromKey("Announcement.HasArrived", (object) Main.npc[index5].GetFullNetName()), new Color(50, 125, (int) byte.MaxValue), -1);
            break;
        }
        AchievementsHelper.NotifyProgressionEvent(8);
        if (Main.npc[index5].type == 160)
          AchievementsHelper.NotifyProgressionEvent(18);
        WorldGen.CheckAchievement_RealEstate();
        WorldGen.prioritizedTownNPCType = 0;
      }
      return TownNPCSpawnResult.Successful;
    }

    private static int FindAHomelessNPC()
    {
      int num = -1;
      for (int index = 0; index < 200; ++index)
      {
        if (Main.npc[index].active && Main.npc[index].homeless && (Main.npc[index].type == WorldGen.prioritizedTownNPCType && WorldGen.CheckSpecialTownNPCSpawningConditions(Main.npc[index].type)))
        {
          num = index;
          break;
        }
      }
      return num;
    }

    private static bool IsRoomConsideredAlreadyOccupied(
      int spawnTileX,
      int spawnTileY,
      int npcTypeToSpawn)
    {
      bool flag = false;
      for (int index = 0; index < 200; ++index)
      {
        NPC npc2 = Main.npc[index];
        if (npc2.active && npc2.townNPC && (!npc2.homeless && npc2.homeTileX == spawnTileX) && (npc2.homeTileY == spawnTileY && !WorldGen.TownManager.CanNPCsLiveWithEachOther(npcTypeToSpawn, npc2)))
        {
          flag = true;
          break;
        }
      }
      return flag;
    }

    public static void CheckAchievement_RealEstate()
    {
      bool[] flagArray = new bool[663];
      for (int index = 0; index < 200; ++index)
      {
        if (Main.npc[index].active && Main.npc[index].type >= 0 && Main.npc[index].type < 663)
          flagArray[Main.npc[index].type] = true;
      }
      if (!flagArray[38] || !flagArray[17] || (!flagArray[107] || !flagArray[19]) || (!flagArray[22] || !flagArray[124] || (!flagArray[228] || !flagArray[178])) || (!flagArray[18] || !flagArray[229] || (!flagArray[209] || !flagArray[54]) || (!flagArray[108] || !flagArray[160] || (!flagArray[20] || !flagArray[369]))) || (!flagArray[207] || !flagArray[227] || (!flagArray[208] || !flagArray[441]) || (!flagArray[353] || !flagArray[588] || !flagArray[633])))
        return;
      AchievementsHelper.NotifyProgressionEvent(17);
    }

    public static bool RoomNeeds(int npcType)
    {
      WorldGen.roomChair = false;
      WorldGen.roomDoor = false;
      WorldGen.roomTable = false;
      WorldGen.roomTorch = false;
      for (int index = 0; index < TileID.Sets.RoomNeeds.CountsAsChair.Length; ++index)
      {
        if (WorldGen.houseTile[TileID.Sets.RoomNeeds.CountsAsChair[index]])
        {
          WorldGen.roomChair = true;
          break;
        }
      }
      for (int index = 0; index < TileID.Sets.RoomNeeds.CountsAsTable.Length; ++index)
      {
        if (WorldGen.houseTile[TileID.Sets.RoomNeeds.CountsAsTable[index]])
        {
          WorldGen.roomTable = true;
          break;
        }
      }
      for (int index = 0; index < TileID.Sets.RoomNeeds.CountsAsTorch.Length; ++index)
      {
        if (WorldGen.houseTile[TileID.Sets.RoomNeeds.CountsAsTorch[index]])
        {
          WorldGen.roomTorch = true;
          break;
        }
      }
      for (int index = 0; index < TileID.Sets.RoomNeeds.CountsAsDoor.Length; ++index)
      {
        if (WorldGen.houseTile[TileID.Sets.RoomNeeds.CountsAsDoor[index]])
        {
          WorldGen.roomDoor = true;
          break;
        }
      }
      WorldGen.canSpawn = WorldGen.roomChair && WorldGen.roomTable && (WorldGen.roomDoor && WorldGen.roomTorch);
      return WorldGen.canSpawn;
    }

    public static void QuickFindHome(int npc)
    {
      bool flag = Main.tileSolid[379];
      Main.tileSolid[379] = true;
      if (Main.npc[npc].homeTileX > 10 && Main.npc[npc].homeTileY > 10 && (Main.npc[npc].homeTileX < Main.maxTilesX - 10 && Main.npc[npc].homeTileY < Main.maxTilesY))
      {
        WorldGen.canSpawn = false;
        WorldGen.StartRoomCheck(Main.npc[npc].homeTileX, Main.npc[npc].homeTileY - 1);
        if (!WorldGen.canSpawn)
        {
          for (int x = Main.npc[npc].homeTileX - 1; x < Main.npc[npc].homeTileX + 2; ++x)
          {
            int y = Main.npc[npc].homeTileY - 1;
            while (y < Main.npc[npc].homeTileY + 2 && !WorldGen.StartRoomCheck(x, y))
              ++y;
          }
        }
        if (!WorldGen.canSpawn)
        {
          int num = 10;
          for (int x = Main.npc[npc].homeTileX - num; x <= Main.npc[npc].homeTileX + num; x += 2)
          {
            int y = Main.npc[npc].homeTileY - num;
            while (y <= Main.npc[npc].homeTileY + num && !WorldGen.StartRoomCheck(x, y))
              y += 2;
          }
        }
        if (WorldGen.canSpawn)
        {
          WorldGen.RoomNeeds(Main.npc[npc].type);
          if (WorldGen.canSpawn)
            WorldGen.ScoreRoom(npc, Main.npc[npc].type);
          if (WorldGen.canSpawn && WorldGen.hiScore > 0)
            WorldGen.canSpawn = WorldGen.IsRoomConsideredOccupiedForNPCIndex(npc);
          if (WorldGen.canSpawn && WorldGen.hiScore > 0)
          {
            Main.npc[npc].homeTileX = WorldGen.bestX;
            Main.npc[npc].homeTileY = WorldGen.bestY;
            Main.npc[npc].homeless = false;
            AchievementsHelper.NotifyProgressionEvent(8);
            WorldGen.canSpawn = false;
          }
          else
            Main.npc[npc].homeless = true;
        }
        else
          Main.npc[npc].homeless = true;
      }
      Main.tileSolid[379] = flag;
    }

    private static bool IsRoomConsideredOccupiedForNPCIndex(int npc)
    {
      bool flag = true;
      for (int index = 0; index < 200; ++index)
      {
        if (index != npc)
        {
          NPC npc2 = Main.npc[index];
          if (npc2.active && npc2.townNPC && (!npc2.homeless && npc2.homeTileX == WorldGen.bestX) && (npc2.homeTileY == WorldGen.bestY && !WorldGen.TownManager.CanNPCsLiveWithEachOther(Main.npc[npc], npc2)))
          {
            flag = false;
            break;
          }
        }
      }
      return flag;
    }

    private static bool ScoreRoom_IsThisRoomOccupiedBySomeone(int ignoreNPC = -1, int npcTypeAsking = -1)
    {
      for (int index1 = 0; index1 < 200; ++index1)
      {
        if (Main.npc[index1].active && Main.npc[index1].townNPC && (ignoreNPC != index1 && !Main.npc[index1].homeless))
        {
          for (int index2 = 0; index2 < WorldGen.numRoomTiles; ++index2)
          {
            if (Main.npc[index1].homeTileX == WorldGen.roomX[index2] && Main.npc[index1].homeTileY == WorldGen.roomY[index2])
            {
              bool flag = false;
              for (int index3 = 0; index3 < WorldGen.numRoomTiles; ++index3)
              {
                if (Main.npc[index1].homeTileX == WorldGen.roomX[index3] && Main.npc[index1].homeTileY - 1 == WorldGen.roomY[index3])
                {
                  if (WorldGen.TownManager.CanNPCsLiveWithEachOther(npcTypeAsking, Main.npc[index1]))
                  {
                    WorldGen.sharedRoomX = Main.npc[index1].homeTileX;
                  }
                  else
                  {
                    flag = true;
                    break;
                  }
                }
              }
              if (flag)
                return true;
            }
          }
        }
      }
      return false;
    }

    public static void CountTileTypesInArea(
      int[] tileTypeCounts,
      int startX,
      int endX,
      int startY,
      int endY)
    {
      for (int index1 = startX; index1 <= endX; ++index1)
      {
        for (int index2 = startY; index2 <= endY; ++index2)
        {
          if (Main.tile[index1, index2].active())
            ++tileTypeCounts[(int) Main.tile[index1, index2].type];
        }
      }
    }

    public static int GetTileTypeCountByCategory(int[] tileTypeCounts, TileScanGroup group)
    {
      switch (group)
      {
        case TileScanGroup.None:
          return 0;
        case TileScanGroup.Corruption:
          return tileTypeCounts[23] + tileTypeCounts[24] + tileTypeCounts[25] + tileTypeCounts[32] + tileTypeCounts[112] + tileTypeCounts[163] + tileTypeCounts[400] + tileTypeCounts[398] + -5 * tileTypeCounts[27];
        case TileScanGroup.Crimson:
          return tileTypeCounts[199] + tileTypeCounts[203] + tileTypeCounts[200] + tileTypeCounts[401] + tileTypeCounts[399] + tileTypeCounts[234] + tileTypeCounts[352] - 5 * tileTypeCounts[27];
        case TileScanGroup.Hallow:
          return tileTypeCounts[109] + tileTypeCounts[110] + tileTypeCounts[113] + tileTypeCounts[117] + tileTypeCounts[116] + tileTypeCounts[164] + tileTypeCounts[403] + tileTypeCounts[402];
        case TileScanGroup.TotalGoodEvil:
          int typeCountByCategory1 = WorldGen.GetTileTypeCountByCategory(tileTypeCounts, TileScanGroup.Hallow);
          int typeCountByCategory2 = WorldGen.GetTileTypeCountByCategory(tileTypeCounts, TileScanGroup.Corruption);
          int typeCountByCategory3 = WorldGen.GetTileTypeCountByCategory(tileTypeCounts, TileScanGroup.Crimson);
          int num1 = 5 * tileTypeCounts[27];
          int num2 = typeCountByCategory3;
          int num3 = typeCountByCategory2 + num2 + num1;
          return typeCountByCategory1 - num3;
        default:
          return 0;
      }
    }

    public static void ScoreRoom(int ignoreNPC = -1, int npcTypeAskingToScoreRoom = -1)
    {
      WorldGen.roomOccupied = false;
      WorldGen.roomEvil = false;
      WorldGen.sharedRoomX = -1;
      if (WorldGen.ScoreRoom_IsThisRoomOccupiedBySomeone(ignoreNPC, npcTypeAskingToScoreRoom))
      {
        WorldGen.roomOccupied = true;
        WorldGen.hiScore = -1;
      }
      else
      {
        WorldGen.hiScore = 0;
        int num1 = 50;
        int num2 = 40;
        int num3 = WorldGen.roomX1 - Main.buffScanAreaWidth / 2 / 16 - 1 - num2;
        int num4 = WorldGen.roomX2 + Main.buffScanAreaWidth / 2 / 16 + 1 + num2;
        int num5 = WorldGen.roomY1 - Main.buffScanAreaHeight / 2 / 16 - 1 - num2;
        int num6 = WorldGen.roomY2 + Main.buffScanAreaHeight / 2 / 16 + 1 + num2;
        if (num3 < 5)
          num3 = 5;
        if (num4 >= Main.maxTilesX - 5)
          num4 = Main.maxTilesX - 6;
        if (num5 < 5)
          num5 = 5;
        if (num6 >= Main.maxTilesY - 5)
          num6 = Main.maxTilesY - 6;
        int[] tileTypeCounts = new int[623];
        WorldGen.CountTileTypesInArea(tileTypeCounts, num3 + 1, num4 - 1, num5 + 2, num6 + 1);
        int num7 = -WorldGen.GetTileTypeCountByCategory(tileTypeCounts, TileScanGroup.TotalGoodEvil);
        if (num7 < 50)
          num7 = 0;
        int num8 = num1 - num7;
        if (num8 <= -250)
        {
          WorldGen.hiScore = num8;
          WorldGen.roomEvil = true;
        }
        else
        {
          int roomX1 = WorldGen.roomX1;
          int roomX2 = WorldGen.roomX2;
          int roomY1 = WorldGen.roomY1;
          int roomY2 = WorldGen.roomY2;
          for (int index1 = roomX1 + 1; index1 < roomX2; ++index1)
          {
            for (int index2 = roomY1 + 2; index2 < roomY2 + 2; ++index2)
            {
              if (Main.tile[index1, index2].nactive() && WorldGen.ScoreRoom_CanBeHomeSpot(index1, index2))
              {
                int num9 = num8;
                if (Main.tileSolid[(int) Main.tile[index1, index2].type] && !Main.tileSolidTop[(int) Main.tile[index1, index2].type] && (!Collision.SolidTiles(index1 - 1, index1 + 1, index2 - 3, index2 - 1) && Main.tile[index1 - 1, index2].nactive()) && (Main.tileSolid[(int) Main.tile[index1 - 1, index2].type] && Main.tile[index1 + 1, index2].nactive() && Main.tileSolid[(int) Main.tile[index1 + 1, index2].type]))
                {
                  int num10 = 0;
                  int num11 = 0;
                  for (int x = index1 - 2; x < index1 + 3; ++x)
                  {
                    for (int y = index2 - 4; y < index2; ++y)
                    {
                      Tile tile = Main.tile[x, y];
                      if (tile.nactive() && !TileID.Sets.IgnoredInHouseScore[(int) tile.type])
                      {
                        if (x == index1)
                          ++num10;
                        else if (TileID.Sets.BasicChest[(int) tile.type])
                          ++num11;
                        else if (tile.type == (ushort) 10 || tile.type == (ushort) 388)
                          num9 -= 20;
                        else if (WorldGen.IsOpenDoorAnchorFrame(x, y))
                          num9 -= 20;
                        else if (Main.tileSolid[(int) tile.type])
                          num9 -= 5;
                        else
                          num9 += 5;
                      }
                    }
                  }
                  if (WorldGen.sharedRoomX >= 0 && num9 >= 1 && Math.Abs(WorldGen.sharedRoomX - index1) < 3)
                    num9 = 1;
                  if (num9 > 0 && num11 > 0)
                  {
                    num9 -= 30 * num11;
                    if (num9 < 1)
                      num9 = 1;
                  }
                  if (num9 > 0 && num10 > 0)
                  {
                    num9 -= 15 * num10;
                    if (num9 <= 0)
                      num9 = 0;
                  }
                  if (num9 > WorldGen.hiScore)
                  {
                    bool flag1 = WorldGen.Housing_CheckIfInRoom(index1, index2);
                    bool[] flagArray = new bool[3];
                    for (int index3 = 1; index3 <= 3; ++index3)
                    {
                      if (!Main.tile[index1, index2 - index3].active() || !Main.tileSolid[(int) Main.tile[index1, index2 - index3].type])
                        flagArray[index3 - 1] = true;
                      if (!WorldGen.Housing_CheckIfInRoom(index1, index2 - index3))
                        flagArray[index3 - 1] = false;
                    }
                    foreach (bool flag2 in flagArray)
                    {
                      if (!flag2)
                      {
                        flag1 = false;
                        break;
                      }
                    }
                    if (flag1 && !WorldGen.Housing_CheckIfIsCeiling(index1, index2))
                    {
                      WorldGen.hiScore = num9;
                      WorldGen.bestX = index1;
                      WorldGen.bestY = index2;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    private static bool ScoreRoom_CanBeHomeSpot(int x, int y)
    {
      Tile tile = Main.tile[x, y];
      return !tile.active() || tile.type != (ushort) 379;
    }

    private static bool Housing_CheckIfIsCeiling(int i, int j)
    {
      bool flag = false;
      for (int index = 0; index < WorldGen.roomCeilingsCount; ++index)
      {
        if (WorldGen.roomCeilingX[index] == i)
        {
          if (WorldGen.roomCeilingY[index] == j)
          {
            flag = true;
            break;
          }
          break;
        }
      }
      return flag;
    }

    private static bool Housing_CheckIfInRoom(int i, int j)
    {
      bool flag = false;
      for (int index = 0; index < WorldGen.numRoomTiles; ++index)
      {
        if (WorldGen.roomX[index] == i && WorldGen.roomY[index] == j)
        {
          flag = true;
          break;
        }
      }
      return flag;
    }

    public static bool StartRoomCheck(int x, int y)
    {
      WorldGen.roomX1 = x;
      WorldGen.roomX2 = x;
      WorldGen.roomY1 = y;
      WorldGen.roomY2 = y;
      WorldGen.numRoomTiles = 0;
      WorldGen.roomCeilingsCount = 0;
      for (int index = 0; index < 623; ++index)
        WorldGen.houseTile[index] = false;
      WorldGen.canSpawn = true;
      if (Main.tile[x, y].nactive() && Main.tileSolid[(int) Main.tile[x, y].type])
      {
        WorldGen.roomCheckFailureReason = TownNPCRoomCheckFailureReason.RoomCheckStartedInASolidTile;
        WorldGen.canSpawn = false;
        return false;
      }
      WorldGen.roomCheckFailureReason = TownNPCRoomCheckFailureReason.None;
      WorldGen.CheckRoom(x, y);
      if (!WorldGen.canSpawn)
        return false;
      if (WorldGen.numRoomTiles < 60)
      {
        WorldGen.roomCheckFailureReason = TownNPCRoomCheckFailureReason.RoomIsTooSmall;
        WorldGen.canSpawn = false;
        return false;
      }
      return WorldGen.canSpawn;
    }

    public static void CheckRoom(int x, int y)
    {
      if (!WorldGen.canSpawn)
        return;
      if (x < 10 || y < 10 || (x >= Main.maxTilesX - 10 || y >= WorldGen.lastMaxTilesY - 10))
      {
        WorldGen.roomCheckFailureReason = TownNPCRoomCheckFailureReason.TooCloseToWorldEdge;
        WorldGen.canSpawn = false;
      }
      else
      {
        for (int index = 0; index < WorldGen.numRoomTiles; ++index)
        {
          if (WorldGen.roomX[index] == x && WorldGen.roomY[index] == y)
            return;
        }
        WorldGen.roomX[WorldGen.numRoomTiles] = x;
        WorldGen.roomY[WorldGen.numRoomTiles] = y;
        bool flag1 = false;
        for (int index = 0; index < WorldGen.roomCeilingsCount; ++index)
        {
          if (WorldGen.roomCeilingX[index] == x)
          {
            flag1 = true;
            if (WorldGen.roomCeilingY[index] > y)
            {
              WorldGen.roomCeilingY[index] = y;
              break;
            }
            break;
          }
        }
        if (!flag1)
        {
          WorldGen.roomCeilingX[WorldGen.roomCeilingsCount] = x;
          WorldGen.roomCeilingY[WorldGen.roomCeilingsCount] = y;
          ++WorldGen.roomCeilingsCount;
        }
        ++WorldGen.numRoomTiles;
        if (WorldGen.numRoomTiles >= WorldGen.maxRoomTiles)
        {
          WorldGen.roomCheckFailureReason = TownNPCRoomCheckFailureReason.RoomIsTooBig;
          WorldGen.canSpawn = false;
        }
        else
        {
          if (Main.tile[x, y].nactive())
          {
            WorldGen.houseTile[(int) Main.tile[x, y].type] = true;
            if (Main.tileSolid[(int) Main.tile[x, y].type] || Main.tile[x, y].type == (ushort) 11 && (Main.tile[x, y].frameX == (short) 0 || Main.tile[x, y].frameX == (short) 54 || (Main.tile[x, y].frameX == (short) 72 || Main.tile[x, y].frameX == (short) 126)) || (Main.tile[x, y].type == (ushort) 389 || Main.tile[x, y].type == (ushort) 386 && (Main.tile[x, y].frameX < (short) 36 && Main.tile[x, y].frameY == (short) 18 || Main.tile[x, y].frameX >= (short) 36 && Main.tile[x, y].frameY == (short) 0)))
              return;
          }
          if (x < WorldGen.roomX1)
            WorldGen.roomX1 = x;
          if (x > WorldGen.roomX2)
            WorldGen.roomX2 = x;
          if (y < WorldGen.roomY1)
            WorldGen.roomY1 = y;
          if (y > WorldGen.roomY2)
            WorldGen.roomY2 = y;
          bool flag2 = false;
          bool flag3 = false;
          for (int index = -2; index < 3; ++index)
          {
            if (Main.wallHouse[(int) Main.tile[x + index, y].wall])
              flag2 = true;
            if (Main.tile[x + index, y].nactive() && (Main.tileSolid[(int) Main.tile[x + index, y].type] || TileID.Sets.HousingWalls[(int) Main.tile[x + index, y].type]))
              flag2 = true;
            if (Main.wallHouse[(int) Main.tile[x, y + index].wall])
              flag3 = true;
            if (Main.tile[x, y + index].nactive() && (Main.tileSolid[(int) Main.tile[x, y + index].type] || TileID.Sets.HousingWalls[(int) Main.tile[x, y + index].type]))
              flag3 = true;
          }
          if (!flag2 || !flag3)
          {
            WorldGen.roomCheckFailureReason = TownNPCRoomCheckFailureReason.HoleInWallIsTooBig;
            WorldGen.canSpawn = false;
          }
          else
          {
            for (int x1 = x - 1; x1 < x + 2; ++x1)
            {
              for (int y1 = y - 1; y1 < y + 2; ++y1)
              {
                if ((x1 != x || y1 != y) && WorldGen.canSpawn)
                  WorldGen.CheckRoom(x1, y1);
              }
            }
          }
        }
      }
    }

    public static void dropMeteor()
    {
      bool flag = true;
      if (Main.netMode == 1)
        return;
      for (int index = 0; index < (int) byte.MaxValue; ++index)
      {
        if (Main.player[index].active)
        {
          flag = false;
          break;
        }
      }
      int num1 = 0;
      int num2 = (int) (400.0 * (double) (Main.maxTilesX / 4200));
      for (int index1 = 5; index1 < Main.maxTilesX - 5; ++index1)
      {
        for (int index2 = 5; (double) index2 < Main.worldSurface; ++index2)
        {
          if (Main.tile[index1, index2].active() && Main.tile[index1, index2].type == (ushort) 37)
          {
            ++num1;
            if (num1 > num2)
              return;
          }
        }
      }
      float num3 = 600f;
      while (!flag)
      {
        float num4 = (float) Main.maxTilesX * 0.08f;
        int i1 = Main.rand.Next(150, Main.maxTilesX - 150);
        while ((double) i1 > (double) Main.spawnTileX - (double) num4 && (double) i1 < (double) Main.spawnTileX + (double) num4)
          i1 = Main.rand.Next(150, Main.maxTilesX - 150);
        for (int j1 = (int) (Main.worldSurface * 0.3); j1 < Main.maxTilesY; ++j1)
        {
          if (Main.tile[i1, j1].active() && Main.tileSolid[(int) Main.tile[i1, j1].type] && !TileID.Sets.Platforms[(int) Main.tile[i1, j1].type])
          {
            int num5 = 0;
            int num6 = 15;
            for (int i2 = i1 - num6; i2 < i1 + num6; ++i2)
            {
              for (int j2 = j1 - num6; j2 < j1 + num6; ++j2)
              {
                if (WorldGen.SolidTile(i2, j2, false))
                {
                  ++num5;
                  if (Main.tile[i2, j2].type == (ushort) 189 || Main.tile[i2, j2].type == (ushort) 202)
                    num5 -= 100;
                }
                else if (Main.tile[i2, j2].liquid > (byte) 0)
                  --num5;
              }
            }
            if ((double) num5 >= (double) num3)
            {
              flag = WorldGen.meteor(i1, j1, false);
              if (!flag)
                break;
              break;
            }
            num3 -= 0.5f;
            break;
          }
        }
        if ((double) num3 < 100.0)
          break;
      }
    }

    public static bool meteor(int i, int j, bool ignorePlayers = false)
    {
      if (i < 50 || i > Main.maxTilesX - 50 || (j < 50 || j > Main.maxTilesY - 50))
        return false;
      int num1 = 35;
      Microsoft.Xna.Framework.Rectangle rectangle1 = new Microsoft.Xna.Framework.Rectangle((i - num1) * 16, (j - num1) * 16, num1 * 2 * 16, num1 * 2 * 16);
      for (int index = 0; index < (int) byte.MaxValue; ++index)
      {
        if (Main.player[index].active && !ignorePlayers)
        {
          Microsoft.Xna.Framework.Rectangle rectangle2 = new Microsoft.Xna.Framework.Rectangle((int) ((double) Main.player[index].position.X + (double) (Main.player[index].width / 2) - (double) (NPC.sWidth / 2) - (double) NPC.safeRangeX), (int) ((double) Main.player[index].position.Y + (double) (Main.player[index].height / 2) - (double) (NPC.sHeight / 2) - (double) NPC.safeRangeY), NPC.sWidth + NPC.safeRangeX * 2, NPC.sHeight + NPC.safeRangeY * 2);
          if (rectangle1.Intersects(rectangle2))
            return false;
        }
      }
      for (int index = 0; index < 200; ++index)
      {
        if (Main.npc[index].active)
        {
          Microsoft.Xna.Framework.Rectangle rectangle2 = new Microsoft.Xna.Framework.Rectangle((int) Main.npc[index].position.X, (int) Main.npc[index].position.Y, Main.npc[index].width, Main.npc[index].height);
          if (rectangle1.Intersects(rectangle2))
            return false;
        }
      }
      for (int index1 = i - num1; index1 < i + num1; ++index1)
      {
        for (int index2 = j - num1; index2 < j + num1; ++index2)
        {
          if (Main.tile[index1, index2].active())
          {
            if (TileID.Sets.BasicChest[(int) Main.tile[index1, index2].type] || Main.tileDungeon[(int) Main.tile[index1, index2].type])
              return false;
            switch (Main.tile[index1, index2].type)
            {
              case 226:
              case 470:
              case 475:
              case 488:
              case 597:
                return false;
              default:
                continue;
            }
          }
        }
      }
      WorldGen.stopDrops = true;
      int num2 = WorldGen.genRand.Next(17, 23);
      for (int index1 = i - num2; index1 < i + num2; ++index1)
      {
        for (int index2 = j - num2; index2 < j + num2; ++index2)
        {
          if (index2 > j + Main.rand.Next(-2, 3) - 5)
          {
            double num3 = (double) Math.Abs(i - index1);
            float num4 = (float) Math.Abs(j - index2);
            if (Math.Sqrt(num3 * num3 + (double) num4 * (double) num4) < (double) num2 * 0.9 + (double) Main.rand.Next(-4, 5))
            {
              if (!Main.tileSolid[(int) Main.tile[index1, index2].type])
                Main.tile[index1, index2].active(false);
              Main.tile[index1, index2].type = (ushort) 37;
            }
          }
        }
      }
      int num5 = WorldGen.genRand.Next(8, 14);
      for (int index1 = i - num5; index1 < i + num5; ++index1)
      {
        for (int index2 = j - num5; index2 < j + num5; ++index2)
        {
          if (index2 > j + Main.rand.Next(-2, 3) - 4)
          {
            double num3 = (double) Math.Abs(i - index1);
            float num4 = (float) Math.Abs(j - index2);
            if (Math.Sqrt(num3 * num3 + (double) num4 * (double) num4) < (double) num5 * 0.8 + (double) Main.rand.Next(-3, 4))
              Main.tile[index1, index2].active(false);
          }
        }
      }
      int num6 = WorldGen.genRand.Next(25, 35);
      for (int i1 = i - num6; i1 < i + num6; ++i1)
      {
        for (int j1 = j - num6; j1 < j + num6; ++j1)
        {
          double num3 = (double) Math.Abs(i - i1);
          float num4 = (float) Math.Abs(j - j1);
          if (Math.Sqrt(num3 * num3 + (double) num4 * (double) num4) < (double) num6 * 0.7)
          {
            if (TileID.Sets.GetsDestroyedForMeteors[(int) Main.tile[i1, j1].type])
              WorldGen.KillTile(i1, j1, false, false, false);
            Main.tile[i1, j1].liquid = (byte) 0;
          }
          if (Main.tile[i1, j1].type == (ushort) 37)
          {
            if (!WorldGen.SolidTile(i1 - 1, j1, false) && !WorldGen.SolidTile(i1 + 1, j1, false) && (!WorldGen.SolidTile(i1, j1 - 1, false) && !WorldGen.SolidTile(i1, j1 + 1, false)))
              Main.tile[i1, j1].active(false);
            else if ((Main.tile[i1, j1].halfBrick() || Main.tile[i1 - 1, j1].topSlope()) && !WorldGen.SolidTile(i1, j1 + 1, false))
              Main.tile[i1, j1].active(false);
          }
          WorldGen.SquareTileFrame(i1, j1, true);
          WorldGen.SquareWallFrame(i1, j1, true);
        }
      }
      int num7 = WorldGen.genRand.Next(23, 32);
      for (int i1 = i - num7; i1 < i + num7; ++i1)
      {
        for (int j1 = j - num7; j1 < j + num7; ++j1)
        {
          if (j1 > j + WorldGen.genRand.Next(-3, 4) - 3 && Main.tile[i1, j1].active() && Main.rand.Next(10) == 0)
          {
            double num3 = (double) Math.Abs(i - i1);
            float num4 = (float) Math.Abs(j - j1);
            if (Math.Sqrt(num3 * num3 + (double) num4 * (double) num4) < (double) num7 * 0.8)
            {
              if (TileID.Sets.GetsDestroyedForMeteors[(int) Main.tile[i1, j1].type])
                WorldGen.KillTile(i1, j1, false, false, false);
              Main.tile[i1, j1].type = (ushort) 37;
              WorldGen.SquareTileFrame(i1, j1, true);
            }
          }
        }
      }
      int num8 = WorldGen.genRand.Next(30, 38);
      for (int i1 = i - num8; i1 < i + num8; ++i1)
      {
        for (int j1 = j - num8; j1 < j + num8; ++j1)
        {
          if (j1 > j + WorldGen.genRand.Next(-2, 3) && Main.tile[i1, j1].active() && Main.rand.Next(20) == 0)
          {
            double num3 = (double) Math.Abs(i - i1);
            float num4 = (float) Math.Abs(j - j1);
            if (Math.Sqrt(num3 * num3 + (double) num4 * (double) num4) < (double) num8 * 0.85)
            {
              if (TileID.Sets.GetsDestroyedForMeteors[(int) Main.tile[i1, j1].type])
                WorldGen.KillTile(i1, j1, false, false, false);
              Main.tile[i1, j1].type = (ushort) 37;
              WorldGen.SquareTileFrame(i1, j1, true);
            }
          }
        }
      }
      WorldGen.stopDrops = false;
      if (Main.netMode == 0)
        Main.NewText(Lang.gen[59].Value, (byte) 50, byte.MaxValue, (byte) 130);
      else if (Main.netMode == 2)
        ChatHelper.BroadcastChatMessage(NetworkText.FromKey(Lang.gen[59].Key), new Color(50, (int) byte.MaxValue, 130), -1);
      if (Main.netMode != 1)
        NetMessage.SendTileSquare(-1, i, j, 40, TileChangeType.None);
      return true;
    }

    public static void setWorldSize()
    {
      Main.bottomWorld = (float) (Main.maxTilesY * 16);
      Main.rightWorld = (float) (Main.maxTilesX * 16);
      Main.maxSectionsX = Main.maxTilesX / 200;
      Main.maxSectionsY = Main.maxTilesY / 150;
    }

    public static void worldGenCallback(object threadContext)
    {
      SoundEngine.PlaySound(10, -1, -1, 1, 1f, 0.0f);
      WorldGen.clearWorld();
      WorldGen.GenerateWorld(Main.ActiveWorldFileData.Seed, threadContext as GenerationProgress);
      WorldFile.SaveWorld(Main.ActiveWorldFileData.IsCloudSave, true);
      if (Main.menuMode == 10 || Main.menuMode == 888)
        Main.menuMode = 6;
      SoundEngine.PlaySound(10, -1, -1, 1, 1f, 0.0f);
      WorldGen.generatingWorld = false;
    }

    public static Task CreateNewWorld(GenerationProgress progress = null)
    {
      WorldGen.generatingWorld = true;
      Main.rand = new UnifiedRandom(Main.ActiveWorldFileData.Seed);
      WorldGen.gen = true;
      Main.menuMode = 888;
      try
      {
        Main.MenuUI.SetState((UIState) new UIWorldLoad());
      }
      catch
      {
      }
      return Task.Factory.StartNew(new Action<object>(WorldGen.worldGenCallback), (object) progress);
    }

    public static void JustQuit()
    {
      try
      {
        SoundEngine.PlaySound(34, -1, -1, 0, 1f, 0.0f);
        SoundEngine.PlaySound(35, -1, -1, 0, 1f, 0.0f);
      }
      catch
      {
      }
      Main.invasionProgress = -1;
      Main.invasionProgressDisplayLeft = 0;
      Main.invasionProgressAlpha = 0.0f;
      Main.invasionProgressIcon = 0;
      Main.menuMode = 10;
      Main.gameMenu = true;
      SoundEngine.StopTrackedSounds();
      CaptureInterface.ResetFocus();
      Main.ActivePlayerFileData.StopPlayTimer();
      Main.fastForwardTime = false;
      Main.UpdateTimeRate();
      if (Main.netMode == 0)
      {
        Main.GoToWorldSelect();
        Main.player[Main.myPlayer].position = new Vector2(0.0f, 0.0f);
      }
      else
      {
        if (Main.netMode != 1)
          return;
        Main.menuMode = 0;
        Netplay.Disconnect = true;
        Main.netMode = 0;
      }
    }

    public static void SaveAndQuitCallBack(object threadContext)
    {
      int netMode = Main.netMode;
      try
      {
        SoundEngine.PlaySound(34, -1, -1, 0, 1f, 0.0f);
        SoundEngine.PlaySound(35, -1, -1, 0, 1f, 0.0f);
      }
      catch
      {
      }
      if (netMode == 0)
        WorldFile.CacheSaveTime();
      Main.invasionProgress = -1;
      Main.invasionProgressDisplayLeft = 0;
      Main.invasionProgressAlpha = 0.0f;
      Main.invasionProgressIcon = 0;
      Main.menuMode = 10;
      Main.gameMenu = true;
      SoundEngine.StopTrackedSounds();
      CaptureInterface.ResetFocus();
      Main.ActivePlayerFileData.StopPlayTimer();
      Player.SavePlayer(Main.ActivePlayerFileData, false);
      Player.ClearPlayerTempInfo();
      Rain.ClearRain();
      if (netMode == 0)
      {
        WorldFile.SaveWorld();
        SoundEngine.PlaySound(10, -1, -1, 1, 1f, 0.0f);
      }
      else
      {
        Netplay.Disconnect = true;
        Main.netMode = 0;
      }
      Main.fastForwardTime = false;
      Main.UpdateTimeRate();
      Main.menuMode = 0;
      if (threadContext == null)
        return;
      ((Action) threadContext)();
    }

    public static void SaveAndQuit(Action callback = null)
    {
      SoundEngine.PlaySound(11, -1, -1, 1, 1f, 0.0f);
      ThreadPool.QueueUserWorkItem(new WaitCallback(WorldGen.SaveAndQuitCallBack), (object) callback);
    }

    public static void playWorldCallBack(object threadContext)
    {
      if (Main.rand == null)
        Main.rand = new UnifiedRandom((int) DateTime.Now.Ticks);
      for (int index = 0; index < (int) byte.MaxValue; ++index)
      {
        if (index != Main.myPlayer)
          Main.player[index].active = false;
      }
      WorldGen.noMapUpdate = true;
      WorldFile.LoadWorld(Main.ActiveWorldFileData.IsCloudSave);
      if (WorldGen.loadFailed || !WorldGen.loadSuccess)
      {
        WorldFile.LoadWorld(Main.ActiveWorldFileData.IsCloudSave);
        if (WorldGen.loadFailed || !WorldGen.loadSuccess)
        {
          bool isCloudSave = Main.ActiveWorldFileData.IsCloudSave;
          WorldGen.worldBackup = FileUtilities.Exists(Main.worldPathName + ".bak", isCloudSave);
          if (!Main.dedServ)
          {
            if (WorldGen.worldBackup)
            {
              Main.menuMode = 200;
              return;
            }
            Main.menuMode = 201;
            return;
          }
          if (WorldGen.worldBackup)
          {
            FileUtilities.Copy(Main.worldPathName, Main.worldPathName + ".bad", isCloudSave, true);
            FileUtilities.Copy(Main.worldPathName + ".bak", Main.worldPathName, isCloudSave, true);
            FileUtilities.Delete(Main.worldPathName + ".bak", isCloudSave);
            WorldFile.LoadWorld(Main.ActiveWorldFileData.IsCloudSave);
            if (WorldGen.loadFailed || !WorldGen.loadSuccess)
            {
              WorldFile.LoadWorld(Main.ActiveWorldFileData.IsCloudSave);
              if (WorldGen.loadFailed || !WorldGen.loadSuccess)
              {
                FileUtilities.Copy(Main.worldPathName, Main.worldPathName + ".bak", isCloudSave, true);
                FileUtilities.Copy(Main.worldPathName + ".bad", Main.worldPathName, isCloudSave, true);
                FileUtilities.Delete(Main.worldPathName + ".bad", isCloudSave);
                Console.WriteLine(Language.GetTextValue("Error.LoadFailed"));
                return;
              }
            }
          }
          else
          {
            Console.WriteLine(Language.GetTextValue("Error.LoadFailedNoBackup"));
            return;
          }
        }
      }
      if (Main.mapEnabled)
        Main.Map.Load();
      if (Main.netMode != 2)
        Main.sectionManager.SetAllFramesLoaded();
      while (Main.loadMapLock)
      {
        float num = (float) Main.loadMapLastX / (float) Main.maxTilesX;
        Main.statusText = Lang.gen[68].Value + " " + (object) (int) ((double) num * 100.0 + 1.0) + "%";
        Thread.Sleep(0);
        if (!Main.mapEnabled)
          break;
      }
      if (Main.gameMenu)
        Main.gameMenu = false;
      if (Main.netMode == 0 && Main.anglerWhoFinishedToday.Contains(Main.player[Main.myPlayer].name))
        Main.anglerQuestFinished = true;
      Main.player[Main.myPlayer].Spawn(PlayerSpawnContext.SpawningIntoWorld);
      Main.ActivePlayerFileData.StartPlayTimer();
      WorldGen._lastSeed = Main.ActiveWorldFileData.Seed;
      Player.Hooks.EnterWorld(Main.myPlayer);
      WorldFile.SetOngoingToTemps();
      SoundEngine.PlaySound(11, -1, -1, 1, 1f, 0.0f);
      Main.resetClouds = true;
      WorldGen.noMapUpdate = false;
    }

    public static void playWorld()
    {
      ThreadPool.QueueUserWorkItem(new WaitCallback(WorldGen.playWorldCallBack), (object) 1);
    }

    public static void saveAndPlayCallBack(object threadContext)
    {
      WorldFile.SaveWorld();
    }

    public static void saveAndPlay()
    {
      ThreadPool.QueueUserWorkItem(new WaitCallback(WorldGen.saveAndPlayCallBack), (object) 1);
    }

    public static void saveToonWhilePlayingCallBack(object threadContext)
    {
      Player.SavePlayer(Main.ActivePlayerFileData, false);
    }

    public static void saveToonWhilePlaying()
    {
      ThreadPool.QueueUserWorkItem(new WaitCallback(WorldGen.saveToonWhilePlayingCallBack), (object) 1);
    }

    public static void serverLoadWorldCallBack()
    {
      Main.rand = new UnifiedRandom((int) DateTime.Now.Ticks);
      WorldFile.LoadWorld(Main.ActiveWorldFileData.IsCloudSave);
      if (WorldGen.loadFailed || !WorldGen.loadSuccess)
      {
        WorldFile.LoadWorld(Main.ActiveWorldFileData.IsCloudSave);
        if (WorldGen.loadFailed || !WorldGen.loadSuccess)
        {
          bool isCloudSave = Main.ActiveWorldFileData.IsCloudSave;
          WorldGen.worldBackup = FileUtilities.Exists(Main.worldPathName + ".bak", isCloudSave);
          if (!Main.dedServ)
          {
            if (WorldGen.worldBackup)
            {
              Main.menuMode = 200;
              return;
            }
            Main.menuMode = 201;
            return;
          }
          if (WorldGen.worldBackup)
          {
            FileUtilities.Copy(Main.worldPathName + ".bak", Main.worldPathName, isCloudSave, true);
            FileUtilities.Delete(Main.worldPathName + ".bak", isCloudSave);
            WorldFile.LoadWorld(Main.ActiveWorldFileData.IsCloudSave);
            if (WorldGen.loadFailed || !WorldGen.loadSuccess)
            {
              WorldFile.LoadWorld(Main.ActiveWorldFileData.IsCloudSave);
              if (WorldGen.loadFailed || !WorldGen.loadSuccess)
              {
                Console.WriteLine(Language.GetTextValue("Error.LoadFailed"));
                return;
              }
            }
          }
          else
          {
            Console.WriteLine(Language.GetTextValue("Error.LoadFailedNoBackup"));
            return;
          }
        }
      }
      WorldGen._lastSeed = Main.ActiveWorldFileData.Seed;
      SoundEngine.PlaySound(10, -1, -1, 1, 1f, 0.0f);
      WorldFile.SetOngoingToTemps();
      WorldGen.Hooks.WorldLoaded();
    }

    public static Task serverLoadWorld()
    {
      return Task.Factory.StartNew(new Action(WorldGen.serverLoadWorldCallBack));
    }

    public static void clearWorld()
    {
      Main.getGoodWorld = false;
      Main.drunkWorld = false;
      NPC.ResetBadgerHatTime();
      NPC.freeCake = false;
      Main.mapDelay = 2;
      Main.ResetWindCounter(true);
      WorldGen.TownManager = new TownRoomManager();
      WorldGen.Hooks.ClearWorld();
      TileEntity.Clear();
      Main.checkXMas();
      Main.checkHalloween();
      if (Main.mapReady)
      {
        for (int index = 0; index < WorldGen.lastMaxTilesX; ++index)
        {
          double num = (double) index / (double) WorldGen.lastMaxTilesX;
          Main.statusText = Lang.gen[65].Value;
        }
        Main.Map.Clear();
      }
      NPC.MoonLordCountdown = 0;
      Main.forceHalloweenForToday = false;
      Main.forceXMasForToday = false;
      NPC.RevengeManager.Reset();
      Main.pumpkinMoon = false;
      Main.clearMap = true;
      Main.mapTime = 0;
      Main.updateMap = false;
      Main.mapReady = false;
      Main.refreshMap = false;
      Main.eclipse = false;
      Main.slimeRain = false;
      Main.slimeRainTime = 0.0;
      Main.slimeWarningTime = 0;
      Main.sundialCooldown = 0;
      Main.fastForwardTime = false;
      BirthdayParty.WorldClear();
      LanternNight.WorldClear();
      WorldGen.mysticLogsEvent.WorldClear();
      Sandstorm.WorldClear();
      Main.UpdateTimeRate();
      Main.wofNPCIndex = -1;
      NPC.waveKills = 0.0f;
      WorldGen.spawnHardBoss = 0;
      WorldGen.totalSolid2 = 0;
      WorldGen.totalGood2 = 0;
      WorldGen.totalEvil2 = 0;
      WorldGen.totalBlood2 = 0;
      WorldGen.totalSolid = 0;
      WorldGen.totalGood = 0;
      WorldGen.totalEvil = 0;
      WorldGen.totalBlood = 0;
      WorldFile.ResetTemps();
      Main.maxRaining = 0.0f;
      WorldGen.totalX = 0;
      WorldGen.totalD = 0;
      WorldGen.tEvil = (byte) 0;
      WorldGen.tBlood = (byte) 0;
      WorldGen.tGood = (byte) 0;
      WorldGen.spawnEye = false;
      WorldGen.prioritizedTownNPCType = 0;
      WorldGen.shadowOrbCount = 0;
      WorldGen.altarCount = 0;
      WorldGen.SavedOreTiers.Copper = -1;
      WorldGen.SavedOreTiers.Iron = -1;
      WorldGen.SavedOreTiers.Silver = -1;
      WorldGen.SavedOreTiers.Gold = -1;
      WorldGen.SavedOreTiers.Cobalt = -1;
      WorldGen.SavedOreTiers.Mythril = -1;
      WorldGen.SavedOreTiers.Adamantite = -1;
      Main.cloudBGActive = 0.0f;
      Main.raining = false;
      Main.hardMode = false;
      Main.helpText = 0;
      Main.BartenderHelpTextIndex = 0;
      Main.dungeonX = 0;
      Main.dungeonY = 0;
      NPC.downedBoss1 = false;
      NPC.downedBoss2 = false;
      NPC.downedBoss3 = false;
      NPC.downedQueenBee = false;
      NPC.downedSlimeKing = false;
      NPC.downedMechBossAny = false;
      NPC.downedMechBoss1 = false;
      NPC.downedMechBoss2 = false;
      NPC.downedMechBoss3 = false;
      NPC.downedFishron = false;
      NPC.downedAncientCultist = false;
      NPC.downedMoonlord = false;
      NPC.downedHalloweenKing = false;
      NPC.downedHalloweenTree = false;
      NPC.downedChristmasIceQueen = false;
      NPC.downedChristmasSantank = false;
      NPC.downedChristmasTree = false;
      NPC.downedPlantBoss = false;
      NPC.downedGolemBoss = false;
      NPC.downedEmpressOfLight = false;
      NPC.downedQueenSlime = false;
      NPC.combatBookWasUsed = false;
      NPC.savedStylist = false;
      NPC.savedGoblin = false;
      NPC.savedWizard = false;
      NPC.savedMech = false;
      NPC.savedTaxCollector = false;
      NPC.savedAngler = false;
      NPC.savedBartender = false;
      NPC.savedGolfer = false;
      NPC.boughtCat = false;
      NPC.boughtDog = false;
      NPC.boughtBunny = false;
      NPC.downedGoblins = false;
      NPC.downedClown = false;
      NPC.downedFrost = false;
      NPC.downedPirates = false;
      NPC.downedMartians = false;
      int num1;
      NPC.LunarApocalypseIsUp = (num1 = 0) != 0;
      NPC.downedTowerStardust = num1 != 0;
      NPC.downedTowerNebula = num1 != 0;
      NPC.downedTowerVortex = num1 != 0;
      NPC.downedTowerSolar = num1 != 0;
      int num2;
      NPC.TowerActiveStardust = (num2 = 0) != 0;
      NPC.TowerActiveNebula = num2 != 0;
      NPC.TowerActiveVortex = num2 != 0;
      NPC.TowerActiveSolar = num2 != 0;
      DD2Event.ResetProgressEntirely();
      NPC.ClearFoundActiveNPCs();
      Main.BestiaryTracker.Reset();
      Main.PylonSystem.Reset();
      CreativePowerManager.Instance.Reset();
      Main.CreativeMenu.Reset();
      WorldGen.shadowOrbSmashed = false;
      WorldGen.spawnMeteor = false;
      WorldGen.stopDrops = false;
      Main.invasionDelay = 0;
      Main.invasionType = 0;
      Main.invasionSize = 0;
      Main.invasionWarn = 0;
      Main.invasionX = 0.0;
      Main.invasionSizeStart = 0;
      Main.treeX[0] = Main.maxTilesX;
      Main.treeX[1] = Main.maxTilesX;
      Main.treeX[2] = Main.maxTilesX;
      Main.treeStyle[0] = 0;
      Main.treeStyle[1] = 0;
      Main.treeStyle[2] = 0;
      Main.treeStyle[3] = 0;
      WorldGen.noLiquidCheck = false;
      Liquid.numLiquid = 0;
      LiquidBuffer.numLiquidBuffer = 0;
      if (Main.netMode == 1 || WorldGen.lastMaxTilesX > Main.maxTilesX || WorldGen.lastMaxTilesY > Main.maxTilesY)
      {
        for (int index1 = 0; index1 < WorldGen.lastMaxTilesX; ++index1)
        {
          float num3 = (float) index1 / (float) WorldGen.lastMaxTilesX;
          Main.statusText = Lang.gen[46].Value + " " + (object) (int) ((double) num3 * 100.0 + 1.0) + "%";
          for (int index2 = 0; index2 < WorldGen.lastMaxTilesY; ++index2)
            Main.tile[index1, index2] = (Tile) null;
        }
      }
      WorldGen.lastMaxTilesX = Main.maxTilesX;
      WorldGen.lastMaxTilesY = Main.maxTilesY;
      if (Main.netMode != 2)
        Main.sectionManager = new WorldSections(Main.maxTilesX / 200, Main.maxTilesY / 150);
      if (Main.netMode != 1)
      {
        for (int index1 = 0; index1 < Main.maxTilesX; ++index1)
        {
          float num3 = (float) index1 / (float) Main.maxTilesX;
          Main.statusText = Lang.gen[47].Value + " " + (object) (int) ((double) num3 * 100.0 + 1.0) + "%";
          for (int index2 = 0; index2 < Main.maxTilesY; ++index2)
          {
            if (Main.tile[index1, index2] == null)
              Main.tile[index1, index2] = new Tile();
            else
              Main.tile[index1, index2].ClearEverything();
          }
        }
      }
      for (int index = 0; index < Main.countsAsHostForGameplay.Length; ++index)
        Main.countsAsHostForGameplay[index] = false;
      CombatText.clearAll();
      for (int index = 0; index < 6000; ++index)
      {
        Main.dust[index] = new Dust();
        Main.dust[index].dustIndex = index;
      }
      for (int index = 0; index < 600; ++index)
        Main.gore[index] = new Gore();
      for (int index = 0; index < 400; ++index)
      {
        Main.item[index] = new Item();
        Main.timeItemSlotCannotBeReusedFor[index] = 0;
      }
      for (int index = 0; index < 200; ++index)
        Main.npc[index] = new NPC();
      for (int index = 0; index < 1000; ++index)
        Main.projectile[index] = new Projectile();
      for (int index = 0; index < 8000; ++index)
        Main.chest[index] = (Chest) null;
      for (int index = 0; index < 1000; ++index)
        Main.sign[index] = (Sign) null;
      for (int index = 0; index < Liquid.maxLiquid; ++index)
        Main.liquid[index] = new Liquid();
      for (int index = 0; index < 50000; ++index)
        Main.liquidBuffer[index] = new LiquidBuffer();
      WorldGen.setWorldSize();
      Star.SpawnStars(-1);
      WorldGen.worldCleared = true;
    }

    public static void setBG(int bg, int style)
    {
      switch (bg)
      {
        case 0:
          WorldGen.treeBG1 = style;
          WorldGen.SetForestBGSet(style, Main.treeMntBGSet1, Main.treeBGSet1);
          break;
        case 1:
          WorldGen.corruptBG = style;
          switch (style)
          {
            case 1:
              Main.corruptBG[0] = 56;
              Main.corruptBG[1] = 57;
              Main.corruptBG[2] = 58;
              return;
            case 2:
              Main.corruptBG[0] = 211;
              Main.corruptBG[1] = 212;
              Main.corruptBG[2] = 213;
              return;
            case 3:
              Main.corruptBG[0] = 225;
              Main.corruptBG[1] = 226;
              Main.corruptBG[2] = 227;
              return;
            case 4:
              Main.corruptBG[0] = 240;
              Main.corruptBG[1] = 241;
              Main.corruptBG[2] = 242;
              return;
            default:
              Main.corruptBG[0] = 12;
              Main.corruptBG[1] = 13;
              Main.corruptBG[2] = 14;
              return;
          }
        case 2:
          WorldGen.jungleBG = style;
          switch (style)
          {
            case 1:
              Main.jungleBG[0] = 59;
              Main.jungleBG[1] = 60;
              Main.jungleBG[2] = 61;
              return;
            case 2:
              Main.jungleBG[0] = 222;
              Main.jungleBG[1] = 223;
              Main.jungleBG[2] = 224;
              return;
            case 3:
              Main.jungleBG[0] = 237;
              Main.jungleBG[1] = 238;
              Main.jungleBG[2] = 239;
              return;
            case 4:
              Main.jungleBG[0] = 284;
              Main.jungleBG[1] = 285;
              Main.jungleBG[2] = 286;
              return;
            case 5:
              Main.jungleBG[0] = 271;
              Main.jungleBG[1] = 272;
              Main.jungleBG[2] = 273;
              return;
            default:
              Main.jungleBG[0] = 15;
              Main.jungleBG[1] = 16;
              Main.jungleBG[2] = 17;
              return;
          }
        case 3:
          WorldGen.snowBG = style;
          Main.snowMntBG[0] = 35;
          Main.snowMntBG[1] = 36;
          switch (style)
          {
            case 1:
              Main.snowBG[0] = 97;
              Main.snowBG[1] = 96;
              Main.snowBG[2] = 95;
              return;
            case 2:
              Main.snowMntBG[0] = 98;
              Main.snowMntBG[1] = 99;
              Main.snowBG[0] = -1;
              Main.snowBG[1] = -1;
              Main.snowBG[2] = -1;
              return;
            case 3:
              Main.snowMntBG[0] = 98;
              Main.snowMntBG[1] = 100;
              Main.snowBG[0] = -1;
              Main.snowBG[1] = -1;
              Main.snowBG[2] = -1;
              return;
            case 4:
              Main.snowMntBG[0] = 98;
              Main.snowMntBG[1] = 101;
              Main.snowBG[0] = -1;
              Main.snowBG[1] = -1;
              Main.snowBG[2] = -1;
              return;
            case 5:
              Main.snowMntBG[0] = -1;
              Main.snowMntBG[1] = -1;
              Main.snowBG[0] = 258;
              Main.snowBG[1] = 259;
              Main.snowBG[2] = 260;
              return;
            case 6:
              Main.snowMntBG[0] = -1;
              Main.snowMntBG[1] = -1;
              Main.snowBG[0] = 263;
              Main.snowBG[1] = 264;
              Main.snowBG[2] = 265;
              return;
            case 7:
              Main.snowMntBG[0] = 269;
              Main.snowMntBG[1] = 270;
              Main.snowBG[0] = 267;
              Main.snowBG[1] = 266;
              Main.snowBG[2] = 268;
              return;
            case 21:
              Main.snowMntBG[0] = 98;
              Main.snowMntBG[1] = 99;
              Main.snowBG[0] = 95;
              Main.snowBG[1] = 96;
              Main.snowBG[2] = 97;
              return;
            case 22:
              Main.snowMntBG[0] = 98;
              Main.snowMntBG[1] = 99;
              Main.snowBG[0] = 37;
              Main.snowBG[1] = 38;
              Main.snowBG[2] = 39;
              return;
            case 31:
              Main.snowMntBG[0] = 98;
              Main.snowMntBG[1] = 100;
              Main.snowBG[0] = 95;
              Main.snowBG[1] = 96;
              Main.snowBG[2] = 97;
              return;
            case 32:
              Main.snowMntBG[0] = 98;
              Main.snowMntBG[1] = 100;
              Main.snowBG[0] = 37;
              Main.snowBG[1] = 38;
              Main.snowBG[2] = 39;
              return;
            case 41:
              Main.snowMntBG[0] = 98;
              Main.snowMntBG[1] = 101;
              Main.snowBG[0] = 95;
              Main.snowBG[1] = 96;
              Main.snowBG[2] = 97;
              return;
            case 42:
              Main.snowMntBG[0] = 98;
              Main.snowMntBG[1] = 101;
              Main.snowBG[0] = 37;
              Main.snowBG[1] = 38;
              Main.snowBG[2] = 39;
              return;
            default:
              Main.snowBG[0] = 37;
              Main.snowBG[1] = 38;
              Main.snowBG[2] = 39;
              return;
          }
        case 4:
          WorldGen.hallowBG = style;
          switch (style)
          {
            case 1:
              Main.hallowBG[0] = 102;
              Main.hallowBG[1] = 103;
              Main.hallowBG[2] = 104;
              return;
            case 2:
              Main.hallowBG[0] = 219;
              Main.hallowBG[1] = 220;
              Main.hallowBG[2] = 221;
              return;
            case 3:
              Main.hallowBG[0] = 243;
              Main.hallowBG[1] = 244;
              Main.hallowBG[2] = 245;
              return;
            case 4:
              Main.hallowBG[0] = -1;
              Main.hallowBG[1] = 261;
              Main.hallowBG[2] = 262;
              return;
            default:
              Main.hallowBG[0] = 29;
              Main.hallowBG[1] = 30;
              Main.hallowBG[2] = 31;
              return;
          }
        case 5:
          WorldGen.crimsonBG = style;
          switch (style)
          {
            case 1:
              Main.crimsonBG[0] = 105;
              Main.crimsonBG[1] = 106;
              Main.crimsonBG[2] = 107;
              return;
            case 2:
              Main.crimsonBG[0] = 174;
              Main.crimsonBG[1] = -1;
              Main.crimsonBG[2] = 175;
              return;
            case 3:
              Main.crimsonBG[0] = 214;
              Main.crimsonBG[1] = 215;
              Main.crimsonBG[2] = 216;
              return;
            case 4:
              Main.crimsonBG[0] = -1;
              Main.crimsonBG[1] = 229;
              Main.crimsonBG[2] = 230;
              return;
            case 5:
              Main.crimsonBG[0] = (int) byte.MaxValue;
              Main.crimsonBG[1] = 256;
              Main.crimsonBG[2] = 257;
              return;
            default:
              Main.crimsonBG[0] = 43;
              Main.crimsonBG[1] = 44;
              Main.crimsonBG[2] = 45;
              return;
          }
        case 6:
          WorldGen.desertBG = style;
          switch (style)
          {
            case 1:
              Main.desertBG[0] = 108;
              Main.desertBG[1] = 109;
              Main.desertBG[2] = -1;
              return;
            case 2:
              Main.desertBG[0] = 207;
              Main.desertBG[1] = 208;
              Main.desertBG[2] = -1;
              return;
            case 3:
              Main.desertBG[0] = 217;
              Main.desertBG[1] = 218;
              Main.desertBG[2] = -1;
              return;
            case 4:
              Main.desertBG[0] = 248;
              Main.desertBG[1] = 249;
              Main.desertBG[2] = 250;
              return;
            default:
              Main.desertBG[0] = 21;
              Main.desertBG[1] = 20;
              Main.desertBG[2] = -1;
              return;
          }
        case 7:
          WorldGen.oceanBG = style;
          switch (style)
          {
            case 1:
              Main.oceanBG = 110;
              return;
            case 2:
              Main.oceanBG = 111;
              return;
            case 3:
              Main.oceanBG = 209;
              return;
            case 4:
              Main.oceanBG = 210;
              return;
            case 5:
              Main.oceanBG = 283;
              return;
            default:
              Main.oceanBG = 28;
              return;
          }
        case 8:
          WorldGen.mushroomBG = style;
          switch (style)
          {
            case 1:
              Main.mushroomBG[0] = 231;
              Main.mushroomBG[1] = 232;
              Main.mushroomBG[2] = 233;
              return;
            case 2:
              Main.mushroomBG[0] = 234;
              Main.mushroomBG[1] = 235;
              Main.mushroomBG[2] = 236;
              return;
            case 3:
              Main.mushroomBG[0] = 287;
              Main.mushroomBG[1] = 288;
              Main.mushroomBG[2] = 289;
              return;
            default:
              Main.mushroomBG[0] = 46;
              Main.mushroomBG[1] = 47;
              Main.mushroomBG[2] = 48;
              return;
          }
        case 9:
          WorldGen.underworldBG = style;
          if (style != 1)
          {
            if (style != 2)
            {
              Main.underworldBG[0] = 0;
              Main.underworldBG[1] = 1;
              Main.underworldBG[2] = 2;
              Main.underworldBG[3] = 3;
              Main.underworldBG[4] = 4;
              break;
            }
            Main.underworldBG[0] = 10;
            Main.underworldBG[1] = 11;
            Main.underworldBG[2] = 12;
            Main.underworldBG[3] = 13;
            Main.underworldBG[4] = 9;
            break;
          }
          Main.underworldBG[0] = 5;
          Main.underworldBG[1] = 6;
          Main.underworldBG[2] = 7;
          Main.underworldBG[3] = 8;
          Main.underworldBG[4] = 9;
          break;
        case 10:
          WorldGen.treeBG2 = style;
          WorldGen.SetForestBGSet(style, Main.treeMntBGSet2, Main.treeBGSet2);
          break;
        case 11:
          WorldGen.treeBG3 = style;
          WorldGen.SetForestBGSet(style, Main.treeMntBGSet3, Main.treeBGSet3);
          break;
        case 12:
          WorldGen.treeBG4 = style;
          WorldGen.SetForestBGSet(style, Main.treeMntBGSet4, Main.treeBGSet4);
          break;
      }
    }

    private static void SetForestBGSet(int style, int[] mountainSet, int[] treeSet)
    {
      mountainSet[0] = 7;
      mountainSet[1] = 8;
      switch (style)
      {
        case 1:
          treeSet[0] = 50;
          treeSet[1] = 51;
          treeSet[2] = 52;
          break;
        case 2:
          treeSet[0] = 53;
          treeSet[1] = 54;
          treeSet[2] = 55;
          break;
        case 3:
          mountainSet[1] = 90;
          treeSet[0] = 91;
          treeSet[1] = -1;
          treeSet[2] = 92;
          break;
        case 4:
          mountainSet[0] = 93;
          mountainSet[1] = 94;
          treeSet[0] = -1;
          treeSet[1] = -1;
          treeSet[2] = -1;
          break;
        case 5:
          mountainSet[0] = 93;
          mountainSet[1] = 94;
          treeSet[0] = -1;
          treeSet[1] = -1;
          treeSet[2] = 55;
          break;
        case 6:
          mountainSet[0] = 171;
          mountainSet[1] = 172;
          treeSet[0] = 173;
          treeSet[1] = -1;
          treeSet[2] = -1;
          break;
        case 7:
          mountainSet[0] = 176;
          mountainSet[1] = 177;
          treeSet[0] = 178;
          treeSet[1] = -1;
          treeSet[2] = -1;
          break;
        case 8:
          mountainSet[0] = 179;
          mountainSet[1] = 180;
          treeSet[0] = 184;
          treeSet[1] = -1;
          treeSet[2] = -1;
          break;
        case 9:
          mountainSet[0] = 277;
          mountainSet[1] = 278;
          treeSet[0] = 279;
          treeSet[1] = -1;
          treeSet[2] = -1;
          break;
        case 10:
          mountainSet[0] = 280;
          mountainSet[1] = 281;
          treeSet[0] = 282;
          treeSet[1] = -1;
          treeSet[2] = -1;
          break;
        case 31:
          mountainSet[1] = 90;
          treeSet[0] = 91;
          treeSet[1] = -1;
          treeSet[2] = 11;
          break;
        case 51:
          mountainSet[0] = 93;
          mountainSet[1] = 94;
          treeSet[0] = -1;
          treeSet[1] = -1;
          treeSet[2] = 11;
          break;
        case 71:
          mountainSet[0] = 176;
          mountainSet[1] = 177;
          treeSet[0] = 178;
          treeSet[1] = -1;
          treeSet[2] = 11;
          break;
        case 72:
          mountainSet[0] = 176;
          mountainSet[1] = 177;
          treeSet[0] = 178;
          treeSet[1] = -1;
          treeSet[2] = 52;
          break;
        case 73:
          mountainSet[0] = 176;
          mountainSet[1] = 177;
          treeSet[0] = 178;
          treeSet[1] = -1;
          treeSet[2] = 55;
          break;
        default:
          treeSet[0] = 9;
          treeSet[1] = 10;
          treeSet[2] = 11;
          break;
      }
    }

    public static void RandomizeWeather()
    {
      Main.numClouds = WorldGen.genRand.Next(10, 200);
      Main.windSpeedCurrent = 0.0f;
      while ((double) Main.windSpeedCurrent == 0.0)
      {
        Main.windSpeedCurrent = (float) WorldGen.genRand.Next(-400, 401) * (1f / 1000f);
        Main.windSpeedTarget = Main.windSpeedCurrent;
      }
      Cloud.resetClouds();
    }

    public static void RandomizeMoonState()
    {
      Main.moonType = WorldGen.genRand.Next(9);
    }

    public static void RandomizeBackgroundBasedOnPlayer(UnifiedRandom random, Player player)
    {
      if (player.ZoneGlowshroom)
      {
        int mushroomBg = WorldGen.mushroomBG;
        while (mushroomBg == WorldGen.mushroomBG)
          WorldGen.setBG(8, random.Next(4));
      }
      else if (player.ZoneUnderworldHeight)
      {
        int underworldBg = WorldGen.underworldBG;
        while (underworldBg == WorldGen.underworldBG)
          WorldGen.setBG(9, random.Next(3));
      }
      else if (player.ZoneDesert)
      {
        int desertBg = WorldGen.desertBG;
        while (desertBg == WorldGen.desertBG)
          WorldGen.setBG(6, random.Next(5));
      }
      else if (player.ZoneHallow)
      {
        int hallowBg = WorldGen.hallowBG;
        while (hallowBg == WorldGen.hallowBG)
          WorldGen.setBG(4, random.Next(5));
      }
      else if (player.ZoneCorrupt)
      {
        int corruptBg = WorldGen.corruptBG;
        while (corruptBg == WorldGen.corruptBG)
          WorldGen.setBG(1, random.Next(5));
      }
      else if (player.ZoneCrimson)
      {
        int crimsonBg = WorldGen.crimsonBG;
        while (crimsonBg == WorldGen.crimsonBG)
          WorldGen.setBG(5, random.Next(6));
      }
      else if (player.ZoneJungle)
      {
        int jungleBg = WorldGen.jungleBG;
        while (jungleBg == WorldGen.jungleBG)
          WorldGen.setBG(2, random.Next(6));
      }
      else if (player.ZoneSnow)
      {
        int snowBg = WorldGen.snowBG;
        while (snowBg == WorldGen.snowBG)
        {
          WorldGen.snowBG = random.Next(8);
          if (WorldGen.snowBG == 2 && random.Next(2) == 0)
            WorldGen.snowBG = random.Next(2) != 0 ? 22 : 21;
          if (WorldGen.snowBG == 3 && random.Next(2) == 0)
            WorldGen.snowBG = random.Next(2) != 0 ? 32 : 31;
          if (WorldGen.snowBG == 4 && random.Next(2) == 0)
            WorldGen.snowBG = random.Next(2) != 0 ? 42 : 41;
          WorldGen.setBG(3, WorldGen.snowBG);
        }
      }
      else if (player.ZoneBeach)
      {
        int oceanBg = WorldGen.oceanBG;
        while (oceanBg == WorldGen.oceanBG)
          WorldGen.setBG(7, random.Next(6));
      }
      else
      {
        int num = (int) ((double) player.Center.X / 16.0);
        if (num < Main.treeX[0])
        {
          int treeBg1 = WorldGen.treeBG1;
          while (treeBg1 == WorldGen.treeBG1)
            WorldGen.treeBG1 = WorldGen.RollRandomForestBGStyle(random);
          WorldGen.setBG(0, WorldGen.treeBG1);
        }
        else if (num < Main.treeX[1])
        {
          int treeBg2 = WorldGen.treeBG2;
          while (treeBg2 == WorldGen.treeBG2)
            WorldGen.treeBG2 = WorldGen.RollRandomForestBGStyle(random);
          WorldGen.setBG(10, WorldGen.treeBG2);
        }
        else if (num < Main.treeX[2])
        {
          int treeBg3 = WorldGen.treeBG3;
          while (treeBg3 == WorldGen.treeBG3)
            WorldGen.treeBG3 = WorldGen.RollRandomForestBGStyle(random);
          WorldGen.setBG(11, WorldGen.treeBG3);
        }
        else
        {
          int treeBg4 = WorldGen.treeBG4;
          while (treeBg4 == WorldGen.treeBG4)
            WorldGen.treeBG4 = WorldGen.RollRandomForestBGStyle(random);
          WorldGen.setBG(12, WorldGen.treeBG4);
        }
      }
      WorldGen.BackgroundsCache.UpdateCache();
    }

    public static void RandomizeBackgrounds(UnifiedRandom random)
    {
      WorldGen.treeBG1 = WorldGen.RollRandomForestBGStyle(random);
      WorldGen.treeBG2 = WorldGen.RollRandomForestBGStyle(random);
      while (WorldGen.treeBG2 == WorldGen.treeBG1)
        WorldGen.treeBG2 = WorldGen.RollRandomForestBGStyle(random);
      WorldGen.treeBG3 = WorldGen.RollRandomForestBGStyle(random);
      while (WorldGen.treeBG3 == WorldGen.treeBG1 || WorldGen.treeBG3 == WorldGen.treeBG2)
        WorldGen.treeBG3 = WorldGen.RollRandomForestBGStyle(random);
      WorldGen.treeBG4 = WorldGen.RollRandomForestBGStyle(random);
      while (WorldGen.treeBG4 == WorldGen.treeBG1 || WorldGen.treeBG4 == WorldGen.treeBG2 || WorldGen.treeBG4 == WorldGen.treeBG3)
        WorldGen.treeBG4 = WorldGen.RollRandomForestBGStyle(random);
      WorldGen.setBG(0, WorldGen.treeBG1);
      WorldGen.setBG(10, WorldGen.treeBG2);
      WorldGen.setBG(11, WorldGen.treeBG3);
      WorldGen.setBG(12, WorldGen.treeBG4);
      WorldGen.setBG(1, random.Next(5));
      WorldGen.setBG(2, random.Next(6));
      WorldGen.snowBG = random.Next(8);
      if (WorldGen.snowBG == 2 && random.Next(2) == 0)
        WorldGen.snowBG = random.Next(2) != 0 ? 22 : 21;
      if (WorldGen.snowBG == 3 && random.Next(2) == 0)
        WorldGen.snowBG = random.Next(2) != 0 ? 32 : 31;
      if (WorldGen.snowBG == 4 && random.Next(2) == 0)
        WorldGen.snowBG = random.Next(2) != 0 ? 42 : 41;
      WorldGen.setBG(3, WorldGen.snowBG);
      WorldGen.setBG(4, random.Next(5));
      WorldGen.setBG(5, random.Next(6));
      WorldGen.setBG(6, random.Next(5));
      WorldGen.setBG(7, random.Next(6));
      WorldGen.setBG(8, random.Next(4));
      WorldGen.setBG(9, random.Next(3));
    }

    private static int RollRandomForestBGStyle(UnifiedRandom random)
    {
      int num = random.Next(11);
      if ((num == 1 || num == 2) && random.Next(2) == 0)
        num = random.Next(11);
      if (num == 0)
        num = random.Next(11);
      if (num == 3 && random.Next(3) == 0)
        num = 31;
      if (num == 5 && random.Next(2) == 0)
        num = 51;
      if (num == 7 && random.Next(4) == 0)
        num = random.Next(71, 74);
      return num;
    }

    public static void RandomizeTreeStyle()
    {
      switch (Main.maxTilesX)
      {
        case 4200:
          Main.treeX[0] = WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.5 - (double) Main.maxTilesX * 0.25), (int) ((double) Main.maxTilesX * 0.5 + (double) Main.maxTilesX * 0.25));
          Main.treeStyle[0] = WorldGen.genRand.Next(6);
          Main.treeStyle[1] = WorldGen.genRand.Next(6);
          while (Main.treeStyle[1] == Main.treeStyle[0])
            Main.treeStyle[1] = WorldGen.genRand.Next(6);
          Main.treeX[1] = Main.maxTilesX;
          Main.treeX[2] = Main.maxTilesX;
          for (int index = 0; index < 2; ++index)
          {
            if (Main.treeStyle[index] == 0 && WorldGen.genRand.Next(3) != 0)
              Main.treeStyle[index] = 4;
          }
          break;
        case 6400:
          Main.treeX[0] = WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.334 - (double) Main.maxTilesX * 0.200000002980232), (int) ((double) Main.maxTilesX * 0.334 + (double) Main.maxTilesX * 0.200000002980232));
          Main.treeX[1] = WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.667 - (double) Main.maxTilesX * 0.200000002980232), (int) ((double) Main.maxTilesX * 0.667 + (double) Main.maxTilesX * 0.200000002980232));
          Main.treeStyle[0] = WorldGen.genRand.Next(6);
          Main.treeStyle[1] = WorldGen.genRand.Next(6);
          Main.treeStyle[2] = WorldGen.genRand.Next(6);
          while (Main.treeStyle[1] == Main.treeStyle[0])
            Main.treeStyle[1] = WorldGen.genRand.Next(6);
          while (Main.treeStyle[2] == Main.treeStyle[0] || Main.treeStyle[2] == Main.treeStyle[1])
            Main.treeStyle[2] = WorldGen.genRand.Next(6);
          Main.treeX[2] = Main.maxTilesX;
          for (int index = 0; index < 3; ++index)
          {
            if (Main.treeStyle[index] == 0 && WorldGen.genRand.Next(3) != 0)
              Main.treeStyle[index] = 4;
          }
          break;
        default:
          Main.treeX[0] = WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.25 - (double) Main.maxTilesX * 0.150000005960464), (int) ((double) Main.maxTilesX * 0.25 + (double) Main.maxTilesX * 0.150000005960464));
          Main.treeX[1] = WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.5 - (double) Main.maxTilesX * 0.150000005960464), (int) ((double) Main.maxTilesX * 0.5 + (double) Main.maxTilesX * 0.150000005960464));
          Main.treeX[2] = WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.75 - (double) Main.maxTilesX * 0.150000005960464), (int) ((double) Main.maxTilesX * 0.75 + (double) Main.maxTilesX * 0.150000005960464));
          Main.treeStyle[0] = WorldGen.genRand.Next(6);
          Main.treeStyle[1] = WorldGen.genRand.Next(6);
          Main.treeStyle[2] = WorldGen.genRand.Next(6);
          Main.treeStyle[3] = WorldGen.genRand.Next(6);
          while (Main.treeStyle[1] == Main.treeStyle[0])
            Main.treeStyle[1] = WorldGen.genRand.Next(6);
          while (Main.treeStyle[2] == Main.treeStyle[0] || Main.treeStyle[2] == Main.treeStyle[1])
            Main.treeStyle[2] = WorldGen.genRand.Next(6);
          while (Main.treeStyle[3] == Main.treeStyle[0] || Main.treeStyle[3] == Main.treeStyle[1] || Main.treeStyle[3] == Main.treeStyle[2])
            Main.treeStyle[3] = WorldGen.genRand.Next(6);
          for (int index = 0; index < 4; ++index)
          {
            if (Main.treeStyle[index] == 0 && WorldGen.genRand.Next(3) != 0)
              Main.treeStyle[index] = 4;
          }
          break;
      }
    }

    public static void RandomizeCaveBackgrounds()
    {
      int maxValue = 8;
      switch (Main.maxTilesX)
      {
        case 4200:
          Main.caveBackX[0] = WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.5 - (double) Main.maxTilesX * 0.25), (int) ((double) Main.maxTilesX * 0.5 + (double) Main.maxTilesX * 0.25));
          Main.caveBackX[1] = Main.maxTilesX;
          Main.caveBackX[2] = Main.maxTilesX;
          Main.caveBackStyle[0] = WorldGen.genRand.Next(maxValue);
          Main.caveBackStyle[1] = WorldGen.genRand.Next(maxValue);
          while (Main.caveBackStyle[1] == Main.caveBackStyle[0])
            Main.caveBackStyle[1] = WorldGen.genRand.Next(maxValue);
          break;
        case 6400:
          Main.caveBackX[0] = WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.334 - (double) Main.maxTilesX * 0.200000002980232), (int) ((double) Main.maxTilesX * 0.334 + (double) Main.maxTilesX * 0.200000002980232));
          Main.caveBackX[1] = WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.667 - (double) Main.maxTilesX * 0.200000002980232), (int) ((double) Main.maxTilesX * 0.667 + (double) Main.maxTilesX * 0.200000002980232));
          Main.caveBackX[2] = Main.maxTilesX;
          Main.caveBackStyle[0] = WorldGen.genRand.Next(maxValue);
          Main.caveBackStyle[1] = WorldGen.genRand.Next(maxValue);
          Main.caveBackStyle[2] = WorldGen.genRand.Next(maxValue);
          while (Main.caveBackStyle[1] == Main.caveBackStyle[0])
            Main.caveBackStyle[1] = WorldGen.genRand.Next(maxValue);
          while (Main.caveBackStyle[2] == Main.caveBackStyle[0] || Main.caveBackStyle[2] == Main.caveBackStyle[1])
            Main.caveBackStyle[2] = WorldGen.genRand.Next(maxValue);
          break;
        default:
          Main.caveBackX[0] = WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.25 - (double) Main.maxTilesX * 0.150000005960464), (int) ((double) Main.maxTilesX * 0.25 + (double) Main.maxTilesX * 0.150000005960464));
          Main.caveBackX[1] = WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.5 - (double) Main.maxTilesX * 0.150000005960464), (int) ((double) Main.maxTilesX * 0.5 + (double) Main.maxTilesX * 0.150000005960464));
          Main.caveBackX[2] = WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.75 - (double) Main.maxTilesX * 0.150000005960464), (int) ((double) Main.maxTilesX * 0.75 + (double) Main.maxTilesX * 0.150000005960464));
          Main.caveBackStyle[0] = WorldGen.genRand.Next(maxValue);
          Main.caveBackStyle[1] = WorldGen.genRand.Next(maxValue);
          Main.caveBackStyle[2] = WorldGen.genRand.Next(maxValue);
          Main.caveBackStyle[3] = WorldGen.genRand.Next(maxValue);
          while (Main.caveBackStyle[1] == Main.caveBackStyle[0])
            Main.caveBackStyle[1] = WorldGen.genRand.Next(maxValue);
          while (Main.caveBackStyle[2] == Main.caveBackStyle[0] || Main.caveBackStyle[2] == Main.caveBackStyle[1])
            Main.caveBackStyle[2] = WorldGen.genRand.Next(maxValue);
          while (Main.caveBackStyle[3] == Main.caveBackStyle[0] || Main.caveBackStyle[3] == Main.caveBackStyle[1] || Main.caveBackStyle[3] == Main.caveBackStyle[2])
            Main.caveBackStyle[3] = WorldGen.genRand.Next(maxValue);
          break;
      }
      Main.iceBackStyle = WorldGen.genRand.Next(4);
      Main.hellBackStyle = WorldGen.genRand.Next(3);
      Main.jungleBackStyle = WorldGen.genRand.Next(2);
    }

    private static void ResetGenerator()
    {
      WorldGen.numOrePatch = 0;
      WorldGen.numTunnels = 0;
      WorldGen.numLakes = 0;
      WorldGen.numMushroomBiomes = 0;
      WorldGen.numOceanCaveTreasure = 0;
      WorldGen.numOasis = 0;
      WorldGen.mudWall = false;
      WorldGen.hellChest = 0;
      WorldGen.JungleX = 0;
      WorldGen.numMCaves = 0;
      WorldGen.numIslandHouses = 0;
      WorldGen.houseCount = 0;
      WorldGen.dEnteranceX = 0;
      WorldGen.numDRooms = 0;
      WorldGen.numDDoors = 0;
      WorldGen.generatedShadowKey = false;
      WorldGen.numDungeonPlatforms = 0;
      WorldGen.numJChests = 0;
      WorldGen.JungleItemCount = 0;
    }

    public static bool mayanTrap(int x2, int y2)
    {
      int num1 = 1;
      if (WorldGen.genRand.Next(3) == 0)
        num1 = 0;
      int index1 = x2;
      int y = y2;
      while (!WorldGen.SolidOrSlopedTile(index1, y))
      {
        ++y;
        if (y >= Main.maxTilesY - 300)
          return false;
      }
      if (Main.tile[index1, y].type == (ushort) 232 || Main.tile[index1, y].type == (ushort) 10)
        return false;
      int j = y - 1;
      if (Main.tile[index1, j].liquid > (byte) 0 && Main.tile[index1, j].lava())
        return false;
      if (num1 == -1 && WorldGen.genRand.Next(20) == 0)
        num1 = 2;
      else if (num1 == -1)
        num1 = WorldGen.genRand.Next(2);
      if (Main.tile[index1, j].nactive() || Main.tile[index1 - 1, j].nactive() || (Main.tile[index1 + 1, j].nactive() || Main.tile[index1, j - 1].nactive()) || (Main.tile[index1 - 1, j - 1].nactive() || Main.tile[index1 + 1, j - 1].nactive() || (Main.tile[index1, j - 2].nactive() || Main.tile[index1 - 1, j - 2].nactive())) || (Main.tile[index1 + 1, j - 2].nactive() || Main.tile[index1, j + 1].type == (ushort) 10 || (Main.tile[index1, j + 1].type == (ushort) 48 || Main.tile[index1, j + 1].type == (ushort) 232)))
        return false;
      switch (num1)
      {
        case 0:
          int x1 = index1;
          int index2 = j - WorldGen.genRand.Next(3);
          while (!WorldGen.SolidOrSlopedTile(x1, index2))
            --x1;
          int x3 = x1;
          int x4 = index1;
          while (!WorldGen.SolidOrSlopedTile(x4, index2))
            ++x4;
          int x5 = x4;
          int num2 = index1 - x3;
          int num3 = x5 - index1;
          bool flag1 = false;
          bool flag2 = false;
          if (num2 > 5 && num2 < 50)
            flag1 = true;
          if (num3 > 5 && num3 < 50)
            flag2 = true;
          if (flag1 && !WorldGen.SolidOrSlopedTile(x3, index2 + 1))
            flag1 = false;
          if (flag2 && !WorldGen.SolidOrSlopedTile(x5, index2 + 1))
            flag2 = false;
          if (flag1 && (Main.tile[x3, index2].type == (ushort) 10 || Main.tile[x3, index2].type == (ushort) 48 || (Main.tile[x3, index2 + 1].type == (ushort) 10 || Main.tile[x3, index2 + 1].type == (ushort) 48)))
            flag1 = false;
          if (flag2 && (Main.tile[x5, index2].type == (ushort) 10 || Main.tile[x5, index2].type == (ushort) 48 || (Main.tile[x5, index2 + 1].type == (ushort) 10 || Main.tile[x5, index2 + 1].type == (ushort) 48)))
            flag2 = false;
          int num4;
          int i;
          if (flag1 & flag2)
          {
            num4 = 1;
            i = x3;
            if (WorldGen.genRand.Next(2) == 0)
            {
              i = x5;
              num4 = -1;
            }
          }
          else if (flag2)
          {
            i = x5;
            num4 = -1;
          }
          else
          {
            if (!flag1)
              return false;
            i = x3;
            num4 = 1;
          }
          if (Main.tile[i, index2].wall != (ushort) 87 || Main.tile[i, index2].type == (ushort) 190 || (Main.tile[i, index2].type == (ushort) 135 || Main.tile[i, index2].type == (ushort) 137) || (Main.tile[i, index2].type == (ushort) 232 || Main.tile[i, index2].type == (ushort) 237 || Main.tile[i, index2].type == (ushort) 10))
            return false;
          WorldGen.PlaceTile(index1, j, 135, true, true, -1, 6);
          WorldGen.KillTile(i, index2, false, false, false);
          int num5 = WorldGen.genRand.Next(3);
          if (Main.tile[index1, j].wire())
            num5 = 0;
          if (Main.tile[index1, j].wire2())
            num5 = 1;
          if (Main.tile[index1, j].wire3())
            num5 = 2;
          int num6 = Math.Abs(i - index1);
          int style1 = 1;
          if (num6 < 10 && WorldGen.genRand.Next(3) != 0)
            style1 = 2;
          WorldGen.PlaceTile(i, index2, 137, true, true, -1, style1);
          if (num4 == 1)
            Main.tile[i, index2].frameX += (short) 18;
          int num7 = WorldGen.genRand.Next(5);
          int index3 = index2;
          while (num7 > 0)
          {
            --num7;
            --index3;
            if (WorldGen.SolidTile(i, index3, false) && WorldGen.SolidTile(i - num4, index3, false) && !WorldGen.SolidOrSlopedTile(i + num4, index3))
            {
              WorldGen.PlaceTile(i, index3, 137, true, true, -1, style1);
              if (num4 == 1)
                Main.tile[i, index3].frameX += (short) 18;
              switch (num5)
              {
                case 0:
                  Main.tile[i, index3].wire(true);
                  continue;
                case 1:
                  Main.tile[i, index3].wire2(true);
                  continue;
                case 2:
                  Main.tile[i, index3].wire3(true);
                  continue;
                default:
                  continue;
              }
            }
            else
              break;
          }
          int index4 = index1;
          int index5 = j;
          while (index4 != i || index5 != index2)
          {
            switch (num5)
            {
              case 0:
                Main.tile[index4, index5].wire(true);
                break;
              case 1:
                Main.tile[index4, index5].wire2(true);
                break;
              case 2:
                Main.tile[index4, index5].wire3(true);
                break;
            }
            if (index4 > i)
              --index4;
            if (index4 < i)
              ++index4;
            switch (num5)
            {
              case 0:
                Main.tile[index4, index5].wire(true);
                break;
              case 1:
                Main.tile[index4, index5].wire2(true);
                break;
              case 2:
                Main.tile[index4, index5].wire3(true);
                break;
            }
            if (index5 > index2)
              --index5;
            if (index5 < index2)
              ++index5;
            switch (num5)
            {
              case 0:
                Main.tile[index4, index5].wire(true);
                continue;
              case 1:
                Main.tile[index4, index5].wire2(true);
                continue;
              case 2:
                Main.tile[index4, index5].wire3(true);
                continue;
              default:
                continue;
            }
          }
          return true;
        case 1:
          int index6 = index1;
          int index7 = j;
          while (!WorldGen.SolidOrSlopedTile(index6, index7))
          {
            --index7;
            if ((double) index7 < Main.worldSurface)
              return false;
          }
          int num8 = Math.Abs(index7 - j);
          if (num8 < 3)
            return false;
          int num9 = WorldGen.genRand.Next(3);
          if (Main.tile[index1, j].wire())
            num9 = 0;
          if (Main.tile[index1, j].wire2())
            num9 = 1;
          if (Main.tile[index1, j].wire3())
            num9 = 2;
          int style2 = 3;
          if (num8 < 16 && WorldGen.genRand.Next(3) != 0)
            style2 = 4;
          if (Main.tile[index6, index7].type == (ushort) 135 || Main.tile[index6, index7].type == (ushort) 137 || (Main.tile[index6, index7].type == (ushort) 232 || Main.tile[index6, index7].type == (ushort) 237) || (Main.tile[index6, index7].type == (ushort) 10 || Main.tile[index6, index7].wall != (ushort) 87))
            return false;
          WorldGen.PlaceTile(index1, j, 135, true, true, -1, 6);
          WorldGen.PlaceTile(index6, index7, 137, true, true, -1, style2);
          for (int index8 = 0; index8 < 2; ++index8)
          {
            int num10 = WorldGen.genRand.Next(1, 5);
            int index9 = index6;
            int num11 = -1;
            if (index8 == 1)
              num11 = 1;
            while (num10 > 0)
            {
              --num10;
              index9 += num11;
              if (WorldGen.SolidTile(index9, index7 - 1, false) && !WorldGen.SolidOrSlopedTile(index9, index7 + 1))
              {
                WorldGen.PlaceTile(index9, index7, 137, true, true, -1, style2);
                switch (num9)
                {
                  case 0:
                    Main.tile[index9, index7].wire(true);
                    continue;
                  case 1:
                    Main.tile[index9, index7].wire2(true);
                    continue;
                  case 2:
                    Main.tile[index9, index7].wire3(true);
                    continue;
                  default:
                    continue;
                }
              }
              else
                break;
            }
          }
          int index10 = index1;
          int index11 = j;
          while (index10 != index6 || index11 != index7)
          {
            switch (num9)
            {
              case 0:
                Main.tile[index10, index11].wire(true);
                break;
              case 1:
                Main.tile[index10, index11].wire2(true);
                break;
              case 2:
                Main.tile[index10, index11].wire3(true);
                break;
            }
            if (index10 > index6)
              --index10;
            if (index10 < index6)
              ++index10;
            switch (num9)
            {
              case 0:
                Main.tile[index10, index11].wire(true);
                break;
              case 1:
                Main.tile[index10, index11].wire2(true);
                break;
              case 2:
                Main.tile[index10, index11].wire3(true);
                break;
            }
            if (index11 > index7)
              --index11;
            if (index11 < index7)
              ++index11;
            switch (num9)
            {
              case 0:
                Main.tile[index10, index11].wire(true);
                continue;
              case 1:
                Main.tile[index10, index11].wire2(true);
                continue;
              case 2:
                Main.tile[index10, index11].wire3(true);
                continue;
              default:
                continue;
            }
          }
          return true;
        default:
          return false;
      }
    }

    public static bool placeLavaTrap(int x, int y)
    {
      int num1 = 5;
      int num2 = 50;
      int num3 = 40;
      int num4 = 20;
      int num5 = 4;
      if (Main.tile[x, y].active() || Main.tile[x, y].liquid < byte.MaxValue || !Main.tile[x, y].lava())
        return false;
      int num6 = 0;
      for (int index1 = x - num1; index1 <= x + num1; ++index1)
      {
        for (int index2 = y - num1; index2 <= y + num1; ++index2)
        {
          if (Main.tile[index1, index2].lava() && !Main.tile[index1, index2].active() && Main.tile[index1, index2].liquid == byte.MaxValue)
            ++num6;
        }
      }
      if (num6 < num2)
        return false;
      int index3 = y;
      while (!Main.tile[x, index3].active())
      {
        ++index3;
        if (index3 > Main.maxTilesY - 200)
          return false;
      }
      if (!Main.tileSolid[(int) Main.tile[x, index3].type] || Main.tileSolidTop[(int) Main.tile[x, index3].type])
        return false;
      int num7 = index3;
      for (int index1 = x - num4; index1 <= x + num4; ++index1)
      {
        for (int index2 = index3 - num4; index2 <= index3 + num4; ++index2)
        {
          if (Main.tile[index1, index2].wire())
            return false;
        }
      }
      while (Main.tile[x, index3].active() && Main.tileSolid[(int) Main.tile[x, index3].type] && !Main.tileSolidTop[(int) Main.tile[x, index3].type])
      {
        ++index3;
        if (index3 > Main.maxTilesY - 200)
          return false;
      }
      Tile tile = Main.tile[x, index3 - 1];
      if (Main.tileDungeon[(int) tile.type] || tile.type == (ushort) 225 || tile.type == (ushort) 226)
        return false;
      int num8 = index3;
      while (!Main.tile[x, index3].active())
      {
        ++index3;
        if (index3 > Main.maxTilesY - 200 || Main.tile[x, index3].liquid > (byte) 0)
          return false;
      }
      if (!Main.tileSolid[(int) Main.tile[x, index3].type] || Main.tileSolidTop[(int) Main.tile[x, index3].type])
        return false;
      int j = index3 - 1;
      if (j - num7 > num3 || j - num8 < num5)
        return false;
      Main.tile[x, index3].slope((byte) 0);
      Main.tile[x, index3].halfBrick(false);
      WorldGen.PlaceTile(x, j, 135, false, true, -1, 7);
      for (int index1 = num7; index1 <= j; ++index1)
      {
        Main.tile[x, index1].wire(true);
        if (index1 < num8)
        {
          Main.tile[x, index1].slope((byte) 0);
          Main.tile[x, index1].halfBrick(false);
          Main.tile[x, index1].actuator(true);
        }
      }
      return true;
    }

    public static bool IsTileNearby(int x, int y, int type, int distance)
    {
      for (int x1 = x - distance; x1 <= x + distance; ++x1)
      {
        for (int y1 = y - distance; y1 <= y + distance; ++y1)
        {
          if (WorldGen.InWorld(x1, y1, 0) && Main.tile[x1, y1].active() && (int) Main.tile[x1, y1].type == type)
            return true;
        }
      }
      return false;
    }

    public static bool placeTrap(int x2, int y2, int type = -1)
    {
      int index1 = x2;
      int j1 = y2;
      bool flag1 = false;
      bool flag2 = false;
      while (!WorldGen.SolidTile(index1, j1, false))
      {
        ++j1;
        if (j1 > Main.maxTilesY - 10)
          return false;
        if (j1 >= Main.maxTilesY - 300)
          flag2 = true;
      }
      int index2 = j1 - 1;
      if (WorldGen.IsTileNearby(index1, index2, 70, 20) || Main.tile[index1, index2].wall == (ushort) 87)
        return false;
      if (Main.tile[index1, index2].liquid > (byte) 0 && Main.tile[index1, index2].lava())
        flag1 = true;
      if (type == -1 && WorldGen.genRand.Next(20) == 0)
        type = 2;
      else if (type == -1 && index2 > WorldGen.lavaLine + 30 && WorldGen.genRand.Next(6) != 0)
        type = 3;
      else if (type == -1)
        type = WorldGen.genRand.Next(2);
      if (!WorldGen.InWorld(index1, index2, 3) || flag1 && type != 3 || (flag2 && type != 3 || (Main.tile[index1, index2].nactive() || Main.tile[index1 - 1, index2].nactive())) || (Main.tile[index1 + 1, index2].nactive() || Main.tile[index1, index2 - 1].nactive() || (Main.tile[index1 - 1, index2 - 1].nactive() || Main.tile[index1 + 1, index2 - 1].nactive()) || (Main.tile[index1, index2 - 2].nactive() || Main.tile[index1 - 1, index2 - 2].nactive() || (Main.tile[index1 + 1, index2 - 2].nactive() || Main.tile[index1, index2 + 1].type == (ushort) 48))) || Main.tile[index1, index2 + 1].type == (ushort) 232)
        return false;
      if (type == 1)
      {
        for (int index3 = index1 - 3; index3 <= index1 + 3; ++index3)
        {
          for (int index4 = index2 - 3; index4 <= index2 + 3; ++index4)
          {
            if (Main.tile[index3, index4].type == (ushort) 147 || Main.tile[index3, index4].type == (ushort) 161)
              type = 0;
          }
        }
      }
      if (type == 0)
      {
        int i1 = index1;
        int j2 = index2 - WorldGen.genRand.Next(3);
        while (!WorldGen.SolidTile(i1, j2, false) && !Main.tileCracked[(int) Main.tile[i1, j2].type])
        {
          --i1;
          if (i1 < 0)
            return false;
        }
        int i2 = i1;
        int i3 = index1;
        while (!WorldGen.SolidTile(i3, j2, false) && !Main.tileCracked[(int) Main.tile[i3, j2].type])
        {
          ++i3;
          if (i3 > Main.maxTilesX)
            return false;
        }
        int i4 = i3;
        int num1 = index1 - i2;
        int num2 = i4 - index1;
        bool flag3 = false;
        bool flag4 = false;
        if (num1 > 5 && num1 < 50)
          flag3 = true;
        if (num2 > 5 && num2 < 50)
          flag4 = true;
        if (flag3 && !WorldGen.SolidTile(i2, j2 + 1, false))
          flag3 = false;
        if (flag4 && !WorldGen.SolidTile(i4, j2 + 1, false))
          flag4 = false;
        if (flag3 && (Main.tile[i2, j2].type == (ushort) 10 || Main.tile[i2, j2].type == (ushort) 48 || (Main.tile[i2, j2 + 1].type == (ushort) 10 || Main.tile[i2, j2 + 1].type == (ushort) 48)))
          flag3 = false;
        if (flag4 && (Main.tile[i4, j2].type == (ushort) 10 || Main.tile[i4, j2].type == (ushort) 48 || (Main.tile[i4, j2 + 1].type == (ushort) 10 || Main.tile[i4, j2 + 1].type == (ushort) 48)))
          flag4 = false;
        int num3;
        int i5;
        if (flag3 & flag4)
        {
          num3 = 1;
          i5 = i2;
          if (WorldGen.genRand.Next(2) == 0)
          {
            i5 = i4;
            num3 = -1;
          }
        }
        else if (flag4)
        {
          i5 = i4;
          num3 = -1;
        }
        else if (flag3)
        {
          i5 = i2;
          num3 = 1;
        }
        else
        {
          ++WorldGen.trapDiag[type, 0];
          return false;
        }
        if (Main.tile[i5, j2].type == (ushort) 190)
        {
          ++WorldGen.trapDiag[type, 0];
          return false;
        }
        if (Main.tile[index1, index2].wall > (ushort) 0)
          WorldGen.PlaceTile(index1, index2, 135, true, true, -1, 2);
        else
          WorldGen.PlaceTile(index1, index2, 135, true, true, -1, WorldGen.genRand.Next(2, 4));
        WorldGen.KillTile(i5, j2, false, false, false);
        WorldGen.PlaceTile(i5, j2, 137, true, true, -1, 0);
        if (num3 == 1)
          Main.tile[i5, j2].frameX += (short) 18;
        int index3 = index1;
        int index4 = index2;
        while (index3 != i5 || index4 != j2)
        {
          Main.tile[index3, index4].wire(true);
          if (index3 > i5)
            --index3;
          if (index3 < i5)
            ++index3;
          Main.tile[index3, index4].wire(true);
          if (index4 > j2)
            --index4;
          if (index4 < j2)
            ++index4;
          Main.tile[index3, index4].wire(true);
        }
        ++WorldGen.trapDiag[type, 1];
        return true;
      }
      if (type == 1)
      {
        int num1 = index1;
        int y = index2 - 8;
        int index3 = num1 + WorldGen.genRand.Next(-1, 2);
        if (WorldGen.IsTileNearby(index3, y, 138, 10))
          return false;
        bool flag3 = true;
        while (flag3)
        {
          bool flag4 = true;
          int num2 = 0;
          for (int i = index3 - 2; i <= index3 + 3; ++i)
          {
            for (int j2 = y; j2 <= y + 3; ++j2)
            {
              if (!WorldGen.SolidTile(i, j2, false))
                flag4 = false;
              if (Main.tile[i, j2].active() && (Main.tile[i, j2].type == (ushort) 0 || Main.tile[i, j2].type == (ushort) 1 || Main.tile[i, j2].type == (ushort) 59))
                ++num2;
            }
          }
          --y;
          if ((double) y < Main.worldSurface)
          {
            ++WorldGen.trapDiag[type, 0];
            return false;
          }
          if (flag4 && num2 > 2)
            flag3 = false;
        }
        if (index2 - y <= 5 || index2 - y >= 40)
        {
          ++WorldGen.trapDiag[type, 0];
          return false;
        }
        for (int i = index3; i <= index3 + 1; ++i)
        {
          for (int j2 = y; j2 <= index2; ++j2)
            WorldGen.KillTile(i, j2, false, false, false);
        }
        for (int i = index3 - 2; i <= index3 + 3; ++i)
        {
          for (int j2 = y - 2; j2 <= y + 3; ++j2)
          {
            if (WorldGen.SolidTile(i, j2, false))
              Main.tile[i, j2].type = (ushort) 1;
          }
        }
        WorldGen.PlaceTile(index1, index2, 135, true, true, -1, 7);
        WorldGen.PlaceTile(index3, y + 2, 130, true, false, -1, 0);
        WorldGen.PlaceTile(index3 + 1, y + 2, 130, true, false, -1, 0);
        WorldGen.PlaceTile(index3 + 1, y + 1, 138, true, false, -1, 0);
        int index4 = y + 2;
        Main.tile[index3, index4].wire(true);
        Main.tile[index3 + 1, index4].wire(true);
        int j3 = index4 + 1;
        WorldGen.PlaceTile(index3, j3, 130, true, false, -1, 0);
        WorldGen.PlaceTile(index3 + 1, j3, 130, true, false, -1, 0);
        Main.tile[index3, j3].wire(true);
        Main.tile[index3 + 1, j3].wire(true);
        WorldGen.PlaceTile(index3, j3 + 1, 130, true, false, -1, 0);
        WorldGen.PlaceTile(index3 + 1, j3 + 1, 130, true, false, -1, 0);
        Main.tile[index3, j3 + 1].wire(true);
        Main.tile[index3 + 1, j3 + 1].wire(true);
        int index5 = index1;
        int index6 = index2;
        while (index5 != index3 || index6 != j3)
        {
          Main.tile[index5, index6].wire(true);
          if (index5 > index3)
            --index5;
          if (index5 < index3)
            ++index5;
          Main.tile[index5, index6].wire(true);
          if (index6 > j3)
            --index6;
          if (index6 < j3)
            ++index6;
          Main.tile[index5, index6].wire(true);
        }
        ++WorldGen.trapDiag[type, 1];
        return true;
      }
      if (type == 2)
      {
        int num = WorldGen.genRand.Next(4, 7);
        int i1 = index1 + WorldGen.genRand.Next(-1, 2);
        int j2 = index2;
        for (int index3 = 0; index3 < num; ++index3)
        {
          ++j2;
          if (!WorldGen.SolidTile(i1, j2, false))
          {
            ++WorldGen.trapDiag[type, 0];
            return false;
          }
        }
        for (int i2 = i1 - 2; i2 <= i1 + 2; ++i2)
        {
          for (int j3 = j2 - 2; j3 <= j2 + 2; ++j3)
          {
            if (!WorldGen.SolidTile(i2, j3, false))
              return false;
          }
        }
        WorldGen.KillTile(i1, j2, false, false, false);
        Main.tile[i1, j2].active(true);
        Main.tile[i1, j2].type = (ushort) 141;
        Main.tile[i1, j2].frameX = (short) 0;
        Main.tile[i1, j2].frameY = (short) (18 * WorldGen.genRand.Next(2));
        WorldGen.PlaceTile(index1, index2, 135, true, true, -1, WorldGen.genRand.Next(2, 4));
        int index4 = index1;
        int index5 = index2;
        while (index4 != i1 || index5 != j2)
        {
          Main.tile[index4, index5].wire(true);
          if (index4 > i1)
            --index4;
          if (index4 < i1)
            ++index4;
          Main.tile[index4, index5].wire(true);
          if (index5 > j2)
            --index5;
          if (index5 < j2)
            ++index5;
          Main.tile[index4, index5].wire(true);
        }
        ++WorldGen.trapDiag[type, 1];
      }
      else if (type == 3 && !Main.tile[index1 + 1, index2].active())
      {
        for (int i = index1; i <= index1 + 1; ++i)
        {
          int j2 = index2 + 1;
          if (!WorldGen.SolidTile(i, j2, false))
            return false;
        }
        int num = WorldGen.genRand.Next(2);
        for (int index3 = 0; index3 < 2; ++index3)
        {
          Main.tile[index1 + index3, index2].active(true);
          Main.tile[index1 + index3, index2].type = (ushort) 443;
          Main.tile[index1 + index3, index2].frameX = (short) (18 * index3 + 36 * num);
          Main.tile[index1 + index3, index2].frameY = (short) 0;
        }
        return true;
      }
      return false;
    }

    public static int countWires(int x, int y, int size)
    {
      int num = 0;
      for (int x1 = x - size; x1 <= x + size; ++x1)
      {
        for (int y1 = y - size; y1 <= y + size; ++y1)
        {
          if (WorldGen.InWorld(x1, y1, 0))
          {
            if (Main.tile[x1, y1].wire())
              ++num;
            if (Main.tile[x1, y1].wire2())
              ++num;
            if (Main.tile[x1, y1].wire3())
              ++num;
            if (Main.tile[x1, y1].wire4())
              ++num;
          }
        }
      }
      return num;
    }

    public static int countTiles(int x, int y, bool jungle = false, bool lavaOk = false)
    {
      WorldGen.numTileCount = 0;
      WorldGen.shroomCount = 0;
      WorldGen.lavaCount = 0;
      WorldGen.iceCount = 0;
      WorldGen.rockCount = 0;
      WorldGen.CountedTiles.Clear();
      WorldGen.nextCount(x, y, jungle, lavaOk);
      return WorldGen.numTileCount;
    }

    public static void nextCount(int x, int y, bool jungle = false, bool lavaOk = false)
    {
      if (WorldGen.numTileCount >= WorldGen.maxTileCount)
        return;
      if (x <= 1 || x >= Main.maxTilesX - 1 || (y <= 1 || y >= Main.maxTilesY - 1))
      {
        WorldGen.numTileCount = WorldGen.maxTileCount;
      }
      else
      {
        if (WorldGen.CountedTiles.ContainsKey(new Point(x, y)))
          return;
        if (Main.tile[x, y].wall == (ushort) 244)
        {
          WorldGen.numTileCount = WorldGen.maxTileCount;
        }
        else
        {
          if (!jungle)
          {
            if (Main.tile[x, y].wall != (ushort) 0)
            {
              WorldGen.numTileCount = WorldGen.maxTileCount;
              return;
            }
            if (!lavaOk)
            {
              if (Main.tile[x, y].lava() && Main.tile[x, y].liquid > (byte) 0)
              {
                ++WorldGen.lavaCount;
                WorldGen.numTileCount = WorldGen.maxTileCount;
                return;
              }
            }
            else if (Main.tile[x, y].lava() && Main.tile[x, y].liquid > (byte) 0)
              ++WorldGen.lavaCount;
          }
          if (Main.tile[x, y].active())
          {
            if (Main.tile[x, y].type == (ushort) 70)
              ++WorldGen.shroomCount;
            if (Main.tile[x, y].type == (ushort) 1)
              ++WorldGen.rockCount;
            if (Main.tile[x, y].type == (ushort) 147 || Main.tile[x, y].type == (ushort) 161)
              ++WorldGen.iceCount;
          }
          if (WorldGen.SolidTile(x, y, false))
            return;
          WorldGen.CountedTiles.Add(new Point(x, y), true);
          ++WorldGen.numTileCount;
          WorldGen.nextCount(x - 1, y, jungle, lavaOk);
          WorldGen.nextCount(x + 1, y, jungle, lavaOk);
          WorldGen.nextCount(x, y - 1, jungle, lavaOk);
          WorldGen.nextCount(x, y + 1, jungle, lavaOk);
        }
      }
    }

    public static int countDirtTiles(int x, int y)
    {
      WorldGen.numTileCount = 0;
      WorldGen.CountedTiles.Clear();
      WorldGen.nextDirtCount(x, y);
      return WorldGen.numTileCount;
    }

    public static void nextDirtCount(int x, int y)
    {
      if (WorldGen.numTileCount >= WorldGen.maxTileCount)
        return;
      if (x <= 1 || x >= Main.maxTilesX - 1 || (y <= 1 || y >= Main.maxTilesY - 1))
      {
        WorldGen.numTileCount = WorldGen.maxTileCount;
      }
      else
      {
        if (WorldGen.CountedTiles.ContainsKey(new Point(x, y)))
          return;
        if (Main.tile[x, y].active() && (Main.tile[x, y].type == (ushort) 147 || Main.tile[x, y].type == (ushort) 161))
          WorldGen.numTileCount = WorldGen.maxTileCount;
        else if (Main.tile[x, y].wall == (ushort) 244 || Main.tile[x, y].wall == (ushort) 83 || (Main.tile[x, y].wall == (ushort) 3 || Main.tile[x, y].wall == (ushort) 187) || Main.tile[x, y].wall == (ushort) 216)
        {
          WorldGen.numTileCount = WorldGen.maxTileCount;
        }
        else
        {
          if (WorldGen.SolidTile(x, y, false) || Main.tile[x, y].wall != (ushort) 2 && Main.tile[x, y].wall != (ushort) 59)
            return;
          WorldGen.CountedTiles.Add(new Point(x, y), true);
          ++WorldGen.numTileCount;
          WorldGen.nextDirtCount(x - 1, y);
          WorldGen.nextDirtCount(x + 1, y);
          WorldGen.nextDirtCount(x, y - 1);
          WorldGen.nextDirtCount(x, y + 1);
          WorldGen.nextDirtCount(x - 1, y - 1);
          WorldGen.nextDirtCount(x - 1, y + 1);
          WorldGen.nextDirtCount(x + 1, y - 1);
          WorldGen.nextDirtCount(x + 1, y + 1);
          WorldGen.nextDirtCount(x - 2, y);
          WorldGen.nextDirtCount(x + 2, y);
        }
      }
    }

    public static bool InWorld(int x, int y, int fluff = 0)
    {
      return x >= fluff && x < Main.maxTilesX - fluff && (y >= fluff && y < Main.maxTilesY - fluff);
    }

    public static void gemCave(int x, int y)
    {
      WorldGen.countTiles(x, y, false, false);
      for (int index = 0; index < 6; ++index)
        WorldGen.gem[index] = false;
      WorldGen.gem[WorldGen.genRand.Next(6)] = true;
      for (int index = 0; index < 6; ++index)
      {
        if (WorldGen.genRand.Next(6) == 0)
          WorldGen.gem[index] = true;
      }
      WorldGen.Spread.Gem(x, y);
    }

    public static int randGem()
    {
      int index = WorldGen.genRand.Next(6);
      while (!WorldGen.gem[index])
        index = WorldGen.genRand.Next(6);
      return index;
    }

    public static ushort randGemTile()
    {
      if (WorldGen.genRand.Next(20) != 0)
        return 1;
      switch ((ushort) WorldGen.randGem())
      {
        case 0:
          return 67;
        case 1:
          return 66;
        case 2:
          return 63;
        case 3:
          return 65;
        case 4:
          return 64;
        default:
          return 68;
      }
    }

    public static void randMoss()
    {
      WorldGen.neonMossType = WorldGen.genRand.NextFromList<ushort>((ushort) 539, (ushort) 536, (ushort) 534);
      WorldGen.mossType[0] = WorldGen.genRand.Next(5);
      WorldGen.mossType[1] = WorldGen.genRand.Next(5);
      while (WorldGen.mossType[1] == WorldGen.mossType[0])
        WorldGen.mossType[1] = WorldGen.genRand.Next(5);
      WorldGen.mossType[2] = WorldGen.genRand.Next(5);
      while (WorldGen.mossType[2] == WorldGen.mossType[0] || WorldGen.mossType[2] == WorldGen.mossType[1])
        WorldGen.mossType[2] = WorldGen.genRand.Next(5);
    }

    public static void neonMossBiome(int i, int j, int maxY = 99999)
    {
      Vector2 vector2_1;
      vector2_1.X = (float) i;
      vector2_1.Y = (float) j;
      Vector2 vector2_2;
      vector2_2.X = (float) ((double) WorldGen.genRand.NextFloat() * 4.0 - 2.0);
      vector2_2.Y = (float) ((double) WorldGen.genRand.NextFloat() * 4.0 - 2.0);
      if ((double) vector2_2.X == 0.0)
        vector2_2.X = 1f;
      while ((double) vector2_2.Length() < 4.0)
        vector2_2 *= 1.5f;
      double num1 = (double) WorldGen.genRand.Next(60, 80);
      double num2 = (double) WorldGen.genRand.Next(30, 40);
      float num3 = (float) (Main.maxTilesX / 4200);
      if (WorldGen.getGoodWorldGen)
        num3 *= 1.5f;
      double num4 = num1 * (double) num3;
      double num5 = num2 * (double) num3;
      while (num5 > 0.0)
      {
        num4 *= 0.980000019073486;
        --num5;
        int num6 = (int) ((double) vector2_1.X - num4);
        int num7 = (int) ((double) vector2_1.X + num4);
        int num8 = (int) ((double) vector2_1.Y - num4);
        int num9 = (int) ((double) vector2_1.Y + num4);
        if (num6 < 1)
          num6 = 1;
        if (num7 > Main.maxTilesX - 1)
          num7 = Main.maxTilesX - 1;
        if (num8 < 1)
          num8 = 1;
        if (num9 > Main.maxTilesY - 1)
          num9 = Main.maxTilesY - 1;
        if ((double) num8 < Main.rockLayer)
        {
          num8 = (int) Main.rockLayer;
          if ((double) vector2_2.Y < 5.0)
            vector2_2.Y = 5f;
        }
        if (num9 > maxY)
        {
          num9 = maxY;
          if ((double) vector2_2.Y > -5.0)
            vector2_2.Y = -5f;
        }
        double num10 = num4 * (1.0 + (double) WorldGen.genRand.NextFloat() * 0.400000005960464 - 0.200000002980232);
        for (int x = num6; x < num7; ++x)
        {
          for (int index = num8; index < num9; ++index)
          {
            if ((double) new Vector2(Math.Abs((float) x - vector2_1.X), Math.Abs((float) index - vector2_1.Y)).Length() < num10 * 0.8 && WorldGen.TileType(x, index) == 1 && (!Main.tile[x - 1, index].active() || !Main.tile[x + 1, index].active() || (!Main.tile[x, index - 1].active() || !Main.tile[x, index + 1].active())))
              WorldGen.SpreadGrass(x - 1, index, 1, (int) WorldGen.neonMossType, true, (byte) 0);
          }
        }
        vector2_1 += vector2_2;
        vector2_2.X += (float) ((double) WorldGen.genRand.NextFloat() * 4.0 - 2.0);
        vector2_2.Y += (float) ((double) WorldGen.genRand.NextFloat() * 4.0 - 2.0);
        vector2_2.Y = MathHelper.Clamp(vector2_2.Y, -10f, 10f);
        vector2_2.X = MathHelper.Clamp(vector2_2.X, -10f, 10f);
      }
    }

    public static void setMoss(int x, int y)
    {
      int index = (double) x >= (double) Main.maxTilesX * 0.334 ? ((double) x >= (double) Main.maxTilesX * 0.667 ? 2 : 1) : 0;
      WorldGen.mossWall = (ushort) (54 + WorldGen.mossType[index]);
      WorldGen.mossTile = (ushort) (179 + WorldGen.mossType[index]);
    }

    public static void FillWallHolesInArea(Microsoft.Xna.Framework.Rectangle worldCoordsArea)
    {
      int num1 = Math.Max(worldCoordsArea.Left, 0);
      int num2 = Math.Min(worldCoordsArea.Right, Main.maxTilesX);
      int num3 = 0;
      for (int x = num1; x <= num2; ++x)
      {
        if (x >= 0 && x < Main.maxTilesX)
          num3 += WorldGen.FillWallHolesInColumn(x, worldCoordsArea.Top, worldCoordsArea.Bottom);
      }
    }

    private static int FillWallHolesInColumn(int x, int startY, int endY)
    {
      int num = 0;
      x = Utils.Clamp<int>(x, 2, Main.maxTilesX - 1 - 2);
      startY = Math.Max(startY, 2);
      endY = Math.Min(endY, Main.maxTilesY - 2);
      bool flag = false;
      for (int originY = startY; originY < endY; ++originY)
      {
        if (Main.tile[x, originY].wall == (ushort) 0)
        {
          if (flag)
          {
            flag = false;
            if (WorldGen.FillWallHolesInSpot(x, originY, 150))
              ++num;
          }
        }
        else
          flag = true;
      }
      return num;
    }

    private static bool FillWallHolesInSpot(int originX, int originY, int maxWallsThreshold)
    {
      if (!WorldGen.InWorld(originX, originY, 2))
        return false;
      List<Point> pointList1 = new List<Point>();
      List<Point> pointList2 = new List<Point>();
      HashSet<Point> pointSet = new HashSet<Point>();
      Dictionary<ushort, int> dictionary = new Dictionary<ushort, int>();
      pointList2.Add(new Point(originX, originY));
      while (pointList2.Count > 0)
      {
        pointList1.Clear();
        pointList1.AddRange((IEnumerable<Point>) pointList2);
        pointList2.Clear();
        while (pointList1.Count > 0)
        {
          if (pointSet.Count >= maxWallsThreshold)
            return false;
          Point point1 = pointList1[0];
          if (pointSet.Contains(point1))
            pointList1.Remove(point1);
          else if (!WorldGen.InWorld(point1.X, point1.Y, 1))
          {
            pointList1.Remove(point1);
          }
          else
          {
            pointSet.Add(point1);
            pointList1.Remove(point1);
            Tile tile = Main.tile[point1.X, point1.Y];
            if (tile.wall != (ushort) 0)
            {
              dictionary[tile.wall] = !dictionary.ContainsKey(tile.wall) ? 1 : dictionary[tile.wall] + 1;
            }
            else
            {
              bool flag = false;
              if (!flag)
              {
                int y = point1.Y;
                for (int index = point1.X - 1; index <= point1.X + 1; ++index)
                {
                  if (!Main.tile[index, y].active())
                  {
                    flag = true;
                    break;
                  }
                }
              }
              if (!flag)
              {
                int x = point1.X;
                for (int index = point1.Y - 1; index <= point1.Y + 1; ++index)
                {
                  if (!Main.tile[x, index].active())
                  {
                    flag = true;
                    break;
                  }
                }
              }
              if (flag)
              {
                Point point2 = new Point(point1.X - 1, point1.Y);
                if (!pointSet.Contains(point2))
                  pointList2.Add(point2);
                point2 = new Point(point1.X + 1, point1.Y);
                if (!pointSet.Contains(point2))
                  pointList2.Add(point2);
                point2 = new Point(point1.X, point1.Y - 1);
                if (!pointSet.Contains(point2))
                  pointList2.Add(point2);
                point2 = new Point(point1.X, point1.Y + 1);
                if (!pointSet.Contains(point2))
                  pointList2.Add(point2);
              }
            }
          }
        }
      }
      if (pointSet.Count == 1)
        return false;
      ushort num1 = 0;
      int num2 = -1;
      foreach (KeyValuePair<ushort, int> keyValuePair in dictionary)
      {
        if (keyValuePair.Value > num2)
        {
          num1 = keyValuePair.Key;
          num2 = keyValuePair.Value;
        }
      }
      if (num2 == -1)
        num1 = (ushort) 2;
      foreach (Point point in pointSet)
      {
        Tile tile = Main.tile[point.X, point.Y];
        if (tile.wall == (ushort) 0)
          tile.wall = num1;
      }
      return true;
    }

    public static void tileCountAndDestroy()
    {
      for (int x = 10; x < Main.maxTilesX - 10; ++x)
      {
        for (int y = 10; y < Main.maxTilesY - 10; ++y)
        {
          if (Main.tile[x, y].active() && WorldGen.tileCounter(x, y) < WorldGen.tileCounterMax)
            WorldGen.tileCounterKill();
        }
      }
    }

    public static int tileCounter(int x, int y)
    {
      WorldGen.tileCounterNum = 0;
      WorldGen.tileCounterNext(x, y);
      return WorldGen.tileCounterNum;
    }

    public static void tileCounterNext(int x, int y)
    {
      if (WorldGen.tileCounterNum >= WorldGen.tileCounterMax || x < 5 || (x > Main.maxTilesX - 5 || y < 5) || (y > Main.maxTilesY - 5 || !Main.tile[x, y].active() || (!Main.tileSolid[(int) Main.tile[x, y].type] || !TileID.Sets.CanBeClearedDuringGeneration[(int) Main.tile[x, y].type])))
        return;
      for (int index = 0; index < WorldGen.tileCounterNum; ++index)
      {
        if (WorldGen.tileCounterX[index] == x && WorldGen.tileCounterY[index] == y)
          return;
      }
      WorldGen.tileCounterX[WorldGen.tileCounterNum] = x;
      WorldGen.tileCounterY[WorldGen.tileCounterNum] = y;
      ++WorldGen.tileCounterNum;
      WorldGen.tileCounterNext(x - 1, y);
      WorldGen.tileCounterNext(x + 1, y);
      WorldGen.tileCounterNext(x, y - 1);
      WorldGen.tileCounterNext(x, y + 1);
    }

    public static void tileCounterKill()
    {
      for (int index1 = 0; index1 < WorldGen.tileCounterNum; ++index1)
      {
        int index2 = WorldGen.tileCounterX[index1];
        int index3 = WorldGen.tileCounterY[index1];
        Main.tile[index2, index3].active(false);
      }
    }

    private static void AddGenerationPass(string name, WorldGenLegacyMethod method)
    {
      WorldGen._generator.Append((GenPass) new PassLegacy(name, method));
    }

    private static void AddGenerationPass(GenPass pass)
    {
      WorldGen._generator.Append(pass);
    }

    private static void AddGenerationPass(string name, float weight, WorldGenLegacyMethod method)
    {
      WorldGen._generator.Append((GenPass) new PassLegacy(name, method, weight));
    }

    public static bool checkUnderground(int x, int y)
    {
      try
      {
        int num1 = 120;
        int num2 = 80;
        int num3 = 3;
        if ((double) y > Main.worldSurface + (double) num2)
          return true;
        if ((double) y < Main.worldSurface / 2.0)
          return false;
        int num4 = y - num2;
        int num5 = x - num1 / 2;
        int num6 = 0;
        if (num5 < 0)
          num5 = 0;
        if (num5 >= Main.maxTilesX - num1)
          num5 = Main.maxTilesX - num1 - 1;
        for (int i = num5; i < num5 + num1; ++i)
        {
          for (int j = num4; j < num4 + num3; ++j)
          {
            if (WorldGen.SolidTile(i, j, false) || Main.tile[x, y].wall > (ushort) 0)
              ++num6;
          }
        }
        if ((double) num6 >= (double) (num1 * num3) * 0.8)
          return true;
      }
      catch
      {
      }
      return false;
    }

    public static int GetNextJungleChestItem()
    {
      int num = 211;
      switch (WorldGen.JungleItemCount % 4)
      {
        case 0:
          num = 211;
          break;
        case 1:
          num = 212;
          break;
        case 2:
          num = 213;
          break;
        case 3:
          num = 964;
          break;
      }
      if (WorldGen.genRand.Next(50) == 0)
        num = 753;
      else if (WorldGen.genRand.Next(30) == 0)
        num = 2292;
      else if (WorldGen.genRand.Next(20) == 0)
        num = 3017;
      ++WorldGen.JungleItemCount;
      return num;
    }

    private static void ScanTileColumnAndRemoveClumps(int x)
    {
      int num = 0;
      int y = 0;
      for (int index = 10; index < Main.maxTilesY - 10; ++index)
      {
        if (Main.tile[x, index].active() && Main.tileSolid[(int) Main.tile[x, index].type] && TileID.Sets.CanBeClearedDuringGeneration[(int) Main.tile[x, index].type])
        {
          if (num == 0)
            y = index;
          ++num;
        }
        else
        {
          if (num > 0 && num < WorldGen.tileCounterMax)
          {
            ++WorldGen.SmallConsecutivesFound;
            if (WorldGen.tileCounter(x, y) < WorldGen.tileCounterMax)
            {
              ++WorldGen.SmallConsecutivesEliminated;
              WorldGen.tileCounterKill();
            }
          }
          num = 0;
        }
      }
    }

    public static void OreHelper(int X, int Y)
    {
      for (int index1 = X - 1; index1 <= X + 1; ++index1)
      {
        for (int index2 = Y - 1; index2 <= Y + 1; ++index2)
        {
          if (Main.tile[index1, index2].type == (ushort) 1 || Main.tile[index1, index2].type == (ushort) 40)
            Main.tile[index1, index2].type = (ushort) 0;
        }
      }
    }

    public static bool StonePatch(int X, int Y)
    {
      int i1 = X;
      int j1 = Y;
      while (!WorldGen.SolidTile(i1, j1, false))
      {
        ++j1;
        if ((double) j1 > Main.worldSurface)
          return false;
      }
      if (!TileID.Sets.Conversion.Grass[(int) Main.tile[i1, j1].type] || !TileID.Sets.Conversion.Grass[(int) Main.tile[i1 - 1, j1].type] || (!TileID.Sets.Conversion.Grass[(int) Main.tile[i1 + 1, j1].type] || Main.tile[i1, j1].wall > (ushort) 0))
        return false;
      for (int index1 = i1 - 10; index1 <= i1 + 10; ++index1)
      {
        for (int index2 = j1 + 7; index2 <= j1 + 30; ++index2)
        {
          if (!Main.tile[index1, index2].active() || Main.tileDungeon[(int) Main.tile[index1, index2].type] || (TileID.Sets.Clouds[(int) Main.tile[index1, index2].type] || TileID.Sets.Conversion.Sand[(int) Main.tile[index1, index2].type]) || (Main.tile[index1, index2].wall == (ushort) 0 || Main.tile[index1, index2].type == (ushort) 199 || Main.tile[index1, index2].type == (ushort) 23))
            return false;
        }
      }
      Vector2 vector2_1 = new Vector2((float) i1, (float) j1);
      Vector2 vector2_2;
      vector2_2.X = (float) ((double) WorldGen.genRand.NextFloat() * 0.600000023841858 - 0.300000011920929);
      vector2_2.Y = (float) ((double) WorldGen.genRand.NextFloat() * 0.5 + 0.5);
      float num1 = (float) WorldGen.genRand.Next(13, 18);
      int num2 = WorldGen.genRand.Next(13, 19);
      if (WorldGen.genRand.Next(3) == 0)
        num1 += (float) WorldGen.genRand.Next(3);
      if (WorldGen.genRand.Next(3) == 0)
        num2 += WorldGen.genRand.Next(3);
      while (num2 > 0)
      {
        --num2;
        for (int i2 = i1 - (int) num1 * 4; (double) i2 <= (double) i1 + (double) num1 * 4.0; ++i2)
        {
          for (int j2 = j1 - (int) num1 * 4; (double) j2 <= (double) j1 + (double) num1 * 4.0; ++j2)
          {
            float num3 = (float) ((double) num1 * (0.699999988079071 + (double) WorldGen.genRand.NextFloat() * 0.600000023841858) * 0.300000011920929);
            if (WorldGen.genRand.Next(8) == 0)
              num3 *= 2f;
            Vector2 vector2_3 = vector2_1 - new Vector2((float) i2, (float) j2);
            if ((double) vector2_3.Length() < (double) num3 * 2.0 && !Main.tile[i2, j2].active() && (Main.tile[i2, j2 + 1].active() && Main.tile[i2, j2 + 1].type == (ushort) 1) && (WorldGen.genRand.Next(7) == 0 && WorldGen.SolidTile(i2 - 1, j2 + 1, false) && WorldGen.SolidTile(i2 + 1, j2 + 1, false)))
            {
              if (WorldGen.genRand.Next(3) != 0)
                WorldGen.PlaceTile(i2, j2, 186, true, false, -1, WorldGen.genRand.Next(7, 13));
              if (WorldGen.genRand.Next(3) != 0)
                WorldGen.PlaceSmallPile(i2, j2, WorldGen.genRand.Next(6), 1, (ushort) 185);
              WorldGen.PlaceSmallPile(i2, j2, WorldGen.genRand.Next(6), 0, (ushort) 185);
            }
            if ((double) vector2_3.Length() < (double) num3)
            {
              if (Main.tileSolid[(int) Main.tile[i2, j2].type])
                Main.tile[i2, j2].type = (ushort) 1;
              if (!WorldGen.gen)
                WorldGen.SquareTileFrame(i2, j2, true);
            }
          }
        }
        vector2_1 += vector2_2;
        vector2_2.X += (float) ((double) WorldGen.genRand.NextFloat() * 0.200000002980232 - 0.100000001490116);
        vector2_2.Y += (float) ((double) WorldGen.genRand.NextFloat() * 0.200000002980232 - 0.100000001490116);
        double num4 = (double) MathHelper.Clamp(vector2_2.X, -0.3f, 0.3f);
        double num5 = (double) MathHelper.Clamp(vector2_2.Y, 0.5f, 1f);
      }
      return true;
    }

    public static bool ShellPile(int X, int Y)
    {
      int i1 = X;
      int j1 = Y;
      while (!WorldGen.SolidTile(i1, j1, false))
      {
        ++j1;
        if ((double) j1 > Main.worldSurface)
          return false;
      }
      if (Main.tile[i1, j1].type != (ushort) 53 || Main.tile[i1, j1].wall > (ushort) 0)
        return false;
      int num1 = j1 - 1;
      Vector2 vector2_1 = new Vector2((float) i1, (float) num1);
      Vector2 vector2_2;
      vector2_2.X = (float) ((double) WorldGen.genRand.NextFloat() * 0.600000023841858 - 0.300000011920929);
      vector2_2.Y = (float) ((double) WorldGen.genRand.NextFloat() * 0.5 + 0.5);
      float num2 = (float) WorldGen.genRand.Next(2, 4);
      if (WorldGen.genRand.Next(10) == 0)
        ++num2;
      int num3 = WorldGen.genRand.Next(3, 6);
      while (num3 > 0)
      {
        --num3;
        for (int i2 = i1 - (int) num2 * 4; (double) i2 <= (double) i1 + (double) num2 * 4.0; ++i2)
        {
          for (int j2 = num1 + (int) num2 * 4; (double) j2 > (double) num1 - (double) num2 * 4.0; --j2)
          {
            float num4 = (float) ((double) num2 * (double) WorldGen.genRand.Next(70, 91) * 0.00999999977648258);
            Vector2 vector2_3 = vector2_1 - new Vector2((float) i2, (float) j2);
            vector2_3.X *= 0.6f;
            if ((double) vector2_3.Length() < (double) num4)
            {
              if (j2 <= num1 + 1 || WorldGen.genRand.Next(6) == 0)
              {
                Main.tile[i2, j2].type = (ushort) 495;
                Main.tile[i2, j2].active(true);
                Main.tile[i2, j2].halfBrick(false);
                Main.tile[i2, j2].slope((byte) 0);
                if (!Main.tile[i2, j2 + 1].active())
                {
                  Main.tile[i2, j2 + 1].type = (ushort) 495;
                  Main.tile[i2, j2 + 1].active(true);
                  Main.tile[i2, j2 + 1].halfBrick(false);
                  Main.tile[i2, j2 + 1].slope((byte) 0);
                  if (!Main.tile[i2, j2 + 2].active())
                  {
                    Main.tile[i2, j2 + 2].type = (ushort) 53;
                    Main.tile[i2, j2 + 2].active(true);
                    Main.tile[i2, j2 + 2].halfBrick(false);
                    Main.tile[i2, j2 + 2].slope((byte) 0);
                    if (!Main.tile[i2, j2 + 3].active())
                    {
                      Main.tile[i2, j2 + 3].type = (ushort) 397;
                      Main.tile[i2, j2 + 3].active(true);
                      Main.tile[i2, j2 + 3].halfBrick(false);
                      Main.tile[i2, j2 + 3].slope((byte) 0);
                    }
                  }
                }
                if (!WorldGen.gen)
                  WorldGen.SquareTileFrame(i2, j2, true);
              }
              else if (Main.tile[i2, j2].type != (ushort) 495)
              {
                Main.tile[i2, j2].active(true);
                Main.tile[i2, j2].halfBrick(false);
                Main.tile[i2, j2].slope((byte) 0);
                Main.tile[i2, j2].type = (ushort) 53;
                if (!WorldGen.gen)
                  WorldGen.SquareTileFrame(i2, j2, true);
              }
            }
          }
        }
        vector2_1 += vector2_2;
        vector2_2.X += (float) ((double) WorldGen.genRand.NextFloat() * 0.200000002980232 - 0.100000001490116);
        vector2_2.Y += (float) ((double) WorldGen.genRand.NextFloat() * 0.200000002980232 - 0.100000001490116);
        double num5 = (double) MathHelper.Clamp(vector2_2.X, -0.3f, 0.3f);
        double num6 = (double) MathHelper.Clamp(vector2_2.Y, 0.5f, 1f);
      }
      return true;
    }

    public static bool OrePatch(int X, int Y)
    {
      ushort num1 = (ushort) WorldGen.SavedOreTiers.Copper;
      if (WorldGen.genRand.Next(3) == 0)
        num1 = (ushort) WorldGen.SavedOreTiers.Iron;
      int index1 = X;
      int j = Y;
      while (!WorldGen.SolidTile(index1, j, false))
      {
        ++j;
        if ((double) j > Main.worldSurface)
          return false;
      }
      if (!TileID.Sets.Conversion.Grass[(int) Main.tile[index1, j].type] || !TileID.Sets.Conversion.Grass[(int) Main.tile[index1 - 1, j].type] || (!TileID.Sets.Conversion.Grass[(int) Main.tile[index1 + 1, j].type] || Main.tile[index1, j].wall > (ushort) 0))
        return false;
      for (int index2 = index1 - 10; index2 <= index1 + 10; ++index2)
      {
        for (int index3 = j + 7; index3 <= j + 30; ++index3)
        {
          if (!Main.tile[index2, index3].active() || Main.tileDungeon[(int) Main.tile[index2, index3].type] || (TileID.Sets.Clouds[(int) Main.tile[index2, index3].type] || TileID.Sets.Conversion.Sand[(int) Main.tile[index2, index3].type]) || Main.tile[index2, index3].wall == (ushort) 0)
            return false;
        }
      }
      int index4 = j + WorldGen.genRand.Next(2);
      Main.tile[index1, index4].type = num1;
      Main.tile[index1, index4].active(true);
      WorldGen.OreHelper(index1, index4);
      if (!WorldGen.gen)
        WorldGen.SquareTileFrame(index1, index4, true);
      int num2 = index4;
      while (index4 < num2 + WorldGen.genRand.Next(8, 13))
      {
        index1 += WorldGen.genRand.Next(-1, 2);
        index4 += WorldGen.genRand.Next(1, 3);
        if (WorldGen.genRand.Next(3) == 0)
          ++index4;
        Main.tile[index1, index4].type = num1;
        Main.tile[index1, index4].active(true);
        WorldGen.OreHelper(index1, index4);
        if (!WorldGen.gen)
          WorldGen.SquareTileFrame(index1, index4, true);
        if (WorldGen.genRand.Next(4) == 0)
        {
          int index2 = index1 + WorldGen.genRand.Next(-2, 3);
          int index3 = index4 + WorldGen.genRand.Next(2);
          Main.tile[index2, index3].type = num1;
          Main.tile[index2, index3].active(true);
          WorldGen.OreHelper(index2, index3);
          if (!WorldGen.gen)
            WorldGen.SquareTileFrame(index2, index3, true);
        }
      }
      Vector2 vector2_1 = new Vector2((float) index1, (float) index4);
      Vector2 vector2_2;
      vector2_2.X = (float) ((double) WorldGen.genRand.NextFloat() * 0.600000023841858 - 0.300000011920929);
      vector2_2.Y = (float) ((double) WorldGen.genRand.NextFloat() * 0.5 + 0.5);
      float num3 = (float) WorldGen.genRand.Next(5, 9);
      int num4 = WorldGen.genRand.Next(9, 14);
      if (WorldGen.genRand.Next(3) == 0)
        num3 += (float) WorldGen.genRand.Next(2);
      if (WorldGen.genRand.Next(3) == 0)
        num4 += WorldGen.genRand.Next(2);
      while (num4 > 0)
      {
        --num4;
        for (int index2 = index1 - (int) num3 * 4; (double) index2 <= (double) index1 + (double) num3 * 4.0; ++index2)
        {
          for (int index3 = index4 - (int) num3 * 4; (double) index3 <= (double) index4 + (double) num3 * 4.0; ++index3)
          {
            float num5 = (float) ((double) num3 * (0.5 + (double) WorldGen.genRand.NextFloat() * 0.5) * 0.100000001490116);
            float num6 = (float) ((double) num3 * (0.699999988079071 + (double) WorldGen.genRand.NextFloat() * 0.600000023841858) * 0.300000011920929);
            if (WorldGen.genRand.Next(8) == 0)
              num6 *= 2f;
            Vector2 vector2_3 = vector2_1 - new Vector2((float) index2, (float) index3);
            if ((double) vector2_3.Length() < (double) num5)
              Main.tile[index2, index3].active(false);
            else if ((double) vector2_3.Length() < (double) num6)
            {
              Main.tile[index2, index3].type = num1;
              if (WorldGen.genRand.Next(4) == 0)
                Main.tile[index2, index3].active(true);
              WorldGen.OreHelper(index2, index3);
              if (!WorldGen.gen)
                WorldGen.SquareTileFrame(index2, index3, true);
            }
          }
        }
        vector2_1 += vector2_2;
        vector2_2.X += (float) ((double) WorldGen.genRand.NextFloat() * 0.200000002980232 - 0.100000001490116);
        vector2_2.Y += (float) ((double) WorldGen.genRand.NextFloat() * 0.200000002980232 - 0.100000001490116);
        double num7 = (double) MathHelper.Clamp(vector2_2.X, -0.3f, 0.3f);
        double num8 = (double) MathHelper.Clamp(vector2_2.Y, 0.5f, 1f);
      }
      return true;
    }

    public static bool PlaceOasis(int X, int Y)
    {
      int index1 = X;
      int index2 = Y;
      if (Main.tile[index1, index2].active() || Main.tile[index1, index2].wall != (ushort) 0)
        return false;
      while (!Main.tile[index1, index2].active() && Main.tile[index1, index2].wall == (ushort) 0 && (double) index2 <= Main.worldSurface)
        ++index2;
      if ((double) index2 > Main.worldSurface - 10.0 || Main.tile[index1, index2].type != (ushort) 53)
        return false;
      int num1 = 350;
      for (int index3 = 0; index3 < WorldGen.numOasis; ++index3)
      {
        if ((double) Vector2.Distance(WorldGen.oasisPosition[index3], new Vector2((float) index1, (float) index2)) < (double) num1)
          return false;
      }
      int num2 = WorldGen.genRand.Next(45, 61);
      int oasisHeight = WorldGen.oasisHeight;
      int num3 = num2 + 50;
      int num4 = 4;
      for (int index3 = index1 - num3; index3 <= index1 + num3; ++index3)
      {
        for (int index4 = index2 - oasisHeight; index4 <= index2 + oasisHeight + num4; ++index4)
        {
          Tile tile = Main.tile[index3, index4];
          if (tile.active())
          {
            if (Main.tileSolid[(int) tile.type] && ((tile.type == (ushort) 151 || tile.type == (ushort) 397) && (Math.Abs(index3 - index1) < num2 && Math.Abs(index4 - index2) < oasisHeight / 2) || tile.type != (ushort) 53))
              return false;
          }
          else if ((tile.liquid > (byte) 0 || tile.wall > (ushort) 0) && (Math.Abs(index3 - index1) < num2 && Math.Abs(index4 - index2) < oasisHeight / 2))
            return false;
        }
        if (index3 > index1 - num2 / 2 && index3 < index1 - num2 / 2 && (Main.tile[index3, index2 - 6].active() || !Main.tile[index3, index2 + 1].active()))
          return false;
      }
      int num5 = 5;
      int num6 = index2;
      while (!Main.tile[index1 - num2, index2 + num5].active() || Main.tile[index1 - num2, index2 + num5].wall != (ushort) 0 || (!Main.tile[index1 + num2, index2 + num5].active() || Main.tile[index1 + num2, index2 + num5].wall != (ushort) 0))
      {
        ++index2;
        if (index2 - num6 > 20)
          break;
      }
      int num7 = num2 / 2;
      int num8 = index1 - num2 * 3;
      int num9 = index1 + num2 * 3;
      int num10 = index2 - oasisHeight * 4;
      int num11 = index2 + oasisHeight * 3;
      if (num8 < 0)
        num8 = 0;
      if (num9 > Main.maxTilesX)
        num9 = Main.maxTilesX;
      if (num10 < 0)
        num10 = 0;
      if (num11 > Main.maxTilesY)
        num11 = Main.maxTilesY;
      for (int index3 = num8; index3 < num9; ++index3)
      {
        for (int index4 = num10; index4 < num11; ++index4)
        {
          float num12 = (float) Math.Abs(index3 - index1) * 0.7f;
          float num13 = (float) Math.Abs(index4 - index2) * 1.35f;
          double num14 = Math.Sqrt((double) num12 * (double) num12 + (double) num13 * (double) num13);
          float num15 = (float) num7 * (float) (0.529999971389771 + (double) WorldGen.genRand.NextFloat() * 0.0399999991059303);
          float num16 = (1f - (float) Math.Abs(index3 - index1) / (float) (num9 - index1)) * 2.3f;
          float num17 = num16 * num16;
          float num18 = num17 * num17;
          double num19 = (double) num15;
          if (num14 < num19)
          {
            if (index4 == index2 + 1)
              Main.tile[index3, index4].liquid = (byte) 127;
            else if (index4 > index2 + 1)
              Main.tile[index3, index4].liquid = byte.MaxValue;
            Main.tile[index3, index4].lava(false);
            Main.tile[index3, index4].active(false);
          }
          else if (index4 < index2 && (double) num12 < (double) num15 + (double) Math.Abs(index4 - index2) * 3.0 * (double) num18)
          {
            if (Main.tile[index3, index4].type == (ushort) 53)
              Main.tile[index3, index4].active(false);
          }
          else if (index4 >= index2 && (double) num12 < (double) num15 + (double) Math.Abs(index4 - index2) * (double) num18 && Main.tile[index3, index4].wall == (ushort) 0)
          {
            if (Main.tile[index3, index4].active() && Main.tileSolid[(int) Main.tile[index3, index4].type] && !Main.tileSolidTop[(int) Main.tile[index3, index4].type])
            {
              Main.tile[index3, index4].slope((byte) 0);
              Main.tile[index3, index4].halfBrick(false);
            }
            else
            {
              Main.tile[index3, index4].active(true);
              Main.tile[index3, index4].type = (ushort) 53;
              Main.tile[index3, index4].slope((byte) 0);
              Main.tile[index3, index4].halfBrick(false);
            }
          }
        }
      }
      int num20 = 50;
      int num21 = index1 - num2 * 2;
      int num22 = index1 + num2 * 2;
      int num23 = index2 + oasisHeight * 2;
      for (int index3 = num21; index3 < num22; ++index3)
      {
        for (int index4 = num23; index4 >= index2; --index4)
        {
          double num12 = (double) Math.Abs(index3 - index1) * 0.699999988079071;
          float num13 = (float) Math.Abs(index4 - index2) * 1.35f;
          if (Math.Sqrt(num12 * num12 + (double) num13 * (double) num13) > (double) ((float) num7 * 0.57f))
          {
            bool flag1 = false;
            if (!Main.tile[index3, index4].active() && Main.tile[index3, index4].wall == (ushort) 0)
            {
              int num14 = -1;
              int num15 = -1;
              for (int index5 = index3; index5 <= index3 + num20 && (Main.tile[index5, index4 + 1].active() && Main.tileSolid[(int) Main.tile[index5, index4 + 1].type]) && Main.tile[index5, index4].wall <= (ushort) 0; ++index5)
              {
                if (Main.tile[index5, index4].active() && Main.tileSolid[(int) Main.tile[index5, index4].type])
                {
                  if (Main.tile[index5, index4].type == (ushort) 53)
                    flag1 = true;
                  num15 = index5;
                  break;
                }
                if (Main.tile[index5, index4].active())
                  break;
              }
              for (int index5 = index3; index5 >= index3 - num20 && (Main.tile[index5, index4 + 1].active() && Main.tileSolid[(int) Main.tile[index5, index4 + 1].type]) && Main.tile[index5, index4].wall <= (ushort) 0; --index5)
              {
                if (Main.tile[index5, index4].active() && Main.tileSolid[(int) Main.tile[index5, index4].type])
                {
                  if (Main.tile[index5, index4].type == (ushort) 53)
                    flag1 = true;
                  num14 = index5;
                  break;
                }
                if (Main.tile[index5, index4].active())
                  break;
              }
              bool flag2 = true;
              if (((num14 <= -1 ? 0 : (num15 > -1 ? 1 : 0)) & (flag2 ? 1 : 0)) != 0)
              {
                int num16 = 0;
                for (int index5 = num14 + 1; index5 < num15; ++index5)
                {
                  if (num15 - num14 > 5 && WorldGen.genRand.Next(5) == 0)
                    num16 = WorldGen.genRand.Next(5, 10);
                  Main.tile[index5, index4].active(true);
                  Main.tile[index5, index4].type = (ushort) 53;
                  if (num16 > 0)
                  {
                    --num16;
                    Main.tile[index5, index4 - 1].active(true);
                    Main.tile[index5, index4 - 1].type = (ushort) 53;
                  }
                }
              }
            }
          }
        }
      }
      if (WorldGen.numOasis < WorldGen.maxOasis)
      {
        WorldGen.oasisPosition[WorldGen.numOasis] = new Vector2((float) index1, (float) index2);
        WorldGen.oasisWidth[WorldGen.numOasis] = num2;
        ++WorldGen.numOasis;
      }
      return true;
    }

    public static bool BiomeTileCheck(int x, int y)
    {
      int num = 50;
      for (int x1 = x - num; x1 <= x + num; ++x1)
      {
        for (int y1 = y - num; y1 <= y + num; ++y1)
        {
          if (WorldGen.InWorld(x1, y1, 0))
          {
            if (Main.tile[x1, y1].active())
            {
              switch (Main.tile[x1, y1].type)
              {
                case 70:
                case 72:
                case 147:
                case 161:
                case 162:
                case 367:
                case 368:
                case 396:
                case 397:
                  return true;
              }
            }
            switch (Main.tile[x1, y1].wall)
            {
              case 187:
              case 216:
                return true;
              default:
                continue;
            }
          }
        }
      }
      return false;
    }

    public static double oceanLevel
    {
      get
      {
        return (Main.worldSurface + Main.rockLayer) / 2.0 + 40.0;
      }
    }

    public static bool oceanDepths(int x, int y)
    {
      return (double) y <= WorldGen.oceanLevel && (x < WorldGen.beachDistance || x > Main.maxTilesX - WorldGen.beachDistance);
    }

    public static void GenerateWorld(int seed, GenerationProgress customProgressObject = null)
    {
      WorldGen.drunkWorldGen = false;
      WorldGen.drunkWorldGenText = false;
      if (seed == 5162020)
      {
        WorldGen.drunkWorldGen = true;
        WorldGen.drunkWorldGenText = true;
        Main.drunkWorld = true;
        Main.rand = new UnifiedRandom();
        seed = Main.rand.Next(999999999);
        if (!Main.dayTime)
          Main.time = 0.0;
      }
      if (WorldGen.notTheBees)
      {
        Main.rand = new UnifiedRandom();
        seed = Main.rand.Next(999999999);
      }
      if (WorldGen.getGoodWorldGen)
      {
        Main.getGoodWorld = true;
        Main.rand = new UnifiedRandom();
        seed = Main.rand.Next(999999999);
      }
      else
        Main.getGoodWorld = false;
      Console.WriteLine("Creating world - Seed: {0} Width: {1}, Height: {2}, Evil: {3}, IsExpert: {4}", (object) seed, (object) Main.maxTilesX, (object) Main.maxTilesY, (object) WorldGen.WorldGenParam_Evil, (object) Main.expertMode);
      Main.lockMenuBGChange = true;
      WorldGenConfiguration configuration = WorldGenConfiguration.FromEmbeddedPath("Terraria.GameContent.WorldBuilding.Configuration.json");
      WorldGen.Hooks.ProcessWorldGenConfig(ref configuration);
      WorldGen._lastSeed = seed;
      WorldGen._generator = new WorldGenerator(seed, configuration);
      WorldGen._genRand = new UnifiedRandom(seed);
      Main.rand = new UnifiedRandom(seed);
      StructureMap structures = new StructureMap();
      WorldGen.worldSurfaceLow = 0.0;
      double worldSurface = 0.0;
      double worldSurfaceHigh = 0.0;
      double rockLayerLow = 0.0;
      double rockLayer = 0.0;
      double rockLayerHigh = 0.0;
      int copper = 7;
      int iron = 6;
      int silver = 9;
      int gold = 8;
      int dungeonSide = 0;
      ushort jungleHut = (ushort) WorldGen.genRand.Next(5);
      int shellStartXLeft = 0;
      int shellStartYLeft = 0;
      int shellStartXRight = 0;
      int shellStartYRight = 0;
      int howFar = 0;
      int[] PyrX = (int[]) null;
      int[] PyrY = (int[]) null;
      int numPyr = 0;
      int jungleMinX = -1;
      int jungleMaxX = -1;
      int[] snowMinX = new int[Main.maxTilesY];
      int[] snowMaxX = new int[Main.maxTilesY];
      int snowTop = 0;
      int snowBottom = 0;
      float dub2 = 0.0f;
      int skyLakes = 1;
      if (Main.maxTilesX > 8000)
        ++skyLakes;
      if (Main.maxTilesX > 6000)
        ++skyLakes;
      int beachSandRandomCenter = 275 + 5 + 40;
      int beachSandRandomWidthRange = 20;
      int beachSandDungeonExtraWidth = 40;
      int beachSandJungleExtraWidth = 20;
      int oceanWaterStartRandomMin = 220;
      int oceanWaterStartRandomMax = oceanWaterStartRandomMin + 40;
      int oceanWaterForcedJungleLength = 275;
      int leftBeachEnd = 0;
      int rightBeachStart = 0;
      int minSsandBeforeWater = 50;
      int evilBiomeBeachAvoidance = beachSandRandomCenter + 60;
      int evilBiomeAvoidanceMidFixer = 50;
      int lakesBeachAvoidance = beachSandRandomCenter + 20;
      int smallHolesBeachAvoidance = beachSandRandomCenter + 20;
      int num1 = beachSandRandomCenter;
      int surfaceCavesBeachAvoidance2 = beachSandRandomCenter + 20;
      int jungleOriginX = 0;
      int snowOriginLeft = 0;
      int snowOriginRight = 0;
      int logX = -1;
      int logY = -1;
      int dungeonLocation = 0;
      WorldGen.AddGenerationPass("Reset", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        WorldGen.numOceanCaveTreasure = 0;
        WorldGen.skipDesertTileCheck = false;
        WorldGen.gen = true;
        Liquid.ReInit();
        WorldGen.noTileActions = true;
        progress.Message = "";
        WorldGen.SetupStatueList();
        WorldGen.RandomizeWeather();
        Main.cloudAlpha = 0.0f;
        Main.maxRaining = 0.0f;
        Main.raining = false;
        WorldGen.heartCount = 0;
        Main.checkXMas();
        Main.checkHalloween();
        WorldGen.ResetGenerator();
        WorldGen.UndergroundDesertLocation = Microsoft.Xna.Framework.Rectangle.Empty;
        WorldGen.UndergroundDesertHiveLocation = Microsoft.Xna.Framework.Rectangle.Empty;
        WorldGen.numLarva = 0;
        WorldGen.hellChestItem = new int[WorldGen.hellChestItem.Length];
        for (int index1 = 0; index1 < WorldGen.hellChestItem.Length; ++index1)
        {
          bool flag = true;
          while (flag)
          {
            flag = false;
            WorldGen.hellChestItem[index1] = WorldGen.genRand.Next(WorldGen.hellChestItem.Length);
            for (int index2 = 0; index2 < index1; ++index2)
            {
              if (WorldGen.hellChestItem[index2] == WorldGen.hellChestItem[index1])
                flag = true;
            }
          }
        }
        int num2 = 86400;
        Main.slimeRainTime = (double) -WorldGen.genRand.Next(num2 * 2, num2 * 3);
        Main.cloudBGActive = (float) -WorldGen.genRand.Next(8640, 86400);
        WorldGen.skipFramingDuringGen = false;
        WorldGen.SavedOreTiers.Copper = 7;
        WorldGen.SavedOreTiers.Iron = 6;
        WorldGen.SavedOreTiers.Silver = 9;
        WorldGen.SavedOreTiers.Gold = 8;
        WorldGen.copperBar = 20;
        WorldGen.ironBar = 22;
        WorldGen.silverBar = 21;
        WorldGen.goldBar = 19;
        if (WorldGen.genRand.Next(2) == 0)
        {
          copper = 166;
          WorldGen.copperBar = 703;
          WorldGen.SavedOreTiers.Copper = 166;
        }
        if (WorldGen.genRand.Next(2) == 0)
        {
          iron = 167;
          WorldGen.ironBar = 704;
          WorldGen.SavedOreTiers.Iron = 167;
        }
        if (WorldGen.genRand.Next(2) == 0)
        {
          silver = 168;
          WorldGen.silverBar = 705;
          WorldGen.SavedOreTiers.Silver = 168;
        }
        if (WorldGen.genRand.Next(2) == 0)
        {
          gold = 169;
          WorldGen.goldBar = 706;
          WorldGen.SavedOreTiers.Gold = 169;
        }
        WorldGen.crimson = WorldGen.genRand.Next(2) == 0;
        if (WorldGen.WorldGenParam_Evil == 0)
          WorldGen.crimson = false;
        if (WorldGen.WorldGenParam_Evil == 1)
          WorldGen.crimson = true;
        switch (jungleHut)
        {
          case 0:
            jungleHut = (ushort) 119;
            break;
          case 1:
            jungleHut = (ushort) 120;
            break;
          case 2:
            jungleHut = (ushort) 158;
            break;
          case 3:
            jungleHut = (ushort) 175;
            break;
          case 4:
            jungleHut = (ushort) 45;
            break;
        }
        Main.worldID = WorldGen.genRand.Next(int.MaxValue);
        WorldGen.RandomizeTreeStyle();
        WorldGen.RandomizeCaveBackgrounds();
        WorldGen.RandomizeBackgrounds(WorldGen.genRand);
        WorldGen.RandomizeMoonState();
        WorldGen.TreeTops.CopyExistingWorldInfoForWorldGeneration();
        dungeonSide = WorldGen.genRand.Next(2) == 0 ? -1 : 1;
        if (dungeonSide == -1)
        {
          float num3 = (float) (1.0 - (double) WorldGen.genRand.Next(15, 30) * 0.00999999977648258);
          jungleOriginX = (int) ((double) Main.maxTilesX * (double) num3);
        }
        else
        {
          float num3 = (float) WorldGen.genRand.Next(15, 30) * 0.01f;
          jungleOriginX = (int) ((double) Main.maxTilesX * (double) num3);
        }
        int num4 = WorldGen.genRand.Next(Main.maxTilesX);
        if (WorldGen.drunkWorldGen)
          dungeonSide *= -1;
        if (dungeonSide == 1)
        {
          while ((double) num4 < (double) Main.maxTilesX * 0.600000023841858 || (double) num4 > (double) Main.maxTilesX * 0.75)
            num4 = WorldGen.genRand.Next(Main.maxTilesX);
        }
        else
        {
          while ((double) num4 < (double) Main.maxTilesX * 0.25 || (double) num4 > (double) Main.maxTilesX * 0.400000005960464)
            num4 = WorldGen.genRand.Next(Main.maxTilesX);
        }
        if (WorldGen.drunkWorldGen)
          dungeonSide *= -1;
        int num5 = WorldGen.genRand.Next(50, 90);
        float num6 = (float) (Main.maxTilesX / 4200);
        int num7 = num5 + (int) ((double) WorldGen.genRand.Next(20, 40) * (double) num6) + (int) ((double) WorldGen.genRand.Next(20, 40) * (double) num6);
        int num8 = num4 - num7;
        int num9 = WorldGen.genRand.Next(50, 90) + (int) ((double) WorldGen.genRand.Next(20, 40) * (double) num6) + (int) ((double) WorldGen.genRand.Next(20, 40) * (double) num6);
        int num10 = num4 + num9;
        if (num8 < 0)
          num8 = 0;
        if (num10 > Main.maxTilesX)
          num10 = Main.maxTilesX;
        snowOriginLeft = num8;
        snowOriginRight = num10;
        leftBeachEnd = WorldGen.genRand.Next(beachSandRandomCenter - beachSandRandomWidthRange, beachSandRandomCenter + beachSandRandomWidthRange);
        if (dungeonSide == 1)
          leftBeachEnd += beachSandDungeonExtraWidth;
        else
          leftBeachEnd += beachSandJungleExtraWidth;
        rightBeachStart = Main.maxTilesX - WorldGen.genRand.Next(beachSandRandomCenter - beachSandRandomWidthRange, beachSandRandomCenter + beachSandRandomWidthRange);
        if (dungeonSide == -1)
          rightBeachStart -= beachSandDungeonExtraWidth;
        else
          rightBeachStart -= beachSandJungleExtraWidth;
        int num11 = 50;
        if (dungeonSide == -1)
          dungeonLocation = WorldGen.genRand.Next(leftBeachEnd + num11, (int) ((double) Main.maxTilesX * 0.2));
        else
          dungeonLocation = WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.8), rightBeachStart - num11);
      }));
      WorldGen.AddGenerationPass(new TerrainPass().OnBegin((Action<GenPass>) (pass =>
      {
        TerrainPass terrainPass = pass as TerrainPass;
        terrainPass.LeftBeachSize = leftBeachEnd;
        terrainPass.RightBeachSize = Main.maxTilesX - rightBeachStart;
      })).OnComplete((Action<GenPass>) (pass =>
      {
        TerrainPass terrainPass = pass as TerrainPass;
        rockLayer = terrainPass.RockLayer;
        rockLayerHigh = terrainPass.RockLayerHigh;
        rockLayerLow = terrainPass.RockLayerLow;
        worldSurface = terrainPass.WorldSurface;
        worldSurfaceHigh = terrainPass.WorldSurfaceHigh;
        WorldGen.worldSurfaceLow = terrainPass.WorldSurfaceLow;
        WorldGen.waterLine = terrainPass.WaterLine;
        WorldGen.lavaLine = terrainPass.LavaLine;
      })));
      WorldGen.AddGenerationPass("Dunes", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[1].Value;
        int random = passConfig.Get<WorldGenRange>("Count").GetRandom(WorldGen.genRand);
        float num2 = passConfig.Get<float>("ChanceOfPyramid");
        if (WorldGen.drunkWorldGen)
          num2 = 1f;
        float num3 = (float) Main.maxTilesX / 4200f;
        PyrX = new int[random + 3];
        PyrY = new int[random + 3];
        DunesBiome biome = configuration.CreateBiome<DunesBiome>();
        for (int index1 = 0; index1 < random; ++index1)
        {
          progress.Set((float) index1 / (float) random);
          Point origin = Point.Zero;
          bool flag1 = false;
          int num4 = 0;
          bool flag2;
          bool flag3;
          bool flag4;
          for (; !flag1; flag1 = !(flag2 | flag3 | flag4))
          {
            origin = WorldGen.RandomWorldPoint(0, 500, 0, 500);
            flag2 = Math.Abs(origin.X - jungleOriginX) < (int) (600.0 * (double) num3);
            flag3 = Math.Abs(origin.X - Main.maxTilesX / 2) < 300;
            flag4 = origin.X > snowOriginLeft - 300 && origin.Y < snowOriginRight + 300;
            ++num4;
            if (num4 >= Main.maxTilesX)
              flag2 = false;
            if (num4 >= Main.maxTilesX * 2)
              flag4 = false;
          }
          biome.Place(origin, structures);
          if ((double) WorldGen.genRand.NextFloat() <= (double) num2)
          {
            int index2 = WorldGen.genRand.Next(origin.X - 200, origin.X + 200);
            for (int index3 = 0; index3 < Main.maxTilesY; ++index3)
            {
              if (Main.tile[index2, index3].active())
              {
                PyrX[numPyr] = index2;
                PyrY[numPyr] = index3 + 20;
                ++numPyr;
                break;
              }
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Ocean Sand", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Language.GetTextValue("WorldGeneration.OceanSand");
        for (int index1 = 0; index1 < 3; ++index1)
        {
          progress.Set((float) index1 / 3f);
          int num2 = WorldGen.genRand.Next(Main.maxTilesX);
          while ((double) num2 > (double) Main.maxTilesX * 0.400000005960464 && (double) num2 < (double) Main.maxTilesX * 0.600000023841858)
            num2 = WorldGen.genRand.Next(Main.maxTilesX);
          int num3 = WorldGen.genRand.Next(35, 90);
          if (index1 == 1)
          {
            float num4 = (float) (Main.maxTilesX / 4200);
            num3 += (int) ((double) WorldGen.genRand.Next(20, 40) * (double) num4);
          }
          if (WorldGen.genRand.Next(3) == 0)
            num3 *= 2;
          if (index1 == 1)
            num3 *= 2;
          int num5 = num2 - num3;
          int num6 = WorldGen.genRand.Next(35, 90);
          if (WorldGen.genRand.Next(3) == 0)
            num6 *= 2;
          if (index1 == 1)
            num6 *= 2;
          int num7 = num2 + num6;
          if (num5 < 0)
            num5 = 0;
          if (num7 > Main.maxTilesX)
            num7 = Main.maxTilesX;
          switch (index1)
          {
            case 0:
              num5 = 0;
              num7 = leftBeachEnd;
              break;
            case 1:
              continue;
            case 2:
              num5 = rightBeachStart;
              num7 = Main.maxTilesX;
              break;
          }
          int num8 = WorldGen.genRand.Next(50, 100);
          for (int index2 = num5; index2 < num7; ++index2)
          {
            if (WorldGen.genRand.Next(2) == 0)
            {
              num8 += WorldGen.genRand.Next(-1, 2);
              if (num8 < 50)
                num8 = 50;
              if (num8 > 200)
                num8 = 200;
            }
            for (int index3 = 0; (double) index3 < (Main.worldSurface + Main.rockLayer) / 2.0; ++index3)
            {
              if (Main.tile[index2, index3].active())
              {
                if (index2 == (num5 + num7) / 2 && WorldGen.genRand.Next(6) == 0)
                {
                  PyrX[numPyr] = index2;
                  PyrY[numPyr] = index3;
                  ++numPyr;
                }
                int num4 = num8;
                if (index2 - num5 < num4)
                  num4 = index2 - num5;
                if (num7 - index2 < num4)
                  num4 = num7 - index2;
                int num9 = num4 + WorldGen.genRand.Next(5);
                for (int index4 = index3; index4 < index3 + num9; ++index4)
                {
                  if (index2 > num5 + WorldGen.genRand.Next(5) && index2 < num7 - WorldGen.genRand.Next(5))
                    Main.tile[index2, index4].type = (ushort) 53;
                }
                break;
              }
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Sand Patches", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        int num2 = (int) ((double) Main.maxTilesX * 0.0130000002682209);
        for (int index = 0; index < num2; ++index)
        {
          int i = WorldGen.genRand.Next(0, Main.maxTilesX);
          int j;
          for (j = WorldGen.genRand.Next((int) Main.worldSurface, (int) Main.rockLayer); (double) i > (double) Main.maxTilesX * 0.46 && (double) i < (double) Main.maxTilesX * 0.54 && (double) j < Main.worldSurface + 150.0; j = WorldGen.genRand.Next((int) Main.worldSurface, (int) Main.rockLayer))
            i = WorldGen.genRand.Next(0, Main.maxTilesX);
          WorldGen.TileRunner(i, j, (double) WorldGen.genRand.Next(15, 70), WorldGen.genRand.Next(20, 130), 53, false, 0.0f, 0.0f, false, true, -1);
        }
      }));
      WorldGen.AddGenerationPass("Tunnels", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        for (int index1 = 0; index1 < (int) ((double) Main.maxTilesX * 0.0015) && WorldGen.numTunnels < WorldGen.maxTunnels - 1; ++index1)
        {
          int[] numArray1 = new int[10];
          int[] numArray2 = new int[10];
          int num2 = WorldGen.genRand.Next(450, Main.maxTilesX - 450);
          while ((double) num2 > (double) Main.maxTilesX * 0.4 && (double) num2 < (double) Main.maxTilesX * 0.6)
            num2 = WorldGen.genRand.Next(450, Main.maxTilesX - 450);
          int index2 = 0;
          bool flag;
          do
          {
            flag = false;
            for (int index3 = 0; index3 < 10; ++index3)
            {
              int index4 = num2 % Main.maxTilesX;
              while (!Main.tile[index4, index2].active())
                ++index2;
              if (Main.tile[index4, index2].type == (ushort) 53)
                flag = true;
              numArray1[index3] = index4;
              numArray2[index3] = index2 - WorldGen.genRand.Next(11, 16);
              num2 = index4 + WorldGen.genRand.Next(5, 11);
            }
          }
          while (flag);
          WorldGen.tunnelX[WorldGen.numTunnels] = numArray1[5];
          ++WorldGen.numTunnels;
          for (int index3 = 0; index3 < 10; ++index3)
          {
            WorldGen.TileRunner(numArray1[index3], numArray2[index3], (double) WorldGen.genRand.Next(5, 8), WorldGen.genRand.Next(6, 9), 0, true, -2f, -0.3f, false, true, -1);
            WorldGen.TileRunner(numArray1[index3], numArray2[index3], (double) WorldGen.genRand.Next(5, 8), WorldGen.genRand.Next(6, 9), 0, true, 2f, -0.3f, false, true, -1);
          }
        }
      }));
      WorldGen.AddGenerationPass("Mount Caves", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        WorldGen.numMCaves = 0;
        progress.Message = Lang.gen[2].Value;
        for (int index1 = 0; index1 < (int) ((double) Main.maxTilesX * 0.001); ++index1)
        {
          progress.Set((float) ((double) index1 / (double) Main.maxTilesX * (1.0 / 1000.0)));
          int num2 = 0;
          bool flag1 = false;
          bool flag2 = false;
          int i = WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.25), (int) ((double) Main.maxTilesX * 0.75));
          while (!flag2)
          {
            flag2 = true;
            while (i > Main.maxTilesX / 2 - 90 && i < Main.maxTilesX / 2 + 90)
              i = WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.25), (int) ((double) Main.maxTilesX * 0.75));
            for (int index2 = 0; index2 < WorldGen.numMCaves; ++index2)
            {
              if (Math.Abs(i - WorldGen.mCaveX[index2]) < 100)
              {
                ++num2;
                flag2 = false;
                break;
              }
            }
            if (num2 >= Main.maxTilesX / 5)
            {
              flag1 = true;
              break;
            }
          }
          if (!flag1)
          {
            for (int j = 0; (double) j < Main.worldSurface; ++j)
            {
              if (Main.tile[i, j].active())
              {
                for (int index2 = i - 50; index2 < i + 50; ++index2)
                {
                  for (int index3 = j - 25; index3 < j + 25; ++index3)
                  {
                    if (Main.tile[index2, index3].active() && (Main.tile[index2, index3].type == (ushort) 53 || Main.tile[index2, index3].type == (ushort) 151 || Main.tile[index2, index3].type == (ushort) 274))
                      flag1 = true;
                  }
                }
                if (!flag1)
                {
                  WorldGen.Mountinater(i, j);
                  WorldGen.mCaveX[WorldGen.numMCaves] = i;
                  WorldGen.mCaveY[WorldGen.numMCaves] = j;
                  ++WorldGen.numMCaves;
                  break;
                }
              }
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Dirt Wall Backgrounds", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[3].Value;
        for (int index1 = 1; index1 < Main.maxTilesX - 1; ++index1)
        {
          ushort num2 = 2;
          float num3 = (float) index1 / (float) Main.maxTilesX;
          progress.Set(num3);
          bool flag = false;
          howFar += WorldGen.genRand.Next(-1, 2);
          if (howFar < 0)
            howFar = 0;
          if (howFar > 10)
            howFar = 10;
          for (int index2 = 0; (double) index2 < Main.worldSurface + 10.0 && (double) index2 <= Main.worldSurface + (double) howFar; ++index2)
          {
            if (Main.tile[index1, index2].active())
              num2 = Main.tile[index1, index2].type != (ushort) 147 ? (ushort) 2 : (ushort) 40;
            if (flag && Main.tile[index1, index2].wall != (ushort) 64)
              Main.tile[index1, index2].wall = num2;
            if (Main.tile[index1, index2].active() && Main.tile[index1 - 1, index2].active() && (Main.tile[index1 + 1, index2].active() && Main.tile[index1, index2 + 1].active()) && (Main.tile[index1 - 1, index2 + 1].active() && Main.tile[index1 + 1, index2 + 1].active()))
              flag = true;
          }
        }
      }));
      WorldGen.AddGenerationPass("Rocks In Dirt", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[4].Value;
        float num2 = (float) (Main.maxTilesX * Main.maxTilesY) * 0.00015f;
        for (int index = 0; (double) index < (double) num2; ++index)
          WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next(0, (int) WorldGen.worldSurfaceLow + 1), (double) WorldGen.genRand.Next(4, 15), WorldGen.genRand.Next(5, 40), 1, false, 0.0f, 0.0f, false, true, -1);
        progress.Set(0.34f);
        float num3 = (float) (Main.maxTilesX * Main.maxTilesY) * 0.0002f;
        for (int index = 0; (double) index < (double) num3; ++index)
        {
          int i = WorldGen.genRand.Next(0, Main.maxTilesX);
          int j = WorldGen.genRand.Next((int) WorldGen.worldSurfaceLow, (int) worldSurfaceHigh + 1);
          if (!Main.tile[i, j - 10].active())
            j = WorldGen.genRand.Next((int) WorldGen.worldSurfaceLow, (int) worldSurfaceHigh + 1);
          WorldGen.TileRunner(i, j, (double) WorldGen.genRand.Next(4, 10), WorldGen.genRand.Next(5, 30), 1, false, 0.0f, 0.0f, false, true, -1);
        }
        progress.Set(0.67f);
        float num4 = (float) (Main.maxTilesX * Main.maxTilesY) * 0.0045f;
        for (int index = 0; (double) index < (double) num4; ++index)
          WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next((int) worldSurfaceHigh, (int) rockLayerHigh + 1), (double) WorldGen.genRand.Next(2, 7), WorldGen.genRand.Next(2, 23), 1, false, 0.0f, 0.0f, false, true, -1);
      }));
      WorldGen.AddGenerationPass("Dirt In Rocks", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[5].Value;
        float num2 = (float) (Main.maxTilesX * Main.maxTilesY) * 0.005f;
        for (int index = 0; (double) index < (double) num2; ++index)
        {
          progress.Set((float) index / num2);
          WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next((int) rockLayerLow, Main.maxTilesY), (double) WorldGen.genRand.Next(2, 6), WorldGen.genRand.Next(2, 40), 0, false, 0.0f, 0.0f, false, true, -1);
        }
      }));
      WorldGen.AddGenerationPass("Clay", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[6].Value;
        for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 2E-05); ++index)
          WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next(0, (int) WorldGen.worldSurfaceLow), (double) WorldGen.genRand.Next(4, 14), WorldGen.genRand.Next(10, 50), 40, false, 0.0f, 0.0f, false, true, -1);
        progress.Set(0.25f);
        for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 5E-05); ++index)
          WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next((int) WorldGen.worldSurfaceLow, (int) worldSurfaceHigh + 1), (double) WorldGen.genRand.Next(8, 14), WorldGen.genRand.Next(15, 45), 40, false, 0.0f, 0.0f, false, true, -1);
        progress.Set(0.5f);
        for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 2E-05); ++index)
          WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next((int) worldSurfaceHigh, (int) rockLayerHigh + 1), (double) WorldGen.genRand.Next(8, 15), WorldGen.genRand.Next(5, 50), 40, false, 0.0f, 0.0f, false, true, -1);
        progress.Set(0.75f);
        for (int index1 = 5; index1 < Main.maxTilesX - 5; ++index1)
        {
          for (int index2 = 1; (double) index2 < Main.worldSurface - 1.0; ++index2)
          {
            if (Main.tile[index1, index2].active())
            {
              for (int index3 = index2; index3 < index2 + 5; ++index3)
              {
                if (Main.tile[index1, index3].type == (ushort) 40)
                  Main.tile[index1, index3].type = (ushort) 0;
              }
              break;
            }
          }
        }
      }));
      int i2;
      WorldGen.AddGenerationPass("Small Holes", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        i2 = 0;
        progress.Message = Lang.gen[7].Value;
        double num2 = worldSurfaceHigh;
        for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 0.0015); ++index)
        {
          float num3 = (float) index / ((float) (Main.maxTilesX * Main.maxTilesY) * 0.0015f);
          progress.Set(num3);
          int type = -1;
          if (WorldGen.genRand.Next(5) == 0)
            type = -2;
          int i1 = WorldGen.genRand.Next(0, Main.maxTilesX);
          int j1;
          for (j1 = WorldGen.genRand.Next((int) worldSurfaceHigh, Main.maxTilesY); (i1 < smallHolesBeachAvoidance || i1 > Main.maxTilesX - smallHolesBeachAvoidance) && (double) j1 < num2 || (double) i1 > (double) Main.maxTilesX * 0.45 && (double) i1 < (double) Main.maxTilesX * 0.55 && (double) j1 < worldSurface; j1 = WorldGen.genRand.Next((int) worldSurfaceHigh, Main.maxTilesY))
            i1 = WorldGen.genRand.Next(0, Main.maxTilesX);
          WorldGen.TileRunner(i1, j1, (double) WorldGen.genRand.Next(2, 5), WorldGen.genRand.Next(2, 20), type, false, 0.0f, 0.0f, false, true, -1);
          int i3 = WorldGen.genRand.Next(0, Main.maxTilesX);
          int j2;
          for (j2 = WorldGen.genRand.Next((int) worldSurfaceHigh, Main.maxTilesY); (i3 < smallHolesBeachAvoidance || i3 > Main.maxTilesX - smallHolesBeachAvoidance) && (double) j2 < num2 || (double) i3 > (double) Main.maxTilesX * 0.45 && (double) i3 < (double) Main.maxTilesX * 0.55 && (double) j2 < worldSurface; j2 = WorldGen.genRand.Next((int) worldSurfaceHigh, Main.maxTilesY))
            i3 = WorldGen.genRand.Next(0, Main.maxTilesX);
          WorldGen.TileRunner(i3, j2, (double) WorldGen.genRand.Next(8, 15), WorldGen.genRand.Next(7, 30), type, false, 0.0f, 0.0f, false, true, -1);
        }
      }));
      WorldGen.AddGenerationPass("Dirt Layer Caves", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[8].Value;
        double num2 = worldSurfaceHigh;
        for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 3E-05); ++index)
        {
          float num3 = (float) index / ((float) (Main.maxTilesX * Main.maxTilesY) * 3E-05f);
          progress.Set(num3);
          if (rockLayerHigh <= (double) Main.maxTilesY)
          {
            int type = -1;
            if (WorldGen.genRand.Next(6) == 0)
              type = -2;
            int i = WorldGen.genRand.Next(0, Main.maxTilesX);
            int j;
            for (j = WorldGen.genRand.Next((int) WorldGen.worldSurfaceLow, (int) rockLayerHigh + 1); (i < smallHolesBeachAvoidance || i > Main.maxTilesX - smallHolesBeachAvoidance) && (double) j < num2 || (double) i >= (double) Main.maxTilesX * 0.45 && (double) i <= (double) Main.maxTilesX * 0.55 && (double) j < Main.worldSurface; j = WorldGen.genRand.Next((int) WorldGen.worldSurfaceLow, (int) rockLayerHigh + 1))
              i = WorldGen.genRand.Next(0, Main.maxTilesX);
            WorldGen.TileRunner(i, j, (double) WorldGen.genRand.Next(5, 15), WorldGen.genRand.Next(30, 200), type, false, 0.0f, 0.0f, false, true, -1);
          }
        }
      }));
      WorldGen.AddGenerationPass("Rock Layer Caves", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[9].Value;
        for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 0.00013); ++index)
        {
          float num2 = (float) index / ((float) (Main.maxTilesX * Main.maxTilesY) * 0.00013f);
          progress.Set(num2);
          if (rockLayerHigh <= (double) Main.maxTilesY)
          {
            int type = -1;
            if (WorldGen.genRand.Next(10) == 0)
              type = -2;
            WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next((int) rockLayerHigh, Main.maxTilesY), (double) WorldGen.genRand.Next(6, 20), WorldGen.genRand.Next(50, 300), type, false, 0.0f, 0.0f, false, true, -1);
          }
        }
      }));
      WorldGen.AddGenerationPass("Surface Caves", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[10].Value;
        for (int index = 0; index < (int) ((double) Main.maxTilesX * 0.002); ++index)
        {
          i2 = WorldGen.genRand.Next(0, Main.maxTilesX);
          while ((double) i2 > (double) Main.maxTilesX * 0.449999988079071 && (double) i2 < (double) Main.maxTilesX * 0.550000011920929 || (i2 < leftBeachEnd + 20 || i2 > rightBeachStart - 20))
            i2 = WorldGen.genRand.Next(0, Main.maxTilesX);
          for (int j = 0; (double) j < worldSurfaceHigh; ++j)
          {
            if (Main.tile[i2, j].active())
            {
              WorldGen.TileRunner(i2, j, (double) WorldGen.genRand.Next(3, 6), WorldGen.genRand.Next(5, 50), -1, false, (float) WorldGen.genRand.Next(-10, 11) * 0.1f, 1f, false, true, -1);
              break;
            }
          }
        }
        progress.Set(0.2f);
        for (int index = 0; index < (int) ((double) Main.maxTilesX * 0.0007); ++index)
        {
          i2 = WorldGen.genRand.Next(0, Main.maxTilesX);
          while ((double) i2 > (double) Main.maxTilesX * 0.430000007152557 && (double) i2 < (double) Main.maxTilesX * 0.569999992847443 || (i2 < leftBeachEnd + 20 || i2 > rightBeachStart - 20))
            i2 = WorldGen.genRand.Next(0, Main.maxTilesX);
          for (int j = 0; (double) j < worldSurfaceHigh; ++j)
          {
            if (Main.tile[i2, j].active())
            {
              WorldGen.TileRunner(i2, j, (double) WorldGen.genRand.Next(10, 15), WorldGen.genRand.Next(50, 130), -1, false, (float) WorldGen.genRand.Next(-10, 11) * 0.1f, 2f, false, true, -1);
              break;
            }
          }
        }
        progress.Set(0.4f);
        for (int index = 0; index < (int) ((double) Main.maxTilesX * 0.0003); ++index)
        {
          i2 = WorldGen.genRand.Next(0, Main.maxTilesX);
          while ((double) i2 > (double) Main.maxTilesX * 0.400000005960464 && (double) i2 < (double) Main.maxTilesX * 0.600000023841858 || (i2 < leftBeachEnd + 20 || i2 > rightBeachStart - 20))
            i2 = WorldGen.genRand.Next(0, Main.maxTilesX);
          for (int j = 0; (double) j < worldSurfaceHigh; ++j)
          {
            if (Main.tile[i2, j].active())
            {
              WorldGen.TileRunner(i2, j, (double) WorldGen.genRand.Next(12, 25), WorldGen.genRand.Next(150, 500), -1, false, (float) WorldGen.genRand.Next(-10, 11) * 0.1f, 4f, false, true, -1);
              WorldGen.TileRunner(i2, j, (double) WorldGen.genRand.Next(8, 17), WorldGen.genRand.Next(60, 200), -1, false, (float) WorldGen.genRand.Next(-10, 11) * 0.1f, 2f, false, true, -1);
              WorldGen.TileRunner(i2, j, (double) WorldGen.genRand.Next(5, 13), WorldGen.genRand.Next(40, 170), -1, false, (float) WorldGen.genRand.Next(-10, 11) * 0.1f, 2f, false, true, -1);
              break;
            }
          }
        }
        progress.Set(0.6f);
        for (int index = 0; index < (int) ((double) Main.maxTilesX * 0.0004); ++index)
        {
          i2 = WorldGen.genRand.Next(0, Main.maxTilesX);
          while ((double) i2 > (double) Main.maxTilesX * 0.400000005960464 && (double) i2 < (double) Main.maxTilesX * 0.600000023841858 || (i2 < leftBeachEnd + 20 || i2 > rightBeachStart - 20))
            i2 = WorldGen.genRand.Next(0, Main.maxTilesX);
          for (int j = 0; (double) j < worldSurfaceHigh; ++j)
          {
            if (Main.tile[i2, j].active())
            {
              WorldGen.TileRunner(i2, j, (double) WorldGen.genRand.Next(7, 12), WorldGen.genRand.Next(150, 250), -1, false, 0.0f, 1f, true, true, -1);
              break;
            }
          }
        }
        progress.Set(0.8f);
        float num2 = (float) (Main.maxTilesX / 4200);
        for (int index = 0; (double) index < 5.0 * (double) num2; ++index)
        {
          try
          {
            WorldGen.Caverer(WorldGen.genRand.Next(surfaceCavesBeachAvoidance2, Main.maxTilesX - surfaceCavesBeachAvoidance2), WorldGen.genRand.Next((int) Main.rockLayer, Main.maxTilesY - 400));
          }
          catch
          {
          }
        }
      }));
      WorldGen.AddGenerationPass("Generate Ice Biome", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[56].Value;
        snowTop = (int) Main.worldSurface;
        int num2 = WorldGen.lavaLine - WorldGen.genRand.Next(160, 200);
        int num3 = snowOriginLeft;
        int num4 = snowOriginRight;
        int num5 = 10;
        for (int index1 = 0; index1 <= WorldGen.lavaLine - 140; ++index1)
        {
          progress.Set((float) index1 / (float) (WorldGen.lavaLine - 140));
          num3 += WorldGen.genRand.Next(-4, 4);
          num4 += WorldGen.genRand.Next(-3, 5);
          if (index1 > 0)
          {
            num3 = (num3 + snowMinX[index1 - 1]) / 2;
            num4 = (num4 + snowMaxX[index1 - 1]) / 2;
          }
          if (dungeonSide > 0)
          {
            if (WorldGen.genRand.Next(4) == 0)
            {
              ++num3;
              ++num4;
            }
          }
          else if (WorldGen.genRand.Next(4) == 0)
          {
            --num3;
            --num4;
          }
          snowMinX[index1] = num3;
          snowMaxX[index1] = num4;
          for (int index2 = num3; index2 < num4; ++index2)
          {
            if (index1 < num2)
            {
              if (Main.tile[index2, index1].wall == (ushort) 2)
                Main.tile[index2, index1].wall = (ushort) 40;
              switch (Main.tile[index2, index1].type)
              {
                case 0:
                case 2:
                case 23:
                case 40:
                case 53:
                  Main.tile[index2, index1].type = (ushort) 147;
                  continue;
                case 1:
                  Main.tile[index2, index1].type = (ushort) 161;
                  continue;
                default:
                  continue;
              }
            }
            else
            {
              num5 += WorldGen.genRand.Next(-3, 4);
              if (WorldGen.genRand.Next(3) == 0)
              {
                num5 += WorldGen.genRand.Next(-4, 5);
                if (WorldGen.genRand.Next(3) == 0)
                  num5 += WorldGen.genRand.Next(-6, 7);
              }
              if (num5 < 0)
                num5 = WorldGen.genRand.Next(3);
              else if (num5 > 50)
                num5 = 50 - WorldGen.genRand.Next(3);
              for (int index3 = index1; index3 < index1 + num5; ++index3)
              {
                if (Main.tile[index2, index3].wall == (ushort) 2)
                  Main.tile[index2, index3].wall = (ushort) 40;
                switch (Main.tile[index2, index3].type)
                {
                  case 0:
                  case 2:
                  case 23:
                  case 40:
                  case 53:
                    Main.tile[index2, index3].type = (ushort) 147;
                    break;
                  case 1:
                    Main.tile[index2, index3].type = (ushort) 161;
                    break;
                }
              }
            }
          }
          if (snowBottom < index1)
            snowBottom = index1;
        }
      }));
      WorldGen.AddGenerationPass("Grass", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        float num2 = (float) (Main.maxTilesX * Main.maxTilesY) * (1f / 500f);
        for (int index1 = 0; (double) index1 < (double) num2; ++index1)
        {
          progress.Set((float) index1 / num2);
          int index2 = WorldGen.genRand.Next(1, Main.maxTilesX - 1);
          int index3 = WorldGen.genRand.Next((int) WorldGen.worldSurfaceLow, (int) worldSurfaceHigh);
          if (index3 >= Main.maxTilesY)
            index3 = Main.maxTilesY - 2;
          if (Main.tile[index2 - 1, index3].active() && Main.tile[index2 - 1, index3].type == (ushort) 0 && (Main.tile[index2 + 1, index3].active() && Main.tile[index2 + 1, index3].type == (ushort) 0) && (Main.tile[index2, index3 - 1].active() && Main.tile[index2, index3 - 1].type == (ushort) 0 && (Main.tile[index2, index3 + 1].active() && Main.tile[index2, index3 + 1].type == (ushort) 0)))
          {
            Main.tile[index2, index3].active(true);
            Main.tile[index2, index3].type = (ushort) 2;
          }
          int index4 = WorldGen.genRand.Next(1, Main.maxTilesX - 1);
          int index5 = WorldGen.genRand.Next(0, (int) WorldGen.worldSurfaceLow);
          if (index5 >= Main.maxTilesY)
            index5 = Main.maxTilesY - 2;
          if (Main.tile[index4 - 1, index5].active() && Main.tile[index4 - 1, index5].type == (ushort) 0 && (Main.tile[index4 + 1, index5].active() && Main.tile[index4 + 1, index5].type == (ushort) 0) && (Main.tile[index4, index5 - 1].active() && Main.tile[index4, index5 - 1].type == (ushort) 0 && (Main.tile[index4, index5 + 1].active() && Main.tile[index4, index5 + 1].type == (ushort) 0)))
          {
            Main.tile[index4, index5].active(true);
            Main.tile[index4, index5].type = (ushort) 2;
          }
        }
      }));
      WorldGen.AddGenerationPass(new JunglePass().OnBegin((Action<GenPass>) (pass =>
      {
        JunglePass junglePass = pass as JunglePass;
        junglePass.JungleOriginX = jungleOriginX;
        junglePass.DungeonSide = dungeonSide;
        junglePass.WorldSurface = worldSurface;
        junglePass.LeftBeachEnd = leftBeachEnd;
        junglePass.RightBeachStart = rightBeachStart;
      })).OnComplete((Action<GenPass>) (pass => WorldGen.JungleX = (pass as JunglePass).JungleX)));
      WorldGen.AddGenerationPass("Mud Caves To Grass", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[77].Value;
        WorldGen.NotTheBees();
        for (int i = 0; i < Main.maxTilesX; ++i)
        {
          for (int j = 0; j < Main.maxTilesY; ++j)
          {
            if (Main.tile[i, j].active())
            {
              WorldGen.grassSpread = 0;
              WorldGen.SpreadGrass(i, j, 59, 60, true, (byte) 0);
            }
            progress.Set((float) (0.200000002980232 * ((double) (i * Main.maxTilesY + j) / (double) (Main.maxTilesX * Main.maxTilesY))));
          }
        }
        WorldGen.SmallConsecutivesFound = 0;
        WorldGen.SmallConsecutivesEliminated = 0;
        float num2 = (float) (Main.maxTilesX - 20);
        for (int x = 10; x < Main.maxTilesX - 10; ++x)
        {
          WorldGen.ScanTileColumnAndRemoveClumps(x);
          float num3 = (float) (x - 10) / num2;
          progress.Set((float) (0.200000002980232 + (double) num3 * 0.800000011920929));
        }
      }));
      WorldGen.AddGenerationPass("Full Desert", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[78].Value;
        Main.tileSolid[484] = false;
        int num2 = 0;
        int num3 = dungeonSide;
        int maxValue = Main.maxTilesX / 2;
        int num4 = WorldGen.genRand.Next(maxValue) / 8 + maxValue / 8;
        int x = maxValue + num4 * -num3;
        if (WorldGen.drunkWorldGen)
          num3 *= -1;
        int num5 = 0;
        DesertBiome biome = configuration.CreateBiome<DesertBiome>();
        while (!biome.Place(new Point(x, (int) worldSurfaceHigh + 25), structures))
        {
          int num6 = WorldGen.genRand.Next(maxValue) / 2 + maxValue / 8 + WorldGen.genRand.Next(num5 / 12);
          x = maxValue + num6 * -num3;
          if (++num5 > Main.maxTilesX / 4)
          {
            num3 *= -1;
            num5 = 0;
            ++num2;
            if (num2 >= 2)
              WorldGen.skipDesertTileCheck = true;
          }
        }
      }));
      WorldGen.AddGenerationPass("Floating Islands", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        WorldGen.numIslandHouses = 0;
        WorldGen.houseCount = 0;
        progress.Message = Lang.gen[12].Value;
        int num2 = (int) ((double) Main.maxTilesX * 0.0008);
        int num3 = 0;
        float num4 = (float) (num2 + skyLakes);
        for (int index1 = 0; (double) index1 < (double) num4; ++index1)
        {
          progress.Set((float) index1 / num4);
          int num5 = Main.maxTilesX;
          while (--num5 > 0)
          {
            bool flag1 = true;
            int i = WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.1), (int) ((double) Main.maxTilesX * 0.9));
            while (i > Main.maxTilesX / 2 - 150 && i < Main.maxTilesX / 2 + 150)
              i = WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.1), (int) ((double) Main.maxTilesX * 0.9));
            for (int index2 = 0; index2 < WorldGen.numIslandHouses; ++index2)
            {
              if (i > WorldGen.floatingIslandHouseX[index2] - 180 && i < WorldGen.floatingIslandHouseX[index2] + 180)
              {
                flag1 = false;
                break;
              }
            }
            if (flag1)
            {
              bool flag2 = false;
              int num6 = 0;
              for (int index2 = 200; (double) index2 < Main.worldSurface; ++index2)
              {
                if (Main.tile[i, index2].active())
                {
                  num6 = index2;
                  flag2 = true;
                  break;
                }
              }
              if (flag2)
              {
                int num7 = 0;
                num5 = -1;
                int j = Math.Min(WorldGen.genRand.Next(90, num6 - 100), (int) WorldGen.worldSurfaceLow - 50);
                if (num3 >= num2)
                {
                  WorldGen.skyLake[WorldGen.numIslandHouses] = true;
                  WorldGen.CloudLake(i, j);
                }
                else
                {
                  WorldGen.skyLake[WorldGen.numIslandHouses] = false;
                  if (WorldGen.drunkWorldGen)
                  {
                    if (WorldGen.genRand.Next(2) == 0)
                    {
                      num7 = 3;
                      WorldGen.SnowCloudIsland(i, j);
                    }
                    else
                    {
                      num7 = 1;
                      WorldGen.DesertCloudIsland(i, j);
                    }
                  }
                  else
                  {
                    if (WorldGen.getGoodWorldGen)
                      num7 = !WorldGen.crimson ? 4 : 5;
                    WorldGen.CloudIsland(i, j);
                  }
                }
                WorldGen.floatingIslandHouseX[WorldGen.numIslandHouses] = i;
                WorldGen.floatingIslandHouseY[WorldGen.numIslandHouses] = j;
                WorldGen.floatingIslandStyle[WorldGen.numIslandHouses] = num7;
                ++WorldGen.numIslandHouses;
                ++num3;
              }
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Mushroom Patches", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[13].Value;
        float num2 = (float) (Main.maxTilesX / 700);
        if ((double) num2 > (double) WorldGen.maxMushroomBiomes)
          num2 = (float) WorldGen.maxMushroomBiomes;
        for (int index1 = 0; (double) index1 < (double) num2; ++index1)
        {
          int num3 = 0;
          bool flag = true;
          while (flag)
          {
            int i = WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.2), (int) ((double) Main.maxTilesX * 0.8));
            if (num3 > Main.maxTilesX / 4)
              i = WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.25), (int) ((double) Main.maxTilesX * 0.975));
            int j = WorldGen.genRand.Next((int) Main.rockLayer + 50, Main.maxTilesY - 300);
            flag = false;
            int num4 = 100;
            int num5 = 500;
            for (int x = i - num4; x < i + num4; x += 3)
            {
              for (int y = j - num4; y < j + num4; y += 3)
              {
                if (WorldGen.InWorld(x, y, 0))
                {
                  if (Main.tile[x, y].type == (ushort) 147 || Main.tile[x, y].type == (ushort) 161 || (Main.tile[x, y].type == (ushort) 162 || Main.tile[x, y].type == (ushort) 60) || (Main.tile[x, y].type == (ushort) 368 || Main.tile[x, y].type == (ushort) 367))
                  {
                    flag = true;
                    break;
                  }
                  if (WorldGen.UndergroundDesertLocation.Contains(new Point(x, y)))
                  {
                    flag = true;
                    break;
                  }
                }
                else
                  flag = true;
              }
            }
            if (!flag)
            {
              for (int index2 = 0; index2 < WorldGen.numMushroomBiomes; ++index2)
              {
                if ((double) Vector2.Distance(WorldGen.mushroomBiomesPosition[index2], new Vector2((float) i, (float) j)) < (double) num5)
                  flag = true;
              }
            }
            if (!flag && WorldGen.numMushroomBiomes < WorldGen.maxMushroomBiomes)
            {
              WorldGen.ShroomPatch(i, j);
              for (int index2 = 0; index2 < 5; ++index2)
                WorldGen.ShroomPatch(i + WorldGen.genRand.Next(-40, 41), j + WorldGen.genRand.Next(-40, 41));
              WorldGen.mushroomBiomesPosition[WorldGen.numMushroomBiomes].X = (float) i;
              WorldGen.mushroomBiomesPosition[WorldGen.numMushroomBiomes].Y = (float) j;
              ++WorldGen.numMushroomBiomes;
            }
            ++num3;
            if (num3 > Main.maxTilesX / 2)
              break;
          }
        }
        for (int index = 0; index < Main.maxTilesX; ++index)
        {
          progress.Set((float) index / (float) Main.maxTilesX);
          for (int worldSurface1 = (int) Main.worldSurface; worldSurface1 < Main.maxTilesY; ++worldSurface1)
          {
            if (WorldGen.InWorld(index, worldSurface1, 50) && Main.tile[index, worldSurface1].active())
            {
              WorldGen.grassSpread = 0;
              WorldGen.SpreadGrass(index, worldSurface1, 59, 70, false, (byte) 0);
            }
          }
        }
        for (int index1 = 0; index1 < Main.maxTilesX; ++index1)
        {
          for (int worldSurface1 = (int) Main.worldSurface; worldSurface1 < Main.maxTilesY; ++worldSurface1)
          {
            if (Main.tile[index1, worldSurface1].active() && Main.tile[index1, worldSurface1].type == (ushort) 70)
            {
              int Type = 59;
              for (int i = index1 - 1; i <= index1 + 1; ++i)
              {
                for (int j = worldSurface1 - 1; j <= worldSurface1 + 1; ++j)
                {
                  if (Main.tile[i, j].active())
                  {
                    if (!Main.tile[i - 1, j].active() && !Main.tile[i + 1, j].active())
                      WorldGen.KillTile(i, j, false, false, false);
                    else if (!Main.tile[i, j - 1].active() && !Main.tile[i, j + 1].active())
                      WorldGen.KillTile(i, j, false, false, false);
                  }
                  else if (Main.tile[i - 1, j].active() && Main.tile[i + 1, j].active())
                  {
                    WorldGen.PlaceTile(i, j, Type, false, false, -1, 0);
                    if (Main.tile[i - 1, worldSurface1].type == (ushort) 70)
                      Main.tile[i - 1, worldSurface1].type = (ushort) 59;
                    if (Main.tile[i + 1, worldSurface1].type == (ushort) 70)
                      Main.tile[i + 1, worldSurface1].type = (ushort) 59;
                  }
                  else if (Main.tile[i, j - 1].active() && Main.tile[i, j + 1].active())
                  {
                    WorldGen.PlaceTile(i, j, Type, false, false, -1, 0);
                    if (Main.tile[i, worldSurface1 - 1].type == (ushort) 70)
                      Main.tile[i, worldSurface1 - 1].type = (ushort) 59;
                    if (Main.tile[i, worldSurface1 + 1].type == (ushort) 70)
                      Main.tile[i, worldSurface1 + 1].type = (ushort) 59;
                  }
                }
              }
              if (WorldGen.genRand.Next(4) == 0)
              {
                int index2 = index1 + WorldGen.genRand.Next(-20, 21);
                int index3 = worldSurface1 + WorldGen.genRand.Next(-20, 21);
                if (Main.tile[index2, index3].type == (ushort) 59)
                  Main.tile[index2, index3].type = (ushort) 70;
              }
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Marble", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[80].Value;
        int random = passConfig.Get<WorldGenRange>("Count").GetRandom(WorldGen.genRand);
        float num2 = (float) (Main.maxTilesX - 160) / (float) random;
        MarbleBiome biome = configuration.CreateBiome<MarbleBiome>();
        int num3 = 0;
        int num4 = 0;
        while (num4 < random)
        {
          float num5 = (float) num4 / (float) random;
          progress.Set(num5);
          Point origin = WorldGen.RandomRectanglePoint((int) ((double) num5 * (double) (Main.maxTilesX - 160)) + 80, (int) rockLayer + 20, (int) num2, Main.maxTilesY - ((int) rockLayer + 40) - 200);
          while ((double) origin.X > (double) Main.maxTilesX * 0.45 && (double) origin.X < (double) Main.maxTilesX * 0.55)
            origin.X = WorldGen.genRand.Next(WorldGen.beachDistance, Main.maxTilesX - WorldGen.beachDistance);
          ++num3;
          if (biome.Place(origin, structures) || num3 > Main.maxTilesX)
          {
            ++num4;
            num3 = 0;
          }
        }
      }));
      WorldGen.AddGenerationPass("Granite", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[81].Value;
        int random = passConfig.Get<WorldGenRange>("Count").GetRandom(WorldGen.genRand);
        float num2 = (float) (Main.maxTilesX - 200) / (float) random;
        List<Point> pointList = new List<Point>(random);
        int num3 = 0;
        int num4 = 0;
        while (num4 < random)
        {
          float num5 = (float) num4 / (float) random;
          progress.Set(num5);
          Point origin = WorldGen.RandomRectanglePoint((int) ((double) num5 * (double) (Main.maxTilesX - 200)) + 100, (int) rockLayer + 20, (int) num2, Main.maxTilesY - ((int) rockLayer + 40) - 200);
          while ((double) origin.X > (double) Main.maxTilesX * 0.45 && (double) origin.X < (double) Main.maxTilesX * 0.55)
            origin.X = WorldGen.genRand.Next(WorldGen.beachDistance, Main.maxTilesX - WorldGen.beachDistance);
          ++num3;
          if (GraniteBiome.CanPlace(origin, structures))
          {
            pointList.Add(origin);
            ++num4;
          }
          else if (num3 > Main.maxTilesX)
          {
            ++num4;
            num3 = 0;
          }
        }
        GraniteBiome biome = configuration.CreateBiome<GraniteBiome>();
        for (int index = 0; index < random; ++index)
          biome.Place(pointList[index], structures);
      }));
      WorldGen.AddGenerationPass("Dirt To Mud", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[14].Value;
        float num2 = (float) (Main.maxTilesX * Main.maxTilesY) * (1f / 1000f);
        for (int index = 0; (double) index < (double) num2; ++index)
        {
          progress.Set((float) index / num2);
          WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next((int) rockLayerLow, Main.maxTilesY), (double) WorldGen.genRand.Next(2, 6), WorldGen.genRand.Next(2, 40), 59, false, 0.0f, 0.0f, false, true, 53);
        }
      }));
      WorldGen.AddGenerationPass("Silt", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[15].Value;
        for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 0.0001); ++index)
        {
          int i = WorldGen.genRand.Next(0, Main.maxTilesX);
          int j = WorldGen.genRand.Next((int) rockLayerHigh, Main.maxTilesY);
          if (Main.tile[i, j].wall != (ushort) 187 && Main.tile[i, j].wall != (ushort) 216)
            WorldGen.TileRunner(i, j, (double) WorldGen.genRand.Next(5, 12), WorldGen.genRand.Next(15, 50), 123, false, 0.0f, 0.0f, false, true, -1);
        }
        for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 0.0005); ++index)
        {
          int i = WorldGen.genRand.Next(0, Main.maxTilesX);
          int j = WorldGen.genRand.Next((int) rockLayerHigh, Main.maxTilesY);
          if (Main.tile[i, j].wall != (ushort) 187 && Main.tile[i, j].wall != (ushort) 216)
            WorldGen.TileRunner(i, j, (double) WorldGen.genRand.Next(2, 5), WorldGen.genRand.Next(2, 5), 123, false, 0.0f, 0.0f, false, true, -1);
        }
      }));
      WorldGen.AddGenerationPass("Shinies", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[16].Value;
        for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 6E-05); ++index)
        {
          if (WorldGen.drunkWorldGen)
            copper = WorldGen.genRand.Next(2) != 0 ? 166 : 7;
          WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next((int) WorldGen.worldSurfaceLow, (int) worldSurfaceHigh), (double) WorldGen.genRand.Next(3, 6), WorldGen.genRand.Next(2, 6), copper, false, 0.0f, 0.0f, false, true, -1);
        }
        for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 8E-05); ++index)
        {
          if (WorldGen.drunkWorldGen)
            copper = WorldGen.genRand.Next(2) != 0 ? 166 : 7;
          WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next((int) worldSurfaceHigh, (int) rockLayerHigh), (double) WorldGen.genRand.Next(3, 7), WorldGen.genRand.Next(3, 7), copper, false, 0.0f, 0.0f, false, true, -1);
        }
        for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 0.0002); ++index)
        {
          if (WorldGen.drunkWorldGen)
            copper = WorldGen.genRand.Next(2) != 0 ? 166 : 7;
          WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next((int) rockLayerLow, Main.maxTilesY), (double) WorldGen.genRand.Next(4, 9), WorldGen.genRand.Next(4, 8), copper, false, 0.0f, 0.0f, false, true, -1);
        }
        for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 3E-05); ++index)
        {
          if (WorldGen.drunkWorldGen)
            iron = WorldGen.genRand.Next(2) != 0 ? 167 : 6;
          WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next((int) WorldGen.worldSurfaceLow, (int) worldSurfaceHigh), (double) WorldGen.genRand.Next(3, 7), WorldGen.genRand.Next(2, 5), iron, false, 0.0f, 0.0f, false, true, -1);
        }
        for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 8E-05); ++index)
        {
          if (WorldGen.drunkWorldGen)
            iron = WorldGen.genRand.Next(2) != 0 ? 167 : 6;
          WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next((int) worldSurfaceHigh, (int) rockLayerHigh), (double) WorldGen.genRand.Next(3, 6), WorldGen.genRand.Next(3, 6), iron, false, 0.0f, 0.0f, false, true, -1);
        }
        for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 0.0002); ++index)
        {
          if (WorldGen.drunkWorldGen)
            iron = WorldGen.genRand.Next(2) != 0 ? 167 : 6;
          WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next((int) rockLayerLow, Main.maxTilesY), (double) WorldGen.genRand.Next(4, 9), WorldGen.genRand.Next(4, 8), iron, false, 0.0f, 0.0f, false, true, -1);
        }
        for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 2.6E-05); ++index)
        {
          if (WorldGen.drunkWorldGen)
            silver = WorldGen.genRand.Next(2) != 0 ? 168 : 9;
          WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next((int) worldSurfaceHigh, (int) rockLayerHigh), (double) WorldGen.genRand.Next(3, 6), WorldGen.genRand.Next(3, 6), silver, false, 0.0f, 0.0f, false, true, -1);
        }
        for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 0.00015); ++index)
        {
          if (WorldGen.drunkWorldGen)
            silver = WorldGen.genRand.Next(2) != 0 ? 168 : 9;
          WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next((int) rockLayerLow, Main.maxTilesY), (double) WorldGen.genRand.Next(4, 9), WorldGen.genRand.Next(4, 8), silver, false, 0.0f, 0.0f, false, true, -1);
        }
        for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 0.00017); ++index)
        {
          if (WorldGen.drunkWorldGen)
            silver = WorldGen.genRand.Next(2) != 0 ? 168 : 9;
          WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next(0, (int) WorldGen.worldSurfaceLow), (double) WorldGen.genRand.Next(4, 9), WorldGen.genRand.Next(4, 8), silver, false, 0.0f, 0.0f, false, true, -1);
        }
        for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 0.00012); ++index)
        {
          if (WorldGen.drunkWorldGen)
            gold = WorldGen.genRand.Next(2) != 0 ? 169 : 8;
          WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next((int) rockLayerLow, Main.maxTilesY), (double) WorldGen.genRand.Next(4, 8), WorldGen.genRand.Next(4, 8), gold, false, 0.0f, 0.0f, false, true, -1);
        }
        for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 0.00012); ++index)
        {
          if (WorldGen.drunkWorldGen)
            gold = WorldGen.genRand.Next(2) != 0 ? 169 : 8;
          WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next(0, (int) WorldGen.worldSurfaceLow - 20), (double) WorldGen.genRand.Next(4, 8), WorldGen.genRand.Next(4, 8), gold, false, 0.0f, 0.0f, false, true, -1);
        }
        if (WorldGen.drunkWorldGen)
        {
          for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 2.25E-05 / 2.0); ++index)
            WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next((int) Main.rockLayer, Main.maxTilesY), (double) WorldGen.genRand.Next(3, 6), WorldGen.genRand.Next(4, 8), 204, false, 0.0f, 0.0f, false, true, -1);
          for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 2.25E-05 / 2.0); ++index)
            WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next((int) Main.rockLayer, Main.maxTilesY), (double) WorldGen.genRand.Next(3, 6), WorldGen.genRand.Next(4, 8), 22, false, 0.0f, 0.0f, false, true, -1);
        }
        if (WorldGen.crimson)
        {
          for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 2.25E-05); ++index)
            WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next((int) Main.rockLayer, Main.maxTilesY), (double) WorldGen.genRand.Next(3, 6), WorldGen.genRand.Next(4, 8), 204, false, 0.0f, 0.0f, false, true, -1);
        }
        else
        {
          for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 2.25E-05); ++index)
            WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next((int) Main.rockLayer, Main.maxTilesY), (double) WorldGen.genRand.Next(3, 6), WorldGen.genRand.Next(4, 8), 22, false, 0.0f, 0.0f, false, true, -1);
        }
      }));
      WorldGen.AddGenerationPass("Webs", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[17].Value;
        for (int index1 = 0; index1 < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 0.0006); ++index1)
        {
          int index2 = WorldGen.genRand.Next(20, Main.maxTilesX - 20);
          int index3 = WorldGen.genRand.Next((int) worldSurfaceHigh, Main.maxTilesY - 20);
          if (index1 < WorldGen.numMCaves)
          {
            index2 = WorldGen.mCaveX[index1];
            index3 = WorldGen.mCaveY[index1];
          }
          if (!Main.tile[index2, index3].active() && ((double) index3 > Main.worldSurface || Main.tile[index2, index3].wall > (ushort) 0))
          {
            while (!Main.tile[index2, index3].active() && index3 > (int) WorldGen.worldSurfaceLow)
              --index3;
            int j = index3 + 1;
            int num2 = 1;
            if (WorldGen.genRand.Next(2) == 0)
              num2 = -1;
            while (!Main.tile[index2, j].active() && index2 > 10 && index2 < Main.maxTilesX - 10)
              index2 += num2;
            int i = index2 - num2;
            if ((double) j > Main.worldSurface || Main.tile[i, j].wall > (ushort) 0)
              WorldGen.TileRunner(i, j, (double) WorldGen.genRand.Next(4, 11), WorldGen.genRand.Next(2, 4), 51, true, (float) num2, -1f, false, false, -1);
          }
        }
      }));
      WorldGen.AddGenerationPass("Underworld", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[18].Value;
        progress.Set(0.0f);
        int num2 = Main.maxTilesY - WorldGen.genRand.Next(150, 190);
        for (int index1 = 0; index1 < Main.maxTilesX; ++index1)
        {
          num2 += WorldGen.genRand.Next(-3, 4);
          if (num2 < Main.maxTilesY - 190)
            num2 = Main.maxTilesY - 190;
          if (num2 > Main.maxTilesY - 160)
            num2 = Main.maxTilesY - 160;
          for (int index2 = num2 - 20 - WorldGen.genRand.Next(3); index2 < Main.maxTilesY; ++index2)
          {
            if (index2 >= num2)
            {
              Main.tile[index1, index2].active(false);
              Main.tile[index1, index2].lava(false);
              Main.tile[index1, index2].liquid = (byte) 0;
            }
            else
              Main.tile[index1, index2].type = (ushort) 57;
          }
        }
        int num3 = Main.maxTilesY - WorldGen.genRand.Next(40, 70);
        for (int index1 = 10; index1 < Main.maxTilesX - 10; ++index1)
        {
          num3 += WorldGen.genRand.Next(-10, 11);
          if (num3 > Main.maxTilesY - 60)
            num3 = Main.maxTilesY - 60;
          if (num3 < Main.maxTilesY - 100)
            num3 = Main.maxTilesY - 120;
          for (int index2 = num3; index2 < Main.maxTilesY - 10; ++index2)
          {
            if (!Main.tile[index1, index2].active())
            {
              Main.tile[index1, index2].lava(true);
              Main.tile[index1, index2].liquid = byte.MaxValue;
            }
          }
        }
        for (int index1 = 0; index1 < Main.maxTilesX; ++index1)
        {
          if (WorldGen.genRand.Next(50) == 0)
          {
            int index2 = Main.maxTilesY - 65;
            while (!Main.tile[index1, index2].active() && index2 > Main.maxTilesY - 135)
              --index2;
            WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), index2 + WorldGen.genRand.Next(20, 50), (double) WorldGen.genRand.Next(15, 20), 1000, 57, true, 0.0f, (float) WorldGen.genRand.Next(1, 3), true, true, -1);
          }
        }
        Liquid.QuickWater(-2, -1, -1);
        for (int i = 0; i < Main.maxTilesX; ++i)
        {
          float num4 = (float) i / (float) (Main.maxTilesX - 1);
          progress.Set((float) ((double) num4 / 2.0 + 0.5));
          if (WorldGen.genRand.Next(13) == 0)
          {
            int index = Main.maxTilesY - 65;
            while ((Main.tile[i, index].liquid > (byte) 0 || Main.tile[i, index].active()) && index > Main.maxTilesY - 140)
              --index;
            if (!WorldGen.drunkWorldGen || WorldGen.genRand.Next(3) == 0 || ((double) i <= (double) Main.maxTilesX * 0.4 || (double) i >= (double) Main.maxTilesX * 0.6))
              WorldGen.TileRunner(i, index - WorldGen.genRand.Next(2, 5), (double) WorldGen.genRand.Next(5, 30), 1000, 57, true, 0.0f, (float) WorldGen.genRand.Next(1, 3), true, true, -1);
            float num5 = (float) WorldGen.genRand.Next(1, 3);
            if (WorldGen.genRand.Next(3) == 0)
              num5 *= 0.5f;
            if (!WorldGen.drunkWorldGen || WorldGen.genRand.Next(3) == 0 || ((double) i <= (double) Main.maxTilesX * 0.4 || (double) i >= (double) Main.maxTilesX * 0.6))
            {
              if (WorldGen.genRand.Next(2) == 0)
                WorldGen.TileRunner(i, index - WorldGen.genRand.Next(2, 5), (double) (int) ((double) WorldGen.genRand.Next(5, 15) * (double) num5), (int) ((double) WorldGen.genRand.Next(10, 15) * (double) num5), 57, true, 1f, 0.3f, false, true, -1);
              if (WorldGen.genRand.Next(2) == 0)
              {
                float num6 = (float) WorldGen.genRand.Next(1, 3);
                WorldGen.TileRunner(i, index - WorldGen.genRand.Next(2, 5), (double) (int) ((double) WorldGen.genRand.Next(5, 15) * (double) num6), (int) ((double) WorldGen.genRand.Next(10, 15) * (double) num6), 57, true, -1f, 0.3f, false, true, -1);
              }
            }
            WorldGen.TileRunner(i + WorldGen.genRand.Next(-10, 10), index + WorldGen.genRand.Next(-10, 10), (double) WorldGen.genRand.Next(5, 15), WorldGen.genRand.Next(5, 10), -2, false, (float) WorldGen.genRand.Next(-1, 3), (float) WorldGen.genRand.Next(-1, 3), false, true, -1);
            if (WorldGen.genRand.Next(3) == 0)
              WorldGen.TileRunner(i + WorldGen.genRand.Next(-10, 10), index + WorldGen.genRand.Next(-10, 10), (double) WorldGen.genRand.Next(10, 30), WorldGen.genRand.Next(10, 20), -2, false, (float) WorldGen.genRand.Next(-1, 3), (float) WorldGen.genRand.Next(-1, 3), false, true, -1);
            if (WorldGen.genRand.Next(5) == 0)
              WorldGen.TileRunner(i + WorldGen.genRand.Next(-15, 15), index + WorldGen.genRand.Next(-15, 10), (double) WorldGen.genRand.Next(15, 30), WorldGen.genRand.Next(5, 20), -2, false, (float) WorldGen.genRand.Next(-1, 3), (float) WorldGen.genRand.Next(-1, 3), false, true, -1);
          }
        }
        for (int index = 0; index < Main.maxTilesX; ++index)
          WorldGen.TileRunner(WorldGen.genRand.Next(20, Main.maxTilesX - 20), WorldGen.genRand.Next(Main.maxTilesY - 180, Main.maxTilesY - 10), (double) WorldGen.genRand.Next(2, 7), WorldGen.genRand.Next(2, 7), -2, false, 0.0f, 0.0f, false, true, -1);
        if (WorldGen.drunkWorldGen)
        {
          for (int index = 0; index < Main.maxTilesX * 2; ++index)
            WorldGen.TileRunner(WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.35), (int) ((double) Main.maxTilesX * 0.65)), WorldGen.genRand.Next(Main.maxTilesY - 180, Main.maxTilesY - 10), (double) WorldGen.genRand.Next(5, 20), WorldGen.genRand.Next(5, 10), -2, false, 0.0f, 0.0f, false, true, -1);
        }
        for (int index = 0; index < Main.maxTilesX; ++index)
        {
          if (!Main.tile[index, Main.maxTilesY - 145].active())
          {
            Main.tile[index, Main.maxTilesY - 145].liquid = byte.MaxValue;
            Main.tile[index, Main.maxTilesY - 145].lava(true);
          }
          if (!Main.tile[index, Main.maxTilesY - 144].active())
          {
            Main.tile[index, Main.maxTilesY - 144].liquid = byte.MaxValue;
            Main.tile[index, Main.maxTilesY - 144].lava(true);
          }
        }
        for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 0.0008); ++index)
          WorldGen.TileRunner(WorldGen.genRand.Next(0, Main.maxTilesX), WorldGen.genRand.Next(Main.maxTilesY - 140, Main.maxTilesY), (double) WorldGen.genRand.Next(2, 7), WorldGen.genRand.Next(3, 7), 58, false, 0.0f, 0.0f, false, true, -1);
        WorldGen.AddHellHouses();
      }));
      WorldGen.AddGenerationPass("Corruption", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        int num2 = Main.maxTilesX;
        int num3 = 0;
        int num4 = Main.maxTilesX;
        int num5 = 0;
        for (int index1 = 0; index1 < Main.maxTilesX; ++index1)
        {
          for (int index2 = 0; (double) index2 < Main.worldSurface; ++index2)
          {
            if (Main.tile[index1, index2].active())
            {
              if (Main.tile[index1, index2].type == (ushort) 60)
              {
                if (index1 < num2)
                  num2 = index1;
                if (index1 > num3)
                  num3 = index1;
              }
              else if (Main.tile[index1, index2].type == (ushort) 147 || Main.tile[index1, index2].type == (ushort) 161)
              {
                if (index1 < num4)
                  num4 = index1;
                if (index1 > num5)
                  num5 = index1;
              }
            }
          }
        }
        int num6 = 10;
        int num7 = num2 - num6;
        int num8 = num3 + num6;
        int num9 = num4 - num6;
        int num10 = num5 + num6;
        int minValue = 500;
        int num11 = 100;
        bool flag1 = WorldGen.crimson;
        bool flag2 = true;
        double num12 = (double) Main.maxTilesX * 0.00045;
        if (WorldGen.drunkWorldGen)
        {
          flag1 = true;
          num12 /= 2.0;
          if (WorldGen.genRand.Next(2) == 0)
            flag2 = false;
        }
        if (flag1)
        {
          progress.Message = Lang.gen[72].Value;
          for (int index1 = 0; (double) index1 < num12; ++index1)
          {
            int num13 = num9;
            int num14 = num10;
            int num15 = num7;
            int num16 = num8;
            float num17 = (float) index1 / (float) num12;
            progress.Set(num17);
            bool flag3 = false;
            int i = 0;
            int num18 = 0;
            int num19 = 0;
            while (!flag3)
            {
              flag3 = true;
              int num20 = Main.maxTilesX / 2;
              int num21 = 200;
              if (WorldGen.drunkWorldGen)
              {
                num21 = 100;
                i = !flag2 ? WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.5), Main.maxTilesX - minValue) : WorldGen.genRand.Next(minValue, (int) ((double) Main.maxTilesX * 0.5));
              }
              else
                i = WorldGen.genRand.Next(minValue, Main.maxTilesX - minValue);
              num18 = i - WorldGen.genRand.Next(200) - 100;
              num19 = i + WorldGen.genRand.Next(200) + 100;
              if (num18 < evilBiomeBeachAvoidance)
                num18 = evilBiomeBeachAvoidance;
              if (num19 > Main.maxTilesX - evilBiomeBeachAvoidance)
                num19 = Main.maxTilesX - evilBiomeBeachAvoidance;
              if (i < num18 + evilBiomeAvoidanceMidFixer)
                i = num18 + evilBiomeAvoidanceMidFixer;
              if (i > num19 - evilBiomeAvoidanceMidFixer)
                i = num19 - evilBiomeAvoidanceMidFixer;
              if (dungeonSide < 0 && num18 < 400)
                num18 = 400;
              else if (dungeonSide > 0 && num18 > Main.maxTilesX - 400)
                num18 = Main.maxTilesX - 400;
              if (i > num20 - num21 && i < num20 + num21)
                flag3 = false;
              if (num18 > num20 - num21 && num18 < num20 + num21)
                flag3 = false;
              if (num19 > num20 - num21 && num19 < num20 + num21)
                flag3 = false;
              if (i > WorldGen.UndergroundDesertLocation.X && i < WorldGen.UndergroundDesertLocation.X + WorldGen.UndergroundDesertLocation.Width)
                flag3 = false;
              if (num18 > WorldGen.UndergroundDesertLocation.X && num18 < WorldGen.UndergroundDesertLocation.X + WorldGen.UndergroundDesertLocation.Width)
                flag3 = false;
              if (num19 > WorldGen.UndergroundDesertLocation.X && num19 < WorldGen.UndergroundDesertLocation.X + WorldGen.UndergroundDesertLocation.Width)
                flag3 = false;
              if (num18 < dungeonLocation + num11 && num19 > dungeonLocation - num11)
                flag3 = false;
              if (num18 < num14 && num19 > num13)
              {
                ++num13;
                --num14;
                flag3 = false;
              }
              if (num18 < num16 && num19 > num15)
              {
                ++num15;
                --num16;
                flag3 = false;
              }
            }
            WorldGen.CrimStart(i, (int) WorldGen.worldSurfaceLow - 10);
            for (int index2 = num18; index2 < num19; ++index2)
            {
              for (int worldSurfaceLow = (int) WorldGen.worldSurfaceLow; (double) worldSurfaceLow < Main.worldSurface - 1.0; ++worldSurfaceLow)
              {
                if (Main.tile[index2, worldSurfaceLow].active())
                {
                  int num20 = worldSurfaceLow + WorldGen.genRand.Next(10, 14);
                  for (int index3 = worldSurfaceLow; index3 < num20; ++index3)
                  {
                    if ((Main.tile[index2, index3].type == (ushort) 59 || Main.tile[index2, index3].type == (ushort) 60) && (index2 >= num18 + WorldGen.genRand.Next(5) && index2 < num19 - WorldGen.genRand.Next(5)))
                      Main.tile[index2, index3].type = (ushort) 0;
                  }
                  break;
                }
              }
            }
            double num22 = Main.worldSurface + 40.0;
            for (int index2 = num18; index2 < num19; ++index2)
            {
              num22 += (double) WorldGen.genRand.Next(-2, 3);
              if (num22 < Main.worldSurface + 30.0)
                num22 = Main.worldSurface + 30.0;
              if (num22 > Main.worldSurface + 50.0)
                num22 = Main.worldSurface + 50.0;
              i2 = index2;
              bool flag4 = false;
              for (int worldSurfaceLow = (int) WorldGen.worldSurfaceLow; (double) worldSurfaceLow < num22; ++worldSurfaceLow)
              {
                if (Main.tile[i2, worldSurfaceLow].active())
                {
                  if (Main.tile[i2, worldSurfaceLow].type == (ushort) 53 && i2 >= num18 + WorldGen.genRand.Next(5) && i2 <= num19 - WorldGen.genRand.Next(5))
                    Main.tile[i2, worldSurfaceLow].type = (ushort) 234;
                  if (Main.tile[i2, worldSurfaceLow].type == (ushort) 0 && (double) worldSurfaceLow < Main.worldSurface - 1.0 && !flag4)
                  {
                    WorldGen.grassSpread = 0;
                    WorldGen.SpreadGrass(i2, worldSurfaceLow, 0, 199, true, (byte) 0);
                  }
                  flag4 = true;
                  if (Main.tile[i2, worldSurfaceLow].wall == (ushort) 216)
                    Main.tile[i2, worldSurfaceLow].wall = (ushort) 218;
                  else if (Main.tile[i2, worldSurfaceLow].wall == (ushort) 187)
                    Main.tile[i2, worldSurfaceLow].wall = (ushort) 221;
                  if (Main.tile[i2, worldSurfaceLow].type == (ushort) 1)
                  {
                    if (i2 >= num18 + WorldGen.genRand.Next(5) && i2 <= num19 - WorldGen.genRand.Next(5))
                      Main.tile[i2, worldSurfaceLow].type = (ushort) 203;
                  }
                  else if (Main.tile[i2, worldSurfaceLow].type == (ushort) 2)
                    Main.tile[i2, worldSurfaceLow].type = (ushort) 199;
                  else if (Main.tile[i2, worldSurfaceLow].type == (ushort) 161)
                    Main.tile[i2, worldSurfaceLow].type = (ushort) 200;
                  else if (Main.tile[i2, worldSurfaceLow].type == (ushort) 396)
                    Main.tile[i2, worldSurfaceLow].type = (ushort) 401;
                  else if (Main.tile[i2, worldSurfaceLow].type == (ushort) 397)
                    Main.tile[i2, worldSurfaceLow].type = (ushort) 399;
                }
              }
            }
            int num23 = WorldGen.genRand.Next(10, 15);
            for (int index2 = 0; index2 < num23; ++index2)
            {
              int num20 = 0;
              bool flag4 = false;
              int num21 = 0;
              while (!flag4)
              {
                ++num20;
                int x = WorldGen.genRand.Next(num18 - num21, num19 + num21);
                int y;
                for (y = WorldGen.genRand.Next((int) (Main.worldSurface - (double) (num21 / 2)), (int) (Main.worldSurface + 100.0 + (double) num21)); WorldGen.oceanDepths(x, y); y = WorldGen.genRand.Next((int) (Main.worldSurface - (double) (num21 / 2)), (int) (Main.worldSurface + 100.0 + (double) num21)))
                  x = WorldGen.genRand.Next(num18 - num21, num19 + num21);
                if (num20 > 100)
                {
                  ++num21;
                  num20 = 0;
                }
                if (!Main.tile[x, y].active())
                {
                  while (!Main.tile[x, y].active())
                    ++y;
                  --y;
                }
                else
                {
                  while (Main.tile[x, y].active() && (double) y > Main.worldSurface)
                    --y;
                }
                if ((num21 > 10 || Main.tile[x, y + 1].active() && Main.tile[x, y + 1].type == (ushort) 203) && !WorldGen.IsTileNearby(x, y, 26, 3))
                {
                  WorldGen.Place3x2(x, y, (ushort) 26, 1);
                  if (Main.tile[x, y].type == (ushort) 26)
                    flag4 = true;
                }
                if (num21 > 100)
                  flag4 = true;
              }
            }
          }
          WorldGen.CrimPlaceHearts();
        }
        if (WorldGen.drunkWorldGen)
          flag1 = false;
        if (flag1)
          return;
        progress.Message = Lang.gen[20].Value;
        for (int index1 = 0; (double) index1 < num12; ++index1)
        {
          int num13 = num9;
          int num14 = num10;
          int num15 = num7;
          int num16 = num8;
          float num17 = (float) index1 / (float) num12;
          progress.Set(num17);
          bool flag3 = false;
          int num18 = 0;
          int num19 = 0;
          int num20 = 0;
          while (!flag3)
          {
            flag3 = true;
            int num21 = Main.maxTilesX / 2;
            int num22 = 200;
            num18 = !WorldGen.drunkWorldGen ? WorldGen.genRand.Next(minValue, Main.maxTilesX - minValue) : (flag2 ? WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.5), Main.maxTilesX - minValue) : WorldGen.genRand.Next(minValue, (int) ((double) Main.maxTilesX * 0.5)));
            num19 = num18 - WorldGen.genRand.Next(200) - 100;
            num20 = num18 + WorldGen.genRand.Next(200) + 100;
            if (num19 < evilBiomeBeachAvoidance)
              num19 = evilBiomeBeachAvoidance;
            if (num20 > Main.maxTilesX - evilBiomeBeachAvoidance)
              num20 = Main.maxTilesX - evilBiomeBeachAvoidance;
            if (num18 < num19 + evilBiomeAvoidanceMidFixer)
              num18 = num19 + evilBiomeAvoidanceMidFixer;
            if (num18 > num20 - evilBiomeAvoidanceMidFixer)
              num18 = num20 - evilBiomeAvoidanceMidFixer;
            if (num18 > num21 - num22 && num18 < num21 + num22)
              flag3 = false;
            if (num19 > num21 - num22 && num19 < num21 + num22)
              flag3 = false;
            if (num20 > num21 - num22 && num20 < num21 + num22)
              flag3 = false;
            if (num18 > WorldGen.UndergroundDesertLocation.X && num18 < WorldGen.UndergroundDesertLocation.X + WorldGen.UndergroundDesertLocation.Width)
              flag3 = false;
            if (num19 > WorldGen.UndergroundDesertLocation.X && num19 < WorldGen.UndergroundDesertLocation.X + WorldGen.UndergroundDesertLocation.Width)
              flag3 = false;
            if (num20 > WorldGen.UndergroundDesertLocation.X && num20 < WorldGen.UndergroundDesertLocation.X + WorldGen.UndergroundDesertLocation.Width)
              flag3 = false;
            if (num19 < dungeonLocation + num11 && num20 > dungeonLocation - num11)
              flag3 = false;
            if (num19 < num14 && num20 > num13)
            {
              ++num13;
              --num14;
              flag3 = false;
            }
            if (num19 < num16 && num20 > num15)
            {
              ++num15;
              --num16;
              flag3 = false;
            }
          }
          int num23 = 0;
          for (int i = num19; i < num20; ++i)
          {
            if (num23 > 0)
              --num23;
            if (i == num18 || num23 == 0)
            {
              for (int worldSurfaceLow = (int) WorldGen.worldSurfaceLow; (double) worldSurfaceLow < Main.worldSurface - 1.0; ++worldSurfaceLow)
              {
                if (Main.tile[i, worldSurfaceLow].active() || Main.tile[i, worldSurfaceLow].wall > (ushort) 0)
                {
                  if (i == num18)
                  {
                    num23 = 20;
                    WorldGen.ChasmRunner(i, worldSurfaceLow, WorldGen.genRand.Next(150) + 150, true);
                    break;
                  }
                  if (WorldGen.genRand.Next(35) == 0 && num23 == 0)
                  {
                    num23 = 30;
                    bool makeOrb = true;
                    WorldGen.ChasmRunner(i, worldSurfaceLow, WorldGen.genRand.Next(50) + 50, makeOrb);
                    break;
                  }
                  break;
                }
              }
            }
            for (int worldSurfaceLow = (int) WorldGen.worldSurfaceLow; (double) worldSurfaceLow < Main.worldSurface - 1.0; ++worldSurfaceLow)
            {
              if (Main.tile[i, worldSurfaceLow].active())
              {
                int num21 = worldSurfaceLow + WorldGen.genRand.Next(10, 14);
                for (int index2 = worldSurfaceLow; index2 < num21; ++index2)
                {
                  if ((Main.tile[i, index2].type == (ushort) 59 || Main.tile[i, index2].type == (ushort) 60) && (i >= num19 + WorldGen.genRand.Next(5) && i < num20 - WorldGen.genRand.Next(5)))
                    Main.tile[i, index2].type = (ushort) 0;
                }
                break;
              }
            }
          }
          double num24 = Main.worldSurface + 40.0;
          for (int index2 = num19; index2 < num20; ++index2)
          {
            num24 += (double) WorldGen.genRand.Next(-2, 3);
            if (num24 < Main.worldSurface + 30.0)
              num24 = Main.worldSurface + 30.0;
            if (num24 > Main.worldSurface + 50.0)
              num24 = Main.worldSurface + 50.0;
            i2 = index2;
            bool flag4 = false;
            for (int worldSurfaceLow = (int) WorldGen.worldSurfaceLow; (double) worldSurfaceLow < num24; ++worldSurfaceLow)
            {
              if (Main.tile[i2, worldSurfaceLow].active())
              {
                if (Main.tile[i2, worldSurfaceLow].type == (ushort) 53 && i2 >= num19 + WorldGen.genRand.Next(5) && i2 <= num20 - WorldGen.genRand.Next(5))
                  Main.tile[i2, worldSurfaceLow].type = (ushort) 112;
                if (Main.tile[i2, worldSurfaceLow].type == (ushort) 0 && (double) worldSurfaceLow < Main.worldSurface - 1.0 && !flag4)
                {
                  WorldGen.grassSpread = 0;
                  WorldGen.SpreadGrass(i2, worldSurfaceLow, 0, 23, true, (byte) 0);
                }
                flag4 = true;
                if (Main.tile[i2, worldSurfaceLow].type == (ushort) 1 && i2 >= num19 + WorldGen.genRand.Next(5) && i2 <= num20 - WorldGen.genRand.Next(5))
                  Main.tile[i2, worldSurfaceLow].type = (ushort) 25;
                if (Main.tile[i2, worldSurfaceLow].wall == (ushort) 216)
                  Main.tile[i2, worldSurfaceLow].wall = (ushort) 217;
                else if (Main.tile[i2, worldSurfaceLow].wall == (ushort) 187)
                  Main.tile[i2, worldSurfaceLow].wall = (ushort) 220;
                if (Main.tile[i2, worldSurfaceLow].type == (ushort) 2)
                  Main.tile[i2, worldSurfaceLow].type = (ushort) 23;
                if (Main.tile[i2, worldSurfaceLow].type == (ushort) 161)
                  Main.tile[i2, worldSurfaceLow].type = (ushort) 163;
                else if (Main.tile[i2, worldSurfaceLow].type == (ushort) 396)
                  Main.tile[i2, worldSurfaceLow].type = (ushort) 400;
                else if (Main.tile[i2, worldSurfaceLow].type == (ushort) 397)
                  Main.tile[i2, worldSurfaceLow].type = (ushort) 398;
              }
            }
          }
          for (int index2 = num19; index2 < num20; ++index2)
          {
            for (int index3 = 0; index3 < Main.maxTilesY - 50; ++index3)
            {
              if (Main.tile[index2, index3].active() && Main.tile[index2, index3].type == (ushort) 31)
              {
                int num21 = index2 - 13;
                int num22 = index2 + 13;
                int num25 = index3 - 13;
                int num26 = index3 + 13;
                for (int index4 = num21; index4 < num22; ++index4)
                {
                  if (index4 > 10 && index4 < Main.maxTilesX - 10)
                  {
                    for (int index5 = num25; index5 < num26; ++index5)
                    {
                      if (Math.Abs(index4 - index2) + Math.Abs(index5 - index3) < 9 + WorldGen.genRand.Next(11) && WorldGen.genRand.Next(3) != 0 && Main.tile[index4, index5].type != (ushort) 31)
                      {
                        Main.tile[index4, index5].active(true);
                        Main.tile[index4, index5].type = (ushort) 25;
                        if (Math.Abs(index4 - index2) <= 1 && Math.Abs(index5 - index3) <= 1)
                          Main.tile[index4, index5].active(false);
                      }
                      if (Main.tile[index4, index5].type != (ushort) 31 && Math.Abs(index4 - index2) <= 2 + WorldGen.genRand.Next(3) && Math.Abs(index5 - index3) <= 2 + WorldGen.genRand.Next(3))
                        Main.tile[index4, index5].active(false);
                    }
                  }
                }
              }
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Lakes", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[19].Value;
        int num2 = Main.maxTilesX / 4200;
        int num3 = WorldGen.genRand.Next(num2 * 3, num2 * 6);
        for (int index1 = 0; index1 < num3; ++index1)
        {
          int num4 = Main.maxTilesX / 4;
          if (WorldGen.numLakes >= WorldGen.maxLakes - 1)
            break;
          float num5 = (float) index1 / (float) num3;
          progress.Set(num5);
          while (num4 > 0)
          {
            bool flag = false;
            --num4;
            int i1 = WorldGen.genRand.Next(lakesBeachAvoidance, Main.maxTilesX - lakesBeachAvoidance);
            while ((double) i1 > (double) Main.maxTilesX * 0.45 && (double) i1 < (double) Main.maxTilesX * 0.55)
              i1 = WorldGen.genRand.Next(lakesBeachAvoidance, Main.maxTilesX - lakesBeachAvoidance);
            for (int index2 = 0; index2 < WorldGen.numLakes; ++index2)
            {
              if (Math.Abs(i1 - WorldGen.LakeX[index2]) < 150)
              {
                flag = true;
                break;
              }
            }
            for (int index2 = 0; index2 < WorldGen.numMCaves; ++index2)
            {
              if (Math.Abs(i1 - WorldGen.mCaveX[index2]) < 100)
              {
                flag = true;
                break;
              }
            }
            for (int index2 = 0; index2 < WorldGen.numTunnels; ++index2)
            {
              if (Math.Abs(i1 - WorldGen.tunnelX[index2]) < 100)
              {
                flag = true;
                break;
              }
            }
            if (!flag)
            {
              int j1 = (int) WorldGen.worldSurfaceLow - 20;
              while (!Main.tile[i1, j1].active())
              {
                ++j1;
                if ((double) j1 >= Main.worldSurface || Main.tile[i1, j1].wall > (ushort) 0)
                {
                  flag = true;
                  break;
                }
              }
              if (Main.tile[i1, j1].type == (ushort) 53)
                flag = true;
              if (!flag)
              {
                int num6 = 50;
                for (int index2 = i1 - num6; index2 <= i1 + num6; ++index2)
                {
                  for (int index3 = j1 - num6; index3 <= j1 + num6; ++index3)
                  {
                    if (Main.tile[index2, index3].type == (ushort) 203 || Main.tile[index2, index3].type == (ushort) 25)
                    {
                      flag = true;
                      break;
                    }
                  }
                }
                if (!flag)
                {
                  int num7 = j1;
                  int num8 = 20;
                  while (!WorldGen.SolidTile(i1 - num8, j1, false) || !WorldGen.SolidTile(i1 + num8, j1, false))
                  {
                    ++j1;
                    if ((double) j1 > Main.worldSurface - 50.0)
                      flag = true;
                  }
                  if (j1 - num7 <= 10)
                  {
                    int num9 = 60;
                    for (int index2 = i1 - num9; index2 <= i1 + num9; ++index2)
                    {
                      int index3 = j1 - 20;
                      if (Main.tile[index2, index3].active() || Main.tile[index2, index3].wall > (ushort) 0)
                        flag = true;
                    }
                    if (!flag)
                    {
                      int num10 = 0;
                      for (int i3 = i1 - num9; i3 <= i1 + num9; ++i3)
                      {
                        for (int j2 = j1; j2 <= j1 + num9 * 2; ++j2)
                        {
                          if (WorldGen.SolidTile(i3, j2, false))
                            ++num10;
                        }
                      }
                      int num11 = (num9 * 2 + 1) * (num9 * 2 + 1);
                      if ((double) num10 >= (double) num11 * 0.8 && !WorldGen.UndergroundDesertLocation.Intersects(new Microsoft.Xna.Framework.Rectangle(i1 - 8, j1 - 8, 16, 16)))
                      {
                        WorldGen.SonOfLakinater(i1, j1, 1f);
                        WorldGen.LakeX[WorldGen.numLakes] = i1;
                        ++WorldGen.numLakes;
                        break;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Dungeon", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Set(1f);
        int num2 = dungeonLocation;
        int num3 = (int) ((Main.worldSurface + Main.rockLayer) / 2.0) + WorldGen.genRand.Next(-200, 200);
        int num4 = (int) ((Main.worldSurface + Main.rockLayer) / 2.0) + 200;
        int y = num3;
        bool flag = false;
        for (int index = 0; index < 10; ++index)
        {
          if (WorldGen.SolidTile(num2, y + index, false))
          {
            flag = true;
            break;
          }
        }
        if (!flag)
        {
          while (y < num4 && !WorldGen.SolidTile(num2, y + 10, false))
            ++y;
        }
        if (WorldGen.drunkWorldGen)
          y = (int) Main.worldSurface + 70;
        WorldGen.MakeDungeon(num2, y);
      }));
      WorldGen.AddGenerationPass("Slush", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        for (int index1 = snowTop; index1 < snowBottom; ++index1)
        {
          for (int index2 = snowMinX[index1]; index2 < snowMaxX[index1]; ++index2)
          {
            switch (Main.tile[index2, index1].type)
            {
              case 1:
                Main.tile[index2, index1].type = (ushort) 161;
                break;
              case 59:
                bool flag = true;
                int num2 = 3;
                for (int index3 = index2 - num2; index3 <= index2 + num2; ++index3)
                {
                  for (int index4 = index1 - num2; index4 <= index1 + num2; ++index4)
                  {
                    if (Main.tile[index3, index4].type == (ushort) 60 || Main.tile[index3, index4].type == (ushort) 70 || (Main.tile[index3, index4].type == (ushort) 71 || Main.tile[index3, index4].type == (ushort) 72))
                    {
                      flag = false;
                      break;
                    }
                  }
                }
                if (flag)
                {
                  Main.tile[index2, index1].type = (ushort) 224;
                  break;
                }
                break;
              case 123:
                Main.tile[index2, index1].type = (ushort) 224;
                break;
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Mountain Caves", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[21].Value;
        for (int index = 0; index < WorldGen.numMCaves; ++index)
        {
          int i = WorldGen.mCaveX[index];
          int j = WorldGen.mCaveY[index];
          WorldGen.CaveOpenater(i, j);
          WorldGen.Cavinator(i, j, WorldGen.genRand.Next(40, 50));
        }
      }));
      WorldGen.AddGenerationPass("Beaches", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[22].Value;
        bool floridaStyle1 = false;
        bool floridaStyle2 = false;
        if (WorldGen.genRand.Next(4) == 0)
        {
          if (WorldGen.genRand.Next(2) == 0)
            floridaStyle1 = true;
          else
            floridaStyle2 = true;
        }
        for (int index1 = 0; index1 < 2; ++index1)
        {
          if (index1 == 0)
          {
            int num2 = 0;
            int num3 = WorldGen.genRand.Next(oceanWaterStartRandomMin, oceanWaterStartRandomMax);
            if (dungeonSide == 1)
              num3 = oceanWaterForcedJungleLength;
            int num4 = leftBeachEnd - minSsandBeforeWater;
            if (num3 > num4)
              num3 = num4;
            int count = 0;
            float depth = 1f;
            int index2 = 0;
            while (!Main.tile[num3 - 1, index2].active())
              ++index2;
            shellStartYLeft = index2;
            int num5 = index2 + WorldGen.genRand.Next(1, 5);
            for (int index3 = num3 - 1; index3 >= num2; --index3)
            {
              if (index3 > 30)
              {
                ++count;
                depth = WorldGen.TuneOceanDepth(count, depth, floridaStyle1);
              }
              else
                ++depth;
              int num6 = WorldGen.genRand.Next(15, 20);
              for (int index4 = 0; (double) index4 < (double) num5 + (double) depth + (double) num6; ++index4)
              {
                if ((double) index4 < (double) num5 + (double) depth * 0.75 - 3.0)
                {
                  Main.tile[index3, index4].active(false);
                  if (index4 > num5)
                    Main.tile[index3, index4].liquid = byte.MaxValue;
                  else if (index4 == num5)
                  {
                    Main.tile[index3, index4].liquid = (byte) 127;
                    if (shellStartXLeft == 0)
                      shellStartXLeft = index3;
                  }
                }
                else if (index4 > num5)
                {
                  Main.tile[index3, index4].type = (ushort) 53;
                  Main.tile[index3, index4].active(true);
                }
                Main.tile[index3, index4].wall = (ushort) 0;
              }
            }
          }
          else
          {
            int index2 = Main.maxTilesX - WorldGen.genRand.Next(oceanWaterStartRandomMin, oceanWaterStartRandomMax);
            int maxTilesX = Main.maxTilesX;
            if (dungeonSide == -1)
              index2 = Main.maxTilesX - oceanWaterForcedJungleLength;
            int num2 = rightBeachStart + minSsandBeforeWater;
            if (index2 < num2)
              index2 = num2;
            float depth = 1f;
            int count = 0;
            int index3 = 0;
            while (!Main.tile[index2, index3].active())
              ++index3;
            shellStartXRight = 0;
            shellStartYRight = index3;
            int num3 = index3 + WorldGen.genRand.Next(1, 5);
            for (int index4 = index2; index4 < maxTilesX; ++index4)
            {
              if (index4 < maxTilesX - 30)
              {
                ++count;
                depth = WorldGen.TuneOceanDepth(count, depth, floridaStyle2);
              }
              else
                ++depth;
              int num4 = WorldGen.genRand.Next(15, 20);
              for (int index5 = 0; (double) index5 < (double) num3 + (double) depth + (double) num4; ++index5)
              {
                if ((double) index5 < (double) num3 + (double) depth * 0.75 - 3.0)
                {
                  Main.tile[index4, index5].active(false);
                  if (index5 > num3)
                    Main.tile[index4, index5].liquid = byte.MaxValue;
                  else if (index5 == num3)
                  {
                    Main.tile[index4, index5].liquid = (byte) 127;
                    if (shellStartXRight == 0)
                      shellStartXRight = index4;
                  }
                }
                else if (index5 > num3)
                {
                  Main.tile[index4, index5].type = (ushort) 53;
                  Main.tile[index4, index5].active(true);
                }
                Main.tile[index4, index5].wall = (ushort) 0;
              }
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Gems", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[23].Value;
        Main.tileSolid[484] = false;
        for (int type = 63; type <= 68; ++type)
        {
          float num2 = (float) (type - 63) / 6f;
          progress.Set(num2);
          float num3 = 0.0f;
          switch (type)
          {
            case 63:
              num3 = (float) Main.maxTilesX * 0.3f;
              break;
            case 64:
              num3 = (float) Main.maxTilesX * 0.1f;
              break;
            case 65:
              num3 = (float) Main.maxTilesX * 0.25f;
              break;
            case 66:
              num3 = (float) Main.maxTilesX * 0.45f;
              break;
            case 67:
              num3 = (float) Main.maxTilesX * 0.5f;
              break;
            case 68:
              num3 = (float) Main.maxTilesX * 0.05f;
              break;
          }
          float num4 = num3 * 0.2f;
          for (int index = 0; (double) index < (double) num4; ++index)
          {
            int i = WorldGen.genRand.Next(0, Main.maxTilesX);
            int j;
            for (j = WorldGen.genRand.Next((int) Main.worldSurface, Main.maxTilesY); Main.tile[i, j].type != (ushort) 1; j = WorldGen.genRand.Next((int) Main.worldSurface, Main.maxTilesY))
              i = WorldGen.genRand.Next(0, Main.maxTilesX);
            WorldGen.TileRunner(i, j, (double) WorldGen.genRand.Next(2, 6), WorldGen.genRand.Next(3, 7), type, false, 0.0f, 0.0f, false, true, -1);
          }
        }
        for (int index1 = 0; index1 < 2; ++index1)
        {
          int num2 = 1;
          int num3 = 5;
          int num4 = Main.maxTilesX - 5;
          if (index1 == 1)
          {
            num2 = -1;
            num3 = Main.maxTilesX - 5;
            num4 = 5;
          }
          for (int index2 = num3; index2 != num4; index2 += num2)
          {
            if (index2 <= WorldGen.UndergroundDesertLocation.Left || index2 >= WorldGen.UndergroundDesertLocation.Right)
            {
              for (int index3 = 10; index3 < Main.maxTilesY - 10; ++index3)
              {
                if (Main.tile[index2, index3].active() && Main.tile[index2, index3 + 1].active() && (Main.tileSand[(int) Main.tile[index2, index3].type] && Main.tileSand[(int) Main.tile[index2, index3 + 1].type]))
                {
                  ushort type = Main.tile[index2, index3].type;
                  int index4 = index2 + num2;
                  int index5 = index3 + 1;
                  if (!Main.tile[index4, index3].active() && !Main.tile[index4, index5].active())
                  {
                    while (!Main.tile[index4, index5].active())
                      ++index5;
                    int index6 = index5 - 1;
                    Main.tile[index2, index3].active(false);
                    Main.tile[index4, index6].active(true);
                    Main.tile[index4, index6].type = type;
                  }
                }
              }
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Gravitating Sand", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[24].Value;
        for (int x = 0; x < Main.maxTilesX; ++x)
        {
          float num2 = (float) x / (float) (Main.maxTilesX - 1);
          progress.Set(num2);
          bool flag = false;
          int num3 = 0;
          for (int y = Main.maxTilesY - 1; y > 0; --y)
          {
            if (WorldGen.SolidOrSlopedTile(x, y))
            {
              ushort type = Main.tile[x, y].type;
              if (flag && y < (int) Main.worldSurface && (y != num3 - 1 && TileID.Sets.Falling[(int) type]))
              {
                for (int index = y; index < num3; ++index)
                  Main.tile[x, index].ResetToType(type);
              }
              flag = true;
              num3 = y;
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Create Ocean Caves", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        for (int index = 0; index < 2; ++index)
        {
          if (WorldGen.genRand.Next(4) == 0 || WorldGen.drunkWorldGen)
          {
            progress.Message = Lang.gen[90].Value;
            int i = WorldGen.genRand.Next(55, 95);
            if (index == 1)
              i = WorldGen.genRand.Next(Main.maxTilesX - 95, Main.maxTilesX - 55);
            int j = 0;
            while (!Main.tile[i, j].active())
              ++j;
            WorldGen.oceanCave(i, j);
          }
        }
      }));
      WorldGen.AddGenerationPass("Clean Up Dirt", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[25].Value;
        for (int index1 = 3; index1 < Main.maxTilesX - 3; ++index1)
        {
          float num2 = (float) index1 / (float) Main.maxTilesX;
          progress.Set(0.5f * num2);
          bool flag = true;
          for (int index2 = 0; (double) index2 < Main.worldSurface; ++index2)
          {
            if (flag)
            {
              if (Main.tile[index1, index2].wall == (ushort) 2 || Main.tile[index1, index2].wall == (ushort) 40 || (Main.tile[index1, index2].wall == (ushort) 64 || Main.tile[index1, index2].wall == (ushort) 86))
                Main.tile[index1, index2].wall = (ushort) 0;
              if (Main.tile[index1, index2].type != (ushort) 53 && Main.tile[index1, index2].type != (ushort) 112 && Main.tile[index1, index2].type != (ushort) 234)
              {
                if (Main.tile[index1 - 1, index2].wall == (ushort) 2 || Main.tile[index1 - 1, index2].wall == (ushort) 40 || Main.tile[index1 - 1, index2].wall == (ushort) 40)
                  Main.tile[index1 - 1, index2].wall = (ushort) 0;
                if ((Main.tile[index1 - 2, index2].wall == (ushort) 2 || Main.tile[index1 - 2, index2].wall == (ushort) 40 || Main.tile[index1 - 2, index2].wall == (ushort) 40) && WorldGen.genRand.Next(2) == 0)
                  Main.tile[index1 - 2, index2].wall = (ushort) 0;
                if ((Main.tile[index1 - 3, index2].wall == (ushort) 2 || Main.tile[index1 - 3, index2].wall == (ushort) 40 || Main.tile[index1 - 3, index2].wall == (ushort) 40) && WorldGen.genRand.Next(2) == 0)
                  Main.tile[index1 - 3, index2].wall = (ushort) 0;
                if (Main.tile[index1 + 1, index2].wall == (ushort) 2 || Main.tile[index1 + 1, index2].wall == (ushort) 40 || Main.tile[index1 + 1, index2].wall == (ushort) 40)
                  Main.tile[index1 + 1, index2].wall = (ushort) 0;
                if ((Main.tile[index1 + 2, index2].wall == (ushort) 2 || Main.tile[index1 + 2, index2].wall == (ushort) 40 || Main.tile[index1 + 2, index2].wall == (ushort) 40) && WorldGen.genRand.Next(2) == 0)
                  Main.tile[index1 + 2, index2].wall = (ushort) 0;
                if ((Main.tile[index1 + 3, index2].wall == (ushort) 2 || Main.tile[index1 + 3, index2].wall == (ushort) 40 || Main.tile[index1 + 3, index2].wall == (ushort) 40) && WorldGen.genRand.Next(2) == 0)
                  Main.tile[index1 + 3, index2].wall = (ushort) 0;
                if (Main.tile[index1, index2].active())
                  flag = false;
              }
            }
            else if (Main.tile[index1, index2].wall == (ushort) 0 && Main.tile[index1, index2 + 1].wall == (ushort) 0 && (Main.tile[index1, index2 + 2].wall == (ushort) 0 && Main.tile[index1, index2 + 3].wall == (ushort) 0) && (Main.tile[index1, index2 + 4].wall == (ushort) 0 && Main.tile[index1 - 1, index2].wall == (ushort) 0 && (Main.tile[index1 + 1, index2].wall == (ushort) 0 && Main.tile[index1 - 2, index2].wall == (ushort) 0)) && (Main.tile[index1 + 2, index2].wall == (ushort) 0 && !Main.tile[index1, index2].active() && (!Main.tile[index1, index2 + 1].active() && !Main.tile[index1, index2 + 2].active()) && !Main.tile[index1, index2 + 3].active()))
              flag = true;
          }
        }
        for (int index1 = Main.maxTilesX - 5; index1 >= 5; --index1)
        {
          float num2 = (float) index1 / (float) Main.maxTilesX;
          progress.Set((float) (1.0 - 0.5 * (double) num2));
          bool flag = true;
          for (int index2 = 0; (double) index2 < Main.worldSurface; ++index2)
          {
            if (flag)
            {
              if (Main.tile[index1, index2].wall == (ushort) 2 || Main.tile[index1, index2].wall == (ushort) 40 || Main.tile[index1, index2].wall == (ushort) 64)
                Main.tile[index1, index2].wall = (ushort) 0;
              if (Main.tile[index1, index2].type != (ushort) 53)
              {
                if (Main.tile[index1 - 1, index2].wall == (ushort) 2 || Main.tile[index1 - 1, index2].wall == (ushort) 40 || Main.tile[index1 - 1, index2].wall == (ushort) 40)
                  Main.tile[index1 - 1, index2].wall = (ushort) 0;
                if ((Main.tile[index1 - 2, index2].wall == (ushort) 2 || Main.tile[index1 - 2, index2].wall == (ushort) 40 || Main.tile[index1 - 2, index2].wall == (ushort) 40) && WorldGen.genRand.Next(2) == 0)
                  Main.tile[index1 - 2, index2].wall = (ushort) 0;
                if ((Main.tile[index1 - 3, index2].wall == (ushort) 2 || Main.tile[index1 - 3, index2].wall == (ushort) 40 || Main.tile[index1 - 3, index2].wall == (ushort) 40) && WorldGen.genRand.Next(2) == 0)
                  Main.tile[index1 - 3, index2].wall = (ushort) 0;
                if (Main.tile[index1 + 1, index2].wall == (ushort) 2 || Main.tile[index1 + 1, index2].wall == (ushort) 40 || Main.tile[index1 + 1, index2].wall == (ushort) 40)
                  Main.tile[index1 + 1, index2].wall = (ushort) 0;
                if ((Main.tile[index1 + 2, index2].wall == (ushort) 2 || Main.tile[index1 + 2, index2].wall == (ushort) 40 || Main.tile[index1 + 2, index2].wall == (ushort) 40) && WorldGen.genRand.Next(2) == 0)
                  Main.tile[index1 + 2, index2].wall = (ushort) 0;
                if ((Main.tile[index1 + 3, index2].wall == (ushort) 2 || Main.tile[index1 + 3, index2].wall == (ushort) 40 || Main.tile[index1 + 3, index2].wall == (ushort) 40) && WorldGen.genRand.Next(2) == 0)
                  Main.tile[index1 + 3, index2].wall = (ushort) 0;
                if (Main.tile[index1, index2].active())
                  flag = false;
              }
            }
            else if (Main.tile[index1, index2].wall == (ushort) 0 && Main.tile[index1, index2 + 1].wall == (ushort) 0 && (Main.tile[index1, index2 + 2].wall == (ushort) 0 && Main.tile[index1, index2 + 3].wall == (ushort) 0) && (Main.tile[index1, index2 + 4].wall == (ushort) 0 && Main.tile[index1 - 1, index2].wall == (ushort) 0 && (Main.tile[index1 + 1, index2].wall == (ushort) 0 && Main.tile[index1 - 2, index2].wall == (ushort) 0)) && (Main.tile[index1 + 2, index2].wall == (ushort) 0 && !Main.tile[index1, index2].active() && (!Main.tile[index1, index2 + 1].active() && !Main.tile[index1, index2 + 2].active()) && !Main.tile[index1, index2 + 3].active()))
              flag = true;
          }
        }
      }));
      WorldGen.AddGenerationPass("Pyramids", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        for (int index1 = 0; index1 < numPyr; ++index1)
        {
          int i = PyrX[index1];
          int index2 = PyrY[index1];
          if (i > 300 && i < Main.maxTilesX - 300 && (dungeonSide >= 0 || (double) i >= (double) WorldGen.dungeonX + (double) Main.maxTilesX * 0.15) && (dungeonSide <= 0 || (double) i <= (double) WorldGen.dungeonX - (double) Main.maxTilesX * 0.15))
          {
            while (!Main.tile[i, index2].active() && (double) index2 < Main.worldSurface)
              ++index2;
            if ((double) index2 < Main.worldSurface && Main.tile[i, index2].type == (ushort) 53)
            {
              int num2 = Main.maxTilesX;
              for (int index3 = 0; index3 < index1; ++index3)
              {
                int num3 = Math.Abs(i - PyrX[index3]);
                if (num3 < num2)
                  num2 = num3;
              }
              int num4 = 220;
              if (WorldGen.drunkWorldGen)
                num4 /= 2;
              if (num2 >= num4)
              {
                int j = index2 - 1;
                WorldGen.Pyramid(i, j);
              }
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Dirt Rock Wall Runner", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        for (int index = 0; index < Main.maxTilesX; ++index)
        {
          int i = WorldGen.genRand.Next(10, Main.maxTilesX - 10);
          int j = WorldGen.genRand.Next(10, (int) Main.worldSurface);
          if (Main.tile[i, j].wall == (ushort) 2)
            WorldGen.DirtyRockRunner(i, j);
        }
      }));
      WorldGen.AddGenerationPass("Living Trees", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        int num2 = 200;
        float num3 = (float) (Main.maxTilesX / 4200);
        int num4 = WorldGen.genRand.Next(0, (int) (2.0 * (double) num3) + 1);
        if (num4 == 0 && WorldGen.genRand.Next(2) == 0)
          ++num4;
        if (WorldGen.drunkWorldGen)
          num4 += (int) (2.0 * (double) num3);
        for (int index1 = 0; index1 < num4; ++index1)
        {
          bool flag1 = false;
          int num5 = 0;
          while (!flag1)
          {
            ++num5;
            if (num5 > Main.maxTilesX / 2)
              flag1 = true;
            int i1 = WorldGen.genRand.Next(WorldGen.beachDistance, Main.maxTilesX - WorldGen.beachDistance);
            if (i1 <= Main.maxTilesX / 2 - num2 || i1 >= Main.maxTilesX / 2 + num2)
            {
              int index2 = 0;
              while (!Main.tile[i1, index2].active() && (double) index2 < Main.worldSurface)
                ++index2;
              if (Main.tile[i1, index2].type == (ushort) 0)
              {
                int j1 = index2 - 1;
                if (j1 > 150)
                {
                  bool flag2 = true;
                  for (int index3 = i1 - 50; index3 < i1 + 50; ++index3)
                  {
                    for (int index4 = j1 - 50; index4 < j1 + 50; ++index4)
                    {
                      if (Main.tile[index3, index4].active())
                      {
                        switch (Main.tile[index3, index4].type)
                        {
                          case 41:
                          case 43:
                          case 44:
                          case 189:
                          case 196:
                          case 460:
                          case 481:
                          case 482:
                          case 483:
                            flag2 = false;
                            continue;
                          default:
                            continue;
                        }
                      }
                    }
                  }
                  for (int index3 = 0; index3 < WorldGen.numMCaves; ++index3)
                  {
                    if (i1 > WorldGen.mCaveX[index3] - 50 && i1 < WorldGen.mCaveX[index3] + 50)
                    {
                      flag2 = false;
                      break;
                    }
                  }
                  if (flag2)
                  {
                    flag1 = WorldGen.GrowLivingTree(i1, j1, false);
                    if (flag1)
                    {
                      for (int index3 = -1; index3 <= 1; ++index3)
                      {
                        if (index3 != 0)
                        {
                          int i3 = i1;
                          int num6 = WorldGen.genRand.Next(4);
                          if (WorldGen.drunkWorldGen)
                            num6 += WorldGen.genRand.Next(2, 5);
                          for (int index4 = 0; index4 < num6; ++index4)
                          {
                            i3 += WorldGen.genRand.Next(13, 31) * index3;
                            if (i3 <= Main.maxTilesX / 2 - num2 || i3 >= Main.maxTilesX / 2 + num2)
                            {
                              int j2 = j1;
                              if (Main.tile[i3, j2].active())
                              {
                                while (Main.tile[i3, j2].active())
                                  --j2;
                              }
                              else
                              {
                                while (!Main.tile[i3, j2].active())
                                  ++j2;
                                --j2;
                              }
                              bool flag3 = true;
                              for (int index5 = i1 - 50; index5 < i1 + 50; ++index5)
                              {
                                for (int index6 = j1 - 50; index6 < j1 + 50; ++index6)
                                {
                                  if (Main.tile[index5, index6].active())
                                  {
                                    switch (Main.tile[index5, index6].type)
                                    {
                                      case 41:
                                      case 43:
                                      case 44:
                                      case 189:
                                      case 196:
                                      case 460:
                                      case 481:
                                      case 482:
                                      case 483:
                                        flag3 = false;
                                        continue;
                                      default:
                                        continue;
                                    }
                                  }
                                }
                              }
                              if (flag3)
                                WorldGen.GrowLivingTree(i3, j2, true);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        Main.tileSolid[192] = false;
      }));
      WorldGen.AddGenerationPass("Wood Tree Walls", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        for (int index1 = 25; index1 < Main.maxTilesX - 25; ++index1)
        {
          for (int index2 = 25; (double) index2 < Main.worldSurface; ++index2)
          {
            if (Main.tile[index1, index2].type == (ushort) 191 || Main.tile[index1, index2 - 1].type == (ushort) 191 || (Main.tile[index1 - 1, index2].type == (ushort) 191 || Main.tile[index1 + 1, index2].type == (ushort) 191) || Main.tile[index1, index2 + 1].type == (ushort) 191)
            {
              bool flag = true;
              for (int index3 = index1 - 1; index3 <= index1 + 1; ++index3)
              {
                for (int index4 = index2 - 1; index4 <= index2 + 1; ++index4)
                {
                  if (index3 != index1 && index4 != index2 && (Main.tile[index3, index4].type != (ushort) 191 && Main.tile[index3, index4].wall != (ushort) 244))
                    flag = false;
                }
              }
              if (flag)
                Main.tile[index1, index2].wall = (ushort) 244;
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Altars", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        Main.tileSolid[484] = false;
        progress.Message = Lang.gen[26].Value;
        int num2 = (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 1.99999994947575E-05);
        for (int index1 = 0; index1 < num2; ++index1)
        {
          progress.Set((float) index1 / (float) num2);
          for (int index2 = 0; index2 < 10000; ++index2)
          {
            int x = WorldGen.genRand.Next(281, Main.maxTilesX - 3 - 280);
            while ((double) x > (double) Main.maxTilesX * 0.45 && (double) x < (double) Main.maxTilesX * 0.55)
              x = WorldGen.genRand.Next(281, Main.maxTilesX - 3 - 280);
            int y;
            for (y = (int) (Main.worldSurface * 2.0 + Main.rockLayer) / 3; WorldGen.oceanDepths(x, y); y = (int) (Main.worldSurface * 2.0 + Main.rockLayer) / 3)
            {
              x = WorldGen.genRand.Next(281, Main.maxTilesX - 3 - 280);
              while ((double) x > (double) Main.maxTilesX * 0.45 && (double) x < (double) Main.maxTilesX * 0.55)
                x = WorldGen.genRand.Next(281, Main.maxTilesX - 3 - 280);
            }
            int style = WorldGen.crimson ? 1 : 0;
            if (!WorldGen.IsTileNearby(x, y, 26, 3))
              WorldGen.Place3x2(x, y, (ushort) 26, style);
            if (Main.tile[x, y].type == (ushort) 26)
              break;
          }
        }
      }));
      WorldGen.AddGenerationPass("Wet Jungle", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Set(1f);
        for (int index = 0; index < Main.maxTilesX; ++index)
        {
          i2 = index;
          for (int worldSurfaceLow = (int) WorldGen.worldSurfaceLow; (double) worldSurfaceLow < Main.worldSurface - 1.0; ++worldSurfaceLow)
          {
            if (Main.tile[i2, worldSurfaceLow].active())
            {
              if (Main.tile[i2, worldSurfaceLow].type == (ushort) 60)
              {
                Main.tile[i2, worldSurfaceLow - 1].liquid = byte.MaxValue;
                Main.tile[i2, worldSurfaceLow - 2].liquid = byte.MaxValue;
                break;
              }
              break;
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Jungle Temple", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        int num2 = 0;
        progress.Message = Lang.gen[70].Value;
        long num3 = 0;
        double num4 = 0.25;
        while (true)
        {
          do
          {
            int y = WorldGen.genRand.Next((int) Main.rockLayer, Main.maxTilesY - 500);
            int x = (int) (((WorldGen.genRand.NextDouble() * num4 + 0.1) * (double) -dungeonSide + 0.5) * (double) Main.maxTilesX);
            if (Main.tile[x, y].active() && Main.tile[x, y].type == (ushort) 60)
            {
              WorldGen.makeTemple(x, y);
              return;
            }
          }
          while (num3++ <= 2000000L);
          if (num4 == 0.35)
          {
            ++num2;
            if (num2 > 10)
              break;
          }
          num4 = Math.Min(0.35, num4 + 0.05);
          num3 = 0L;
        }
      }));
      WorldGen.AddGenerationPass("Hives", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[71].Value;
        float num2 = (float) (Main.maxTilesX / 4200);
        float num3 = (float) (1 + WorldGen.genRand.Next((int) (5.0 * (double) num2), (int) (8.0 * (double) num2)));
        if (WorldGen.drunkWorldGen)
          num3 *= 0.667f;
        int num4 = 10000;
        HiveBiome biome = configuration.CreateBiome<HiveBiome>();
label_10:
        while ((double) num3 > 0.0 && num4 > 0)
        {
          --num4;
          Point origin = WorldGen.RandomWorldPoint((int) (Main.worldSurface + Main.rockLayer) >> 1, 20, 300, 20);
          if (WorldGen.drunkWorldGen)
            WorldGen.RandomWorldPoint((int) Main.worldSurface, 20, 300, 20);
          if (biome.Place(origin, structures))
          {
            --num3;
            int num5 = WorldGen.genRand.Next(5);
            int num6 = 0;
            int num7 = 10000;
            while (true)
            {
              int x;
              int y;
              do
              {
                if (num6 < num5 && num7 > 0)
                {
                  float num8 = (float) ((double) WorldGen.genRand.NextFloat() * 60.0 + 30.0);
                  double a;
                  x = (int) (Math.Cos(a = (double) WorldGen.genRand.NextFloat() * 6.28318548202515) * (double) num8) + origin.X;
                  y = (int) (Math.Sin(a) * (double) num8) + origin.Y;
                  --num7;
                }
                else
                  goto label_10;
              }
              while (x <= 50 || x >= Main.maxTilesX - 50 || !biome.Place(new Point(x, y), structures));
              ++num6;
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Jungle Chests", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        WorldGen.genRand.Next(40, Main.maxTilesX - 40);
        WorldGen.genRand.Next((int) (Main.worldSurface + Main.rockLayer) / 2, Main.maxTilesY - 400);
        float num2 = (float) WorldGen.genRand.Next(7, 12) * (float) (Main.maxTilesX / 4200);
        int num3 = 0;
        for (int index1 = 0; (double) index1 < (double) num2; ++index1)
        {
          bool flag1 = true;
          while (flag1)
          {
            ++num3;
            int index2 = WorldGen.genRand.Next(40, Main.maxTilesX / 2 - 40);
            if (dungeonSide < 0)
              index2 += Main.maxTilesX / 2;
            int index3 = WorldGen.genRand.Next((int) (Main.worldSurface + Main.rockLayer) / 2, Main.maxTilesY - 400);
            if (Main.tile[index2, index3].type == (ushort) 60)
            {
              int num4 = 30;
              flag1 = false;
              for (int index4 = index2 - num4; index4 < index2 + num4; index4 += 3)
              {
                for (int index5 = index3 - num4; index5 < index3 + num4; index5 += 3)
                {
                  if (Main.tile[index4, index5].active() && (Main.tile[index4, index5].type == (ushort) 225 || Main.tile[index4, index5].type == (ushort) 229 || (Main.tile[index4, index5].type == (ushort) 226 || Main.tile[index4, index5].type == (ushort) 119) || Main.tile[index4, index5].type == (ushort) 120))
                    flag1 = true;
                  if (Main.tile[index4, index5].wall == (ushort) 86 || Main.tile[index4, index5].wall == (ushort) 87)
                    flag1 = true;
                }
              }
            }
            if (!flag1)
            {
              int num4 = WorldGen.genRand.Next(2, 4);
              int num5 = WorldGen.genRand.Next(2, 4);
              ushort num6 = 0;
              switch (jungleHut)
              {
                case 45:
                  num6 = (ushort) 10;
                  break;
                case 119:
                  num6 = (ushort) 23;
                  break;
                case 120:
                  num6 = (ushort) 24;
                  break;
                case 158:
                  num6 = (ushort) 42;
                  break;
                case 175:
                  num6 = (ushort) 45;
                  break;
              }
              for (int index4 = index2 - num4 - 1; index4 <= index2 + num4 + 1; ++index4)
              {
                for (int index5 = index3 - num5 - 1; index5 <= index3 + num5 + 1; ++index5)
                {
                  Main.tile[index4, index5].active(true);
                  Main.tile[index4, index5].type = jungleHut;
                  Main.tile[index4, index5].liquid = (byte) 0;
                  Main.tile[index4, index5].lava(false);
                }
              }
              for (int index4 = index2 - num4; index4 <= index2 + num4; ++index4)
              {
                for (int index5 = index3 - num5; index5 <= index3 + num5; ++index5)
                {
                  Main.tile[index4, index5].active(false);
                  Main.tile[index4, index5].wall = num6;
                }
              }
              bool flag2 = false;
              int num7 = 0;
              while (!flag2 && num7 < 100)
              {
                ++num7;
                int i = WorldGen.genRand.Next(index2 - num4, index2 + num4 + 1);
                int j = WorldGen.genRand.Next(index3 - num5, index3 + num5 - 2);
                WorldGen.PlaceTile(i, j, 4, true, false, -1, 3);
                if (Main.tile[i, j].type == (ushort) 4)
                  flag2 = true;
              }
              for (int index4 = index2 - num4 - 1; index4 <= index2 + num4 + 1; ++index4)
              {
                for (int index5 = index3 + num5 - 2; index5 <= index3 + num5; ++index5)
                  Main.tile[index4, index5].active(false);
              }
              for (int index4 = index2 - num4 - 1; index4 <= index2 + num4 + 1; ++index4)
              {
                for (int index5 = index3 + num5 - 2; index5 <= index3 + num5 - 1; ++index5)
                  Main.tile[index4, index5].active(false);
              }
              for (int index4 = index2 - num4 - 1; index4 <= index2 + num4 + 1; ++index4)
              {
                int num8 = 4;
                for (int index5 = index3 + num5 + 2; !Main.tile[index4, index5].active() && index5 < Main.maxTilesY && num8 > 0; --num8)
                {
                  Main.tile[index4, index5].active(true);
                  Main.tile[index4, index5].type = (ushort) 59;
                  ++index5;
                }
              }
              int num9 = num4 - WorldGen.genRand.Next(1, 3);
              int index6 = index3 - num5 - 2;
              while (num9 > -1)
              {
                for (int index4 = index2 - num9 - 1; index4 <= index2 + num9 + 1; ++index4)
                {
                  Main.tile[index4, index6].active(true);
                  Main.tile[index4, index6].type = jungleHut;
                }
                num9 -= WorldGen.genRand.Next(1, 3);
                --index6;
              }
              WorldGen.JChestX[WorldGen.numJChests] = index2;
              WorldGen.JChestY[WorldGen.numJChests] = index3;
              structures.AddProtectedStructure(new Microsoft.Xna.Framework.Rectangle(index2 - num9 - 1, index3 - num5 - 1, index2 + num9 + 1, index3 + num5 + 1), 0);
              ++WorldGen.numJChests;
              num3 = 0;
            }
            else if (num3 > Main.maxTilesX * 10)
            {
              ++index1;
              num3 = 0;
              break;
            }
          }
        }
        Main.tileSolid[137] = false;
      }));
      WorldGen.AddGenerationPass("Settle Liquids", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[27].Value;
        if (WorldGen.notTheBees)
          WorldGen.NotTheBees();
        Liquid.worldGenTilesIgnoreWater(true);
        Liquid.QuickWater(3, -1, -1);
        WorldGen.WaterCheck();
        int num2 = 0;
        Liquid.quickSettle = true;
        while (num2 < 10)
        {
          int num3 = Liquid.numLiquid + LiquidBuffer.numLiquidBuffer;
          ++num2;
          float num4 = 0.0f;
          while (Liquid.numLiquid > 0)
          {
            float num5 = (float) (num3 - (Liquid.numLiquid + LiquidBuffer.numLiquidBuffer)) / (float) num3;
            if (Liquid.numLiquid + LiquidBuffer.numLiquidBuffer > num3)
              num3 = Liquid.numLiquid + LiquidBuffer.numLiquidBuffer;
            if ((double) num5 > (double) num4)
              num4 = num5;
            else
              num5 = num4;
            if (num2 == 1)
              progress.Set((float) ((double) num5 / 3.0 + 0.330000013113022));
            int num6 = 10;
            if (num2 > num6)
              ;
            Liquid.UpdateLiquid();
          }
          WorldGen.WaterCheck();
          progress.Set((float) ((double) num2 * 0.100000001490116 / 3.0 + 0.660000026226044));
        }
        Liquid.quickSettle = false;
        Liquid.worldGenTilesIgnoreWater(false);
        Main.tileSolid[484] = false;
      }));
      WorldGen.AddGenerationPass("Remove Water From Sand", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Set(1f);
label_11:
        for (int index1 = 400; index1 < Main.maxTilesX - 400; ++index1)
        {
          i2 = index1;
          for (int index2 = 100; (double) index2 < Main.worldSurface - 1.0; ++index2)
          {
            if (Main.tile[i2, index2].active())
            {
              switch (Main.tile[i2, index2].type)
              {
                case 53:
                case 151:
                case 396:
                case 397:
                case 404:
                case 407:
                  int index3 = index2;
                  while (index3 > 100)
                  {
                    --index3;
                    if (!Main.tile[i2, index3].active())
                      Main.tile[i2, index3].liquid = (byte) 0;
                    else
                      break;
                  }
                  goto label_11;
                default:
                  goto label_11;
              }
            }
          }
        }
        Main.tileSolid[192] = true;
      }));
      WorldGen.AddGenerationPass("Oasis", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        if (WorldGen.notTheBees)
          return;
        progress.Set(1f);
        int num2 = Main.maxTilesX / 2100 + WorldGen.genRand.Next(2);
        for (int index = 0; index < num2; ++index)
        {
          int minValue = WorldGen.beachDistance + 300;
          int num3 = Main.maxTilesX * 2;
          while (num3 > 0)
          {
            --num3;
            if (WorldGen.PlaceOasis(WorldGen.genRand.Next(minValue, Main.maxTilesX - minValue), WorldGen.genRand.Next(100, (int) Main.worldSurface)))
              num3 = -1;
          }
        }
      }));
      WorldGen.AddGenerationPass("Shell Piles", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        if (WorldGen.notTheBees)
          return;
        progress.Set(1f);
        if (WorldGen.genRand.Next(2) == 0)
        {
          int num2 = shellStartXLeft;
          int num3 = shellStartYLeft;
          for (int index1 = num2 - 20; index1 <= num2 + 20; ++index1)
          {
            for (int index2 = num3 - 10; index2 <= num3 + 10; ++index2)
            {
              if (Main.tile[index1, index2].active() && Main.tile[index1, index2].type == (ushort) 53 && (!Main.tile[index1, index2 - 1].active() && Main.tile[index1, index2 - 1].liquid == (byte) 0) && (!Main.tile[index1 - 1, index2].active() && Main.tile[index1 - 1, index2].liquid > (byte) 0))
              {
                shellStartXLeft = index1;
                shellStartYLeft = index2;
              }
            }
          }
          shellStartYLeft -= 50;
          shellStartXLeft -= WorldGen.genRand.Next(5);
          if (WorldGen.genRand.Next(2) == 0)
            shellStartXLeft -= WorldGen.genRand.Next(10);
          if (WorldGen.genRand.Next(3) == 0)
            shellStartXLeft -= WorldGen.genRand.Next(15);
          if (WorldGen.genRand.Next(4) != 0)
            WorldGen.ShellPile(shellStartXLeft, shellStartYLeft);
          int maxValue = WorldGen.genRand.Next(2, 4);
          if (WorldGen.genRand.Next(maxValue) == 0)
            WorldGen.ShellPile(shellStartXLeft - WorldGen.genRand.Next(10, 35), shellStartYLeft);
          if (WorldGen.genRand.Next(maxValue) == 0)
            WorldGen.ShellPile(shellStartXLeft - WorldGen.genRand.Next(40, 65), shellStartYLeft);
          if (WorldGen.genRand.Next(maxValue) == 0)
            WorldGen.ShellPile(shellStartXLeft - WorldGen.genRand.Next(70, 95), shellStartYLeft);
          if (WorldGen.genRand.Next(maxValue) == 0)
            WorldGen.ShellPile(shellStartXLeft - WorldGen.genRand.Next(100, 125), shellStartYLeft);
          if (WorldGen.genRand.Next(maxValue) == 0)
            WorldGen.ShellPile(shellStartXLeft + WorldGen.genRand.Next(10, 25), shellStartYLeft);
        }
        if (WorldGen.genRand.Next(2) != 0)
          return;
        int num4 = shellStartXRight;
        int num5 = shellStartYRight;
        for (int index1 = num4 - 20; index1 <= num4 + 20; ++index1)
        {
          for (int index2 = num5 - 10; index2 <= num5 + 10; ++index2)
          {
            if (Main.tile[index1, index2].active() && Main.tile[index1, index2].type == (ushort) 53 && (!Main.tile[index1, index2 - 1].active() && Main.tile[index1, index2 - 1].liquid == (byte) 0) && (!Main.tile[index1 + 1, index2].active() && Main.tile[index1 + 1, index2].liquid > (byte) 0))
            {
              shellStartXRight = index1;
              shellStartYRight = index2;
            }
          }
        }
        shellStartYRight -= 50;
        shellStartXRight += WorldGen.genRand.Next(5);
        if (WorldGen.genRand.Next(2) == 0)
          shellStartXLeft += WorldGen.genRand.Next(10);
        if (WorldGen.genRand.Next(3) == 0)
          shellStartXLeft += WorldGen.genRand.Next(15);
        if (WorldGen.genRand.Next(4) != 0)
          WorldGen.ShellPile(shellStartXRight, shellStartYRight);
        int maxValue1 = WorldGen.genRand.Next(2, 4);
        if (WorldGen.genRand.Next(maxValue1) == 0)
          WorldGen.ShellPile(shellStartXRight + WorldGen.genRand.Next(10, 35), shellStartYRight);
        if (WorldGen.genRand.Next(maxValue1) == 0)
          WorldGen.ShellPile(shellStartXRight + WorldGen.genRand.Next(40, 65), shellStartYRight);
        if (WorldGen.genRand.Next(maxValue1) == 0)
          WorldGen.ShellPile(shellStartXRight + WorldGen.genRand.Next(70, 95), shellStartYRight);
        if (WorldGen.genRand.Next(maxValue1) == 0)
          WorldGen.ShellPile(shellStartXRight + WorldGen.genRand.Next(100, 125), shellStartYRight);
        if (WorldGen.genRand.Next(maxValue1) != 0)
          return;
        WorldGen.ShellPile(shellStartXRight - WorldGen.genRand.Next(10, 25), shellStartYRight);
      }));
      WorldGen.AddGenerationPass("Smooth World", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[60].Value;
        Main.tileSolid[(int) WorldGen.crackedType] = true;
        for (int index1 = 20; index1 < Main.maxTilesX - 20; ++index1)
        {
          float num2 = (float) index1 / (float) Main.maxTilesX;
          progress.Set(num2);
          for (int index2 = 20; index2 < Main.maxTilesY - 20; ++index2)
          {
            if (Main.tile[index1, index2].type != (ushort) 48 && Main.tile[index1, index2].type != (ushort) 137 && (Main.tile[index1, index2].type != (ushort) 232 && Main.tile[index1, index2].type != (ushort) 191) && (Main.tile[index1, index2].type != (ushort) 151 && Main.tile[index1, index2].type != (ushort) 274))
            {
              if (!Main.tile[index1, index2 - 1].active() && Main.tile[index1 - 1, index2].type != (ushort) 136 && Main.tile[index1 + 1, index2].type != (ushort) 136)
              {
                if (WorldGen.SolidTile(index1, index2, false) && TileID.Sets.CanBeClearedDuringGeneration[(int) Main.tile[index1, index2].type])
                {
                  if (!Main.tile[index1 - 1, index2].halfBrick() && !Main.tile[index1 + 1, index2].halfBrick() && (Main.tile[index1 - 1, index2].slope() == (byte) 0 && Main.tile[index1 + 1, index2].slope() == (byte) 0))
                  {
                    if (WorldGen.SolidTile(index1, index2 + 1, false))
                    {
                      if (!WorldGen.SolidTile(index1 - 1, index2, false) && !Main.tile[index1 - 1, index2 + 1].halfBrick() && (WorldGen.SolidTile(index1 - 1, index2 + 1, false) && WorldGen.SolidTile(index1 + 1, index2, false)) && !Main.tile[index1 + 1, index2 - 1].active())
                      {
                        if (WorldGen.genRand.Next(2) == 0)
                          WorldGen.SlopeTile(index1, index2, 2, false);
                        else
                          WorldGen.PoundTile(index1, index2);
                      }
                      else if (!WorldGen.SolidTile(index1 + 1, index2, false) && !Main.tile[index1 + 1, index2 + 1].halfBrick() && (WorldGen.SolidTile(index1 + 1, index2 + 1, false) && WorldGen.SolidTile(index1 - 1, index2, false)) && !Main.tile[index1 - 1, index2 - 1].active())
                      {
                        if (WorldGen.genRand.Next(2) == 0)
                          WorldGen.SlopeTile(index1, index2, 1, false);
                        else
                          WorldGen.PoundTile(index1, index2);
                      }
                      else if (WorldGen.SolidTile(index1 + 1, index2 + 1, false) && WorldGen.SolidTile(index1 - 1, index2 + 1, false) && (!Main.tile[index1 + 1, index2].active() && !Main.tile[index1 - 1, index2].active()))
                        WorldGen.PoundTile(index1, index2);
                      if (WorldGen.SolidTile(index1, index2, false))
                      {
                        if (WorldGen.SolidTile(index1 - 1, index2, false) && WorldGen.SolidTile(index1 + 1, index2 + 2, false) && (!Main.tile[index1 + 1, index2].active() && !Main.tile[index1 + 1, index2 + 1].active()) && !Main.tile[index1 - 1, index2 - 1].active())
                          WorldGen.KillTile(index1, index2, false, false, false);
                        else if (WorldGen.SolidTile(index1 + 1, index2, false) && WorldGen.SolidTile(index1 - 1, index2 + 2, false) && (!Main.tile[index1 - 1, index2].active() && !Main.tile[index1 - 1, index2 + 1].active()) && !Main.tile[index1 + 1, index2 - 1].active())
                          WorldGen.KillTile(index1, index2, false, false, false);
                        else if (!Main.tile[index1 - 1, index2 + 1].active() && !Main.tile[index1 - 1, index2].active() && (WorldGen.SolidTile(index1 + 1, index2, false) && WorldGen.SolidTile(index1, index2 + 2, false)))
                        {
                          if (WorldGen.genRand.Next(5) == 0)
                            WorldGen.KillTile(index1, index2, false, false, false);
                          else if (WorldGen.genRand.Next(5) == 0)
                            WorldGen.PoundTile(index1, index2);
                          else
                            WorldGen.SlopeTile(index1, index2, 2, false);
                        }
                        else if (!Main.tile[index1 + 1, index2 + 1].active() && !Main.tile[index1 + 1, index2].active() && (WorldGen.SolidTile(index1 - 1, index2, false) && WorldGen.SolidTile(index1, index2 + 2, false)))
                        {
                          if (WorldGen.genRand.Next(5) == 0)
                            WorldGen.KillTile(index1, index2, false, false, false);
                          else if (WorldGen.genRand.Next(5) == 0)
                            WorldGen.PoundTile(index1, index2);
                          else
                            WorldGen.SlopeTile(index1, index2, 1, false);
                        }
                      }
                    }
                    if (WorldGen.SolidTile(index1, index2, false) && !Main.tile[index1 - 1, index2].active() && !Main.tile[index1 + 1, index2].active())
                      WorldGen.KillTile(index1, index2, false, false, false);
                  }
                }
                else if (!Main.tile[index1, index2].active() && Main.tile[index1, index2 + 1].type != (ushort) 151 && Main.tile[index1, index2 + 1].type != (ushort) 274)
                {
                  if (Main.tile[index1 + 1, index2].type != (ushort) 190 && Main.tile[index1 + 1, index2].type != (ushort) 48 && (Main.tile[index1 + 1, index2].type != (ushort) 232 && WorldGen.SolidTile(index1 - 1, index2 + 1, false)) && (WorldGen.SolidTile(index1 + 1, index2, false) && !Main.tile[index1 - 1, index2].active() && !Main.tile[index1 + 1, index2 - 1].active()))
                  {
                    if (Main.tile[index1 + 1, index2].type == (ushort) 495)
                      WorldGen.PlaceTile(index1, index2, (int) Main.tile[index1 + 1, index2].type, false, false, -1, 0);
                    else
                      WorldGen.PlaceTile(index1, index2, (int) Main.tile[index1, index2 + 1].type, false, false, -1, 0);
                    if (WorldGen.genRand.Next(2) == 0)
                      WorldGen.SlopeTile(index1, index2, 2, false);
                    else
                      WorldGen.PoundTile(index1, index2);
                  }
                  if (Main.tile[index1 - 1, index2].type != (ushort) 190 && Main.tile[index1 - 1, index2].type != (ushort) 48 && (Main.tile[index1 - 1, index2].type != (ushort) 232 && WorldGen.SolidTile(index1 + 1, index2 + 1, false)) && (WorldGen.SolidTile(index1 - 1, index2, false) && !Main.tile[index1 + 1, index2].active() && !Main.tile[index1 - 1, index2 - 1].active()))
                  {
                    if (Main.tile[index1 - 1, index2].type == (ushort) 495)
                      WorldGen.PlaceTile(index1, index2, (int) Main.tile[index1 - 1, index2].type, false, false, -1, 0);
                    else
                      WorldGen.PlaceTile(index1, index2, (int) Main.tile[index1, index2 + 1].type, false, false, -1, 0);
                    if (WorldGen.genRand.Next(2) == 0)
                      WorldGen.SlopeTile(index1, index2, 1, false);
                    else
                      WorldGen.PoundTile(index1, index2);
                  }
                }
              }
              else if (!Main.tile[index1, index2 + 1].active() && WorldGen.genRand.Next(2) == 0 && (WorldGen.SolidTile(index1, index2, false) && !Main.tile[index1 - 1, index2].halfBrick()) && (!Main.tile[index1 + 1, index2].halfBrick() && Main.tile[index1 - 1, index2].slope() == (byte) 0 && (Main.tile[index1 + 1, index2].slope() == (byte) 0 && WorldGen.SolidTile(index1, index2 - 1, false))))
              {
                if (WorldGen.SolidTile(index1 - 1, index2, false) && !WorldGen.SolidTile(index1 + 1, index2, false) && WorldGen.SolidTile(index1 - 1, index2 - 1, false))
                  WorldGen.SlopeTile(index1, index2, 3, false);
                else if (WorldGen.SolidTile(index1 + 1, index2, false) && !WorldGen.SolidTile(index1 - 1, index2, false) && WorldGen.SolidTile(index1 + 1, index2 - 1, false))
                  WorldGen.SlopeTile(index1, index2, 4, false);
              }
              if (TileID.Sets.Conversion.Sand[(int) Main.tile[index1, index2].type])
                Tile.SmoothSlope(index1, index2, false, false);
            }
          }
        }
        for (int i = 20; i < Main.maxTilesX - 20; ++i)
        {
          for (int j = 20; j < Main.maxTilesY - 20; ++j)
          {
            if (WorldGen.genRand.Next(2) == 0 && !Main.tile[i, j - 1].active() && (Main.tile[i, j].type != (ushort) 137 && Main.tile[i, j].type != (ushort) 48) && (Main.tile[i, j].type != (ushort) 232 && Main.tile[i, j].type != (ushort) 191 && (Main.tile[i, j].type != (ushort) 151 && Main.tile[i, j].type != (ushort) 274)) && (Main.tile[i, j].type != (ushort) 75 && Main.tile[i, j].type != (ushort) 76 && (WorldGen.SolidTile(i, j, false) && Main.tile[i - 1, j].type != (ushort) 137) && Main.tile[i + 1, j].type != (ushort) 137))
            {
              if (WorldGen.SolidTile(i, j + 1, false) && WorldGen.SolidTile(i + 1, j, false) && !Main.tile[i - 1, j].active())
                WorldGen.SlopeTile(i, j, 2, false);
              if (WorldGen.SolidTile(i, j + 1, false) && WorldGen.SolidTile(i - 1, j, false) && !Main.tile[i + 1, j].active())
                WorldGen.SlopeTile(i, j, 1, false);
            }
            if (Main.tile[i, j].slope() == (byte) 1 && !WorldGen.SolidTile(i - 1, j, false))
            {
              WorldGen.SlopeTile(i, j, 0, false);
              WorldGen.PoundTile(i, j);
            }
            if (Main.tile[i, j].slope() == (byte) 2 && !WorldGen.SolidTile(i + 1, j, false))
            {
              WorldGen.SlopeTile(i, j, 0, false);
              WorldGen.PoundTile(i, j);
            }
          }
        }
        Main.tileSolid[137] = true;
        Main.tileSolid[190] = false;
        Main.tileSolid[192] = false;
        Main.tileSolid[(int) WorldGen.crackedType] = false;
      }));
      WorldGen.AddGenerationPass("Waterfalls", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[69].Value;
        Main.tileSolid[191] = false;
        for (int i = 20; i < Main.maxTilesX - 20; ++i)
        {
          float num2 = (float) i / (float) Main.maxTilesX;
          progress.Set(num2 * 0.5f);
          for (int j = 20; j < Main.maxTilesY - 20; ++j)
          {
            if (WorldGen.SolidTile(i, j, false) && !Main.tile[i - 1, j].active() && (WorldGen.SolidTile(i, j + 1, false) && !Main.tile[i + 1, j].active()) && (Main.tile[i - 1, j].liquid > (byte) 0 || Main.tile[i + 1, j].liquid > (byte) 0))
            {
              bool flag = true;
              int num3 = WorldGen.genRand.Next(8, 20);
              int num4 = WorldGen.genRand.Next(8, 20);
              int num5 = j - num3;
              int num6 = num4 + j;
              for (int index = num5; index <= num6; ++index)
              {
                if (Main.tile[i, index].halfBrick())
                  flag = false;
              }
              if ((Main.tile[i, j].type == (ushort) 75 || Main.tile[i, j].type == (ushort) 76) && WorldGen.genRand.Next(10) != 0)
                flag = false;
              if (flag)
                WorldGen.PoundTile(i, j);
            }
          }
        }
        for (int i = 20; i < Main.maxTilesX - 20; ++i)
        {
          float num2 = (float) i / (float) Main.maxTilesX;
          progress.Set((float) ((double) num2 * 0.5 + 0.5));
          for (int j = 20; j < Main.maxTilesY - 20; ++j)
          {
            if (Main.tile[i, j].type != (ushort) 48 && Main.tile[i, j].type != (ushort) 232 && (WorldGen.SolidTile(i, j, false) && WorldGen.SolidTile(i, j + 1, false)))
            {
              if (!WorldGen.SolidTile(i + 1, j, false) && Main.tile[i - 1, j].halfBrick() && Main.tile[i - 2, j].liquid > (byte) 0)
                WorldGen.PoundTile(i, j);
              if (!WorldGen.SolidTile(i - 1, j, false) && Main.tile[i + 1, j].halfBrick() && Main.tile[i + 2, j].liquid > (byte) 0)
                WorldGen.PoundTile(i, j);
            }
          }
        }
        Main.tileSolid[191] = true;
      }));
      WorldGen.AddGenerationPass("Ice", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        if (WorldGen.notTheBees)
          WorldGen.NotTheBees();
        progress.Set(1f);
        for (int i = 10; i < Main.maxTilesX - 10; ++i)
        {
          for (int worldSurface1 = (int) Main.worldSurface; worldSurface1 < Main.maxTilesY - 100; ++worldSurface1)
          {
            if (Main.tile[i, worldSurface1].liquid > (byte) 0 && !Main.tile[i, worldSurface1].lava())
              WorldGen.MakeWateryIceThing(i, worldSurface1);
          }
        }
        Main.tileSolid[226] = false;
        Main.tileSolid[162] = false;
      }));
      WorldGen.AddGenerationPass("Wall Variety", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[79].Value;
        int num2 = (int) (300.0 * (double) ((float) (Main.maxTilesX * Main.maxTilesY) / 5040000f));
        int num3 = num2;
        ShapeData data = new ShapeData();
        while (num2 > 0)
        {
          progress.Set((float) (1.0 - (double) num2 / (double) num3));
          Point point = WorldGen.RandomWorldPoint((int) worldSurface, 2, 190, 2);
          Tile tile1 = Main.tile[point.X, point.Y];
          Tile tile2 = Main.tile[point.X, point.Y - 1];
          ushort type = 0;
          if (tile1.type == (ushort) 60)
            type = (ushort) (204 + WorldGen.genRand.Next(4));
          else if (tile1.type == (ushort) 1 && tile2.wall == (ushort) 0)
            type = (double) point.Y >= rockLayer ? (point.Y >= WorldGen.lavaLine ? (ushort) (208 + WorldGen.genRand.Next(4)) : (ushort) (212 + WorldGen.genRand.Next(4))) : (ushort) (196 + WorldGen.genRand.Next(4));
          if (tile1.active() && type != (ushort) 0 && !tile2.active())
          {
            bool foundInvalidTile = false;
            bool flag;
            if (tile1.type == (ushort) 60)
              flag = WorldUtils.Gen(new Point(point.X, point.Y - 1), (GenShape) new ShapeFloodFill(1000), Actions.Chain((GenAction) new Modifiers.IsNotSolid(), new Actions.Blank().Output(data), (GenAction) new Actions.ContinueWrapper(Actions.Chain((GenAction) new Modifiers.IsTouching(true, new ushort[6]
              {
                (ushort) 147,
                (ushort) 161,
                (ushort) 396,
                (ushort) 397,
                (ushort) 70,
                (ushort) 191
              }), (GenAction) new Actions.Custom((GenBase.CustomPerUnitAction) ((x, y, args) =>
              {
                foundInvalidTile = true;
                return true;
              }))))));
            else
              flag = WorldUtils.Gen(new Point(point.X, point.Y - 1), (GenShape) new ShapeFloodFill(1000), Actions.Chain((GenAction) new Modifiers.IsNotSolid(), new Actions.Blank().Output(data), (GenAction) new Actions.ContinueWrapper(Actions.Chain((GenAction) new Modifiers.IsTouching(true, new ushort[7]
              {
                (ushort) 60,
                (ushort) 147,
                (ushort) 161,
                (ushort) 396,
                (ushort) 397,
                (ushort) 70,
                (ushort) 191
              }), (GenAction) new Modifiers.IsTouching(true, new ushort[6]
              {
                (ushort) 147,
                (ushort) 161,
                (ushort) 396,
                (ushort) 397,
                (ushort) 70,
                (ushort) 191
              }), (GenAction) new Actions.Custom((GenBase.CustomPerUnitAction) ((x, y, args) =>
              {
                foundInvalidTile = true;
                return true;
              }))))));
            if (data.Count > 50 & flag && !foundInvalidTile)
            {
              WorldUtils.Gen(new Point(point.X, point.Y), (GenShape) new ModShapes.OuterOutline(data, true, true), Actions.Chain((GenAction) new Modifiers.SkipWalls(new ushort[1]
              {
                (ushort) 87
              }), (GenAction) new Actions.PlaceWall(type, true)));
              --num2;
            }
            data.Clear();
          }
        }
      }));
      WorldGen.AddGenerationPass("Life Crystals", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        if (WorldGen.getGoodWorldGen)
          Main.tileSolid[56] = false;
        if (WorldGen.notTheBees)
          WorldGen.NotTheBees();
        dub2 = (float) (Main.maxTilesX / 4200);
        progress.Message = Lang.gen[28].Value;
        for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 2E-05); ++index)
        {
          float num2 = (float) index / ((float) (Main.maxTilesX * Main.maxTilesY) * 2E-05f);
          progress.Set(num2);
          bool flag = false;
          int num3 = 0;
          while (!flag)
          {
            if (WorldGen.AddLifeCrystal(WorldGen.genRand.Next(40, Main.maxTilesX - 40), WorldGen.genRand.Next((int) (Main.worldSurface * 2.0 + Main.rockLayer) / 3, Main.maxTilesY - 300)))
            {
              flag = true;
            }
            else
            {
              ++num3;
              if (num3 >= 10000)
                flag = true;
            }
          }
        }
        Main.tileSolid[225] = false;
      }));
      WorldGen.AddGenerationPass("Statues", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[29].Value;
        int index1 = 0;
        int num2 = (int) ((double) (WorldGen.statueList.Length * 2) * (double) dub2);
        for (int index2 = 0; index2 < num2; ++index2)
        {
          if (index1 >= WorldGen.statueList.Length)
            index1 = 0;
          int x = (int) WorldGen.statueList[index1].X;
          int y1 = (int) WorldGen.statueList[index1].Y;
          float num3 = (float) (index2 / num2);
          progress.Set(num3);
          bool flag = false;
          int num4 = 0;
          while (!flag)
          {
            int index3 = WorldGen.genRand.Next(20, Main.maxTilesX - 20);
            int y2;
            for (y2 = WorldGen.genRand.Next((int) (Main.worldSurface * 2.0 + Main.rockLayer) / 3, Main.maxTilesY - 300); WorldGen.oceanDepths(index3, y2); y2 = WorldGen.genRand.Next((int) (Main.worldSurface * 2.0 + Main.rockLayer) / 3, Main.maxTilesY - 300))
              index3 = WorldGen.genRand.Next(20, Main.maxTilesX - 20);
            while (!Main.tile[index3, y2].active())
            {
              ++y2;
              if (y2 >= Main.maxTilesY)
                break;
            }
            if (y2 < Main.maxTilesY)
            {
              int index4 = y2 - 1;
              WorldGen.PlaceTile(index3, index4, x, true, true, -1, y1);
              if (Main.tile[index3, index4].active() && (int) Main.tile[index3, index4].type == x)
              {
                flag = true;
                if (WorldGen.StatuesWithTraps.Contains(index1))
                  WorldGen.PlaceStatueTrap(index3, index4);
                ++index1;
              }
              else
              {
                ++num4;
                if (num4 >= 10000)
                  flag = true;
              }
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Buried Chests", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[30].Value;
        Main.tileSolid[226] = true;
        Main.tileSolid[162] = true;
        Main.tileSolid[225] = true;
        CaveHouseBiome biome = configuration.CreateBiome<CaveHouseBiome>();
        int random1 = passConfig.Get<WorldGenRange>("CaveHouseCount").GetRandom(WorldGen.genRand);
        int random2 = passConfig.Get<WorldGenRange>("UnderworldChestCount").GetRandom(WorldGen.genRand);
        int random3 = passConfig.Get<WorldGenRange>("CaveChestCount").GetRandom(WorldGen.genRand);
        int random4 = passConfig.Get<WorldGenRange>("AdditionalDesertHouseCount").GetRandom(WorldGen.genRand);
        int num2 = random1 + random2 + random3 + random4;
        int num3 = 10000;
        for (int index1 = 0; index1 < random3 && num3 > 0; ++index1)
        {
          progress.Set((float) index1 / (float) num2);
          int index2 = WorldGen.genRand.Next(20, Main.maxTilesX - 20);
          int index3 = WorldGen.genRand.Next((int) ((worldSurfaceHigh + 20.0 + Main.rockLayer) / 2.0), Main.maxTilesY - 230);
          ushort wall = Main.tile[index2, index3].wall;
          if (Main.wallDungeon[(int) wall] || wall == (ushort) 87 || (WorldGen.oceanDepths(index2, index3) || !WorldGen.AddBuriedChest(index2, index3, 0, false, -1, false, (ushort) 0)))
          {
            --num3;
            --index1;
          }
        }
        int num4 = 10000;
        for (int index = 0; index < random2 && num4 > 0; ++index)
        {
          progress.Set((float) (index + random3) / (float) num2);
          int i = WorldGen.genRand.Next(20, Main.maxTilesX - 20);
          int j = WorldGen.genRand.Next(Main.UnderworldLayer, Main.maxTilesY - 50);
          if (Main.wallDungeon[(int) Main.tile[i, j].wall] || !WorldGen.AddBuriedChest(i, j, 0, false, -1, false, (ushort) 0))
          {
            --num4;
            --index;
          }
        }
        int num5 = 10000;
        for (int index = 0; index < random1 && num5 > 0; ++index)
        {
          progress.Set((float) (index + random3 + random2) / (float) num2);
          int x = WorldGen.genRand.Next(80, Main.maxTilesX - 80);
          int y = WorldGen.genRand.Next((int) (worldSurfaceHigh + 20.0), Main.maxTilesY - 230);
          if (WorldGen.oceanDepths(x, y) || !biome.Place(new Point(x, y), structures))
          {
            --num5;
            --index;
          }
        }
        int num6 = 10000;
        Microsoft.Xna.Framework.Rectangle desertHiveLocation = WorldGen.UndergroundDesertHiveLocation;
        if ((double) desertHiveLocation.Y < Main.worldSurface + 26.0)
        {
          int num7 = (int) Main.worldSurface + 26 - desertHiveLocation.Y;
          desertHiveLocation.Y += num7;
          desertHiveLocation.Height -= num7;
        }
        for (int index = 0; index < random4 && num6 > 0; ++index)
        {
          progress.Set((float) (index + random3 + random2 + random1) / (float) num2);
          if (!biome.Place(WorldGen.RandomRectanglePoint(desertHiveLocation), structures))
          {
            --num6;
            --index;
          }
        }
        Main.tileSolid[226] = false;
        Main.tileSolid[162] = false;
        Main.tileSolid[225] = false;
      }));
      WorldGen.AddGenerationPass("Surface Chests", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[31].Value;
        for (int index1 = 0; index1 < (int) ((double) Main.maxTilesX * 0.005); ++index1)
        {
          float num2 = (float) index1 / ((float) Main.maxTilesX * 0.005f);
          progress.Set(num2);
          bool flag1 = false;
          int num3 = 0;
          while (!flag1)
          {
            int index2 = WorldGen.genRand.Next(300, Main.maxTilesX - 300);
            int index3;
            for (index3 = WorldGen.genRand.Next((int) WorldGen.worldSurfaceLow, (int) Main.worldSurface); WorldGen.oceanDepths(index2, index3); index3 = WorldGen.genRand.Next((int) WorldGen.worldSurfaceLow, (int) Main.worldSurface))
              index2 = WorldGen.genRand.Next(300, Main.maxTilesX - 300);
            bool flag2 = false;
            if (!Main.tile[index2, index3].active())
            {
              if (Main.tile[index2, index3].wall == (ushort) 2 || Main.tile[index2, index3].wall == (ushort) 59 || Main.tile[index2, index3].wall == (ushort) 244)
                flag2 = true;
            }
            else
            {
              int num4 = 50;
              int num5 = index2;
              int num6 = index3;
              int maxValue = 1;
              for (int index4 = num5 - num4; index4 <= num5 + num4; index4 += 2)
              {
                for (int index5 = num6 - num4; index5 <= num6 + num4; index5 += 2)
                {
                  if ((double) index5 < Main.worldSurface && !Main.tile[index4, index5].active() && (Main.tile[index4, index5].wall == (ushort) 244 && WorldGen.genRand.Next(maxValue) == 0))
                  {
                    ++maxValue;
                    flag2 = true;
                    index2 = index4;
                    index3 = index5;
                  }
                }
              }
            }
            if (flag2 && WorldGen.AddBuriedChest(index2, index3, 0, true, -1, false, (ushort) 0))
            {
              flag1 = true;
            }
            else
            {
              ++num3;
              if (num3 >= 2000)
                flag1 = true;
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Jungle Chests Placement", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[32].Value;
        for (int index1 = 0; index1 < WorldGen.numJChests; ++index1)
        {
          float num2 = (float) (index1 / WorldGen.numJChests);
          progress.Set(num2);
          int nextJungleChestItem = WorldGen.GetNextJungleChestItem();
          if (!WorldGen.AddBuriedChest(WorldGen.JChestX[index1] + WorldGen.genRand.Next(2), WorldGen.JChestY[index1], nextJungleChestItem, false, 10, false, (ushort) 0))
          {
            for (int i = WorldGen.JChestX[index1] - 1; i <= WorldGen.JChestX[index1] + 1; ++i)
            {
              for (int j = WorldGen.JChestY[index1]; j <= WorldGen.JChestY[index1] + 2; ++j)
                WorldGen.KillTile(i, j, false, false, false);
            }
            for (int index2 = WorldGen.JChestX[index1] - 1; index2 <= WorldGen.JChestX[index1] + 1; ++index2)
            {
              for (int index3 = WorldGen.JChestY[index1]; index3 <= WorldGen.JChestY[index1] + 3; ++index3)
              {
                if (index3 < Main.maxTilesY)
                {
                  Main.tile[index2, index3].slope((byte) 0);
                  Main.tile[index2, index3].halfBrick(false);
                }
              }
            }
            WorldGen.AddBuriedChest(WorldGen.JChestX[index1], WorldGen.JChestY[index1], nextJungleChestItem, false, 10, false, (ushort) 0);
          }
        }
      }));
      WorldGen.AddGenerationPass("Water Chests", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[33].Value;
        for (int index = 0; index < WorldGen.numOceanCaveTreasure; ++index)
        {
          int contain = (int) WorldGen.genRand.NextFromList<short>((short) 863, (short) 186, (short) 277, (short) 187, (short) 4404, (short) 4425);
          bool flag = false;
          float num2 = 2f;
          while (!flag && (double) num2 < 50.0)
          {
            num2 += 0.1f;
            int num3 = WorldGen.genRand.Next(WorldGen.oceanCaveTreasure[index].X - (int) num2, WorldGen.oceanCaveTreasure[index].X + (int) num2 + 1);
            int j = WorldGen.genRand.Next(WorldGen.oceanCaveTreasure[index].Y - (int) num2 / 2, WorldGen.oceanCaveTreasure[index].Y + (int) num2 / 2 + 1);
            int i = num3 >= Main.maxTilesX ? (int) ((double) num3 + (double) num2 / 2.0) : (int) ((double) num3 - (double) num2 / 2.0);
            if (Main.tile[i, j].liquid > (byte) 250 && (Main.tile[i, j].liquidType() == (byte) 0 || WorldGen.notTheBees))
              flag = WorldGen.AddBuriedChest(i, j, contain, false, 17, true, (ushort) 0);
          }
        }
        int num4 = 0;
        for (int index = 0; (double) index < 9.0 * (double) dub2; ++index)
        {
          float num2 = (float) index / (9f * dub2);
          progress.Set(num2);
          ++num4;
          int contain;
          if (WorldGen.genRand.Next(10) == 0)
            contain = 4425;
          else if (WorldGen.genRand.Next(10) == 0)
          {
            contain = 863;
          }
          else
          {
            switch (num4)
            {
              case 1:
                contain = 186;
                break;
              case 2:
                contain = 4404;
                break;
              case 3:
                contain = 277;
                break;
              default:
                contain = 187;
                num4 = 0;
                break;
            }
          }
          bool flag1 = false;
          int num3 = 0;
          while (!flag1)
          {
            int i = WorldGen.genRand.Next(50, Main.maxTilesX - 50);
            int j;
            for (j = WorldGen.genRand.Next(1, Main.UnderworldLayer); Main.tile[i, j].liquid < (byte) 250 || Main.tile[i, j].liquidType() != (byte) 0 && !WorldGen.notTheBees; j = WorldGen.genRand.Next(50, Main.UnderworldLayer))
              i = WorldGen.genRand.Next(50, Main.maxTilesX - 50);
            flag1 = WorldGen.AddBuriedChest(i, j, contain, false, 17, i < WorldGen.beachDistance || i > Main.maxTilesX - WorldGen.beachDistance, (ushort) 0);
            ++num3;
            if (num3 > 10000)
              break;
          }
          bool flag2 = false;
          int num5 = 0;
          while (!flag2)
          {
            int i = WorldGen.genRand.Next(50, Main.maxTilesX - 50);
            int j;
            for (j = WorldGen.genRand.Next((int) Main.worldSurface, Main.UnderworldLayer); Main.tile[i, j].liquid < (byte) 250 || Main.tile[i, j].liquidType() != (byte) 0 && !WorldGen.notTheBees; j = WorldGen.genRand.Next((int) Main.worldSurface, Main.UnderworldLayer))
              i = WorldGen.genRand.Next(50, Main.maxTilesX - 50);
            flag2 = WorldGen.AddBuriedChest(i, j, contain, false, 17, i < WorldGen.beachDistance || i > Main.maxTilesX - WorldGen.beachDistance, (ushort) 0);
            ++num5;
            if (num5 > 10000)
              break;
          }
        }
      }));
      WorldGen.AddGenerationPass("Spider Caves", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[64].Value;
        WorldGen.maxTileCount = 3500;
        int num2 = Main.maxTilesX / 2;
        int num3 = (int) ((double) Main.maxTilesX * 0.005);
        if (WorldGen.getGoodWorldGen)
          num3 *= 3;
        for (int index = 0; index < num3; ++index)
        {
          float num4 = (float) index / ((float) Main.maxTilesX * 0.005f);
          progress.Set(num4);
          int num5 = 0;
          int x = WorldGen.genRand.Next(200, Main.maxTilesX - 200);
          int y = WorldGen.genRand.Next((int) (Main.worldSurface + Main.rockLayer) / 2, Main.maxTilesY - 230);
          int num6 = WorldGen.countTiles(x, y, false, true);
          while ((num6 >= 3500 || num6 < 500) && num5 < num2)
          {
            ++num5;
            x = WorldGen.genRand.Next(200, Main.maxTilesX - 200);
            y = WorldGen.genRand.Next((int) Main.rockLayer + 30, Main.maxTilesY - 230);
            num6 = WorldGen.countTiles(x, y, false, true);
            if (WorldGen.shroomCount > 1)
              num6 = 0;
          }
          if (num5 < num2)
            WorldGen.Spread.Spider(x, y);
        }
        Main.tileSolid[162] = true;
      }));
      WorldGen.AddGenerationPass("Gem Caves", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        if (WorldGen.notTheBees)
          return;
        progress.Message = Lang.gen[64].Value;
        WorldGen.maxTileCount = 300;
        for (int index1 = 0; index1 < (int) ((double) Main.maxTilesX * 0.003); ++index1)
        {
          float num2 = (float) index1 / ((float) Main.maxTilesX * (3f / 1000f));
          progress.Set(num2);
          int num3 = 0;
          int x = WorldGen.genRand.Next(200, Main.maxTilesX - 200);
          int y = WorldGen.genRand.Next((int) Main.rockLayer + 30, Main.maxTilesY - 230);
          for (int index2 = WorldGen.countTiles(x, y, false, false); (index2 >= 300 || index2 < 50 || (WorldGen.lavaCount > 0 || WorldGen.iceCount > 0) || WorldGen.rockCount == 0) && num3 < 1000; index2 = WorldGen.countTiles(x, y, false, false))
          {
            ++num3;
            x = WorldGen.genRand.Next(200, Main.maxTilesX - 200);
            y = WorldGen.genRand.Next((int) Main.rockLayer + 30, Main.maxTilesY - 230);
          }
          if (num3 < 1000)
            WorldGen.gemCave(x, y);
        }
      }));
      WorldGen.AddGenerationPass("Moss", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        if (WorldGen.notTheBees)
          return;
        progress.Message = Lang.gen[61].Value;
        WorldGen.randMoss();
        int num2 = Main.maxTilesX / 2100;
        int num3 = 0;
        int num4 = 0;
        while (num4 < num2)
        {
          int i = WorldGen.genRand.Next(100, Main.maxTilesX - 100);
          if (WorldGen.getGoodWorldGen)
          {
            while ((double) i > (double) Main.maxTilesX * 0.42 && (double) i < (double) Main.maxTilesX * 0.48)
              i = WorldGen.genRand.Next(100, Main.maxTilesX - 100);
          }
          else if (!WorldGen.drunkWorldGen)
          {
            while ((double) i > (double) Main.maxTilesX * 0.38 && (double) i < (double) Main.maxTilesX * 0.62)
              i = WorldGen.genRand.Next(100, Main.maxTilesX - 100);
          }
          int j = WorldGen.genRand.Next((int) Main.rockLayer + 40, WorldGen.lavaLine - 40);
          bool flag = false;
          int num5 = 50;
label_19:
          for (int index1 = i - num5; index1 <= i + num5; ++index1)
          {
            for (int index2 = j - num5; index2 <= j + num5; ++index2)
            {
              if (Main.tile[index1, index2].active())
              {
                int type = (int) Main.tile[index1, index2].type;
                switch (type)
                {
                  case 60:
                  case 70:
                  case 147:
                  case 161:
                  case 367:
                  case 368:
                  case 396:
                  case 397:
                    flag = true;
                    index1 = i + num5 + 1;
                    goto label_19;
                  default:
                    if (!Main.tileDungeon[type])
                      continue;
                    goto case 60;
                }
              }
            }
          }
          if (flag)
          {
            ++num3;
            if (num3 > Main.maxTilesX)
              ++num4;
          }
          else
          {
            num3 = 0;
            ++num4;
            WorldGen.neonMossBiome(i, j, WorldGen.lavaLine);
          }
        }
        WorldGen.maxTileCount = 2500;
        for (int index1 = 0; index1 < (int) ((double) Main.maxTilesX * 0.01); ++index1)
        {
          float num5 = (float) index1 / ((float) Main.maxTilesX * 0.01f);
          progress.Set(num5);
          int num6 = 0;
          int x = WorldGen.genRand.Next(200, Main.maxTilesX - 200);
          int y = WorldGen.genRand.Next((int) (Main.worldSurface + Main.rockLayer) / 2, WorldGen.waterLine);
          for (int index2 = WorldGen.countTiles(x, y, false, false); (index2 >= 2500 || index2 < 10 || (WorldGen.lavaCount > 0 || WorldGen.iceCount > 0) || (WorldGen.rockCount == 0 || WorldGen.shroomCount > 0)) && num6 < 1000; index2 = WorldGen.countTiles(x, y, false, false))
          {
            ++num6;
            x = WorldGen.genRand.Next(200, Main.maxTilesX - 200);
            y = WorldGen.genRand.Next((int) Main.rockLayer + 30, Main.maxTilesY - 230);
          }
          if (num6 < 1000)
          {
            WorldGen.setMoss(x, y);
            WorldGen.Spread.Moss(x, y);
          }
        }
        for (int index = 0; index < Main.maxTilesX; ++index)
        {
          int x = WorldGen.genRand.Next(50, Main.maxTilesX - 50);
          int y = WorldGen.genRand.Next((int) (Main.worldSurface + Main.rockLayer) / 2, WorldGen.lavaLine);
          if (Main.tile[x, y].type == (ushort) 1)
          {
            WorldGen.setMoss(x, y);
            Main.tile[x, y].type = WorldGen.mossTile;
          }
        }
        float num7 = (float) Main.maxTilesX * 0.05f;
        while ((double) num7 > 0.0)
        {
          int x = WorldGen.genRand.Next(50, Main.maxTilesX - 50);
          int y = WorldGen.genRand.Next((int) (Main.worldSurface + Main.rockLayer) / 2, WorldGen.lavaLine);
          if (Main.tile[x, y].type == (ushort) 1 && (!Main.tile[x - 1, y].active() || !Main.tile[x + 1, y].active() || (!Main.tile[x, y - 1].active() || !Main.tile[x, y + 1].active())))
          {
            WorldGen.setMoss(x, y);
            Main.tile[x, y].type = WorldGen.mossTile;
            --num7;
          }
        }
        float num8 = (float) Main.maxTilesX * 0.065f;
        while ((double) num8 > 0.0)
        {
          int index1 = WorldGen.genRand.Next(50, Main.maxTilesX - 50);
          int index2 = WorldGen.genRand.Next(WorldGen.waterLine, Main.UnderworldLayer);
          if (Main.tile[index1, index2].type == (ushort) 1 && (!Main.tile[index1 - 1, index2].active() || !Main.tile[index1 + 1, index2].active() || (!Main.tile[index1, index2 - 1].active() || !Main.tile[index1, index2 + 1].active())))
          {
            int num5 = 25;
            int num6 = 0;
            for (int index3 = index1 - num5; index3 < index1 + num5; ++index3)
            {
              for (int index4 = index2 - num5; index4 < index2 + num5; ++index4)
              {
                if (Main.tile[index3, index4].liquid > (byte) 0 && Main.tile[index3, index4].lava())
                  ++num6;
              }
            }
            if (num6 > 20)
            {
              Main.tile[index1, index2].type = (ushort) 381;
              --num8;
            }
            else
              num8 -= 1f / 500f;
          }
        }
        for (int index1 = 0; index1 < Main.maxTilesX; ++index1)
        {
          for (int index2 = 0; index2 < Main.maxTilesY; ++index2)
          {
            if (Main.tile[index1, index2].active() && Main.tileMoss[(int) Main.tile[index1, index2].type])
            {
              for (int index3 = 0; index3 < 4; ++index3)
              {
                int i = index1;
                int j = index2;
                if (index3 == 0)
                  --i;
                if (index3 == 1)
                  ++i;
                if (index3 == 2)
                  --j;
                if (index3 == 3)
                  ++j;
                try
                {
                  WorldGen.grassSpread = 0;
                  WorldGen.SpreadGrass(i, j, 1, (int) Main.tile[index1, index2].type, true, (byte) 0);
                }
                catch
                {
                  WorldGen.grassSpread = 0;
                  WorldGen.SpreadGrass(i, j, 1, (int) Main.tile[index1, index2].type, false, (byte) 0);
                }
              }
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Temple", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        Main.tileSolid[162] = false;
        Main.tileSolid[226] = true;
        WorldGen.templePart2();
        Main.tileSolid[232] = false;
      }));
      WorldGen.AddGenerationPass("Cave Walls", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[63].Value;
        WorldGen.maxTileCount = 1500;
        for (int index1 = 0; index1 < (int) ((double) Main.maxTilesX * 0.04); ++index1)
        {
          float num2 = (float) index1 / ((float) Main.maxTilesX * 0.04f);
          progress.Set(num2 * 0.66f);
          int num3 = 0;
          int x = WorldGen.genRand.Next(200, Main.maxTilesX - 200);
          int y = WorldGen.genRand.Next((int) (Main.worldSurface + Main.rockLayer) / 2, Main.maxTilesY - 220);
          for (int index2 = WorldGen.countTiles(x, y, false, true); (index2 >= WorldGen.maxTileCount || index2 < 10) && num3 < 500; index2 = WorldGen.countTiles(x, y, false, true))
          {
            ++num3;
            x = WorldGen.genRand.Next(200, Main.maxTilesX - 200);
            y = WorldGen.genRand.Next((int) (Main.worldSurface + Main.rockLayer) / 2, Main.maxTilesY - 220);
          }
          if (num3 < 500)
          {
            int wallType = WorldGen.genRand.Next(2);
            if ((double) WorldGen.shroomCount > (double) WorldGen.rockCount * 0.75)
              wallType = 80;
            else if (WorldGen.iceCount > 0)
            {
              switch (wallType)
              {
                case 0:
                  wallType = 40;
                  break;
                case 1:
                  wallType = 71;
                  break;
              }
            }
            else if (WorldGen.lavaCount > 0)
            {
              wallType = 79;
            }
            else
            {
              wallType = WorldGen.genRand.Next(4);
              switch (wallType)
              {
                case 0:
                  wallType = 59;
                  break;
                case 1:
                  wallType = 61;
                  break;
                case 2:
                  wallType = 170;
                  break;
                case 3:
                  wallType = 171;
                  break;
              }
            }
            WorldGen.Spread.Wall(x, y, wallType);
          }
        }
        WorldGen.maxTileCount = 1500;
        float num4 = (float) Main.maxTilesX * 0.02f;
        for (int index = 0; (double) index < (double) num4; ++index)
        {
          float num2 = (float) index / ((float) Main.maxTilesX * 0.02f);
          progress.Set((float) ((double) num2 * 0.330000013113022 + 0.660000026226044));
          int num3 = 0;
          int x = WorldGen.genRand.Next(200, Main.maxTilesX - 200);
          int y = WorldGen.genRand.Next((int) Main.worldSurface, WorldGen.lavaLine);
          int num5 = 0;
          if (Main.tile[x, y].wall == (ushort) 64)
            num5 = WorldGen.countTiles(x, y, true, false);
          while ((num5 >= WorldGen.maxTileCount || num5 < 10) && num3 < 1000)
          {
            ++num3;
            x = WorldGen.genRand.Next(200, Main.maxTilesX - 200);
            y = WorldGen.genRand.Next((int) Main.worldSurface, WorldGen.lavaLine);
            if (!Main.wallHouse[(int) Main.tile[x, y].wall] && Main.tile[x, y].wall != (ushort) 244)
              num5 = Main.tile[x, y].wall != (ushort) 64 ? 0 : WorldGen.countTiles(x, y, true, false);
          }
          if (num3 < 1000)
            WorldGen.Spread.Wall2(x, y, 15);
        }
      }));
      WorldGen.AddGenerationPass("Jungle Trees", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[83].Value;
        for (int i = 0; i < Main.maxTilesX; ++i)
        {
          progress.Set((float) i / (float) Main.maxTilesX);
          for (int y = (int) Main.worldSurface - 1; y < Main.maxTilesY - 350; ++y)
          {
            if (WorldGen.genRand.Next(10) == 0 || WorldGen.drunkWorldGen)
              WorldGen.GrowUndergroundTree(i, y);
          }
        }
      }));
      WorldGen.AddGenerationPass("Floating Island Houses", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Set(1f);
        for (int index = 0; index < WorldGen.numIslandHouses; ++index)
        {
          if (!WorldGen.skyLake[index])
            WorldGen.IslandHouse(WorldGen.floatingIslandHouseX[index], WorldGen.floatingIslandHouseY[index], WorldGen.floatingIslandStyle[index]);
        }
      }));
      WorldGen.AddGenerationPass("Quick Cleanup", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Set(1f);
        if (WorldGen.notTheBees)
          WorldGen.NotTheBees();
        Main.tileSolid[137] = false;
        Main.tileSolid[130] = false;
        for (int index1 = 20; index1 < Main.maxTilesX - 20; ++index1)
        {
          for (int y = 20; y < Main.maxTilesY - 20; ++y)
          {
            if ((double) y < Main.worldSurface && WorldGen.oceanDepths(index1, y) && (Main.tile[index1, y].type == (ushort) 53 && Main.tile[index1, y].active()))
            {
              if (Main.tile[index1, y].bottomSlope())
                Main.tile[index1, y].slope((byte) 0);
              for (int index2 = y + 1; index2 < y + WorldGen.genRand.Next(4, 7) && (!Main.tile[index1, index2].active() || Main.tile[index1, index2].type != (ushort) 397 && Main.tile[index1, index2].type != (ushort) 53) && (!Main.tile[index1, index2 + 1].active() || Main.tile[index1, index2 + 1].type != (ushort) 397 && Main.tile[index1, index2 + 1].type != (ushort) 53 && Main.tile[index1, index2 + 1].type != (ushort) 495) && (!Main.tile[index1, index2 + 2].active() || Main.tile[index1, index2 + 2].type != (ushort) 397 && Main.tile[index1, index2 + 2].type != (ushort) 53 && Main.tile[index1, index2 + 2].type != (ushort) 495); ++index2)
              {
                Main.tile[index1, index2].type = (ushort) 0;
                Main.tile[index1, index2].active(true);
                Main.tile[index1, index2].halfBrick(false);
                Main.tile[index1, index2].slope((byte) 0);
              }
            }
            if (Main.tile[index1, y].wall == (ushort) 187 || Main.tile[index1, y].wall == (ushort) 216)
            {
              if (Main.tile[index1, y].type == (ushort) 59 || Main.tile[index1, y].type == (ushort) 123 || Main.tile[index1, y].type == (ushort) 224)
                Main.tile[index1, y].type = (ushort) 397;
              if (Main.tile[index1, y].type == (ushort) 368 || Main.tile[index1, y].type == (ushort) 367)
                Main.tile[index1, y].type = (ushort) 397;
              if ((double) y <= Main.rockLayer)
                Main.tile[index1, y].liquid = (byte) 0;
              else if (Main.tile[index1, y].liquid > (byte) 0)
              {
                Main.tile[index1, y].liquid = byte.MaxValue;
                Main.tile[index1, y].lava(true);
              }
            }
            if ((double) y < Main.worldSurface && Main.tile[index1, y].active() && (Main.tile[index1, y].type == (ushort) 53 && Main.tile[index1, y + 1].wall == (ushort) 0) && !WorldGen.SolidTile(index1, y + 1, false))
            {
              ushort num2 = 0;
              int num3 = 3;
              for (int index2 = index1 - num3; index2 <= index1 + num3; ++index2)
              {
                for (int index3 = y - num3; index3 <= y + num3; ++index3)
                {
                  if (Main.tile[index2, index3].wall > (ushort) 0)
                  {
                    num2 = Main.tile[index2, index3].wall;
                    break;
                  }
                }
              }
              if (num2 > (ushort) 0)
              {
                Main.tile[index1, y + 1].wall = num2;
                if (Main.tile[index1, y].wall == (ushort) 0)
                  Main.tile[index1, y].wall = num2;
              }
            }
            if (Main.tile[index1, y].type != (ushort) 19 && TileID.Sets.CanBeClearedDuringGeneration[(int) Main.tile[index1, y].type])
            {
              if (Main.tile[index1, y].topSlope() || Main.tile[index1, y].halfBrick())
              {
                if (Main.tile[index1, y].type != (ushort) 225 || !Main.tile[index1, y].halfBrick())
                {
                  if (!WorldGen.SolidTile(index1, y + 1, false))
                    Main.tile[index1, y].active(false);
                  if (Main.tile[index1 + 1, y].type == (ushort) 137 || Main.tile[index1 - 1, y].type == (ushort) 137)
                    Main.tile[index1, y].active(false);
                }
              }
              else if (Main.tile[index1, y].bottomSlope())
              {
                if (!WorldGen.SolidTile(index1, y - 1, false))
                  Main.tile[index1, y].active(false);
                if (Main.tile[index1 + 1, y].type == (ushort) 137 || Main.tile[index1 - 1, y].type == (ushort) 137)
                  Main.tile[index1, y].active(false);
              }
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Pots", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        Main.tileSolid[137] = true;
        Main.tileSolid[130] = true;
        progress.Message = Lang.gen[35].Value;
        for (int index = 0; index < (int) ((double) (Main.maxTilesX * Main.maxTilesY) * 0.0008); ++index)
        {
          float num2 = (float) index / ((float) (Main.maxTilesX * Main.maxTilesY) * 0.0008f);
          progress.Set(num2);
          bool flag1 = false;
          int num3 = 0;
          while (!flag1)
          {
            int num4 = WorldGen.genRand.Next((int) worldSurfaceHigh, Main.maxTilesY - 10);
            if ((double) num2 > 0.93)
              num4 = Main.maxTilesY - 150;
            else if ((double) num2 > 0.75)
              num4 = (int) WorldGen.worldSurfaceLow;
            int x = WorldGen.genRand.Next(1, Main.maxTilesX);
            bool flag2 = false;
            for (int y = num4; y < Main.maxTilesY; ++y)
            {
              if (!flag2)
              {
                if (Main.tile[x, y].active() && Main.tileSolid[(int) Main.tile[x, y].type] && !Main.tile[x, y - 1].lava())
                  flag2 = true;
              }
              else if ((double) y >= Main.worldSurface || Main.tile[x, y].wall != (ushort) 0)
              {
                int style = WorldGen.genRand.Next(0, 4);
                int num5 = 0;
                int num6 = 0;
                if (y < Main.maxTilesY - 5)
                {
                  num5 = (int) Main.tile[x, y + 1].type;
                  num6 = (int) Main.tile[x, y].wall;
                }
                if (num5 == 147 || num5 == 161 || num5 == 162)
                  style = WorldGen.genRand.Next(4, 7);
                if (num5 == 60)
                  style = WorldGen.genRand.Next(7, 10);
                if (Main.wallDungeon[(int) Main.tile[x, y].wall])
                  style = WorldGen.genRand.Next(10, 13);
                if (num5 == 41 || num5 == 43 || (num5 == 44 || num5 == 481) || (num5 == 482 || num5 == 483))
                  style = WorldGen.genRand.Next(10, 13);
                if (num5 == 22 || num5 == 23 || num5 == 25)
                  style = WorldGen.genRand.Next(16, 19);
                if (num5 == 199 || num5 == 203 || (num5 == 204 || num5 == 200))
                  style = WorldGen.genRand.Next(22, 25);
                if (num5 == 367)
                  style = WorldGen.genRand.Next(31, 34);
                if (num5 == 226)
                  style = WorldGen.genRand.Next(28, 31);
                if (num6 == 187 || num6 == 216)
                  style = WorldGen.genRand.Next(34, 37);
                if (y > Main.UnderworldLayer)
                  style = WorldGen.genRand.Next(13, 16);
                if (!WorldGen.oceanDepths(x, y) && WorldGen.PlacePot(x, y, (ushort) 28, style))
                {
                  flag1 = true;
                  break;
                }
                ++num3;
                if (num3 >= 10000)
                {
                  flag1 = true;
                  break;
                }
              }
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Hellforge", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[36].Value;
        for (int index1 = 0; index1 < Main.maxTilesX / 200; ++index1)
        {
          float num2 = (float) (index1 / (Main.maxTilesX / 200));
          progress.Set(num2);
          bool flag = false;
          int num3 = 0;
          while (!flag)
          {
            int i = WorldGen.genRand.Next(1, Main.maxTilesX);
            int index2 = WorldGen.genRand.Next(Main.maxTilesY - 250, Main.maxTilesY - 30);
            try
            {
              if (Main.tile[i, index2].wall != (ushort) 13)
              {
                if (Main.tile[i, index2].wall != (ushort) 14)
                  continue;
              }
              while (!Main.tile[i, index2].active() && index2 < Main.maxTilesY - 20)
                ++index2;
              int j = index2 - 1;
              WorldGen.PlaceTile(i, j, 77, false, false, -1, 0);
              if (Main.tile[i, j].type == (ushort) 77)
              {
                flag = true;
              }
              else
              {
                ++num3;
                if (num3 >= 10000)
                  flag = true;
              }
            }
            catch
            {
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Spreading Grass", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        if (WorldGen.notTheBees)
          return;
        progress.Message = Lang.gen[37].Value;
        for (int index1 = 50; index1 < Main.maxTilesX - 50; ++index1)
        {
          for (int index2 = 50; (double) index2 <= Main.worldSurface; ++index2)
          {
            if (Main.tile[index1, index2].active())
            {
              int type = (int) Main.tile[index1, index2].type;
              if (Main.tile[index1, index2].active() && type == 60)
              {
                for (int index3 = index1 - 1; index3 <= index1 + 1; ++index3)
                {
                  for (int index4 = index2 - 1; index4 <= index2 + 1; ++index4)
                  {
                    if (Main.tile[index3, index4].active() && Main.tile[index3, index4].type == (ushort) 0)
                      Main.tile[index3, index4].type = Main.tile[index3, index4 - 1].active() ? (ushort) 59 : (ushort) 60;
                  }
                }
              }
              else if (type == 1 || type == 40 || TileID.Sets.Ore[type])
              {
                int num2 = 3;
                bool flag = false;
                ushort num3 = 0;
                for (int index3 = index1 - num2; index3 <= index1 + num2; ++index3)
                {
                  for (int index4 = index2 - num2; index4 <= index2 + num2; ++index4)
                  {
                    if (Main.tile[index3, index4].active())
                    {
                      if (Main.tile[index3, index4].type == (ushort) 53 || num3 == (ushort) 53)
                        num3 = (ushort) 53;
                      else if (Main.tile[index3, index4].type == (ushort) 59 || Main.tile[index3, index4].type == (ushort) 60 || (Main.tile[index3, index4].type == (ushort) 147 || Main.tile[index3, index4].type == (ushort) 161) || (Main.tile[index3, index4].type == (ushort) 199 || Main.tile[index3, index4].type == (ushort) 23))
                        num3 = Main.tile[index3, index4].type;
                    }
                    else if (index4 < index2 && Main.tile[index3, index4].wall == (ushort) 0)
                      flag = true;
                  }
                }
                if (flag)
                {
                  switch (num3)
                  {
                    case 23:
                    case 199:
                      if (Main.tile[index1, index2 - 1].active())
                      {
                        num3 = (ushort) 0;
                        break;
                      }
                      break;
                    case 59:
                    case 60:
                      if (index1 >= jungleMinX && index1 <= jungleMaxX)
                      {
                        num3 = Main.tile[index1, index2 - 1].active() ? (ushort) 59 : (ushort) 60;
                        break;
                      }
                      break;
                  }
                  Main.tile[index1, index2].type = num3;
                }
              }
            }
          }
        }
        for (int index = 10; index < Main.maxTilesX - 10; ++index)
        {
          i2 = index;
          bool flag = true;
          for (int j = 0; (double) j < Main.worldSurface - 1.0; ++j)
          {
            if (Main.tile[i2, j].active())
            {
              if (flag)
              {
                if (Main.tile[i2, j].type == (ushort) 0)
                {
                  try
                  {
                    WorldGen.grassSpread = 0;
                    WorldGen.SpreadGrass(i2, j, 0, 2, true, (byte) 0);
                  }
                  catch
                  {
                    WorldGen.grassSpread = 0;
                    WorldGen.SpreadGrass(i2, j, 0, 2, false, (byte) 0);
                  }
                }
              }
              if ((double) j <= worldSurfaceHigh)
                flag = false;
              else
                break;
            }
            else if (Main.tile[i2, j].wall == (ushort) 0)
              flag = true;
          }
        }
      }));
      WorldGen.AddGenerationPass("Surface Ore and Stone", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Set(1f);
        int num2 = WorldGen.genRand.Next(Main.maxTilesX / 4200 * 5, Main.maxTilesX / 4200 * 10);
        for (int index1 = 0; index1 < num2; ++index1)
        {
          int num3 = Main.maxTilesX / 420;
          while (num3 > 0)
          {
            --num3;
            int X = WorldGen.genRand.Next(WorldGen.beachDistance, Main.maxTilesX - WorldGen.beachDistance);
            while ((double) X >= (double) Main.maxTilesX * 0.48 && (double) X <= (double) Main.maxTilesX * 0.52)
              X = WorldGen.genRand.Next(WorldGen.beachDistance, Main.maxTilesX - WorldGen.beachDistance);
            int Y = WorldGen.genRand.Next((int) WorldGen.worldSurfaceLow, (int) worldSurface);
            bool flag = false;
            for (int index2 = 0; index2 < WorldGen.numOrePatch; ++index2)
            {
              if (Math.Abs(X - WorldGen.orePatchX[index2]) < 200)
                flag = true;
            }
            if (!flag && WorldGen.OrePatch(X, Y))
            {
              if (WorldGen.numOrePatch < WorldGen.maxOrePatch - 1)
              {
                WorldGen.orePatchX[WorldGen.numOrePatch] = X;
                ++WorldGen.numOrePatch;
                break;
              }
              break;
            }
          }
        }
        int num4 = WorldGen.genRand.Next(1, Main.maxTilesX / 4200 * 7);
        for (int index1 = 0; index1 < num4; ++index1)
        {
          int num3 = Main.maxTilesX / 420;
          while (num3 > 0)
          {
            --num3;
            int X = WorldGen.genRand.Next(WorldGen.beachDistance, Main.maxTilesX - WorldGen.beachDistance);
            while ((double) X >= (double) Main.maxTilesX * 0.47 && (double) X <= (double) Main.maxTilesX * 0.53)
              X = WorldGen.genRand.Next(WorldGen.beachDistance, Main.maxTilesX - WorldGen.beachDistance);
            int Y = WorldGen.genRand.Next((int) WorldGen.worldSurfaceLow, (int) worldSurface);
            bool flag = false;
            for (int index2 = 0; index2 < WorldGen.numOrePatch; ++index2)
            {
              if (Math.Abs(X - WorldGen.orePatchX[index2]) < 100)
                flag = true;
            }
            if (!flag && WorldGen.StonePatch(X, Y))
              break;
          }
        }
      }));
      WorldGen.AddGenerationPass("Place Fallen Log", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[85].Value;
        int num2 = Main.maxTilesX / 2100 + WorldGen.genRand.Next(-1, 2);
        for (int index1 = 0; index1 < num2; ++index1)
        {
          progress.Set((float) index1 / (float) num2);
          int minValue = WorldGen.beachDistance + 20;
          int num3 = 50000;
          int num4 = 5000;
          while (num3 > 0)
          {
            --num3;
            int i = WorldGen.genRand.Next(minValue, Main.maxTilesX - minValue);
            int index2 = WorldGen.genRand.Next(10, (int) Main.worldSurface);
            bool flag1 = false;
            if (num3 < num4)
              flag1 = true;
            if (num3 > num4 / 2)
            {
              while ((double) i > (double) Main.maxTilesX * 0.4 && (double) i < (double) Main.maxTilesX * 0.6)
                i = WorldGen.genRand.Next(minValue, Main.maxTilesX - minValue);
            }
            if (!Main.tile[i, index2].active() && Main.tile[i, index2].wall == (ushort) 0)
            {
              while (!Main.tile[i, index2].active() && Main.tile[i, index2].wall == (ushort) 0 && (double) index2 <= Main.worldSurface)
                ++index2;
              bool flag2 = true;
              if ((double) index2 > Main.worldSurface - 10.0)
                flag2 = false;
              else if (!flag1)
              {
                int num5 = 50;
                for (int index3 = i - num5; index3 < i + num5; ++index3)
                {
                  if (index3 > 10 && index3 < Main.maxTilesX - 10)
                  {
                    for (int index4 = index2 - num5; index4 < index2 + num5; ++index4)
                    {
                      if (index4 > 10 && index4 < Main.maxTilesY - 10)
                      {
                        int type = (int) Main.tile[index3, index4].type;
                        switch (type)
                        {
                          case 53:
                            flag2 = false;
                            continue;
                          case 189:
                            flag2 = false;
                            continue;
                          default:
                            if (Main.tileDungeon[type])
                            {
                              flag2 = false;
                              continue;
                            }
                            if (TileID.Sets.Crimson[type])
                            {
                              flag2 = false;
                              continue;
                            }
                            if (TileID.Sets.Corrupt[type])
                            {
                              flag2 = false;
                              continue;
                            }
                            continue;
                        }
                      }
                    }
                  }
                }
                if (flag2)
                {
                  int num6 = 10;
                  int num7 = 10;
                  for (int index3 = i - num6; index3 < i + num6; ++index3)
                  {
                    for (int index4 = index2 - num7; index4 < index2 - 1; ++index4)
                    {
                      if (Main.tile[index3, index4].active() && Main.tileSolid[(int) Main.tile[index3, index4].type])
                        flag2 = false;
                      if (Main.tile[index3, index4].wall != (ushort) 0)
                        flag2 = false;
                    }
                  }
                }
              }
              if (flag2 && (Main.tile[i, index2 - 1].liquid == (byte) 0 || num3 < num4 / 5) && (Main.tile[i, index2].type == (ushort) 2 || WorldGen.notTheBees && Main.tile[i, index2].type == (ushort) 60) && ((Main.tile[i - 1, index2].type == (ushort) 2 || WorldGen.notTheBees && Main.tile[i - 1, index2].type == (ushort) 60) && (Main.tile[i + 1, index2].type == (ushort) 2 || WorldGen.notTheBees && Main.tile[i + 1, index2].type == (ushort) 60)))
              {
                int j = index2 - 1;
                WorldGen.PlaceTile(i, j, 488, false, false, -1, 0);
                if (Main.tile[i, j].active() && Main.tile[i, j].type == (ushort) 488)
                {
                  if (WorldGen.genRand.Next(2) == 0)
                  {
                    logX = i;
                    logY = j;
                  }
                  num3 = -1;
                }
              }
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Traps", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        if (WorldGen.notTheBees)
          return;
        WorldGen.placingTraps = true;
        progress.Message = Lang.gen[34].Value;
        float num2 = (float) Main.maxTilesX * 0.05f;
        if (WorldGen.getGoodWorldGen)
          num2 *= 1.5f;
        for (int index1 = 0; (double) index1 < (double) num2; ++index1)
        {
          progress.Set((float) ((double) index1 / (double) num2 / 2.0));
          for (int index2 = 0; index2 < 1150; ++index2)
          {
            int index3 = WorldGen.genRand.Next(200, Main.maxTilesX - 200);
            int index4;
            for (index4 = WorldGen.genRand.Next((int) Main.worldSurface, Main.maxTilesY - 210); WorldGen.oceanDepths(index3, index4); index4 = WorldGen.genRand.Next((int) Main.worldSurface, Main.maxTilesY - 210))
              index3 = WorldGen.genRand.Next(200, Main.maxTilesX - 200);
            if (Main.tile[index3, index4].wall == (ushort) 0 && WorldGen.placeTrap(index3, index4, -1))
              break;
          }
        }
        float num3 = (float) Main.maxTilesX * (3f / 1000f);
        if (WorldGen.getGoodWorldGen)
          num3 *= 1.5f;
        for (int index1 = 0; (double) index1 < (double) num3; ++index1)
        {
          progress.Set((float) ((double) index1 / (double) num3 / 2.0 + 0.5));
          for (int index2 = 0; index2 < 20000; ++index2)
          {
            int i = WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.15), (int) ((double) Main.maxTilesX * 0.85));
            int j = WorldGen.genRand.Next((int) Main.worldSurface + 20, Main.maxTilesY - 210);
            if (Main.tile[i, j].wall == (ushort) 187 && WorldGen.PlaceSandTrap(i, j))
              break;
          }
        }
        if (WorldGen.drunkWorldGen)
        {
          for (int index1 = 0; index1 < 8; ++index1)
          {
            progress.Message = Lang.gen[34].Value;
            float num4 = 100f;
            for (int index2 = 0; (double) index2 < (double) num4; ++index2)
            {
              progress.Set((float) index2 / num4);
              Thread.Sleep(10);
            }
          }
        }
        WorldGen.placingTraps = false;
      }));
      WorldGen.AddGenerationPass("Piles", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[89].Value;
        Main.tileSolid[229] = false;
        Main.tileSolid[190] = false;
        Main.tileSolid[196] = false;
        Main.tileSolid[189] = false;
        Main.tileSolid[202] = false;
        Main.tileSolid[460] = false;
        for (int index1 = 0; (double) index1 < (double) Main.maxTilesX * 0.06; ++index1)
        {
          int num2 = Main.maxTilesX / 2;
          bool flag = false;
          while (!flag && num2 > 0)
          {
            --num2;
            int index2 = WorldGen.genRand.Next(25, Main.maxTilesX - 25);
            int index3;
            for (index3 = WorldGen.genRand.Next((int) Main.worldSurface, Main.maxTilesY - 300); WorldGen.oceanDepths(index2, index3); index3 = WorldGen.genRand.Next((int) Main.worldSurface, Main.maxTilesY - 300))
              index2 = WorldGen.genRand.Next(25, Main.maxTilesX - 25);
            if (!Main.tile[index2, index3].active())
            {
              int Type = 186;
              while (!Main.tile[index2, index3 + 1].active() && index3 < Main.maxTilesY - 5)
                ++index3;
              int style = WorldGen.genRand.Next(22);
              switch (style)
              {
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                  style = WorldGen.genRand.Next(22);
                  break;
              }
              if ((Main.tile[index2, index3 + 1].type == (ushort) 0 || Main.tile[index2, index3 + 1].type == (ushort) 1 || Main.tileMoss[(int) Main.tile[index2, index3 + 1].type]) && WorldGen.genRand.Next(5) == 0)
              {
                style = WorldGen.genRand.Next(23, 29);
                Type = 187;
              }
              if (index3 > Main.maxTilesY - 300 || Main.wallDungeon[(int) Main.tile[index2, index3].wall] || (Main.tile[index2, index3 + 1].type == (ushort) 30 || Main.tile[index2, index3 + 1].type == (ushort) 19) || (Main.tile[index2, index3 + 1].type == (ushort) 25 || Main.tile[index2, index3 + 1].type == (ushort) 203))
              {
                style = WorldGen.genRand.Next(7);
                Type = 186;
              }
              if (Main.tile[index2, index3 + 1].type == (ushort) 147 || Main.tile[index2, index3 + 1].type == (ushort) 161 || Main.tile[index2, index3 + 1].type == (ushort) 162)
              {
                style = WorldGen.genRand.Next(26, 32);
                Type = 186;
              }
              if (Main.tile[index2, index3 + 1].type == (ushort) 60)
              {
                Type = 187;
                style = WorldGen.genRand.Next(6);
              }
              if ((Main.tile[index2, index3 + 1].type == (ushort) 57 || Main.tile[index2, index3 + 1].type == (ushort) 58) && WorldGen.genRand.Next(3) < 2)
              {
                Type = 187;
                style = WorldGen.genRand.Next(6, 9);
              }
              if (Main.tile[index2, index3 + 1].type == (ushort) 226)
              {
                Type = 187;
                style = WorldGen.genRand.Next(18, 23);
              }
              if (Main.tile[index2, index3 + 1].type == (ushort) 70)
              {
                style = WorldGen.genRand.Next(32, 35);
                Type = 186;
              }
              if (Main.tile[index2, index3 + 1].type == (ushort) 396 || Main.tile[index2, index3 + 1].type == (ushort) 397 || Main.tile[index2, index3 + 1].type == (ushort) 404)
              {
                style = WorldGen.genRand.Next(29, 35);
                Type = 187;
              }
              if (Main.tile[index2, index3 + 1].type == (ushort) 368)
              {
                style = WorldGen.genRand.Next(35, 41);
                Type = 187;
              }
              if (Main.tile[index2, index3 + 1].type == (ushort) 367)
              {
                style = WorldGen.genRand.Next(41, 47);
                Type = 187;
              }
              if (Type == 186 && style >= 7 && (style <= 15 && WorldGen.genRand.Next(75) == 0))
              {
                Type = 187;
                style = 17;
              }
              if (Main.wallDungeon[(int) Main.tile[index2, index3].wall] && WorldGen.genRand.Next(3) != 0)
              {
                flag = true;
              }
              else
              {
                WorldGen.PlaceTile(index2, index3, Type, true, false, -1, style);
                if (Main.tile[index2, index3].type == (ushort) 186 || Main.tile[index2, index3].type == (ushort) 187)
                  flag = true;
                if (flag && Type == 186 && style <= 7)
                {
                  int num3 = WorldGen.genRand.Next(1, 5);
                  for (int index4 = 0; index4 < num3; ++index4)
                  {
                    int i = index2 + WorldGen.genRand.Next(-10, 11);
                    int j = index3 - WorldGen.genRand.Next(5);
                    if (!Main.tile[i, j].active())
                    {
                      while (!Main.tile[i, j + 1].active() && j < Main.maxTilesY - 5)
                        ++j;
                      int X = WorldGen.genRand.Next(12, 36);
                      WorldGen.PlaceSmallPile(i, j, X, 0, (ushort) 185);
                    }
                  }
                }
              }
            }
          }
        }
        for (int index1 = 0; (double) index1 < (double) Main.maxTilesX * 0.01; ++index1)
        {
          int num2 = Main.maxTilesX / 2;
          bool flag = false;
          while (!flag && num2 > 0)
          {
            --num2;
            int i1 = WorldGen.genRand.Next(25, Main.maxTilesX - 25);
            int j1 = WorldGen.genRand.Next(Main.maxTilesY - 300, Main.maxTilesY - 10);
            if (!Main.tile[i1, j1].active())
            {
              int Type = 186;
              while (!Main.tile[i1, j1 + 1].active() && j1 < Main.maxTilesY - 5)
                ++j1;
              int style = WorldGen.genRand.Next(22);
              switch (style)
              {
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                  style = WorldGen.genRand.Next(22);
                  break;
              }
              if (j1 > Main.maxTilesY - 300 || Main.wallDungeon[(int) Main.tile[i1, j1].wall] || (Main.tile[i1, j1 + 1].type == (ushort) 30 || Main.tile[i1, j1 + 1].type == (ushort) 19))
                style = WorldGen.genRand.Next(7);
              if ((Main.tile[i1, j1 + 1].type == (ushort) 57 || Main.tile[i1, j1 + 1].type == (ushort) 58) && WorldGen.genRand.Next(3) < 2)
              {
                Type = 187;
                style = WorldGen.genRand.Next(6, 9);
              }
              if (Main.tile[i1, j1 + 1].type == (ushort) 147 || Main.tile[i1, j1 + 1].type == (ushort) 161 || Main.tile[i1, j1 + 1].type == (ushort) 162)
                style = WorldGen.genRand.Next(26, 32);
              WorldGen.PlaceTile(i1, j1, Type, true, false, -1, style);
              if (Main.tile[i1, j1].type == (ushort) 186 || Main.tile[i1, j1].type == (ushort) 187)
                flag = true;
              if (flag && Type == 186 && style <= 7)
              {
                int num3 = WorldGen.genRand.Next(1, 5);
                for (int index2 = 0; index2 < num3; ++index2)
                {
                  int i3 = i1 + WorldGen.genRand.Next(-10, 11);
                  int j2 = j1 - WorldGen.genRand.Next(5);
                  if (!Main.tile[i3, j2].active())
                  {
                    while (!Main.tile[i3, j2 + 1].active() && j2 < Main.maxTilesY - 5)
                      ++j2;
                    int X = WorldGen.genRand.Next(12, 36);
                    WorldGen.PlaceSmallPile(i3, j2, X, 0, (ushort) 185);
                  }
                }
              }
            }
          }
        }
        for (int index1 = 0; (double) index1 < (double) Main.maxTilesX * 0.003; ++index1)
        {
          int num2 = Main.maxTilesX / 2;
          bool flag = false;
          while (!flag && num2 > 0)
          {
            --num2;
            int Type = 186;
            int index2 = WorldGen.genRand.Next(25, Main.maxTilesX - 25);
            int index3;
            for (index3 = WorldGen.genRand.Next(10, (int) Main.worldSurface); WorldGen.oceanDepths(index2, index3); index3 = WorldGen.genRand.Next(10, (int) Main.worldSurface))
              index2 = WorldGen.genRand.Next(25, Main.maxTilesX - 25);
            if (!Main.tile[index2, index3].active())
            {
              while (!Main.tile[index2, index3 + 1].active() && index3 < Main.maxTilesY - 5)
                ++index3;
              int style = WorldGen.genRand.Next(7, 13);
              if (index3 > Main.maxTilesY - 300 || Main.wallDungeon[(int) Main.tile[index2, index3].wall] || (Main.tile[index2, index3 + 1].type == (ushort) 30 || Main.tile[index2, index3 + 1].type == (ushort) 19) || (Main.tile[index2, index3 + 1].type == (ushort) 25 || Main.tile[index2, index3 + 1].type == (ushort) 203 || (Main.tile[index2, index3 + 1].type == (ushort) 234 || Main.tile[index2, index3 + 1].type == (ushort) 112)))
                style = -1;
              if (Main.tile[index2, index3 + 1].type == (ushort) 147 || Main.tile[index2, index3 + 1].type == (ushort) 161 || Main.tile[index2, index3 + 1].type == (ushort) 162)
                style = WorldGen.genRand.Next(26, 32);
              if (Main.tile[index2, index3 + 1].type == (ushort) 53)
              {
                Type = 187;
                style = WorldGen.genRand.Next(52, 55);
              }
              if (Main.tile[index2, index3 + 1].type == (ushort) 2 || Main.tile[index2 - 1, index3 + 1].type == (ushort) 2 || Main.tile[index2 + 1, index3 + 1].type == (ushort) 2)
              {
                Type = 187;
                style = WorldGen.genRand.Next(14, 17);
              }
              if (Main.tile[index2, index3 + 1].type == (ushort) 151 || Main.tile[index2, index3 + 1].type == (ushort) 274)
              {
                Type = 186;
                style = WorldGen.genRand.Next(7);
              }
              if (style >= 0)
                WorldGen.PlaceTile(index2, index3, Type, true, false, -1, style);
              if ((int) Main.tile[index2, index3].type == Type)
                flag = true;
            }
          }
        }
        for (int index1 = 0; (double) index1 < (double) Main.maxTilesX * 0.0035; ++index1)
        {
          int num2 = Main.maxTilesX / 2;
          bool flag = false;
          while (!flag && num2 > 0)
          {
            --num2;
            int i1 = WorldGen.genRand.Next(25, Main.maxTilesX - 25);
            int j1 = WorldGen.genRand.Next(10, (int) Main.worldSurface);
            if (!Main.tile[i1, j1].active() && Main.tile[i1, j1].wall > (ushort) 0)
            {
              int Type = 186;
              while (!Main.tile[i1, j1 + 1].active() && j1 < Main.maxTilesY - 5)
                ++j1;
              int style = WorldGen.genRand.Next(7, 13);
              if (j1 > Main.maxTilesY - 300 || Main.wallDungeon[(int) Main.tile[i1, j1].wall] || (Main.tile[i1, j1 + 1].type == (ushort) 30 || Main.tile[i1, j1 + 1].type == (ushort) 19))
                style = -1;
              if (Main.tile[i1, j1 + 1].type == (ushort) 25)
                style = WorldGen.genRand.Next(7);
              if (Main.tile[i1, j1 + 1].type == (ushort) 147 || Main.tile[i1, j1 + 1].type == (ushort) 161 || Main.tile[i1, j1 + 1].type == (ushort) 162)
                style = WorldGen.genRand.Next(26, 32);
              if (Main.tile[i1, j1 + 1].type == (ushort) 2 || Main.tile[i1 - 1, j1 + 1].type == (ushort) 2 || Main.tile[i1 + 1, j1 + 1].type == (ushort) 2)
              {
                Type = 187;
                style = WorldGen.genRand.Next(14, 17);
              }
              if (Main.tile[i1, j1 + 1].type == (ushort) 151 || Main.tile[i1, j1 + 1].type == (ushort) 274)
              {
                Type = 186;
                style = WorldGen.genRand.Next(7);
              }
              if (style >= 0)
                WorldGen.PlaceTile(i1, j1, Type, true, false, -1, style);
              if ((int) Main.tile[i1, j1].type == Type)
                flag = true;
              if (flag && style <= 7)
              {
                int num3 = WorldGen.genRand.Next(1, 5);
                for (int index2 = 0; index2 < num3; ++index2)
                {
                  int i3 = i1 + WorldGen.genRand.Next(-10, 11);
                  int j2 = j1 - WorldGen.genRand.Next(5);
                  if (!Main.tile[i3, j2].active())
                  {
                    while (!Main.tile[i3, j2 + 1].active() && j2 < Main.maxTilesY - 5)
                      ++j2;
                    int X = WorldGen.genRand.Next(12, 36);
                    WorldGen.PlaceSmallPile(i3, j2, X, 0, (ushort) 185);
                  }
                }
              }
            }
          }
        }
        for (int index1 = 0; (double) index1 < (double) Main.maxTilesX * 0.6; ++index1)
        {
          int num2 = Main.maxTilesX / 2;
          bool flag = false;
          while (!flag && num2 > 0)
          {
            --num2;
            int index2 = WorldGen.genRand.Next(25, Main.maxTilesX - 25);
            int index3 = WorldGen.genRand.Next((int) Main.worldSurface, Main.maxTilesY - 20);
            if (Main.tile[index2, index3].wall == (ushort) 87 && WorldGen.genRand.Next(2) == 0)
            {
              index2 = WorldGen.genRand.Next(25, Main.maxTilesX - 25);
              index3 = WorldGen.genRand.Next((int) Main.worldSurface, Main.maxTilesY - 20);
            }
            for (; WorldGen.oceanDepths(index2, index3); index3 = WorldGen.genRand.Next((int) Main.worldSurface, Main.maxTilesY - 20))
              index2 = WorldGen.genRand.Next(25, Main.maxTilesX - 25);
            if (!Main.tile[index2, index3].active())
            {
              while (!Main.tile[index2, index3 + 1].active() && index3 < Main.maxTilesY - 5)
                ++index3;
              int Y = WorldGen.genRand.Next(2);
              int X1 = WorldGen.genRand.Next(36);
              switch (X1)
              {
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                case 33:
                case 34:
                case 35:
                  X1 = WorldGen.genRand.Next(36);
                  break;
              }
              if (Y == 1)
              {
                X1 = WorldGen.genRand.Next(25);
                switch (X1)
                {
                  case 16:
                  case 17:
                  case 18:
                  case 19:
                  case 20:
                  case 21:
                  case 22:
                  case 23:
                  case 24:
                    X1 = WorldGen.genRand.Next(25);
                    break;
                }
              }
              if (index3 > Main.maxTilesY - 300)
              {
                if (Y == 0)
                  X1 = WorldGen.genRand.Next(12, 28);
                if (Y == 1)
                  X1 = WorldGen.genRand.Next(6, 16);
              }
              if (Main.wallDungeon[(int) Main.tile[index2, index3].wall] || Main.tile[index2, index3 + 1].type == (ushort) 30 || (Main.tile[index2, index3 + 1].type == (ushort) 19 || Main.tile[index2, index3 + 1].type == (ushort) 25) || (Main.tile[index2, index3 + 1].type == (ushort) 203 || Main.tile[index2, index3].wall == (ushort) 87))
              {
                if (Y == 0 && X1 < 12)
                  X1 += 12;
                if (Y == 1 && X1 < 6)
                  X1 += 6;
                if (Y == 1 && X1 >= 17)
                  X1 -= 10;
              }
              if (Main.tile[index2, index3 + 1].type == (ushort) 147 || Main.tile[index2, index3 + 1].type == (ushort) 161 || Main.tile[index2, index3 + 1].type == (ushort) 162)
              {
                if (Y == 0 && X1 < 12)
                  X1 += 36;
                if (Y == 1 && X1 >= 20)
                  X1 += 6;
                if (Y == 1 && X1 < 6)
                  X1 += 25;
              }
              if (Main.tile[index2, index3 + 1].type == (ushort) 151 || Main.tile[index2, index3 + 1].type == (ushort) 274)
              {
                if (Y == 0)
                  X1 = WorldGen.genRand.Next(12, 28);
                if (Y == 1)
                  X1 = WorldGen.genRand.Next(12, 19);
              }
              if (Main.tile[index2, index3 + 1].type == (ushort) 368)
              {
                if (Y == 0)
                  X1 = WorldGen.genRand.Next(60, 66);
                if (Y == 1)
                  X1 = WorldGen.genRand.Next(47, 53);
              }
              if (Main.tile[index2, index3 + 1].type == (ushort) 367)
              {
                if (Y == 0)
                  X1 = WorldGen.genRand.Next(66, 72);
                if (Y == 1)
                  X1 = WorldGen.genRand.Next(53, 59);
              }
              flag = Main.wallDungeon[(int) Main.tile[index2, index3].wall] && WorldGen.genRand.Next(3) != 0 || WorldGen.PlaceSmallPile(index2, index3, X1, Y, (ushort) 185);
              if (flag && Y == 1 && (X1 >= 6 && X1 <= 15))
              {
                int num3 = WorldGen.genRand.Next(1, 5);
                for (int index4 = 0; index4 < num3; ++index4)
                {
                  int i = index2 + WorldGen.genRand.Next(-10, 11);
                  int j = index3 - WorldGen.genRand.Next(5);
                  if (!Main.tile[i, j].active())
                  {
                    while (!Main.tile[i, j + 1].active() && j < Main.maxTilesY - 5)
                      ++j;
                    int X2 = WorldGen.genRand.Next(12, 36);
                    WorldGen.PlaceSmallPile(i, j, X2, 0, (ushort) 185);
                  }
                }
              }
            }
          }
        }
        for (int index1 = 0; (double) index1 < (double) Main.maxTilesX * 0.0199999995529652; ++index1)
        {
          int num2 = Main.maxTilesX / 2;
          bool flag = false;
          while (!flag && num2 > 0)
          {
            --num2;
            int index2 = WorldGen.genRand.Next(25, Main.maxTilesX - 25);
            int index3;
            for (index3 = WorldGen.genRand.Next(15, (int) Main.worldSurface); WorldGen.oceanDepths(index2, index3); index3 = WorldGen.genRand.Next(15, (int) Main.worldSurface))
              index2 = WorldGen.genRand.Next(25, Main.maxTilesX - 25);
            if (!Main.tile[index2, index3].active())
            {
              while (!Main.tile[index2, index3 + 1].active() && index3 < Main.maxTilesY - 5)
                ++index3;
              int Y = WorldGen.genRand.Next(2);
              int X = WorldGen.genRand.Next(11);
              if (Y == 1)
                X = WorldGen.genRand.Next(5);
              if (Main.tile[index2, index3 + 1].type == (ushort) 147 || Main.tile[index2, index3 + 1].type == (ushort) 161 || Main.tile[index2, index3 + 1].type == (ushort) 162)
              {
                if (Y == 0 && X < 12)
                  X += 36;
                if (Y == 1 && X >= 20)
                  X += 6;
                if (Y == 1 && X < 6)
                  X += 25;
              }
              if (Main.tile[index2, index3 + 1].type == (ushort) 2 && Y == 1)
                X = WorldGen.genRand.Next(38, 41);
              if (Main.tile[index2, index3 + 1].type == (ushort) 151 || Main.tile[index2, index3 + 1].type == (ushort) 274)
              {
                if (Y == 0)
                  X = WorldGen.genRand.Next(12, 28);
                if (Y == 1)
                  X = WorldGen.genRand.Next(12, 19);
              }
              if (!Main.wallDungeon[(int) Main.tile[index2, index3].wall] && Main.tile[index2, index3 + 1].type != (ushort) 30 && (Main.tile[index2, index3 + 1].type != (ushort) 19 && Main.tile[index2, index3 + 1].type != (ushort) 41) && (Main.tile[index2, index3 + 1].type != (ushort) 43 && Main.tile[index2, index3 + 1].type != (ushort) 44 && (Main.tile[index2, index3 + 1].type != (ushort) 481 && Main.tile[index2, index3 + 1].type != (ushort) 482)) && (Main.tile[index2, index3 + 1].type != (ushort) 483 && Main.tile[index2, index3 + 1].type != (ushort) 45 && (Main.tile[index2, index3 + 1].type != (ushort) 46 && Main.tile[index2, index3 + 1].type != (ushort) 47) && (Main.tile[index2, index3 + 1].type != (ushort) 175 && Main.tile[index2, index3 + 1].type != (ushort) 176 && (Main.tile[index2, index3 + 1].type != (ushort) 177 && Main.tile[index2, index3 + 1].type != (ushort) 53))) && (Main.tile[index2, index3 + 1].type != (ushort) 25 && Main.tile[index2, index3 + 1].type != (ushort) 203))
                flag = WorldGen.PlaceSmallPile(index2, index3, X, Y, (ushort) 185);
            }
          }
        }
        for (int index = 0; (double) index < (double) Main.maxTilesX * 0.150000005960464; ++index)
        {
          int num2 = Main.maxTilesX / 2;
          bool flag = false;
          while (!flag && num2 > 0)
          {
            --num2;
            int i = WorldGen.genRand.Next(25, Main.maxTilesX - 25);
            int j = WorldGen.genRand.Next(15, (int) Main.worldSurface);
            if (!Main.tile[i, j].active() && (Main.tile[i, j].wall == (ushort) 2 || Main.tile[i, j].wall == (ushort) 40))
            {
              while (!Main.tile[i, j + 1].active() && j < Main.maxTilesY - 5)
                ++j;
              int Y = WorldGen.genRand.Next(2);
              int X = WorldGen.genRand.Next(11);
              if (Y == 1)
                X = WorldGen.genRand.Next(5);
              if (Main.tile[i, j + 1].type == (ushort) 147 || Main.tile[i, j + 1].type == (ushort) 161 || Main.tile[i, j + 1].type == (ushort) 162)
              {
                if (Y == 0 && X < 12)
                  X += 36;
                if (Y == 1 && X >= 20)
                  X += 6;
                if (Y == 1 && X < 6)
                  X += 25;
              }
              if (Main.tile[i, j + 1].type == (ushort) 2 && Y == 1)
                X = WorldGen.genRand.Next(38, 41);
              if (Main.tile[i, j + 1].type == (ushort) 151 || Main.tile[i, j + 1].type == (ushort) 274)
              {
                if (Y == 0)
                  X = WorldGen.genRand.Next(12, 28);
                if (Y == 1)
                  X = WorldGen.genRand.Next(12, 19);
              }
              if ((Main.tile[i, j].liquid != byte.MaxValue || Main.tile[i, j + 1].type != (ushort) 53 || Main.tile[i, j].wall != (ushort) 0) && (!Main.wallDungeon[(int) Main.tile[i, j].wall] && Main.tile[i, j + 1].type != (ushort) 30 && (Main.tile[i, j + 1].type != (ushort) 19 && Main.tile[i, j + 1].type != (ushort) 41)) && (Main.tile[i, j + 1].type != (ushort) 43 && Main.tile[i, j + 1].type != (ushort) 44 && (Main.tile[i, j + 1].type != (ushort) 481 && Main.tile[i, j + 1].type != (ushort) 482) && (Main.tile[i, j + 1].type != (ushort) 483 && Main.tile[i, j + 1].type != (ushort) 45 && (Main.tile[i, j + 1].type != (ushort) 46 && Main.tile[i, j + 1].type != (ushort) 47))) && (Main.tile[i, j + 1].type != (ushort) 175 && Main.tile[i, j + 1].type != (ushort) 176 && (Main.tile[i, j + 1].type != (ushort) 177 && Main.tile[i, j + 1].type != (ushort) 25) && Main.tile[i, j + 1].type != (ushort) 203))
                flag = WorldGen.PlaceSmallPile(i, j, X, Y, (ushort) 185);
            }
          }
        }
        Main.tileSolid[190] = true;
        Main.tileSolid[192] = true;
        Main.tileSolid[196] = true;
        Main.tileSolid[189] = true;
        Main.tileSolid[202] = true;
        Main.tileSolid[225] = true;
        Main.tileSolid[460] = true;
      }));
      WorldGen.AddGenerationPass("Spawn Point", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Set(1f);
        int num2 = 5;
        bool flag = true;
        while (flag)
        {
          int index1 = Main.maxTilesX / 2 + WorldGen.genRand.Next(-num2, num2 + 1);
          for (int index2 = 0; index2 < Main.maxTilesY; ++index2)
          {
            if (Main.tile[index1, index2].active())
            {
              Main.spawnTileX = index1;
              Main.spawnTileY = index2;
              break;
            }
          }
          flag = false;
          ++num2;
          if ((double) Main.spawnTileY > Main.worldSurface)
            flag = true;
          if (Main.tile[Main.spawnTileX, Main.spawnTileY - 1].liquid > (byte) 0)
            flag = true;
        }
        int num3 = 10;
        while ((double) Main.spawnTileY > Main.worldSurface)
        {
          int index1 = WorldGen.genRand.Next(Main.maxTilesX / 2 - num3, Main.maxTilesX / 2 + num3);
          for (int index2 = 0; index2 < Main.maxTilesY; ++index2)
          {
            if (Main.tile[index1, index2].active())
            {
              Main.spawnTileX = index1;
              Main.spawnTileY = index2;
              break;
            }
          }
          ++num3;
        }
      }));
      WorldGen.AddGenerationPass("Grass Wall", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        WorldGen.maxTileCount = 3500;
        progress.Set(1f);
        for (int index1 = 50; index1 < Main.maxTilesX - 50; ++index1)
        {
          for (int index2 = 0; (double) index2 < Main.worldSurface - 10.0; ++index2)
          {
            if (WorldGen.genRand.Next(4) == 0)
            {
              bool flag = false;
              int x = -1;
              int y = -1;
              if (Main.tile[index1, index2].active() && Main.tile[index1, index2].type == (ushort) 2 && (Main.tile[index1, index2].wall == (ushort) 2 || Main.tile[index1, index2].wall == (ushort) 63))
              {
                for (int i = index1 - 1; i <= index1 + 1; ++i)
                {
                  for (int j = index2 - 1; j <= index2 + 1; ++j)
                  {
                    if (Main.tile[i, j].wall == (ushort) 0 && !WorldGen.SolidTile(i, j, false))
                      flag = true;
                  }
                }
                if (flag)
                {
                  for (int i = index1 - 1; i <= index1 + 1; ++i)
                  {
                    for (int j = index2 - 1; j <= index2 + 1; ++j)
                    {
                      if ((Main.tile[i, j].wall == (ushort) 2 || Main.tile[i, j].wall == (ushort) 15) && !WorldGen.SolidTile(i, j, false))
                      {
                        x = i;
                        y = j;
                      }
                    }
                  }
                }
              }
              if (flag && x > -1 && y > -1)
              {
                if (WorldGen.countDirtTiles(x, y) < WorldGen.maxTileCount)
                {
                  try
                  {
                    WorldGen.Spread.Wall2(x, y, 63);
                  }
                  catch
                  {
                  }
                }
              }
            }
          }
        }
        for (int i = 5; i < Main.maxTilesX - 5; ++i)
        {
          for (int j = 10; (double) j < Main.worldSurface - 1.0; ++j)
          {
            if (Main.tile[i, j].wall == (ushort) 63 && WorldGen.genRand.Next(10) == 0)
              Main.tile[i, j].wall = (ushort) 65;
            if (Main.tile[i, j].active() && Main.tile[i, j].type == (ushort) 0)
            {
              bool flag = false;
              for (int index1 = i - 1; index1 <= i + 1; ++index1)
              {
                for (int index2 = j - 1; index2 <= j + 1; ++index2)
                {
                  if (Main.tile[index1, index2].wall == (ushort) 63 || Main.tile[index1, index2].wall == (ushort) 65)
                  {
                    flag = true;
                    break;
                  }
                }
              }
              if (flag)
                WorldGen.SpreadGrass(i, j, 0, 2, true, (byte) 0);
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Guide", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Set(1f);
        if (WorldGen.getGoodWorldGen)
        {
          int index = NPC.NewNPC(Main.spawnTileX * 16, Main.spawnTileY * 16, 38, 0, 0.0f, 0.0f, 0.0f, 0.0f, (int) byte.MaxValue);
          Main.npc[index].homeTileX = Main.spawnTileX;
          Main.npc[index].homeTileY = Main.spawnTileY;
          Main.npc[index].direction = 1;
          Main.npc[index].homeless = true;
        }
        else if (WorldGen.drunkWorldGen)
        {
          int index = NPC.NewNPC(Main.spawnTileX * 16, Main.spawnTileY * 16, 208, 0, 0.0f, 0.0f, 0.0f, 0.0f, (int) byte.MaxValue);
          Main.npc[index].homeTileX = Main.spawnTileX;
          Main.npc[index].homeTileY = Main.spawnTileY;
          Main.npc[index].direction = 1;
          Main.npc[index].homeless = true;
        }
        else if (WorldGen.notTheBees)
        {
          int index = NPC.NewNPC(Main.spawnTileX * 16, Main.spawnTileY * 16, 17, 0, 0.0f, 0.0f, 0.0f, 0.0f, (int) byte.MaxValue);
          Main.npc[index].homeTileX = Main.spawnTileX;
          Main.npc[index].homeTileY = Main.spawnTileY;
          Main.npc[index].direction = 1;
          Main.npc[index].homeless = true;
        }
        else
        {
          int index = NPC.NewNPC(Main.spawnTileX * 16, Main.spawnTileY * 16, 22, 0, 0.0f, 0.0f, 0.0f, 0.0f, (int) byte.MaxValue);
          Main.npc[index].homeTileX = Main.spawnTileX;
          Main.npc[index].homeTileY = Main.spawnTileY;
          Main.npc[index].direction = 1;
          Main.npc[index].homeless = true;
        }
      }));
      WorldGen.AddGenerationPass("Sunflowers", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[39].Value;
        for (int index1 = 0; (double) index1 < (double) Main.maxTilesX * 0.002; ++index1)
        {
          progress.Set((float) ((double) index1 / (double) Main.maxTilesX * (1.0 / 500.0)));
          int num2 = Main.maxTilesX / 2;
          int num3 = WorldGen.genRand.Next(Main.maxTilesX);
          int num4 = num3 - WorldGen.genRand.Next(10) - 7;
          int num5 = num3 + WorldGen.genRand.Next(10) + 7;
          if (num4 < 0)
            num4 = 0;
          if (num5 > Main.maxTilesX - 1)
            num5 = Main.maxTilesX - 1;
          for (int i = num4; i < num5; ++i)
          {
            for (int index2 = 1; (double) index2 < Main.worldSurface - 1.0; ++index2)
            {
              if (Main.tile[i, index2].type == (ushort) 2 && Main.tile[i, index2].active() && !Main.tile[i, index2 - 1].active())
                WorldGen.PlaceTile(i, index2 - 1, 27, true, false, -1, 0);
              if (Main.tile[i, index2].active())
                break;
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Planting Trees", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[40].Value;
        if (!WorldGen.drunkWorldGen)
        {
          for (int index = 0; (double) index < (double) Main.maxTilesX * 0.003; ++index)
          {
            progress.Set((float) ((double) index / (double) Main.maxTilesX * (3.0 / 1000.0)));
            int num2 = WorldGen.genRand.Next(50, Main.maxTilesX - 50);
            int num3 = WorldGen.genRand.Next(25, 50);
            for (int i = num2 - num3; i < num2 + num3; ++i)
            {
              for (int y = 20; (double) y < Main.worldSurface; ++y)
                WorldGen.GrowEpicTree(i, y);
            }
          }
        }
        WorldGen.AddTrees();
      }));
      WorldGen.AddGenerationPass("Herbs", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[41].Value;
        for (int index = 0; (double) index < (double) Main.maxTilesX * 1.7; ++index)
        {
          progress.Set((float) ((double) index / (double) Main.maxTilesX * 1.70000004768372));
          WorldGen.PlantAlch();
        }
      }));
      WorldGen.AddGenerationPass("Dye Plants", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Set(1f);
        for (int index = 0; index < Main.maxTilesX; ++index)
          WorldGen.plantDye(WorldGen.genRand.Next(100, Main.maxTilesX - 100), WorldGen.genRand.Next(100, Main.UnderworldLayer), false);
        WorldGen.MatureTheHerbPlants();
      }));
      WorldGen.AddGenerationPass("Webs And Honey", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Set(1f);
        for (int index = 100; index < Main.maxTilesX - 100; ++index)
        {
          for (int worldSurface1 = (int) Main.worldSurface; worldSurface1 < Main.maxTilesY - 100; ++worldSurface1)
          {
            if (Main.tile[index, worldSurface1].wall == (ushort) 86)
            {
              if (Main.tile[index, worldSurface1].liquid > (byte) 0)
                Main.tile[index, worldSurface1].honey(true);
              if (WorldGen.genRand.Next(3) == 0)
                WorldGen.PlaceTight(index, worldSurface1, false);
            }
            if (Main.tile[index, worldSurface1].wall == (ushort) 62)
            {
              Main.tile[index, worldSurface1].liquid = (byte) 0;
              Main.tile[index, worldSurface1].lava(false);
            }
            if (Main.tile[index, worldSurface1].wall == (ushort) 62 && !Main.tile[index, worldSurface1].active() && WorldGen.genRand.Next(10) != 0)
            {
              int num2 = WorldGen.genRand.Next(2, 5);
              int num3 = index - num2;
              int num4 = index + num2;
              int num5 = worldSurface1 - num2;
              int num6 = worldSurface1 + num2;
              bool flag = false;
              for (int i = num3; i <= num4; ++i)
              {
                for (int j = num5; j <= num6; ++j)
                {
                  if (WorldGen.SolidTile(i, j, false))
                  {
                    flag = true;
                    break;
                  }
                }
              }
              if (flag)
              {
                WorldGen.PlaceTile(index, worldSurface1, 51, true, false, -1, 0);
                WorldGen.TileFrame(index, worldSurface1, false, false);
              }
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Weeds", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[42].Value;
        if (Main.halloween)
        {
          for (int index1 = 40; index1 < Main.maxTilesX - 40; ++index1)
          {
            for (int index2 = 50; (double) index2 < Main.worldSurface; ++index2)
            {
              if (Main.tile[index1, index2].active() && Main.tile[index1, index2].type == (ushort) 2 && WorldGen.genRand.Next(15) == 0)
              {
                WorldGen.PlacePumpkin(index1, index2 - 1);
                int num2 = WorldGen.genRand.Next(5);
                for (int index3 = 0; index3 < num2; ++index3)
                  WorldGen.GrowPumpkin(index1, index2 - 1, 254);
              }
            }
          }
        }
        for (int i = 0; i < Main.maxTilesX; ++i)
        {
          progress.Set((float) i / (float) Main.maxTilesX);
          for (int index = 1; index < Main.maxTilesY; ++index)
          {
            if (Main.tile[i, index].type == (ushort) 2 && Main.tile[i, index].nactive())
            {
              if (!Main.tile[i, index - 1].active())
                WorldGen.PlaceTile(i, index - 1, 3, true, false, -1, 0);
            }
            else if (Main.tile[i, index].type == (ushort) 23 && Main.tile[i, index].nactive())
            {
              if (!Main.tile[i, index - 1].active())
                WorldGen.PlaceTile(i, index - 1, 24, true, false, -1, 0);
            }
            else if (Main.tile[i, index].type == (ushort) 199 && Main.tile[i, index].nactive() && !Main.tile[i, index - 1].active())
              WorldGen.PlaceTile(i, index - 1, 201, true, false, -1, 0);
          }
        }
      }));
      WorldGen.AddGenerationPass("Glowing Mushrooms and Jungle Plants", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Set(1f);
        for (int i = 0; i < Main.maxTilesX; ++i)
        {
          for (int y = 0; y < Main.maxTilesY; ++y)
          {
            if (Main.tile[i, y].active())
            {
              if (y >= (int) Main.worldSurface && Main.tile[i, y].type == (ushort) 70 && !Main.tile[i, y - 1].active())
              {
                WorldGen.GrowTree(i, y);
                if (!Main.tile[i, y - 1].active())
                {
                  WorldGen.GrowTree(i, y);
                  if (!Main.tile[i, y - 1].active())
                  {
                    WorldGen.GrowShroom(i, y);
                    if (!Main.tile[i, y - 1].active())
                      WorldGen.PlaceTile(i, y - 1, 71, true, false, -1, 0);
                  }
                }
              }
              if (Main.tile[i, y].type == (ushort) 60 && !Main.tile[i, y - 1].active())
                WorldGen.PlaceTile(i, y - 1, 61, true, false, -1, 0);
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Jungle Plants", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Set(1f);
        for (int index1 = 0; index1 < Main.maxTilesX * 100; ++index1)
        {
          int X2 = WorldGen.genRand.Next(40, Main.maxTilesX / 2 - 40);
          if (dungeonSide < 0)
            X2 += Main.maxTilesX / 2;
          int index2 = WorldGen.genRand.Next(Main.maxTilesY - 300);
          while (!Main.tile[X2, index2].active() && index2 < Main.maxTilesY - 300)
            ++index2;
          if (Main.tile[X2, index2].active() && Main.tile[X2, index2].type == (ushort) 60)
          {
            int Y2 = index2 - 1;
            WorldGen.PlaceJunglePlant(X2, Y2, (ushort) 233, WorldGen.genRand.Next(8), 0);
            if (Main.tile[X2, Y2].type != (ushort) 233)
              WorldGen.PlaceJunglePlant(X2, Y2, (ushort) 233, WorldGen.genRand.Next(12), 1);
          }
        }
      }));
      WorldGen.AddGenerationPass("Vines", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[43].Value;
        for (int index1 = 5; index1 < Main.maxTilesX - 5; ++index1)
        {
          progress.Set((float) index1 / (float) Main.maxTilesX);
          int num2 = 0;
          ushort num3 = 52;
          for (int y = 0; (double) y < Main.worldSurface; ++y)
          {
            if (num2 > 0 && !Main.tile[index1, y].active())
            {
              Main.tile[index1, y].active(true);
              Main.tile[index1, y].type = num3;
              Main.tile[index1, y].color(Main.tile[index1, y - 1].color());
              --num2;
            }
            else
              num2 = 0;
            if (Main.tile[index1, y].active() && !Main.tile[index1, y].bottomSlope() && (Main.tile[index1, y].type == (ushort) 2 || Main.tile[index1, y].type == (ushort) 192 && WorldGen.genRand.Next(4) == 0) && WorldGen.GrowMoreVines(index1, y))
            {
              num3 = (ushort) 52;
              if (Main.tile[index1, y].wall == (ushort) 68 || Main.tile[index1, y].wall == (ushort) 65 || (Main.tile[index1, y].wall == (ushort) 66 || Main.tile[index1, y].wall == (ushort) 63))
                num3 = (ushort) 382;
              else if (Main.tile[index1, y + 1].wall == (ushort) 68 || Main.tile[index1, y + 1].wall == (ushort) 65 || (Main.tile[index1, y + 1].wall == (ushort) 66 || Main.tile[index1, y + 1].wall == (ushort) 63))
                num3 = (ushort) 382;
              if (WorldGen.genRand.Next(5) < 3)
                num2 = WorldGen.genRand.Next(1, 10);
            }
          }
          int num4 = 0;
          for (int index2 = 5; index2 < Main.maxTilesY - 5; ++index2)
          {
            if (num4 > 0 && !Main.tile[index1, index2].active())
            {
              Main.tile[index1, index2].active(true);
              Main.tile[index1, index2].type = (ushort) 62;
              --num4;
            }
            else
              num4 = 0;
            if (Main.tile[index1, index2].active() && Main.tile[index1, index2].type == (ushort) 60 && (!Main.tile[index1, index2].bottomSlope() && WorldGen.GrowMoreVines(index1, index2)))
            {
              if (WorldGen.notTheBees && index2 < Main.maxTilesY - 10 && (Main.tile[index1, index2 - 1].active() && !Main.tile[index1, index2 - 1].bottomSlope()) && (Main.tile[index1 + 1, index2 - 1].active() && !Main.tile[index1 + 1, index2 - 1].bottomSlope()) && (Main.tile[index1, index2 - 1].type == (ushort) 60 || Main.tile[index1, index2 - 1].type == (ushort) 444 || Main.tile[index1, index2 - 1].type == (ushort) 230))
              {
                bool flag = true;
                for (int index3 = index1; index3 < index1 + 2; ++index3)
                {
                  for (int index4 = index2 + 1; index4 < index2 + 3; ++index4)
                  {
                    if (Main.tile[index3, index4].active() && (!Main.tileCut[(int) Main.tile[index3, index4].type] || Main.tile[index3, index4].type == (ushort) 444))
                    {
                      flag = false;
                      break;
                    }
                    if (Main.tile[index3, index4].liquid > (byte) 0 || Main.wallHouse[(int) Main.tile[index3, index4].wall])
                    {
                      flag = false;
                      break;
                    }
                  }
                  if (!flag)
                    break;
                }
                if (flag)
                {
                  if (WorldGen.CountNearBlocksTypes(index1, index2, WorldGen.genRand.Next(3, 10), 1, 444) > 0)
                    flag = false;
                }
                if (flag)
                {
                  for (int i = index1; i < index1 + 2; ++i)
                  {
                    for (int j = index2 + 1; j < index2 + 3; ++j)
                      WorldGen.KillTile(i, j, false, false, false);
                  }
                  for (int index3 = index1; index3 < index1 + 2; ++index3)
                  {
                    for (int index4 = index2 + 1; index4 < index2 + 3; ++index4)
                    {
                      Main.tile[index3, index4].active(true);
                      Main.tile[index3, index4].type = (ushort) 444;
                      Main.tile[index3, index4].frameX = (short) ((index3 - index1) * 18);
                      Main.tile[index3, index4].frameY = (short) ((index4 - index2 - 1) * 18);
                    }
                  }
                  continue;
                }
              }
              else if (index1 < Main.maxTilesX - 1 && index2 < Main.maxTilesY - 2 && (Main.tile[index1 + 1, index2].active() && Main.tile[index1 + 1, index2].type == (ushort) 60) && (!Main.tile[index1 + 1, index2].bottomSlope() && WorldGen.genRand.Next(40) == 0))
              {
                bool flag = true;
                for (int index3 = index1; index3 < index1 + 2; ++index3)
                {
                  for (int index4 = index2 + 1; index4 < index2 + 3; ++index4)
                  {
                    if (Main.tile[index3, index4].active() && (!Main.tileCut[(int) Main.tile[index3, index4].type] || Main.tile[index3, index4].type == (ushort) 444))
                    {
                      flag = false;
                      break;
                    }
                    if (Main.tile[index3, index4].liquid > (byte) 0 || Main.wallHouse[(int) Main.tile[index3, index4].wall])
                    {
                      flag = false;
                      break;
                    }
                  }
                  if (!flag)
                    break;
                }
                if (flag)
                {
                  if (WorldGen.CountNearBlocksTypes(index1, index2, 20, 1, 444) > 0)
                    flag = false;
                }
                if (flag)
                {
                  for (int i = index1; i < index1 + 2; ++i)
                  {
                    for (int j = index2 + 1; j < index2 + 3; ++j)
                      WorldGen.KillTile(i, j, false, false, false);
                  }
                  for (int index3 = index1; index3 < index1 + 2; ++index3)
                  {
                    for (int index4 = index2 + 1; index4 < index2 + 3; ++index4)
                    {
                      Main.tile[index3, index4].active(true);
                      Main.tile[index3, index4].type = (ushort) 444;
                      Main.tile[index3, index4].frameX = (short) ((index3 - index1) * 18);
                      Main.tile[index3, index4].frameY = (short) ((index4 - index2 - 1) * 18);
                    }
                  }
                  continue;
                }
              }
              if (WorldGen.genRand.Next(5) < 3)
                num4 = WorldGen.genRand.Next(1, 10);
            }
          }
          int num5 = 0;
          for (int y = 0; y < Main.maxTilesY; ++y)
          {
            if (num5 > 0 && !Main.tile[index1, y].active())
            {
              Main.tile[index1, y].active(true);
              Main.tile[index1, y].type = (ushort) 528;
              --num5;
            }
            else
              num5 = 0;
            if (Main.tile[index1, y].active() && Main.tile[index1, y].type == (ushort) 70 && (WorldGen.genRand.Next(5) == 0 && !Main.tile[index1, y].bottomSlope()) && (WorldGen.GrowMoreVines(index1, y) && WorldGen.genRand.Next(5) < 3))
              num5 = WorldGen.genRand.Next(1, 10);
          }
          int num6 = 0;
          for (int y = 0; y < Main.maxTilesY; ++y)
          {
            if (num6 > 0 && !Main.tile[index1, y].active())
            {
              Main.tile[index1, y].active(true);
              Main.tile[index1, y].type = (ushort) 205;
              --num6;
            }
            else
              num6 = 0;
            if (Main.tile[index1, y].active() && !Main.tile[index1, y].bottomSlope() && (Main.tile[index1, y].type == (ushort) 199 && WorldGen.GrowMoreVines(index1, y)) && WorldGen.genRand.Next(5) < 3)
              num6 = WorldGen.genRand.Next(1, 10);
          }
        }
      }));
      WorldGen.AddGenerationPass("Flowers", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[44].Value;
        for (int index1 = 0; (double) index1 < (double) Main.maxTilesX * 0.004; ++index1)
        {
          progress.Set((float) ((double) index1 / (double) Main.maxTilesX * 0.00400000018998981));
          int index2 = WorldGen.genRand.Next(32, Main.maxTilesX - 32);
          int num2 = WorldGen.genRand.Next(15, 30);
          int num3 = WorldGen.genRand.Next(15, 30);
          for (int index3 = num3; (double) index3 < Main.worldSurface - (double) num3 - 1.0; ++index3)
          {
            if (Main.tile[index2, index3].active())
            {
              if (logX >= 0)
              {
                index2 = logX;
                index3 = logY;
                logX = -1;
              }
              int num4 = WorldGen.genRand.NextFromList<int>(21, 24, 27, 30, 33, 36, 39, 42);
              for (int i = index2 - num2; i < index2 + num2; ++i)
              {
                for (int j = index3 - num3; j < index3 + num3; ++j)
                {
                  if (Main.tile[i, j].type != (ushort) 488 && !Main.tileSolid[(int) Main.tile[i, j].type])
                  {
                    if (Main.tile[i, j].type == (ushort) 3)
                    {
                      Main.tile[i, j].frameX = (short) ((num4 + WorldGen.genRand.Next(3)) * 18);
                      if (WorldGen.genRand.Next(3) != 0)
                        Main.tile[i, j].type = (ushort) 73;
                    }
                    else if (Main.tile[i, j + 1].wall == (ushort) 0 && (Main.tile[i, j + 1].type == (ushort) 2 || (Main.tile[i, j + 1].type == (ushort) 40 || Main.tile[i, j + 1].type == (ushort) 1 || TileID.Sets.Ore[(int) Main.tile[i, j + 1].type]) && !Main.tile[i, j].active()) && (!Main.tile[i, j].active() || Main.tile[i, j].type == (ushort) 185 || (Main.tile[i, j].type == (ushort) 186 || Main.tile[i, j].type == (ushort) 187) || (Main.tile[i, j].type == (ushort) 5 && (double) i < (double) Main.maxTilesX * 0.48 || (double) i > (double) Main.maxTilesX * 0.52)))
                    {
                      if (Main.tile[i, j + 1].type == (ushort) 40 || Main.tile[i, j + 1].type == (ushort) 1 || TileID.Sets.Ore[(int) Main.tile[i, j + 1].type])
                      {
                        Main.tile[i, j + 1].type = (ushort) 2;
                        if (Main.tile[i, j + 2].type == (ushort) 40 || Main.tile[i, j + 2].type == (ushort) 1 || TileID.Sets.Ore[(int) Main.tile[i, j + 2].type])
                          Main.tile[i, j + 2].type = (ushort) 2;
                      }
                      WorldGen.KillTile(i, j, false, false, false);
                      if (WorldGen.genRand.Next(2) == 0)
                      {
                        Main.tile[i, j + 1].slope((byte) 0);
                        Main.tile[i, j + 1].halfBrick(false);
                      }
                      WorldGen.PlaceTile(i, j, 3, false, false, -1, 0);
                      if (Main.tile[i, j].active() && Main.tile[i, j].type == (ushort) 3)
                      {
                        Main.tile[i, j].frameX = (short) ((num4 + WorldGen.genRand.Next(3)) * 18);
                        if (WorldGen.genRand.Next(3) != 0)
                          Main.tile[i, j].type = (ushort) 73;
                      }
                      if (Main.tile[i, j + 2].type == (ushort) 40 || Main.tile[i, j + 2].type == (ushort) 1 || TileID.Sets.Ore[(int) Main.tile[i, j + 2].type])
                        Main.tile[i, j + 2].type = (ushort) 0;
                    }
                  }
                }
              }
              break;
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Mushrooms", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[45].Value;
        for (int index1 = 0; (double) index1 < (double) Main.maxTilesX * 0.002; ++index1)
        {
          progress.Set((float) ((double) index1 / (double) Main.maxTilesX * (1.0 / 500.0)));
          int index2 = WorldGen.genRand.Next(20, Main.maxTilesX - 20);
          int num2 = WorldGen.genRand.Next(4, 10);
          int num3 = WorldGen.genRand.Next(15, 30);
          for (int index3 = 1; (double) index3 < Main.worldSurface - 1.0; ++index3)
          {
            if (Main.tile[index2, index3].active())
            {
              for (int index4 = index2 - num2; index4 < index2 + num2; ++index4)
              {
                for (int index5 = index3 - num3; index5 < index3 + num3 && (index4 >= 10 && index5 >= 0) && (index4 <= Main.maxTilesX - 10 && index5 <= Main.maxTilesY - 10); ++index5)
                {
                  if (Main.tile[index4, index5].type == (ushort) 3 || Main.tile[index4, index5].type == (ushort) 24)
                    Main.tile[index4, index5].frameX = (short) 144;
                  else if (Main.tile[index4, index5].type == (ushort) 201)
                    Main.tile[index4, index5].frameX = (short) 270;
                }
              }
              break;
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Gems In Ice Biome", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Set(1f);
        for (int index1 = 0; (double) index1 < (double) Main.maxTilesX * 0.25; ++index1)
        {
          int index2 = WorldGen.genRand.Next((int) (Main.worldSurface + Main.rockLayer) / 2, WorldGen.lavaLine);
          int index3 = WorldGen.genRand.Next(snowMinX[index2], snowMaxX[index2]);
          if (Main.tile[index3, index2].active() && (Main.tile[index3, index2].type == (ushort) 147 || Main.tile[index3, index2].type == (ushort) 161 || (Main.tile[index3, index2].type == (ushort) 162 || Main.tile[index3, index2].type == (ushort) 224)))
          {
            int num2 = WorldGen.genRand.Next(1, 4);
            int num3 = WorldGen.genRand.Next(1, 4);
            int num4 = WorldGen.genRand.Next(1, 4);
            int num5 = WorldGen.genRand.Next(1, 4);
            int num6 = WorldGen.genRand.Next(12);
            int style = num6 >= 3 ? (num6 >= 6 ? (num6 >= 8 ? (num6 >= 10 ? (num6 >= 11 ? 5 : 4) : 3) : 2) : 1) : 0;
            for (int i = index3 - num2; i < index3 + num3; ++i)
            {
              for (int j = index2 - num4; j < index2 + num5; ++j)
              {
                if (!Main.tile[i, j].active())
                  WorldGen.PlaceTile(i, j, 178, true, false, -1, style);
              }
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Random Gems", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Set(1f);
        for (int index = 0; index < Main.maxTilesX; ++index)
        {
          int i = WorldGen.genRand.Next(20, Main.maxTilesX - 20);
          int j = WorldGen.genRand.Next((int) Main.rockLayer, Main.maxTilesY - 300);
          if (!Main.tile[i, j].active() && !Main.tile[i, j].lava() && (!Main.wallDungeon[(int) Main.tile[i, j].wall] && Main.tile[i, j].wall != (ushort) 27))
          {
            int num2 = WorldGen.genRand.Next(12);
            int style = num2 >= 3 ? (num2 >= 6 ? (num2 >= 8 ? (num2 >= 10 ? (num2 >= 11 ? 5 : 4) : 3) : 2) : 1) : 0;
            WorldGen.PlaceTile(i, j, 178, true, false, -1, style);
          }
        }
        for (int index1 = 0; index1 < Main.maxTilesX; ++index1)
        {
          int index2 = WorldGen.genRand.Next(20, Main.maxTilesX - 20);
          int index3 = WorldGen.genRand.Next((int) Main.worldSurface, Main.maxTilesY - 300);
          if (!Main.tile[index2, index3].active() && !Main.tile[index2, index3].lava() && (Main.tile[index2, index3].wall == (ushort) 216 || Main.tile[index2, index3].wall == (ushort) 187))
          {
            int num2 = WorldGen.genRand.Next(1, 4);
            int num3 = WorldGen.genRand.Next(1, 4);
            int num4 = WorldGen.genRand.Next(1, 4);
            int num5 = WorldGen.genRand.Next(1, 4);
            for (int i = index2 - num2; i < index2 + num3; ++i)
            {
              for (int j = index3 - num4; j < index3 + num5; ++j)
              {
                if (!Main.tile[i, j].active())
                  WorldGen.PlaceTile(i, j, 178, true, false, -1, 6);
              }
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Moss Grass", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Set(1f);
        for (int index1 = 5; index1 < Main.maxTilesX - 5; ++index1)
        {
          for (int index2 = 5; index2 < Main.maxTilesY - 5; ++index2)
          {
            if (Main.tile[index1, index2].active() && Main.tileMoss[(int) Main.tile[index1, index2].type])
            {
              for (int index3 = 0; index3 < 4; ++index3)
              {
                int i = index1;
                int j = index2;
                if (index3 == 0)
                  --i;
                if (index3 == 1)
                  ++i;
                if (index3 == 2)
                  --j;
                if (index3 == 3)
                  ++j;
                if (!Main.tile[i, j].active())
                  WorldGen.PlaceTile(i, j, 184, true, false, -1, 0);
              }
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Muds Walls In Jungle", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Set(1f);
        int num2 = 0;
        int num3 = 0;
        bool flag1 = false;
        for (int index1 = 5; index1 < Main.maxTilesX - 5; ++index1)
        {
          for (int index2 = 0; (double) index2 < Main.worldSurface + 20.0; ++index2)
          {
            if (Main.tile[index1, index2].active() && Main.tile[index1, index2].type == (ushort) 60)
            {
              num2 = index1;
              flag1 = true;
              break;
            }
          }
          if (flag1)
            break;
        }
        bool flag2 = false;
        for (int index1 = Main.maxTilesX - 5; index1 > 5; --index1)
        {
          for (int index2 = 0; (double) index2 < Main.worldSurface + 20.0; ++index2)
          {
            if (Main.tile[index1, index2].active() && Main.tile[index1, index2].type == (ushort) 60)
            {
              num3 = index1;
              flag2 = true;
              break;
            }
          }
          if (flag2)
            break;
        }
        jungleMinX = num2;
        jungleMaxX = num3;
        for (int index1 = num2; index1 <= num3; ++index1)
        {
          for (int index2 = 0; (double) index2 < Main.worldSurface + 20.0; ++index2)
          {
            if ((index1 >= num2 + 2 && index1 <= num3 - 2 || WorldGen.genRand.Next(2) != 0) && (index1 >= num2 + 3 && index1 <= num3 - 3 || WorldGen.genRand.Next(3) != 0) && (Main.tile[index1, index2].wall == (ushort) 2 || Main.tile[index1, index2].wall == (ushort) 59))
              Main.tile[index1, index2].wall = (ushort) 15;
          }
        }
      }));
      WorldGen.AddGenerationPass("Larva", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        Main.tileSolid[229] = true;
        progress.Set(1f);
        for (int index1 = 0; index1 < WorldGen.numLarva; ++index1)
        {
          int i = WorldGen.larvaX[index1];
          int j = WorldGen.larvaY[index1];
          for (int index2 = i - 1; index2 <= i + 1; ++index2)
          {
            for (int index3 = j - 2; index3 <= j + 1; ++index3)
            {
              if (index3 != j + 1)
              {
                Main.tile[index2, index3].active(false);
              }
              else
              {
                Main.tile[index2, index3].active(true);
                Main.tile[index2, index3].type = (ushort) 225;
                Main.tile[index2, index3].slope((byte) 0);
                Main.tile[index2, index3].halfBrick(false);
              }
            }
          }
          WorldGen.PlaceTile(i, j, 231, true, false, -1, 0);
        }
        Main.tileSolid[232] = true;
        Main.tileSolid[162] = true;
      }));
      WorldGen.AddGenerationPass("Settle Liquids Again", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        if (WorldGen.getGoodWorldGen)
          Main.tileSolid[56] = true;
        progress.Message = Lang.gen[27].Value;
        if (WorldGen.notTheBees)
          WorldGen.NotTheBees();
        Liquid.worldGenTilesIgnoreWater(true);
        Liquid.QuickWater(3, -1, -1);
        WorldGen.WaterCheck();
        int num2 = 0;
        Liquid.quickSettle = true;
        int num3 = 10;
        while (num2 < num3)
        {
          int num4 = Liquid.numLiquid + LiquidBuffer.numLiquidBuffer;
          ++num2;
          float num5 = 0.0f;
          while (Liquid.numLiquid > 0)
          {
            float num6 = (float) (num4 - (Liquid.numLiquid + LiquidBuffer.numLiquidBuffer)) / (float) num4;
            if (Liquid.numLiquid + LiquidBuffer.numLiquidBuffer > num4)
              num4 = Liquid.numLiquid + LiquidBuffer.numLiquidBuffer;
            if ((double) num6 > (double) num5)
              num5 = num6;
            else
              num6 = num5;
            if (num2 == 1)
              progress.Set((float) ((double) num6 / 3.0 + 0.330000013113022));
            Liquid.UpdateLiquid();
          }
          WorldGen.WaterCheck();
          progress.Set((float) ((double) (num2 / num3) / 3.0 + 0.660000026226044));
        }
        Liquid.quickSettle = false;
        Liquid.worldGenTilesIgnoreWater(false);
        Main.tileSolid[484] = false;
      }));
      WorldGen.AddGenerationPass("Cactus, Palm Trees, & Coral", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[38].Value;
        int num2 = 8;
        int num3 = 400;
        int num4 = WorldGen.genRand.Next(3, 13);
        int num5 = WorldGen.genRand.Next(3, 13);
        WorldGen.genRand.Next(2, 6);
        WorldGen.genRand.Next(2, 6);
        int num6 = 380;
        for (int index1 = 0; index1 < WorldGen.numOasis; ++index1)
        {
          int num7 = (int) ((double) WorldGen.oasisWidth[index1] * 1.5);
          for (int index2 = (int) WorldGen.oasisPosition[index1].X - num7; index2 <= (int) WorldGen.oasisPosition[index1].X + num7; ++index2)
          {
            for (int index3 = (int) WorldGen.oasisPosition[index1].Y - WorldGen.oasisHeight; index3 <= (int) WorldGen.oasisPosition[index1].Y + WorldGen.oasisHeight; ++index3)
            {
              float num8 = 1f;
              int num9 = 8;
              for (int x = index2 - num9; x <= index2 + num9; ++x)
              {
                for (int y = index3 - num9; y <= index3 + num9; ++y)
                {
                  if (WorldGen.InWorld(x, y, 0) && Main.tile[x, y] != null && (Main.tile[x, y].active() && Main.tile[x, y].type == (ushort) 323))
                    num8 = 0.13f;
                }
              }
              if ((double) WorldGen.genRand.NextFloat() < (double) num8)
                WorldGen.GrowPalmTree(index2, index3);
              if (WorldGen.PlantSeaOat(index2, index3))
              {
                if (WorldGen.genRand.Next(2) == 0)
                  WorldGen.GrowSeaOat(index2, index3);
                if (WorldGen.genRand.Next(2) == 0)
                  WorldGen.GrowSeaOat(index2, index3);
              }
              WorldGen.PlaceOasisPlant(index2, index3, (ushort) 530);
            }
          }
        }
        for (int index1 = 0; index1 < 3; ++index1)
        {
          progress.Set((float) index1 / 3f);
          int num7;
          int num8;
          bool flag;
          int maxValue;
          switch (index1)
          {
            case 1:
              num7 = num3;
              num8 = Main.maxTilesX - num3;
              flag = true;
              maxValue = num2;
              break;
            case 2:
              num7 = Main.maxTilesX - num6;
              num8 = Main.maxTilesX - 5;
              flag = false;
              maxValue = num5;
              break;
            default:
              num7 = 5;
              num8 = num6;
              flag = false;
              maxValue = num4;
              break;
          }
          for (int index2 = num7; index2 < num8; ++index2)
          {
            if (WorldGen.genRand.Next(maxValue) == 0)
            {
              for (int index3 = 0; (double) index3 < Main.worldSurface - 1.0; ++index3)
              {
                Tile tile1 = Main.tile[index2, index3];
                if (tile1.active() && (tile1.type == (ushort) 53 || tile1.type == (ushort) 112 || tile1.type == (ushort) 234))
                {
                  Tile tile2 = Main.tile[index2, index3 - 1];
                  if (!tile2.active() && tile2.wall == (ushort) 0)
                  {
                    if (flag)
                    {
                      int num9 = 0;
                      for (int index4 = index2 - WorldGen.cactusWaterWidth; index4 < index2 + WorldGen.cactusWaterWidth; ++index4)
                      {
                        for (int index5 = index3 - WorldGen.cactusWaterHeight; index5 < index3 + WorldGen.cactusWaterHeight; ++index5)
                          num9 += (int) Main.tile[index4, index5].liquid;
                      }
                      if (num9 / (int) byte.MaxValue > WorldGen.cactusWaterLimit)
                      {
                        if (WorldGen.genRand.Next(4) == 0)
                        {
                          WorldGen.GrowPalmTree(index2, index3);
                          break;
                        }
                        break;
                      }
                      WorldGen.PlantCactus(index2, index3);
                      break;
                    }
                    if (Main.tile[index2, index3 - 2].liquid == byte.MaxValue && Main.tile[index2, index3 - 3].liquid == byte.MaxValue && Main.tile[index2, index3 - 4].liquid == byte.MaxValue)
                    {
                      if (WorldGen.genRand.Next(2) == 0)
                      {
                        WorldGen.PlaceTile(index2, index3 - 1, 81, true, false, -1, 0);
                        break;
                      }
                      WorldGen.PlaceTile(index2, index3 - 1, 324, true, false, -1, WorldGen.RollRandomSeaShellStyle());
                      break;
                    }
                    if (Main.tile[index2, index3 - 2].liquid == (byte) 0 && (double) index3 < Main.worldSurface)
                    {
                      WorldGen.PlaceTile(index2, index3 - 1, 324, true, false, -1, WorldGen.RollRandomSeaShellStyle());
                      break;
                    }
                  }
                }
              }
            }
            else
            {
              for (int index3 = 0; (double) index3 < Main.worldSurface - 1.0; ++index3)
              {
                if (WorldGen.PlantSeaOat(index2, index3))
                {
                  if (WorldGen.genRand.Next(2) == 0)
                    WorldGen.GrowSeaOat(index2, index3);
                  if (WorldGen.genRand.Next(2) == 0)
                    WorldGen.GrowSeaOat(index2, index3);
                }
                WorldGen.PlaceOasisPlant(index2, index3, (ushort) 530);
              }
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Tile Cleanup", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[84].Value;
        for (int i = 40; i < Main.maxTilesX - 40; ++i)
        {
          progress.Set((float) (i - 40) / (float) (Main.maxTilesX - 80));
          for (int j = 40; j < Main.maxTilesY - 40; ++j)
          {
            if (Main.tile[i, j].active() && Main.tile[i, j].topSlope() && (Main.tile[i, j].leftSlope() && Main.tile[i + 1, j].halfBrick() || Main.tile[i, j].rightSlope() && Main.tile[i - 1, j].halfBrick()))
            {
              Main.tile[i, j].slope((byte) 0);
              Main.tile[i, j].halfBrick(true);
            }
            if (Main.tile[i, j].active() && Main.tile[i, j].liquid > (byte) 0 && TileID.Sets.SlowlyDiesInWater[(int) Main.tile[i, j].type])
              WorldGen.KillTile(i, j, false, false, false);
            if (!Main.tile[i, j].active() && Main.tile[i, j].liquid == (byte) 0 && (WorldGen.genRand.Next(3) != 0 && WorldGen.SolidTile(i, j - 1, false)))
            {
              int num2 = WorldGen.genRand.Next(15, 21);
              for (int index = j - 2; index >= j - num2; --index)
              {
                if (Main.tile[i, index].liquid >= (byte) 128)
                {
                  int num3 = 373;
                  if (Main.tile[i, index].lava())
                    num3 = 374;
                  else if (Main.tile[i, index].honey())
                    num3 = 375;
                  if (WorldGen.genRand.Next(j - index) <= 1)
                  {
                    if (Main.tile[i, j].wall == (ushort) 86)
                      num3 = 375;
                    Main.tile[i, j].type = (ushort) num3;
                    Main.tile[i, j].frameX = (short) 0;
                    Main.tile[i, j].frameY = (short) 0;
                    Main.tile[i, j].active(true);
                    break;
                  }
                }
              }
              if (!Main.tile[i, j].active())
              {
                int num3 = WorldGen.genRand.Next(3, 11);
                for (int index = j + 1; index <= j + num3; ++index)
                {
                  if (Main.tile[i, index].liquid >= (byte) 200)
                  {
                    int num4 = 373;
                    if (Main.tile[i, index].lava())
                      num4 = 374;
                    else if (Main.tile[i, index].honey())
                      num4 = 375;
                    if (WorldGen.genRand.Next((index - j) * 3) <= 1)
                    {
                      Main.tile[i, j].type = (ushort) num4;
                      Main.tile[i, j].frameX = (short) 0;
                      Main.tile[i, j].frameY = (short) 0;
                      Main.tile[i, j].active(true);
                      break;
                    }
                  }
                }
              }
              if (!Main.tile[i, j].active() && WorldGen.genRand.Next(4) == 0)
              {
                Tile tile = Main.tile[i, j - 1];
                if (TileID.Sets.Conversion.Sandstone[(int) tile.type] || TileID.Sets.Conversion.HardenedSand[(int) tile.type])
                {
                  Main.tile[i, j].type = (ushort) 461;
                  Main.tile[i, j].frameX = (short) 0;
                  Main.tile[i, j].frameY = (short) 0;
                  Main.tile[i, j].active(true);
                }
              }
            }
            if (Main.tile[i, j].type == (ushort) 137)
            {
              if (Main.tile[i, j].frameY <= (short) 52)
              {
                int num2 = -1;
                if (Main.tile[i, j].frameX >= (short) 18)
                  num2 = 1;
                if (Main.tile[i + num2, j].halfBrick() || Main.tile[i + num2, j].slope() != (byte) 0)
                  Main.tile[i + num2, j].active(false);
              }
            }
            else if (Main.tile[i, j].type == (ushort) 162 && Main.tile[i, j + 1].liquid == (byte) 0 && WorldGen.CanKillTile(i, j))
              Main.tile[i, j].active(false);
            if (Main.tile[i, j].wall == (ushort) 13 || Main.tile[i, j].wall == (ushort) 14)
              Main.tile[i, j].liquid = (byte) 0;
            if (Main.tile[i, j].type == (ushort) 31)
            {
              int num2 = (int) Main.tile[i, j].frameX / 18;
              int num3 = 0;
              int num4 = i;
              int num5 = num3 + num2 / 2;
              int num6 = !WorldGen.drunkWorldGen ? (WorldGen.crimson ? 1 : 0) : (Main.tile[i, j].wall != (ushort) 83 ? 0 : 1);
              int num7 = num2 % 2;
              int num8 = num4 - num7;
              int num9 = (int) Main.tile[i, j].frameY / 18;
              int num10 = 0;
              int num11 = j;
              int num12 = num10 + num9 / 2;
              int num13 = num9 % 2;
              int num14 = num11 - num13;
              for (int index1 = 0; index1 < 2; ++index1)
              {
                for (int index2 = 0; index2 < 2; ++index2)
                {
                  int index3 = num8 + index1;
                  int index4 = num14 + index2;
                  Main.tile[index3, index4].active(true);
                  Main.tile[index3, index4].slope((byte) 0);
                  Main.tile[index3, index4].halfBrick(false);
                  Main.tile[index3, index4].type = (ushort) 31;
                  Main.tile[index3, index4].frameX = (short) (index1 * 18 + 36 * num6);
                  Main.tile[index3, index4].frameY = (short) (index2 * 18 + 36 * num12);
                }
              }
            }
            if (Main.tile[i, j].type == (ushort) 12)
            {
              int num2 = (int) Main.tile[i, j].frameX / 18;
              int num3 = 0;
              int num4 = i;
              int num5 = num3 + num2 / 2;
              int num6 = num2 % 2;
              int num7 = num4 - num6;
              int num8 = (int) Main.tile[i, j].frameY / 18;
              int num9 = 0;
              int num10 = j;
              int num11 = num9 + num8 / 2;
              int num12 = num8 % 2;
              int num13 = num10 - num12;
              for (int index1 = 0; index1 < 2; ++index1)
              {
                for (int index2 = 0; index2 < 2; ++index2)
                {
                  int index3 = num7 + index1;
                  int index4 = num13 + index2;
                  Main.tile[index3, index4].active(true);
                  Main.tile[index3, index4].slope((byte) 0);
                  Main.tile[index3, index4].halfBrick(false);
                  Main.tile[index3, index4].type = (ushort) 12;
                  Main.tile[index3, index4].frameX = (short) (index1 * 18 + 36 * num5);
                  Main.tile[index3, index4].frameY = (short) (index2 * 18 + 36 * num11);
                }
                if (!Main.tile[index1, j + 2].active())
                {
                  Main.tile[index1, j + 2].active(true);
                  if (!Main.tileSolid[(int) Main.tile[index1, j + 2].type] || Main.tileSolidTop[(int) Main.tile[index1, j + 2].type])
                    Main.tile[index1, j + 2].type = (ushort) 0;
                }
                Main.tile[index1, j + 2].slope((byte) 0);
                Main.tile[index1, j + 2].halfBrick(false);
              }
            }
            if (TileID.Sets.BasicChest[(int) Main.tile[i, j].type])
            {
              int num2 = (int) Main.tile[i, j].frameX / 18;
              int num3 = 0;
              ushort num4 = 21;
              int num5 = i;
              int Y = j - (int) Main.tile[i, j].frameY / 18;
              if (Main.tile[i, j].type == (ushort) 467)
                num4 = (ushort) 467;
              for (; num2 >= 2; num2 -= 2)
                ++num3;
              int X = num5 - num2;
              int chest = Chest.FindChest(X, Y);
              if (chest != -1)
              {
                switch (Main.chest[chest].item[0].type)
                {
                  case 1156:
                    num3 = 23;
                    break;
                  case 1260:
                    num3 = 26;
                    break;
                  case 1569:
                    num3 = 25;
                    break;
                  case 1571:
                    num3 = 24;
                    break;
                  case 1572:
                    num3 = 27;
                    break;
                }
              }
              for (int index1 = 0; index1 < 2; ++index1)
              {
                for (int index2 = 0; index2 < 2; ++index2)
                {
                  int index3 = X + index1;
                  int index4 = Y + index2;
                  Main.tile[index3, index4].active(true);
                  Main.tile[index3, index4].slope((byte) 0);
                  Main.tile[index3, index4].halfBrick(false);
                  Main.tile[index3, index4].type = num4;
                  Main.tile[index3, index4].frameX = (short) (index1 * 18 + 36 * num3);
                  Main.tile[index3, index4].frameY = (short) (index2 * 18);
                }
                if (!Main.tile[index1, j + 2].active())
                {
                  Main.tile[index1, j + 2].active(true);
                  if (!Main.tileSolid[(int) Main.tile[index1, j + 2].type] || Main.tileSolidTop[(int) Main.tile[index1, j + 2].type])
                    Main.tile[index1, j + 2].type = (ushort) 0;
                }
                Main.tile[index1, j + 2].slope((byte) 0);
                Main.tile[index1, j + 2].halfBrick(false);
              }
            }
            if (Main.tile[i, j].type == (ushort) 28)
            {
              int num2 = (int) Main.tile[i, j].frameX / 18;
              int num3 = 0;
              int num4 = i;
              for (; num2 >= 2; num2 -= 2)
                ++num3;
              int num5 = num4 - num2;
              int num6 = (int) Main.tile[i, j].frameY / 18;
              int num7 = 0;
              int num8 = j;
              for (; num6 >= 2; num6 -= 2)
                ++num7;
              int num9 = num8 - num6;
              for (int index1 = 0; index1 < 2; ++index1)
              {
                for (int index2 = 0; index2 < 2; ++index2)
                {
                  int index3 = num5 + index1;
                  int index4 = num9 + index2;
                  Main.tile[index3, index4].active(true);
                  Main.tile[index3, index4].slope((byte) 0);
                  Main.tile[index3, index4].halfBrick(false);
                  Main.tile[index3, index4].type = (ushort) 28;
                  Main.tile[index3, index4].frameX = (short) (index1 * 18 + 36 * num3);
                  Main.tile[index3, index4].frameY = (short) (index2 * 18 + 36 * num7);
                }
                if (!Main.tile[index1, j + 2].active())
                {
                  Main.tile[index1, j + 2].active(true);
                  if (!Main.tileSolid[(int) Main.tile[index1, j + 2].type] || Main.tileSolidTop[(int) Main.tile[index1, j + 2].type])
                    Main.tile[index1, j + 2].type = (ushort) 0;
                }
                Main.tile[index1, j + 2].slope((byte) 0);
                Main.tile[index1, j + 2].halfBrick(false);
              }
            }
            if (Main.tile[i, j].type == (ushort) 26)
            {
              int num2 = (int) Main.tile[i, j].frameX / 18;
              int num3 = 0;
              int num4 = i;
              int num5 = j - (int) Main.tile[i, j].frameY / 18;
              for (; num2 >= 3; num2 -= 3)
                ++num3;
              int num6 = num4 - num2;
              int num7 = !WorldGen.drunkWorldGen ? (!WorldGen.crimson ? 0 : 1) : (Main.tile[i, j].wall != (ushort) 83 ? 0 : 1);
              for (int index1 = 0; index1 < 3; ++index1)
              {
                for (int index2 = 0; index2 < 2; ++index2)
                {
                  int index3 = num6 + index1;
                  int index4 = num5 + index2;
                  Main.tile[index3, index4].active(true);
                  Main.tile[index3, index4].slope((byte) 0);
                  Main.tile[index3, index4].halfBrick(false);
                  Main.tile[index3, index4].type = (ushort) 26;
                  Main.tile[index3, index4].frameX = (short) (index1 * 18 + 54 * num7);
                  Main.tile[index3, index4].frameY = (short) (index2 * 18);
                }
                if (!Main.tile[num6 + index1, num5 + 2].active() || !Main.tileSolid[(int) Main.tile[num6 + index1, num5 + 2].type] || Main.tileSolidTop[(int) Main.tile[num6 + index1, num5 + 2].type])
                {
                  Main.tile[num6 + index1, num5 + 2].active(true);
                  if (!TileID.Sets.Platforms[(int) Main.tile[num6 + index1, num5 + 2].type] && (!Main.tileSolid[(int) Main.tile[num6 + index1, num5 + 2].type] || Main.tileSolidTop[(int) Main.tile[num6 + index1, num5 + 2].type]))
                    Main.tile[num6 + index1, num5 + 2].type = (ushort) 0;
                }
                Main.tile[num6 + index1, num5 + 2].slope((byte) 0);
                Main.tile[num6 + index1, num5 + 2].halfBrick(false);
                if (Main.tile[num6 + index1, num5 + 3].type == (ushort) 28 && (int) Main.tile[num6 + index1, num5 + 3].frameY % 36 >= 18)
                {
                  Main.tile[num6 + index1, num5 + 3].type = (ushort) 0;
                  Main.tile[num6 + index1, num5 + 3].active(false);
                }
              }
              for (int index = 0; index < 3; ++index)
              {
                if ((Main.tile[num6 - 1, num5 + index].type == (ushort) 28 || Main.tile[num6 - 1, num5 + index].type == (ushort) 12) && (int) Main.tile[num6 - 1, num5 + index].frameX % 36 < 18)
                {
                  Main.tile[num6 - 1, num5 + index].type = (ushort) 0;
                  Main.tile[num6 - 1, num5 + index].active(false);
                }
                if ((Main.tile[num6 + 3, num5 + index].type == (ushort) 28 || Main.tile[num6 + 3, num5 + index].type == (ushort) 12) && (int) Main.tile[num6 + 3, num5 + index].frameX % 36 >= 18)
                {
                  Main.tile[num6 + 3, num5 + index].type = (ushort) 0;
                  Main.tile[num6 + 3, num5 + index].active(false);
                }
              }
            }
            if (Main.tile[i, j].type == (ushort) 237 && Main.tile[i, j + 1].type == (ushort) 232)
              Main.tile[i, j + 1].type = (ushort) 226;
            if (Main.tile[i, j].wall == (ushort) 87)
              Main.tile[i, j].liquid = (byte) 0;
          }
        }
      }));
      WorldGen.AddGenerationPass("Lihzahrd Altars", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Set(1f);
        for (int index1 = 0; index1 < 3; ++index1)
        {
          for (int index2 = 0; index2 < 2; ++index2)
          {
            int index3 = WorldGen.lAltarX + index1;
            int index4 = WorldGen.lAltarY + index2;
            Main.tile[index3, index4].active(true);
            Main.tile[index3, index4].type = (ushort) 237;
            Main.tile[index3, index4].frameX = (short) (index1 * 18);
            Main.tile[index3, index4].frameY = (short) (index2 * 18);
          }
          Main.tile[WorldGen.lAltarX + index1, WorldGen.lAltarY + 2].active(true);
          Main.tile[WorldGen.lAltarX + index1, WorldGen.lAltarY + 2].slope((byte) 0);
          Main.tile[WorldGen.lAltarX + index1, WorldGen.lAltarY + 2].halfBrick(false);
          Main.tile[WorldGen.lAltarX + index1, WorldGen.lAltarY + 2].type = (ushort) 226;
        }
        for (int index1 = 0; index1 < 3; ++index1)
        {
          for (int index2 = 0; index2 < 2; ++index2)
            WorldGen.SquareTileFrame(WorldGen.lAltarX + index1, WorldGen.lAltarY + index2, true);
        }
      }));
      WorldGen.AddGenerationPass("Micro Biomes", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[76].Value;
        double num2 = (double) (Main.maxTilesX * Main.maxTilesY) / 5040000.0;
        float num3 = 10f;
        if (WorldGen.getGoodWorldGen)
          num3 *= 10f;
        DeadMansChestBiome biome1 = configuration.CreateBiome<DeadMansChestBiome>();
        List<int> possibleChestsToTrapify = biome1.GetPossibleChestsToTrapify(structures);
        int random1 = passConfig.Get<WorldGenRange>("DeadManChests").GetRandom(WorldGen.genRand);
        int num4 = 0;
        while (num4 < random1 && possibleChestsToTrapify.Count > 0)
        {
          int index = possibleChestsToTrapify[WorldGen.genRand.Next(possibleChestsToTrapify.Count)];
          Point origin = new Point(Main.chest[index].x, Main.chest[index].y);
          biome1.Place(origin, structures);
          ++num4;
          possibleChestsToTrapify.Remove(index);
        }
        progress.Set(1f / num3);
        if (!WorldGen.notTheBees)
        {
          ThinIceBiome biome2 = configuration.CreateBiome<ThinIceBiome>();
          int random2 = passConfig.Get<WorldGenRange>("ThinIcePatchCount").GetRandom(WorldGen.genRand);
          int num5 = 0;
          while (num5 < random2)
          {
            if (biome2.Place(WorldGen.RandomWorldPoint((int) Main.worldSurface + 20, 50, 200, 50), structures))
              ++num5;
          }
        }
        progress.Set(0.1f);
        progress.Set(2f / num3);
        EnchantedSwordBiome biome3 = configuration.CreateBiome<EnchantedSwordBiome>();
        int random3 = passConfig.Get<WorldGenRange>("SwordShrineAttempts").GetRandom(WorldGen.genRand);
        float num6 = passConfig.Get<float>("SwordShrinePlacementChance");
        for (int index = 0; index < random3; ++index)
        {
          if ((double) WorldGen.genRand.NextFloat() <= (double) num6)
          {
            int num5 = 0;
            while (num5++ <= Main.maxTilesX)
            {
              Point origin;
              origin.Y = (int) worldSurface + WorldGen.genRand.Next(50, 100);
              origin.X = WorldGen.genRand.Next(2) != 0 ? WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.699999988079071), Main.maxTilesX - 50) : WorldGen.genRand.Next(50, (int) ((double) Main.maxTilesX * 0.300000011920929));
              if (biome3.Place(origin, structures))
                break;
            }
          }
        }
        progress.Set(0.2f);
        progress.Set(3f / num3);
        if (!WorldGen.notTheBees)
        {
          CampsiteBiome biome2 = configuration.CreateBiome<CampsiteBiome>();
          int random2 = passConfig.Get<WorldGenRange>("CampsiteCount").GetRandom(WorldGen.genRand);
          int num5 = 0;
          while (num5 < random2)
          {
            if (biome2.Place(WorldGen.RandomWorldPoint((int) Main.worldSurface, WorldGen.beachDistance, 200, WorldGen.beachDistance), structures))
              ++num5;
          }
        }
        progress.Set(4f / num3);
        if (!WorldGen.notTheBees)
        {
          MiningExplosivesBiome biome2 = configuration.CreateBiome<MiningExplosivesBiome>();
          int num5 = passConfig.Get<WorldGenRange>("ExplosiveTrapCount").GetRandom(WorldGen.genRand);
          if (WorldGen.getGoodWorldGen)
            num5 = (int) ((double) num5 * 1.5);
          int num7 = 0;
          while (num7 < num5)
          {
            if (biome2.Place(WorldGen.RandomWorldPoint((int) rockLayer, WorldGen.beachDistance, 200, WorldGen.beachDistance), structures))
              ++num7;
          }
        }
        progress.Set(0.3f);
        progress.Set(5f / num3);
        MahoganyTreeBiome biome4 = configuration.CreateBiome<MahoganyTreeBiome>();
        int random4 = passConfig.Get<WorldGenRange>("LivingTreeCount").GetRandom(WorldGen.genRand);
        int num8 = 0;
        for (int index = 0; num8 < random4 && index < 20000; ++index)
        {
          if (biome4.Place(WorldGen.RandomWorldPoint((int) Main.worldSurface + 50, 50, 500, 50), structures))
            ++num8;
        }
        progress.Set(0.4f);
        progress.Set(6f / num3);
        progress.Set(7f / num3);
        TrackGenerator trackGenerator = new TrackGenerator();
        int random5 = passConfig.Get<WorldGenRange>("LongTrackCount").GetRandom(WorldGen.genRand);
        WorldGenRange worldGenRange1 = passConfig.Get<WorldGenRange>("LongTrackLength");
        int num9 = Main.maxTilesX * 10;
        int num10 = 0;
        int num11 = 0;
        while (num11 < random5)
        {
          if (trackGenerator.Place(WorldGen.RandomWorldPoint((int) Main.worldSurface, 10, 200, 10), worldGenRange1.ScaledMinimum, worldGenRange1.ScaledMaximum))
          {
            ++num11;
            num10 = 0;
          }
          else
          {
            ++num10;
            if (num10 > num9)
            {
              ++num11;
              num10 = 0;
            }
          }
        }
        progress.Set(8f / num3);
        int random6 = passConfig.Get<WorldGenRange>("StandardTrackCount").GetRandom(WorldGen.genRand);
        WorldGenRange worldGenRange2 = passConfig.Get<WorldGenRange>("StandardTrackLength");
        int num12 = 0;
        while (num12 < random6)
        {
          if (trackGenerator.Place(WorldGen.RandomWorldPoint((int) Main.worldSurface, 10, 200, 10), worldGenRange2.ScaledMinimum, worldGenRange2.ScaledMaximum))
            ++num12;
        }
        progress.Set(9f / num3);
        if (!WorldGen.notTheBees)
        {
          double num5 = (double) Main.maxTilesX * 0.02;
          if (WorldGen.getGoodWorldGen)
          {
            float num7 = num3 * 2f;
          }
          for (int index = 0; (double) index < num5; ++index)
          {
            int num13 = 0;
            while (num13 < 10150 && !WorldGen.placeLavaTrap(WorldGen.genRand.Next(200, Main.maxTilesX - 200), WorldGen.genRand.Next(WorldGen.lavaLine - 100, Main.maxTilesY - 210)))
              ++num13;
          }
        }
        progress.Set(1f);
      }));
      WorldGen.AddGenerationPass("Water Plants", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[88].Value;
        for (int x = 20; x < Main.maxTilesX - 20; ++x)
        {
          progress.Set((float) x / (float) Main.maxTilesX);
          for (int index1 = 1; (double) index1 < Main.worldSurface; ++index1)
          {
            if (WorldGen.genRand.Next(5) == 0 && Main.tile[x, index1].liquid > (byte) 0)
            {
              if (!Main.tile[x, index1].active())
              {
                if (WorldGen.genRand.Next(2) == 0)
                {
                  WorldGen.PlaceLilyPad(x, index1);
                }
                else
                {
                  Point point = WorldGen.PlaceCatTail(x, index1);
                  if (WorldGen.InWorld(point.X, point.Y, 0))
                  {
                    int num2 = WorldGen.genRand.Next(14);
                    for (int index2 = 0; index2 < num2; ++index2)
                      WorldGen.GrowCatTail(point.X, point.Y);
                    WorldGen.SquareTileFrame(point.X, point.Y, true);
                  }
                }
              }
              if ((!Main.tile[x, index1].active() || Main.tile[x, index1].type == (ushort) 61 || Main.tile[x, index1].type == (ushort) 74) && WorldGen.PlaceBamboo(x, index1))
              {
                int num2 = WorldGen.genRand.Next(10, 20);
                int num3 = 0;
                while (num3 < num2 && WorldGen.PlaceBamboo(x, index1 - num3))
                  ++num3;
              }
            }
          }
          for (int underworldLayer = Main.UnderworldLayer; (double) underworldLayer > Main.worldSurface; --underworldLayer)
          {
            if (Main.tile[x, underworldLayer].type == (ushort) 53 && WorldGen.genRand.Next(3) != 0)
              WorldGen.GrowCheckSeaweed(x, underworldLayer);
            else if (Main.tile[x, underworldLayer].type == (ushort) 549)
              WorldGen.GrowCheckSeaweed(x, underworldLayer);
          }
        }
      }));
      WorldGen.AddGenerationPass("Stalac", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Set(1f);
        for (int index = 20; index < Main.maxTilesX - 20; ++index)
        {
          for (int worldSurface1 = (int) Main.worldSurface; worldSurface1 < Main.maxTilesY - 20; ++worldSurface1)
          {
            if ((WorldGen.drunkWorldGen || WorldGen.genRand.Next(5) == 0) && Main.tile[index, worldSurface1 - 1].liquid == (byte) 0)
            {
              int num2 = WorldGen.genRand.Next(7);
              int treeTileType = 0;
              switch (num2)
              {
                case 0:
                  treeTileType = 583;
                  break;
                case 1:
                  treeTileType = 584;
                  break;
                case 2:
                  treeTileType = 585;
                  break;
                case 3:
                  treeTileType = 586;
                  break;
                case 4:
                  treeTileType = 587;
                  break;
                case 5:
                  treeTileType = 588;
                  break;
                case 6:
                  treeTileType = 589;
                  break;
              }
              WorldGen.TryGrowingTreeByType(treeTileType, index, worldSurface1);
            }
            if (!WorldGen.oceanDepths(index, worldSurface1) && !Main.tile[index, worldSurface1].active() && WorldGen.genRand.Next(5) == 0)
            {
              if ((Main.tile[index, worldSurface1 - 1].type == (ushort) 1 || Main.tile[index, worldSurface1 - 1].type == (ushort) 147 || (Main.tile[index, worldSurface1 - 1].type == (ushort) 161 || Main.tile[index, worldSurface1 - 1].type == (ushort) 25) || (Main.tile[index, worldSurface1 - 1].type == (ushort) 203 || Main.tileStone[(int) Main.tile[index, worldSurface1 - 1].type] || Main.tileMoss[(int) Main.tile[index, worldSurface1 - 1].type])) && (!Main.tile[index, worldSurface1].active() && !Main.tile[index, worldSurface1 + 1].active()))
                Main.tile[index, worldSurface1 - 1].slope((byte) 0);
              if ((Main.tile[index, worldSurface1 + 1].type == (ushort) 1 || Main.tile[index, worldSurface1 + 1].type == (ushort) 147 || (Main.tile[index, worldSurface1 + 1].type == (ushort) 161 || Main.tile[index, worldSurface1 + 1].type == (ushort) 25) || (Main.tile[index, worldSurface1 + 1].type == (ushort) 203 || Main.tileStone[(int) Main.tile[index, worldSurface1 + 1].type] || Main.tileMoss[(int) Main.tile[index, worldSurface1 + 1].type])) && (!Main.tile[index, worldSurface1].active() && !Main.tile[index, worldSurface1 - 1].active()))
                Main.tile[index, worldSurface1 + 1].slope((byte) 0);
              WorldGen.PlaceTight(index, worldSurface1, false);
            }
          }
          for (int y = 5; y < (int) Main.worldSurface; ++y)
          {
            if ((Main.tile[index, y - 1].type == (ushort) 147 || Main.tile[index, y - 1].type == (ushort) 161) && WorldGen.genRand.Next(5) == 0)
            {
              if (!Main.tile[index, y].active() && !Main.tile[index, y + 1].active())
                Main.tile[index, y - 1].slope((byte) 0);
              WorldGen.PlaceTight(index, y, false);
            }
            if ((Main.tile[index, y - 1].type == (ushort) 25 || Main.tile[index, y - 1].type == (ushort) 203) && WorldGen.genRand.Next(5) == 0)
            {
              if (!Main.tile[index, y].active() && !Main.tile[index, y + 1].active())
                Main.tile[index, y - 1].slope((byte) 0);
              WorldGen.PlaceTight(index, y, false);
            }
            if ((Main.tile[index, y + 1].type == (ushort) 25 || Main.tile[index, y + 1].type == (ushort) 203) && WorldGen.genRand.Next(5) == 0)
            {
              if (!Main.tile[index, y].active() && !Main.tile[index, y - 1].active())
                Main.tile[index, y + 1].slope((byte) 0);
              WorldGen.PlaceTight(index, y, false);
            }
          }
        }
      }));
      WorldGen.AddGenerationPass("Remove Broken Traps", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        progress.Message = Lang.gen[82].Value;
        List<Point> pointsWeAlreadyWentOver = new List<Point>();
        int num2 = 50;
        for (int x = num2; x < Main.maxTilesX - num2; ++x)
        {
          float num3 = (float) (x - num2) / (float) (Main.maxTilesX - num2 * 2);
          progress.Set(num3);
          for (int y = 50; y < Main.maxTilesY - 50; ++y)
          {
            if (Main.tile[x, y].wire() && !pointsWeAlreadyWentOver.Contains(new Point(x, y)))
              WorldGen.ClearBrokenTraps(new Point(x, y), pointsWeAlreadyWentOver);
          }
        }
      }));
      WorldGen.AddGenerationPass("Final Cleanup", (WorldGenLegacyMethod) ((progress, passConfig) =>
      {
        WorldGen.FillWallHolesInArea(new Microsoft.Xna.Framework.Rectangle(0, 0, Main.maxTilesX, (int) Main.worldSurface));
        progress.Message = Lang.gen[86].Value;
        for (int index1 = 0; index1 < Main.maxTilesX; ++index1)
        {
          progress.Set((float) index1 / (float) Main.maxTilesX);
          for (int index2 = 0; index2 < Main.maxTilesY; ++index2)
          {
            if (Main.tile[index1, index2].active() && !WorldGen.SolidTile(index1, index2 + 1, false) && (Main.tile[index1, index2].type == (ushort) 53 || Main.tile[index1, index2].type == (ushort) 112 || (Main.tile[index1, index2].type == (ushort) 234 || Main.tile[index1, index2].type == (ushort) 224) || Main.tile[index1, index2].type == (ushort) 123))
            {
              if ((double) index2 < Main.worldSurface + 10.0 && !Main.tile[index1, index2 + 1].active() && (Main.tile[index1, index2 + 1].wall != (ushort) 191 && !WorldGen.oceanDepths(index1, index2)))
              {
                int num2 = 10;
                int index3 = index2 + 1;
                for (int index4 = index3; index4 < index3 + 10; ++index4)
                {
                  if (Main.tile[index1, index4].active() && Main.tile[index1, index4].type == (ushort) 314)
                  {
                    num2 = 0;
                    break;
                  }
                }
                for (; !Main.tile[index1, index3].active() && num2 > 0 && index3 < Main.maxTilesY - 50; --num2)
                {
                  Main.tile[index1, index3 - 1].slope((byte) 0);
                  Main.tile[index1, index3 - 1].halfBrick(false);
                  Main.tile[index1, index3].active(true);
                  Main.tile[index1, index3].type = Main.tile[index1, index2].type;
                  Main.tile[index1, index3].slope((byte) 0);
                  Main.tile[index1, index3].halfBrick(false);
                  ++index3;
                }
                if (num2 == 0 && !Main.tile[index1, index3].active())
                {
                  switch (Main.tile[index1, index2].type)
                  {
                    case 53:
                      Main.tile[index1, index3].type = (ushort) 397;
                      Main.tile[index1, index3].active(true);
                      break;
                    case 112:
                      Main.tile[index1, index3].type = (ushort) 398;
                      Main.tile[index1, index3].active(true);
                      break;
                    case 123:
                      Main.tile[index1, index3].type = (ushort) 1;
                      Main.tile[index1, index3].active(true);
                      break;
                    case 224:
                      Main.tile[index1, index3].type = (ushort) 147;
                      Main.tile[index1, index3].active(true);
                      break;
                    case 234:
                      Main.tile[index1, index3].type = (ushort) 399;
                      Main.tile[index1, index3].active(true);
                      break;
                  }
                }
                else if (Main.tile[index1, index3].active() && Main.tileSolid[(int) Main.tile[index1, index3].type] && !Main.tileSolidTop[(int) Main.tile[index1, index3].type])
                {
                  Main.tile[index1, index3].slope((byte) 0);
                  Main.tile[index1, index3].halfBrick(false);
                }
              }
              else if (Main.tileSolid[(int) Main.tile[index1, index2 + 1].type] && !Main.tileSolidTop[(int) Main.tile[index1, index2 + 1].type] && (Main.tile[index1, index2 + 1].topSlope() || Main.tile[index1, index2 + 1].halfBrick()))
              {
                Main.tile[index1, index2 + 1].slope((byte) 0);
                Main.tile[index1, index2 + 1].halfBrick(false);
              }
              else
              {
                switch (Main.tile[index1, index2].type)
                {
                  case 53:
                    Main.tile[index1, index2].type = (ushort) 397;
                    break;
                  case 112:
                    Main.tile[index1, index2].type = (ushort) 398;
                    break;
                  case 123:
                    Main.tile[index1, index2].type = (ushort) 1;
                    break;
                  case 224:
                    Main.tile[index1, index2].type = (ushort) 147;
                    break;
                  case 234:
                    Main.tile[index1, index2].type = (ushort) 399;
                    break;
                }
              }
            }
            if ((Main.tile[index1, index2].wall == (ushort) 187 || Main.tile[index1, index2].wall == (ushort) 216) && Main.tile[index1, index2].liquid > (byte) 0)
            {
              Main.tile[index1, index2].liquid = byte.MaxValue;
              Main.tile[index1, index2].lava(true);
            }
            if (Main.tile[index1, index2].type == (ushort) 485 || Main.tile[index1, index2].type == (ushort) 187 || Main.tile[index1, index2].type == (ushort) 165)
              WorldGen.TileFrame(index1, index2, false, false);
            if (Main.tile[index1, index2].type == (ushort) 28)
              WorldGen.TileFrame(index1, index2, false, false);
            if (Main.tile[index1, index2].type == (ushort) 137)
            {
              Main.tile[index1, index2].slope((byte) 0);
              Main.tile[index1, index2].halfBrick(false);
            }
            if (Main.tile[index1, index2].active() && TileID.Sets.Boulders[(int) Main.tile[index1, index2].type])
            {
              int num2 = (int) Main.tile[index1, index2].frameX / 18;
              int num3 = index1 - num2;
              int num4 = (int) Main.tile[index1, index2].frameY / 18;
              int num5 = index2 - num4;
              for (int index3 = 0; index3 < 2; ++index3)
              {
                for (int index4 = 0; index4 < 2; ++index4)
                {
                  int index5 = num3 + index3;
                  int index6 = num5 + index4;
                  Main.tile[index5, index6].active(true);
                  Main.tile[index5, index6].slope((byte) 0);
                  Main.tile[index5, index6].halfBrick(false);
                  Main.tile[index5, index6].type = Main.tile[index1, index2].type;
                  Main.tile[index5, index6].frameX = (short) (index3 * 18);
                  Main.tile[index5, index6].frameY = (short) (index4 * 18);
                }
              }
            }
            if (Main.tile[index1, index2].type == (ushort) 323 && Main.tile[index1, index2].liquid > (byte) 0)
              WorldGen.KillTile(index1, index2, false, false, false);
            if (Main.wallDungeon[(int) Main.tile[index1, index2].wall])
            {
              Main.tile[index1, index2].lava(false);
              if (Main.tile[index1, index2].active() && Main.tile[index1, index2].type == (ushort) 56)
              {
                WorldGen.KillTile(index1, index2, false, false, false);
                Main.tile[index1, index2].lava(false);
                Main.tile[index1, index2].liquid = byte.MaxValue;
              }
            }
            if (Main.tile[index1, index2].active() && Main.tile[index1, index2].type == (ushort) 314)
            {
              int num2 = 15;
              int num3 = 1;
              for (int index3 = index2; index2 - index3 < num2; --index3)
                Main.tile[index1, index3].liquid = (byte) 0;
              for (int index3 = index2; index3 - index2 < num3; ++index3)
                Main.tile[index1, index3].liquid = (byte) 0;
            }
            if (Main.tile[index1, index2].active() && Main.tile[index1, index2].type == (ushort) 332 && !Main.tile[index1, index2 + 1].active())
            {
              Main.tile[index1, index2 + 1].ClearEverything();
              Main.tile[index1, index2 + 1].active(true);
              Main.tile[index1, index2 + 1].type = (ushort) 332;
            }
            if (index1 > WorldGen.beachDistance && index1 < Main.maxTilesX - WorldGen.beachDistance && ((double) index2 < Main.worldSurface && Main.tile[index1, index2].liquid > (byte) 0) && (Main.tile[index1, index2].liquid < byte.MaxValue && Main.tile[index1 - 1, index2].liquid < byte.MaxValue && (Main.tile[index1 + 1, index2].liquid < byte.MaxValue && Main.tile[index1, index2 + 1].liquid < byte.MaxValue)) && (!TileID.Sets.Clouds[(int) Main.tile[index1 - 1, index2].type] && !TileID.Sets.Clouds[(int) Main.tile[index1 + 1, index2].type] && !TileID.Sets.Clouds[(int) Main.tile[index1, index2 + 1].type]))
              Main.tile[index1, index2].liquid = (byte) 0;
          }
        }
        if (WorldGen.drunkWorldGen)
          WorldGen.FinishDrunkGen();
        if (WorldGen.notTheBees)
        {
          WorldGen.NotTheBees();
          WorldGen.FinishNotTheBees();
          WorldGen.notTheBees = false;
        }
        if (WorldGen.getGoodWorldGen)
        {
          WorldGen.FinishGetGoodWorld();
          WorldGen.getGoodWorldGen = false;
        }
        WorldGen.noTileActions = false;
        Main.tileSolid[(int) WorldGen.crackedType] = true;
        Main.tileSolid[484] = true;
        WorldGen.gen = false;
        Main.AnglerQuestSwap();
        WorldGen.skipFramingDuringGen = false;
        progress.Message = Lang.gen[87].Value;
      }));
      WorldGen._generator.GenerateWorld(customProgressObject);
      WorldGen.ConsumePostGenActions(structures);
      Main.WorldFileMetadata = FileMetadata.FromCurrentSettings(FileType.World);
      Main.NotifyOfEvent(GameNotificationType.WorldGen);
      WorldGen.drunkWorldGenText = false;
    }

    private static void NotTheBees()
    {
      if (!WorldGen.notTheBees)
        return;
      for (int x = 0; x < Main.maxTilesX; ++x)
      {
        for (int y = 0; y < Main.maxTilesY - 180; ++y)
        {
          if (Main.tile[x, y].type == (ushort) 52)
            Main.tile[x, y].type = (ushort) 62;
          if ((WorldGen.SolidOrSlopedTile(x, y) || TileID.Sets.CrackedBricks[(int) Main.tile[x, y].type]) && (!TileID.Sets.Ore[(int) Main.tile[x, y].type] && Main.tile[x, y].type != (ushort) 123) && Main.tile[x, y].type != (ushort) 40)
          {
            if (Main.tile[x, y].type == (ushort) 191 || Main.tile[x, y].type == (ushort) 383)
              Main.tile[x, y].type = (ushort) 383;
            else if (Main.tile[x, y].type == (ushort) 192 || Main.tile[x, y].type == (ushort) 384)
              Main.tile[x, y].type = (ushort) 384;
            else if (Main.tile[x, y].type != (ushort) 151 && Main.tile[x, y].type != (ushort) 189 && (Main.tile[x, y].type != (ushort) 196 && Main.tile[x, y].type != (ushort) 120) && (Main.tile[x, y].type != (ushort) 158 && Main.tile[x, y].type != (ushort) 175 && (Main.tile[x, y].type != (ushort) 45 && Main.tile[x, y].type != (ushort) 119)))
            {
              if (Main.tile[x, y].type >= (ushort) 63 && Main.tile[x, y].type <= (ushort) 68)
                Main.tile[x, y].type = (ushort) 230;
              else if (Main.tile[x, y].type != (ushort) 57 && Main.tile[x, y].type != (ushort) 76 && (Main.tile[x, y].type != (ushort) 75 && Main.tile[x, y].type != (ushort) 229) && (Main.tile[x, y].type != (ushort) 230 && Main.tile[x, y].type != (ushort) 407 && Main.tile[x, y].type != (ushort) 404))
              {
                if (Main.tile[x, y].type == (ushort) 224)
                  Main.tile[x, y].type = (ushort) 229;
                else if (Main.tile[x, y].type == (ushort) 53)
                {
                  if (x < WorldGen.beachDistance + WorldGen.genRand.Next(3) || x > Main.maxTilesX - WorldGen.beachDistance - WorldGen.genRand.Next(3))
                    Main.tile[x, y].type = (ushort) 229;
                }
                else if ((x <= WorldGen.beachDistance - WorldGen.genRand.Next(3) || x >= Main.maxTilesX - WorldGen.beachDistance + WorldGen.genRand.Next(3) || Main.tile[x, y].type != (ushort) 397 && Main.tile[x, y].type != (ushort) 396) && (Main.tile[x, y].type != (ushort) 10 && Main.tile[x, y].type != (ushort) 203 && (Main.tile[x, y].type != (ushort) 25 && Main.tile[x, y].type != (ushort) 137)) && (Main.tile[x, y].type != (ushort) 138 && Main.tile[x, y].type != (ushort) 141))
                {
                  if (Main.tileDungeon[(int) Main.tile[x, y].type] || TileID.Sets.CrackedBricks[(int) Main.tile[x, y].type])
                    Main.tile[x, y].color((byte) 14);
                  else if (Main.tile[x, y].type == (ushort) 226)
                    Main.tile[x, y].color((byte) 15);
                  else if (Main.tile[x, y].type != (ushort) 202 && Main.tile[x, y].type != (ushort) 70 && (Main.tile[x, y].type != (ushort) 48 && Main.tile[x, y].type != (ushort) 232))
                    Main.tile[x, y].type = !TileID.Sets.Conversion.Grass[(int) Main.tile[x, y].type] ? (Main.tile[x, y].type == (ushort) 0 || Main.tile[x, y].type == (ushort) 59 ? (ushort) 59 : (y <= WorldGen.lavaLine + WorldGen.genRand.Next(-2, 3) + 2 ? (ushort) 225 : (ushort) 230)) : (y <= WorldGen.lavaLine + WorldGen.genRand.Next(-2, 3) + 2 ? (ushort) 60 : (ushort) 70);
                }
              }
            }
          }
          if (Main.tile[x, y].wall != (ushort) 15 && Main.tile[x, y].wall != (ushort) 64 && (Main.tile[x, y].wall != (ushort) 204 && Main.tile[x, y].wall != (ushort) 205) && (Main.tile[x, y].wall != (ushort) 206 && Main.tile[x, y].wall != (ushort) 207 && (Main.tile[x, y].wall != (ushort) 23 && Main.tile[x, y].wall != (ushort) 24)) && (Main.tile[x, y].wall != (ushort) 42 && Main.tile[x, y].wall != (ushort) 10 && (Main.tile[x, y].wall != (ushort) 21 && Main.tile[x, y].wall != (ushort) 82) && (Main.tile[x, y].wall != (ushort) 187 && Main.tile[x, y].wall != (ushort) 216 && (Main.tile[x, y].wall != (ushort) 34 && Main.tile[x, y].wall != (ushort) 244))))
          {
            if (Main.tile[x, y].wall == (ushort) 87)
              Main.tile[x, y].wallColor((byte) 15);
            else if (Main.wallDungeon[(int) Main.tile[x, y].wall])
              Main.tile[x, y].wallColor((byte) 14);
            else if (Main.tile[x, y].wall == (ushort) 2)
              Main.tile[x, y].wall = (ushort) 2;
            else if (Main.tile[x, y].wall == (ushort) 196)
              Main.tile[x, y].wall = (ushort) 196;
            else if (Main.tile[x, y].wall == (ushort) 197)
              Main.tile[x, y].wall = (ushort) 197;
            else if (Main.tile[x, y].wall == (ushort) 198)
              Main.tile[x, y].wall = (ushort) 198;
            else if (Main.tile[x, y].wall == (ushort) 199)
              Main.tile[x, y].wall = (ushort) 199;
            else if (Main.tile[x, y].wall == (ushort) 63)
              Main.tile[x, y].wall = (ushort) 64;
            else if (Main.tile[x, y].wall != (ushort) 3 && Main.tile[x, y].wall != (ushort) 83 && (Main.tile[x, y].wall != (ushort) 73 && Main.tile[x, y].wall != (ushort) 13) && (Main.tile[x, y].wall != (ushort) 14 && Main.tile[x, y].wall > (ushort) 0))
              Main.tile[x, y].wall = (ushort) 86;
          }
          if (Main.tile[x, y].liquid > (byte) 0 && y <= WorldGen.lavaLine + 2)
          {
            if ((double) y > Main.rockLayer && (x < WorldGen.beachDistance + 200 || x > Main.maxTilesX - WorldGen.beachDistance - 200))
              Main.tile[x, y].honey(false);
            else if (Main.wallDungeon[(int) Main.tile[x, y].wall])
              Main.tile[x, y].honey(false);
            else
              Main.tile[x, y].honey(true);
          }
        }
      }
    }

    private static void FinishNotTheBees()
    {
      if (!WorldGen.notTheBees)
        return;
      int num1 = 0;
      for (int index1 = 20; (double) index1 < Main.worldSurface; ++index1)
      {
        for (int index2 = 20; index2 < Main.maxTilesX - 20; ++index2)
        {
          if (Main.tile[index2, index1].active() && TileID.Sets.Clouds[(int) Main.tile[index2, index1].type])
          {
            num1 = index1;
            break;
          }
        }
      }
      for (int i1 = 20; i1 < Main.maxTilesX - 20; ++i1)
      {
        for (int j = 20; j < Main.maxTilesY - 20; ++j)
        {
          int num2 = 20;
          if (Main.tile[i1, j].type == (ushort) 25)
          {
            for (int i2 = i1 - num2; i2 <= i1 + num2; ++i2)
            {
              for (int index = j - num2; index <= j + num2; ++index)
              {
                if (Main.tile[i2, index].type == (ushort) 60)
                {
                  if (Main.tile[i2, index + 1].type == (ushort) 444)
                    WorldGen.KillTile(i2, index + 1, false, false, false);
                  Main.tile[i2, index].type = (ushort) 23;
                  if (Main.tile[i2, index - 1].type == (ushort) 61 || Main.tile[i2, index - 1].type == (ushort) 74)
                  {
                    Main.tile[i2, index - 1].active(false);
                    WorldGen.PlaceTile(i2, index - 1, 24, false, false, -1, 0);
                  }
                }
                else if (Main.tile[i2, index - 1].type == (ushort) 233 || Main.tile[i2, index - 1].type == (ushort) 82)
                  WorldGen.KillTile(i2, index - 1, false, false, false);
                if (Main.tile[i2, index].type == (ushort) 59)
                  Main.tile[i2, index].type = (ushort) 0;
              }
            }
          }
          else if (Main.tile[i1, j].type == (ushort) 203)
          {
            for (int i2 = i1 - num2; i2 <= i1 + num2; ++i2)
            {
              for (int index = j - num2; index <= j + num2; ++index)
              {
                if (Main.tile[i2, index].type == (ushort) 60)
                {
                  if (Main.tile[i2, index + 1].type == (ushort) 444)
                    WorldGen.KillTile(i2, index + 1, false, false, false);
                  Main.tile[i2, index].type = (ushort) 199;
                  if (Main.tile[i2, index - 1].type == (ushort) 61 || Main.tile[i2, index - 1].type == (ushort) 74)
                  {
                    Main.tile[i2, index - 1].active(false);
                    WorldGen.PlaceTile(i2, index - 1, 201, false, false, -1, 0);
                  }
                  else if (Main.tile[i2, index - 1].type == (ushort) 233 || Main.tile[i2, index - 1].type == (ushort) 82)
                    WorldGen.KillTile(i2, index - 1, false, false, false);
                }
                if (Main.tile[i2, index].type == (ushort) 59)
                  Main.tile[i2, index].type = (ushort) 0;
              }
            }
          }
          if (Main.tile[i1, j].type == (ushort) 382 || Main.tile[i1, j].type == (ushort) 52)
            Main.tile[i1, j].type = (ushort) 62;
          if (j > WorldGen.lavaLine + WorldGen.genRand.Next(-2, 3) + 2)
            WorldGen.SpreadGrass(i1, j, 59, 70, true, (byte) 0);
          else
            WorldGen.SpreadGrass(i1, j, 59, 60, true, (byte) 0);
          if ((double) j > Main.rockLayer + 20.0 + (double) WorldGen.genRand.Next(-2, 3) && j <= WorldGen.lavaLine + 2 - 20 - WorldGen.genRand.Next(-2, 3) && (i1 < WorldGen.beachDistance + 200 - 20 - WorldGen.genRand.Next(-2, 3) || i1 > Main.maxTilesX - WorldGen.beachDistance - 200 + 20 + WorldGen.genRand.Next(-2, 3)))
          {
            if (Main.tile[i1, j].liquid > (byte) 0)
            {
              Main.tile[i1, j].honey(false);
              Main.tile[i1, j].lava(false);
            }
            if (Main.tile[i1, j].type == (ushort) 59)
            {
              bool flag = false;
              for (int index1 = i1 - 1; index1 <= i1 + 1; ++index1)
              {
                for (int index2 = j - 1; index2 <= j + 1; ++index2)
                {
                  if (Main.tile[index1, index2].type == (ushort) 60)
                    flag = true;
                }
              }
              if (!flag)
                Main.tile[i1, j].type = (double) j >= (Main.rockLayer + (double) WorldGen.lavaLine) / 2.0 ? (ushort) 147 : (ushort) 161;
            }
          }
          if (Main.tile[i1, j].type == (ushort) 7 || Main.tile[i1, j].type == (ushort) 166 || (Main.tile[i1, j].type == (ushort) 6 || Main.tile[i1, j].type == (ushort) 167))
          {
            if ((double) j > ((double) WorldGen.lavaLine + Main.rockLayer * 2.0) / 3.0 + (double) WorldGen.genRand.Next(-2, 3) + 2.0)
              Main.tile[i1, j].type = (ushort) 0;
          }
          else if ((Main.tile[i1, j].type == (ushort) 123 || Main.tile[i1, j].type == (ushort) 40) && (double) j > ((double) WorldGen.lavaLine + Main.rockLayer) / 2.0 + (double) WorldGen.genRand.Next(-2, 3) + 2.0)
            Main.tile[i1, j].type = (ushort) 1;
          if (j > num1 && (Main.tile[i1, j].liquid == (byte) 0 || !Main.tile[i1, j].lava()) && WorldGen.genRand.Next(25) == 0)
            WorldGen.PlaceTile(i1, j, 231, true, false, -1, 0);
        }
      }
      for (int checkedY = 20; checkedY < num1; ++checkedY)
      {
        for (int index = 20; index <= Main.maxTilesX - 20; ++index)
        {
          Main.tile[index, checkedY].honey(false);
          if (Main.tile[index, checkedY].type == (ushort) 375)
            Main.tile[index, checkedY].type = (ushort) 373;
          if (Main.tile[index, checkedY].type == (ushort) 60)
          {
            Main.tile[index, checkedY].type = (ushort) 2;
            if (WorldGen.genRand.Next(2) == 0)
              WorldGen.GrowTreeWithSettings(index, checkedY, WorldGen.GrowTreeSettings.Profiles.VanityTree_Willow);
            else
              WorldGen.GrowTreeWithSettings(index, checkedY, WorldGen.GrowTreeSettings.Profiles.VanityTree_Sakura);
            if (!Main.tile[index, checkedY - 1].active())
              WorldGen.PlaceTile(index, checkedY - 1, 3, false, false, -1, 0);
          }
          if (Main.tile[index, checkedY].type == (ushort) 59)
            Main.tile[index, checkedY].type = (ushort) 0;
        }
      }
    }

    private static void FinishGetGoodWorld()
    {
      int num1 = 0;
      for (int index1 = 20; (double) index1 < Main.worldSurface; ++index1)
      {
        for (int index2 = 20; index2 < Main.maxTilesX - 20; ++index2)
        {
          if (Main.tile[index2, index1].active() && TileID.Sets.Clouds[(int) Main.tile[index2, index1].type])
          {
            num1 = index1;
            break;
          }
        }
      }
      byte num2 = (byte) WorldGen.genRand.Next(13, 25);
      for (int index1 = 0; index1 < Main.maxTilesX; ++index1)
      {
        bool flag = false;
        for (int index2 = 0; index2 < Main.maxTilesY; ++index2)
        {
          if (Main.tile[index1, index2].active() && Main.tileDungeon[(int) Main.tile[index1, index2].type])
          {
            if (Main.tile[index1, index2].type == (ushort) 44)
            {
              num2 = (byte) WorldGen.genRand.Next(13, 15);
              if (WorldGen.genRand.Next(2) == 0)
                num2 = (byte) WorldGen.genRand.Next(23, 25);
            }
            if (Main.tile[index1, index2].type == (ushort) 43)
              num2 = (byte) WorldGen.genRand.Next(15, 19);
            if (Main.tile[index1, index2].type == (ushort) 41)
              num2 = (byte) WorldGen.genRand.Next(19, 23);
          }
        }
        if (flag)
          break;
      }
      for (int i = 0; i < Main.maxTilesX; ++i)
      {
        for (int index = 5; index < Main.maxTilesY - 5; ++index)
        {
          if (Main.tile[i, index].active() && (Main.tileDungeon[(int) Main.tile[i, index].type] || TileID.Sets.CrackedBricks[(int) Main.tile[i, index].type]))
            Main.tile[i, index].color(num2);
          if (Main.wallDungeon[(int) Main.tile[i, index].wall])
            Main.tile[i, index].wallColor(num2);
          if (Main.tile[i, index].active() && (Main.tile[i, index].type == (ushort) 226 || Main.tile[i, index].type == (ushort) 137 && Main.tile[i, index].frameY > (short) 0))
            Main.tile[i, index].color((byte) 17);
          if (Main.tile[i, index].wall == (ushort) 87)
            Main.tile[i, index].wallColor((byte) 25);
          if (Main.tile[i, index].active())
          {
            if (Main.tile[i, index].type == (ushort) 57 && WorldGen.genRand.Next(15) == 0)
            {
              if (Main.tile[i, index - 1].type == (ushort) 57)
                Main.tile[i, index].active(false);
              Main.tile[i, index].liquid = byte.MaxValue;
              Main.tile[i, index].lava(true);
            }
            if (index < num1 && Main.tile[i, index].type == (ushort) 2)
            {
              Main.tile[i, index].type = !WorldGen.crimson ? (ushort) 23 : (ushort) 199;
              if (Main.tile[i, index - 1].type == (ushort) 3)
                Main.tile[i, index - 1].active(false);
              if (Main.tile[i, index - 1].type == (ushort) 73)
                Main.tile[i, index - 1].active(false);
              if (Main.tile[i, index - 1].type == (ushort) 27)
                WorldGen.KillTile(i, index - 1, false, false, false);
              if (Main.tile[i, index - 1].type == (ushort) 596)
                WorldGen.KillTile(i, index - 1, false, false, false);
              if (Main.tile[i, index - 1].type == (ushort) 616)
                WorldGen.KillTile(i, index - 1, false, false, false);
              if (Main.tile[i, index - 1].type == (ushort) 82)
                WorldGen.KillTile(i, index - 1, false, false, false);
              if (Main.tile[i, index - 1].type == (ushort) 83)
                WorldGen.KillTile(i, index - 1, false, false, false);
              if (Main.tile[i, index - 1].type == (ushort) 186)
                WorldGen.KillTile(i, index - 1, false, false, false);
              if (Main.tile[i, index - 1].type == (ushort) 187)
                WorldGen.KillTile(i, index - 1, false, false, false);
              if (Main.tile[i, index - 1].type == (ushort) 185)
                WorldGen.KillTile(i, index - 1, false, false, false);
              if (Main.tile[i, index - 1].type == (ushort) 227)
                WorldGen.KillTile(i, index - 1, false, false, false);
            }
          }
        }
      }
      for (int index1 = 0; index1 < 8000 && Main.chest[index1] != null; ++index1)
      {
        if (WorldGen.genRand.Next(10) == 0 && Main.chest[index1].item[1].stack != 0)
        {
          for (int index2 = 1; index2 < 40; ++index2)
          {
            if (Main.chest[index1].item[index2].stack == 0)
            {
              Main.chest[index1].item[index2].SetDefaults(678);
              break;
            }
          }
        }
      }
    }

    private static void FinishDrunkGen()
    {
      byte color = (byte) WorldGen.genRand.Next(13, 25);
      byte num = 16;
      for (int index1 = 0; index1 < Main.maxTilesX; ++index1)
      {
        bool flag = false;
        for (int index2 = 0; index2 < Main.maxTilesY; ++index2)
        {
          if (Main.tile[index1, index2].active() && Main.tileDungeon[(int) Main.tile[index1, index2].type])
          {
            if (Main.tile[index1, index2].type == (ushort) 44)
            {
              color = (byte) WorldGen.genRand.Next(13, 15);
              if (WorldGen.genRand.Next(2) == 0)
                color = (byte) WorldGen.genRand.Next(23, 25);
            }
            if (Main.tile[index1, index2].type == (ushort) 43)
              color = (byte) WorldGen.genRand.Next(15, 19);
            if (Main.tile[index1, index2].type == (ushort) 41)
              color = (byte) WorldGen.genRand.Next(19, 23);
          }
        }
        if (flag)
          break;
      }
      for (int index1 = 0; index1 < Main.maxTilesX; ++index1)
      {
        for (int index2 = 0; index2 < Main.maxTilesY; ++index2)
        {
          if (Main.tile[index1, index2].active() && (Main.tileDungeon[(int) Main.tile[index1, index2].type] || TileID.Sets.CrackedBricks[(int) Main.tile[index1, index2].type]))
            Main.tile[index1, index2].color(color);
          if (Main.wallDungeon[(int) Main.tile[index1, index2].wall])
            Main.tile[index1, index2].wallColor((byte) 25);
          if (Main.tile[index1, index2].active() && (Main.tile[index1, index2].type == (ushort) 226 || Main.tile[index1, index2].type == (ushort) 137 && Main.tile[index1, index2].frameY > (short) 0))
            Main.tile[index1, index2].color(num);
          if (Main.tile[index1, index2].wall == (ushort) 87)
            Main.tile[index1, index2].wallColor(num);
        }
      }
      for (int index1 = 0; index1 < 8000 && Main.chest[index1] != null; ++index1)
      {
        if (WorldGen.genRand.Next(15) == 0 && Main.chest[index1].item[1].stack != 0)
        {
          for (int index2 = 1; index2 < 40; ++index2)
          {
            if (Main.chest[index1].item[index2].stack == 0)
            {
              Main.chest[index1].item[index2].SetDefaults(5001);
              break;
            }
          }
        }
        if (WorldGen.genRand.Next(30) == 0 && Main.chest[index1].item[1].stack != 0)
        {
          for (int index2 = 1; index2 < 40; ++index2)
          {
            if (Main.chest[index1].item[index2].stack == 0)
            {
              Main.chest[index1].item[index2].SetDefaults(678);
              break;
            }
          }
        }
      }
    }

    public static bool IsItATrap(Tile tile)
    {
      return tile.actuator() || tile.active() && TileID.Sets.IsAMechanism[(int) tile.type];
    }

    public static bool IsItATrigger(Tile tile)
    {
      return tile.active() && (TileID.Sets.IsATrigger[(int) tile.type] || tile.type == (ushort) 467 && (int) tile.frameX / 36 == 4 || tile.type == (ushort) 314 && Minecart.IsPressurePlate(tile));
    }

    public static void ClearAllBrokenTraps()
    {
      List<Point> pointsWeAlreadyWentOver = new List<Point>();
      for (int x = 50; x < Main.maxTilesX - 50; ++x)
      {
        for (int y = 50; y < Main.maxTilesY - 50; ++y)
        {
          if (Main.tile[x, y].wire() && !pointsWeAlreadyWentOver.Contains(new Point(x, y)))
            WorldGen.ClearBrokenTraps(new Point(x, y), pointsWeAlreadyWentOver);
        }
      }
    }

    public static void ClearBrokenTraps(Point startTileCoords, List<Point> pointsWeAlreadyWentOver)
    {
      List<Point> t1 = new List<Point>();
      List<Point> t2 = new List<Point>();
      List<Point> pointList = new List<Point>();
      bool flag1 = false;
      bool flag2 = false;
      t2.Add(startTileCoords);
      while (t2.Count > 0)
      {
        Utils.Swap<List<Point>>(ref t1, ref t2);
        while (t1.Count > 0)
        {
          Point point1 = t1[0];
          t1.RemoveAt(0);
          if (WorldGen.InWorld(point1.X, point1.Y, 5))
          {
            Tile tile = Main.tile[point1.X, point1.Y];
            if (tile.wire())
            {
              pointsWeAlreadyWentOver.Add(point1);
              pointList.Add(point1);
              if (WorldGen.IsItATrap(tile))
                flag1 = true;
              if (WorldGen.IsItATrigger(tile))
                flag2 = true;
              if (!(flag2 & flag1))
              {
                Point point2 = new Point(point1.X - 1, point1.Y);
                if (!pointList.Contains(point2))
                  t2.Add(point2);
                point2 = new Point(point1.X + 1, point1.Y);
                if (!pointList.Contains(point2))
                  t2.Add(point2);
                point2 = new Point(point1.X, point1.Y - 1);
                if (!pointList.Contains(point2))
                  t2.Add(point2);
                point2 = new Point(point1.X, point1.Y + 1);
                if (!pointList.Contains(point2))
                  t2.Add(point2);
              }
              else
                break;
            }
          }
        }
        if (flag2 & flag1)
          break;
      }
      if (flag2 && flag1)
        return;
      foreach (Point point in pointList)
      {
        Tile tile = Main.tile[point.X, point.Y];
        tile.wire(false);
        if (WorldGen.IsItATrap(tile))
        {
          if (tile.actuator())
            Main.tile[point.X, point.Y].actuator(false);
          else if (tile.type != (ushort) 105)
            WorldGen.KillTile(point.X, point.Y, false, false, false);
        }
        else if (WorldGen.IsItATrigger(tile))
        {
          if (tile.type == (ushort) 314)
            tile.frameX = (short) 1;
          else
            WorldGen.KillTile(point.X, point.Y, false, false, false);
        }
      }
    }

    private static float TuneOceanDepth(int count, float depth, bool floridaStyle = false)
    {
      if (!floridaStyle)
      {
        if (count < 3)
          depth += (float) WorldGen.genRand.Next(10, 20) * 0.2f;
        else if (count < 6)
          depth += (float) WorldGen.genRand.Next(10, 20) * 0.15f;
        else if (count < 9)
          depth += (float) WorldGen.genRand.Next(10, 20) * 0.1f;
        else if (count < 15)
          depth += (float) WorldGen.genRand.Next(10, 20) * 0.07f;
        else if (count < 50)
          depth += (float) WorldGen.genRand.Next(10, 20) * 0.05f;
        else if (count < 75)
          depth += (float) WorldGen.genRand.Next(10, 20) * 0.04f;
        else if (count < 100)
          depth += (float) WorldGen.genRand.Next(10, 20) * 0.03f;
        else if (count < 125)
          depth += (float) WorldGen.genRand.Next(10, 20) * 0.02f;
        else if (count < 150)
          depth += (float) WorldGen.genRand.Next(10, 20) * 0.01f;
        else if (count < 175)
          depth += (float) WorldGen.genRand.Next(10, 20) * 0.005f;
        else if (count < 200)
          depth += (float) WorldGen.genRand.Next(10, 20) * (1f / 1000f);
        else if (count < 230)
          depth += (float) WorldGen.genRand.Next(10, 20) * 0.01f;
        else if (count < 235)
          depth += (float) WorldGen.genRand.Next(10, 20) * 0.05f;
        else if (count < 240)
          depth += (float) WorldGen.genRand.Next(10, 20) * 0.1f;
        else if (count < 245)
          depth += (float) WorldGen.genRand.Next(10, 20) * 0.05f;
        else if (count < (int) byte.MaxValue)
          depth += (float) WorldGen.genRand.Next(10, 20) * 0.01f;
      }
      else if (count < 3)
        depth += (float) WorldGen.genRand.Next(10, 20) * (1f / 1000f);
      else if (count < 6)
        depth += (float) WorldGen.genRand.Next(10, 20) * (1f / 500f);
      else if (count < 9)
        depth += (float) WorldGen.genRand.Next(10, 20) * 0.004f;
      else if (count < 15)
        depth += (float) WorldGen.genRand.Next(10, 20) * 0.007f;
      else if (count < 50)
        depth += (float) WorldGen.genRand.Next(10, 20) * 0.01f;
      else if (count < 75)
        depth += (float) WorldGen.genRand.Next(10, 20) * 0.014f;
      else if (count < 100)
        depth += (float) WorldGen.genRand.Next(10, 20) * 0.019f;
      else if (count < 125)
        depth += (float) WorldGen.genRand.Next(10, 20) * 0.027f;
      else if (count < 150)
        depth += (float) WorldGen.genRand.Next(10, 20) * 0.038f;
      else if (count < 175)
        depth += (float) WorldGen.genRand.Next(10, 20) * 0.052f;
      else if (count < 200)
        depth += (float) WorldGen.genRand.Next(10, 20) * 0.08f;
      else if (count < 230)
        depth += (float) WorldGen.genRand.Next(10, 20) * 0.12f;
      else if (count < 235)
        depth += (float) WorldGen.genRand.Next(10, 20) * 0.16f;
      else if (count < 240)
        depth += (float) WorldGen.genRand.Next(10, 20) * 0.27f;
      else if (count < 245)
        depth += (float) WorldGen.genRand.Next(10, 20) * 0.43f;
      else if (count < (int) byte.MaxValue)
        depth += (float) WorldGen.genRand.Next(10, 20) * 0.6f;
      return depth;
    }

    public static void QueuePostGenAction(Action<StructureMap> action)
    {
      WorldGen._postGenActions.Enqueue(action);
    }

    public static void ConsumePostGenActions(StructureMap structures)
    {
      while (WorldGen._postGenActions.Count > 0)
        WorldGen._postGenActions.Dequeue()(structures);
    }

    public static Point RandomRectanglePoint(Microsoft.Xna.Framework.Rectangle rectangle)
    {
      return new Point(WorldGen.genRand.Next(rectangle.X, rectangle.X + rectangle.Width), WorldGen.genRand.Next(rectangle.Y, rectangle.Y + rectangle.Height));
    }

    public static Point RandomRectanglePoint(int x, int y, int width, int height)
    {
      return new Point(WorldGen.genRand.Next(x, x + width), WorldGen.genRand.Next(y, y + height));
    }

    public static Point RandomWorldPoint(int padding)
    {
      return WorldGen.RandomWorldPoint(padding, padding, padding, padding);
    }

    public static Point RandomWorldPoint(int top = 0, int right = 0, int bottom = 0, int left = 0)
    {
      return new Point(WorldGen.genRand.Next(left, Main.maxTilesX - right), WorldGen.genRand.Next(top, Main.maxTilesY - bottom));
    }

    public static bool GrowPalmTree(int i, int y)
    {
      int index1 = y;
      if (!WorldGen.InWorld(i, y, 0))
        return false;
      while (Main.tile[i, index1].type == (ushort) 20)
      {
        ++index1;
        if (Main.tile[i, index1] == null)
          return false;
      }
      Tile tile1 = Main.tile[i, index1];
      Tile tile2 = Main.tile[i, index1 - 1];
      int num1 = (int) tile1.slope();
      tile1.halfBrick();
      if (!tile1.active() || tile1.halfBrick() || (tile1.slope() != (byte) 0 || tile2.wall != (ushort) 0) || tile2.liquid != (byte) 0 || (tile1.type != (ushort) 53 && tile1.type != (ushort) 234 && (tile1.type != (ushort) 116 && tile1.type != (ushort) 112) || (!WorldGen.EmptyTileCheck(i, i, index1 - 2, index1 - 1, 20) || !WorldGen.EmptyTileCheck(i - 1, i + 1, index1 - 30, index1 - 3, 20))))
        return false;
      int num2 = WorldGen.genRand.Next(10, 21);
      int num3 = WorldGen.genRand.Next(-8, 9) * 2;
      short num4 = 0;
      for (int index2 = 0; index2 < num2; ++index2)
      {
        Tile tile3 = Main.tile[i, index1 - 1 - index2];
        if (index2 == 0)
        {
          tile3.active(true);
          tile3.type = (ushort) 323;
          tile3.frameX = (short) 66;
          tile3.frameY = (short) 0;
        }
        else if (index2 == num2 - 1)
        {
          tile3.active(true);
          tile3.type = (ushort) 323;
          tile3.frameX = (short) (22 * WorldGen.genRand.Next(4, 7));
          tile3.frameY = num4;
        }
        else
        {
          if ((int) num4 != num3)
          {
            float num5 = (float) index2 / (float) num2;
            if ((double) num5 >= 0.25 && ((double) num5 < 0.5 && WorldGen.genRand.Next(13) == 0 || ((double) num5 < 0.699999988079071 && WorldGen.genRand.Next(9) == 0 || ((double) num5 < 0.949999988079071 && WorldGen.genRand.Next(5) == 0 || true))))
            {
              short num6 = (short) Math.Sign(num3);
              num4 += (short) ((int) num6 * 2);
            }
          }
          tile3.active(true);
          tile3.type = (ushort) 323;
          tile3.frameX = (short) (22 * WorldGen.genRand.Next(0, 3));
          tile3.frameY = num4;
        }
      }
      WorldGen.RangeFrame(i - 2, index1 - num2 - 1, i + 2, index1 + 1);
      if (Main.netMode == 2)
        NetMessage.SendTileSquare(-1, i, (int) ((double) index1 - (double) num2 * 0.5), num2 + 1, TileChangeType.None);
      return true;
    }

    public static bool IsPalmOasisTree(int x)
    {
      return x >= WorldGen.beachDistance && x <= Main.maxTilesX - WorldGen.beachDistance;
    }

    public static bool GrowEpicTree(int i, int y)
    {
      int index1 = y;
      while (Main.tile[i, index1].type == (ushort) 20)
        ++index1;
      if (Main.tile[i, index1].active() && !Main.tile[i, index1].halfBrick() && (Main.tile[i, index1].slope() == (byte) 0 && Main.tile[i, index1].type == (ushort) 2) && (Main.tile[i, index1 - 1].wall == (ushort) 0 && Main.tile[i, index1 - 1].liquid == (byte) 0) && (Main.tile[i - 1, index1].active() && (Main.tile[i - 1, index1].type == (ushort) 2 || Main.tile[i - 1, index1].type == (ushort) 23 || (Main.tile[i - 1, index1].type == (ushort) 60 || Main.tile[i - 1, index1].type == (ushort) 109)) || Main.tile[i + 1, index1].active() && (Main.tile[i + 1, index1].type == (ushort) 2 || Main.tile[i + 1, index1].type == (ushort) 23 || (Main.tile[i + 1, index1].type == (ushort) 60 || Main.tile[i + 1, index1].type == (ushort) 109))))
      {
        int num1 = 2;
        if (WorldGen.EmptyTileCheck(i - num1, i + num1, index1 - 55, index1 - 1, 20))
        {
          bool flag1 = false;
          bool flag2 = false;
          int num2 = WorldGen.genRand.Next(20, 30);
          if (WorldGen.drunkWorldGen)
            num2 = WorldGen.genRand.Next(3, 7);
          for (int index2 = index1 - num2; index2 < index1; ++index2)
          {
            Main.tile[i, index2].frameNumber((byte) WorldGen.genRand.Next(3));
            Main.tile[i, index2].active(true);
            Main.tile[i, index2].type = (ushort) 5;
            int num3 = WorldGen.genRand.Next(3);
            int num4 = WorldGen.genRand.Next(10);
            if (index2 == index1 - 1 || index2 == index1 - num2)
              num4 = 0;
            while (((num4 == 5 ? 1 : (num4 == 7 ? 1 : 0)) & (flag1 ? 1 : 0)) != 0 || ((num4 == 6 ? 1 : (num4 == 7 ? 1 : 0)) & (flag2 ? 1 : 0)) != 0)
              num4 = WorldGen.genRand.Next(10);
            flag1 = false;
            flag2 = false;
            if (num4 == 5 || num4 == 7)
              flag1 = true;
            if (num4 == 6 || num4 == 7)
              flag2 = true;
            switch (num4)
            {
              case 1:
                if (num3 == 0)
                {
                  Main.tile[i, index2].frameX = (short) 0;
                  Main.tile[i, index2].frameY = (short) 66;
                }
                if (num3 == 1)
                {
                  Main.tile[i, index2].frameX = (short) 0;
                  Main.tile[i, index2].frameY = (short) 88;
                }
                if (num3 == 2)
                {
                  Main.tile[i, index2].frameX = (short) 0;
                  Main.tile[i, index2].frameY = (short) 110;
                  break;
                }
                break;
              case 2:
                if (num3 == 0)
                {
                  Main.tile[i, index2].frameX = (short) 22;
                  Main.tile[i, index2].frameY = (short) 0;
                }
                if (num3 == 1)
                {
                  Main.tile[i, index2].frameX = (short) 22;
                  Main.tile[i, index2].frameY = (short) 22;
                }
                if (num3 == 2)
                {
                  Main.tile[i, index2].frameX = (short) 22;
                  Main.tile[i, index2].frameY = (short) 44;
                  break;
                }
                break;
              case 3:
                if (num3 == 0)
                {
                  Main.tile[i, index2].frameX = (short) 44;
                  Main.tile[i, index2].frameY = (short) 66;
                }
                if (num3 == 1)
                {
                  Main.tile[i, index2].frameX = (short) 44;
                  Main.tile[i, index2].frameY = (short) 88;
                }
                if (num3 == 2)
                {
                  Main.tile[i, index2].frameX = (short) 44;
                  Main.tile[i, index2].frameY = (short) 110;
                  break;
                }
                break;
              case 4:
                if (num3 == 0)
                {
                  Main.tile[i, index2].frameX = (short) 22;
                  Main.tile[i, index2].frameY = (short) 66;
                }
                if (num3 == 1)
                {
                  Main.tile[i, index2].frameX = (short) 22;
                  Main.tile[i, index2].frameY = (short) 88;
                }
                if (num3 == 2)
                {
                  Main.tile[i, index2].frameX = (short) 22;
                  Main.tile[i, index2].frameY = (short) 110;
                  break;
                }
                break;
              case 5:
                if (num3 == 0)
                {
                  Main.tile[i, index2].frameX = (short) 88;
                  Main.tile[i, index2].frameY = (short) 0;
                }
                if (num3 == 1)
                {
                  Main.tile[i, index2].frameX = (short) 88;
                  Main.tile[i, index2].frameY = (short) 22;
                }
                if (num3 == 2)
                {
                  Main.tile[i, index2].frameX = (short) 88;
                  Main.tile[i, index2].frameY = (short) 44;
                  break;
                }
                break;
              case 6:
                if (num3 == 0)
                {
                  Main.tile[i, index2].frameX = (short) 66;
                  Main.tile[i, index2].frameY = (short) 66;
                }
                if (num3 == 1)
                {
                  Main.tile[i, index2].frameX = (short) 66;
                  Main.tile[i, index2].frameY = (short) 88;
                }
                if (num3 == 2)
                {
                  Main.tile[i, index2].frameX = (short) 66;
                  Main.tile[i, index2].frameY = (short) 110;
                  break;
                }
                break;
              case 7:
                if (num3 == 0)
                {
                  Main.tile[i, index2].frameX = (short) 110;
                  Main.tile[i, index2].frameY = (short) 66;
                }
                if (num3 == 1)
                {
                  Main.tile[i, index2].frameX = (short) 110;
                  Main.tile[i, index2].frameY = (short) 88;
                }
                if (num3 == 2)
                {
                  Main.tile[i, index2].frameX = (short) 110;
                  Main.tile[i, index2].frameY = (short) 110;
                  break;
                }
                break;
              default:
                if (num3 == 0)
                {
                  Main.tile[i, index2].frameX = (short) 0;
                  Main.tile[i, index2].frameY = (short) 0;
                }
                if (num3 == 1)
                {
                  Main.tile[i, index2].frameX = (short) 0;
                  Main.tile[i, index2].frameY = (short) 22;
                }
                if (num3 == 2)
                {
                  Main.tile[i, index2].frameX = (short) 0;
                  Main.tile[i, index2].frameY = (short) 44;
                  break;
                }
                break;
            }
            if (num4 == 5 || num4 == 7)
            {
              Main.tile[i - 1, index2].active(true);
              Main.tile[i - 1, index2].type = (ushort) 5;
              int num5 = WorldGen.genRand.Next(3);
              if (WorldGen.genRand.Next(3) < 2)
              {
                if (num5 == 0)
                {
                  Main.tile[i - 1, index2].frameX = (short) 44;
                  Main.tile[i - 1, index2].frameY = (short) 198;
                }
                if (num5 == 1)
                {
                  Main.tile[i - 1, index2].frameX = (short) 44;
                  Main.tile[i - 1, index2].frameY = (short) 220;
                }
                if (num5 == 2)
                {
                  Main.tile[i - 1, index2].frameX = (short) 44;
                  Main.tile[i - 1, index2].frameY = (short) 242;
                }
              }
              else
              {
                if (num5 == 0)
                {
                  Main.tile[i - 1, index2].frameX = (short) 66;
                  Main.tile[i - 1, index2].frameY = (short) 0;
                }
                if (num5 == 1)
                {
                  Main.tile[i - 1, index2].frameX = (short) 66;
                  Main.tile[i - 1, index2].frameY = (short) 22;
                }
                if (num5 == 2)
                {
                  Main.tile[i - 1, index2].frameX = (short) 66;
                  Main.tile[i - 1, index2].frameY = (short) 44;
                }
              }
            }
            if (num4 == 6 || num4 == 7)
            {
              Main.tile[i + 1, index2].active(true);
              Main.tile[i + 1, index2].type = (ushort) 5;
              int num5 = WorldGen.genRand.Next(3);
              if (WorldGen.genRand.Next(3) < 2)
              {
                if (num5 == 0)
                {
                  Main.tile[i + 1, index2].frameX = (short) 66;
                  Main.tile[i + 1, index2].frameY = (short) 198;
                }
                if (num5 == 1)
                {
                  Main.tile[i + 1, index2].frameX = (short) 66;
                  Main.tile[i + 1, index2].frameY = (short) 220;
                }
                if (num5 == 2)
                {
                  Main.tile[i + 1, index2].frameX = (short) 66;
                  Main.tile[i + 1, index2].frameY = (short) 242;
                }
              }
              else
              {
                if (num5 == 0)
                {
                  Main.tile[i + 1, index2].frameX = (short) 88;
                  Main.tile[i + 1, index2].frameY = (short) 66;
                }
                if (num5 == 1)
                {
                  Main.tile[i + 1, index2].frameX = (short) 88;
                  Main.tile[i + 1, index2].frameY = (short) 88;
                }
                if (num5 == 2)
                {
                  Main.tile[i + 1, index2].frameX = (short) 88;
                  Main.tile[i + 1, index2].frameY = (short) 110;
                }
              }
            }
          }
          int num6 = WorldGen.genRand.Next(3);
          bool flag3 = false;
          bool flag4 = false;
          if (Main.tile[i - 1, index1].active() && !Main.tile[i - 1, index1].halfBrick() && Main.tile[i - 1, index1].slope() == (byte) 0 && (Main.tile[i - 1, index1].type == (ushort) 2 || Main.tile[i - 1, index1].type == (ushort) 23 || (Main.tile[i - 1, index1].type == (ushort) 60 || Main.tile[i - 1, index1].type == (ushort) 109)))
            flag3 = true;
          if (Main.tile[i + 1, index1].active() && !Main.tile[i + 1, index1].halfBrick() && Main.tile[i + 1, index1].slope() == (byte) 0 && (Main.tile[i + 1, index1].type == (ushort) 2 || Main.tile[i + 1, index1].type == (ushort) 23 || (Main.tile[i + 1, index1].type == (ushort) 60 || Main.tile[i + 1, index1].type == (ushort) 109)))
            flag4 = true;
          if (!flag3)
          {
            if (num6 == 0)
              num6 = 2;
            if (num6 == 1)
              num6 = 3;
          }
          if (!flag4)
          {
            if (num6 == 0)
              num6 = 1;
            if (num6 == 2)
              num6 = 3;
          }
          if (flag3 && !flag4)
            num6 = 2;
          if (flag4 && !flag3)
            num6 = 1;
          if (num6 == 0 || num6 == 1)
          {
            Main.tile[i + 1, index1 - 1].active(true);
            Main.tile[i + 1, index1 - 1].type = (ushort) 5;
            int num3 = WorldGen.genRand.Next(3);
            if (num3 == 0)
            {
              Main.tile[i + 1, index1 - 1].frameX = (short) 22;
              Main.tile[i + 1, index1 - 1].frameY = (short) 132;
            }
            if (num3 == 1)
            {
              Main.tile[i + 1, index1 - 1].frameX = (short) 22;
              Main.tile[i + 1, index1 - 1].frameY = (short) 154;
            }
            if (num3 == 2)
            {
              Main.tile[i + 1, index1 - 1].frameX = (short) 22;
              Main.tile[i + 1, index1 - 1].frameY = (short) 176;
            }
          }
          if (num6 == 0 || num6 == 2)
          {
            Main.tile[i - 1, index1 - 1].active(true);
            Main.tile[i - 1, index1 - 1].type = (ushort) 5;
            int num3 = WorldGen.genRand.Next(3);
            if (num3 == 0)
            {
              Main.tile[i - 1, index1 - 1].frameX = (short) 44;
              Main.tile[i - 1, index1 - 1].frameY = (short) 132;
            }
            if (num3 == 1)
            {
              Main.tile[i - 1, index1 - 1].frameX = (short) 44;
              Main.tile[i - 1, index1 - 1].frameY = (short) 154;
            }
            if (num3 == 2)
            {
              Main.tile[i - 1, index1 - 1].frameX = (short) 44;
              Main.tile[i - 1, index1 - 1].frameY = (short) 176;
            }
          }
          int num7 = WorldGen.genRand.Next(3);
          switch (num6)
          {
            case 0:
              if (num7 == 0)
              {
                Main.tile[i, index1 - 1].frameX = (short) 88;
                Main.tile[i, index1 - 1].frameY = (short) 132;
              }
              if (num7 == 1)
              {
                Main.tile[i, index1 - 1].frameX = (short) 88;
                Main.tile[i, index1 - 1].frameY = (short) 154;
              }
              if (num7 == 2)
              {
                Main.tile[i, index1 - 1].frameX = (short) 88;
                Main.tile[i, index1 - 1].frameY = (short) 176;
                break;
              }
              break;
            case 1:
              if (num7 == 0)
              {
                Main.tile[i, index1 - 1].frameX = (short) 0;
                Main.tile[i, index1 - 1].frameY = (short) 132;
              }
              if (num7 == 1)
              {
                Main.tile[i, index1 - 1].frameX = (short) 0;
                Main.tile[i, index1 - 1].frameY = (short) 154;
              }
              if (num7 == 2)
              {
                Main.tile[i, index1 - 1].frameX = (short) 0;
                Main.tile[i, index1 - 1].frameY = (short) 176;
                break;
              }
              break;
            case 2:
              if (num7 == 0)
              {
                Main.tile[i, index1 - 1].frameX = (short) 66;
                Main.tile[i, index1 - 1].frameY = (short) 132;
              }
              if (num7 == 1)
              {
                Main.tile[i, index1 - 1].frameX = (short) 66;
                Main.tile[i, index1 - 1].frameY = (short) 154;
              }
              if (num7 == 2)
              {
                Main.tile[i, index1 - 1].frameX = (short) 66;
                Main.tile[i, index1 - 1].frameY = (short) 176;
                break;
              }
              break;
          }
          if (WorldGen.genRand.Next(13) != 0)
          {
            int num3 = WorldGen.genRand.Next(3);
            if (num3 == 0)
            {
              Main.tile[i, index1 - num2].frameX = (short) 22;
              Main.tile[i, index1 - num2].frameY = (short) 198;
            }
            if (num3 == 1)
            {
              Main.tile[i, index1 - num2].frameX = (short) 22;
              Main.tile[i, index1 - num2].frameY = (short) 220;
            }
            if (num3 == 2)
            {
              Main.tile[i, index1 - num2].frameX = (short) 22;
              Main.tile[i, index1 - num2].frameY = (short) 242;
            }
          }
          else
          {
            int num3 = WorldGen.genRand.Next(3);
            if (num3 == 0)
            {
              Main.tile[i, index1 - num2].frameX = (short) 0;
              Main.tile[i, index1 - num2].frameY = (short) 198;
            }
            if (num3 == 1)
            {
              Main.tile[i, index1 - num2].frameX = (short) 0;
              Main.tile[i, index1 - num2].frameY = (short) 220;
            }
            if (num3 == 2)
            {
              Main.tile[i, index1 - num2].frameX = (short) 0;
              Main.tile[i, index1 - num2].frameY = (short) 242;
            }
          }
          WorldGen.RangeFrame(i - 2, index1 - num2 - 1, i + 2, index1 + 1);
          if (Main.netMode == 2)
            NetMessage.SendTileSquare(-1, i, (int) ((double) index1 - (double) num2 * 0.5), num2 + 1, TileChangeType.None);
          return true;
        }
      }
      return false;
    }

    public static bool Pyramid(int i, int j)
    {
      ushort num1 = 151;
      int num2 = j - WorldGen.genRand.Next(0, 7);
      int num3 = WorldGen.genRand.Next(9, 13);
      int num4 = 1;
      int num5 = j + WorldGen.genRand.Next(75, 125);
      for (int index1 = num2; index1 < num5; ++index1)
      {
        for (int index2 = i - num4; index2 < i + num4 - 1; ++index2)
        {
          Main.tile[index2, index1].type = num1;
          Main.tile[index2, index1].active(true);
          Main.tile[index2, index1].halfBrick(false);
          Main.tile[index2, index1].slope((byte) 0);
        }
        ++num4;
      }
      for (int i1 = i - num4 - 5; i1 <= i + num4 + 5; ++i1)
      {
        for (int j1 = j - 1; j1 <= num5 + 1; ++j1)
        {
          bool flag = true;
          for (int index1 = i1 - 1; index1 <= i1 + 1; ++index1)
          {
            for (int index2 = j1 - 1; index2 <= j1 + 1; ++index2)
            {
              if ((int) Main.tile[index1, index2].type != (int) num1)
                flag = false;
            }
          }
          if (flag)
          {
            Main.tile[i1, j1].wall = (ushort) 34;
            WorldGen.SquareWallFrame(i1, j1, true);
          }
        }
      }
      int num6 = 1;
      if (WorldGen.genRand.Next(2) == 0)
        num6 = -1;
      int num7 = i - num3 * num6;
      int j2 = j + num3;
      int num8 = WorldGen.genRand.Next(5, 8);
      bool flag1 = true;
      int num9 = WorldGen.genRand.Next(20, 30);
      while (flag1)
      {
        flag1 = false;
        bool flag2 = false;
        for (int index1 = j2; index1 <= j2 + num8; ++index1)
        {
          int index2 = num7;
          if (Main.tile[index2, index1 - 1].type == (ushort) 53)
            flag2 = true;
          if ((int) Main.tile[index2, index1].type == (int) num1)
          {
            Main.tile[index2, index1 + 1].wall = (ushort) 34;
            Main.tile[index2 + num6, index1].wall = (ushort) 34;
            Main.tile[index2, index1].active(false);
            flag1 = true;
          }
          if (flag2)
          {
            Main.tile[index2, index1].type = (ushort) 53;
            Main.tile[index2, index1].active(true);
            Main.tile[index2, index1].halfBrick(false);
            Main.tile[index2, index1].slope((byte) 0);
          }
        }
        num7 -= num6;
      }
      int index3 = i - num3 * num6;
      bool flag3 = true;
      bool flag4 = false;
      bool flag5 = true;
      while (flag5)
      {
        for (int index1 = j2; index1 <= j2 + num8; ++index1)
        {
          int index2 = index3;
          Main.tile[index2, index1].active(false);
        }
        index3 += num6;
        ++j2;
        --num9;
        if (j2 >= num5 - num8 * 2)
          num9 = 10;
        if (num9 <= 0)
        {
          bool flag2 = false;
          if (!flag3 && !flag4)
          {
            flag4 = true;
            flag2 = true;
            int num10 = WorldGen.genRand.Next(7, 13);
            int num11 = WorldGen.genRand.Next(23, 28);
            int num12 = num11;
            int num13 = index3;
            while (num11 > 0)
            {
              for (int index1 = j2 - num10 + num8; index1 <= j2 + num8; ++index1)
              {
                if (num11 == num12 || num11 == 1)
                {
                  if (index1 >= j2 - num10 + num8 + 2)
                    Main.tile[index3, index1].active(false);
                }
                else if (num11 == num12 - 1 || num11 == 2 || (num11 == num12 - 2 || num11 == 3))
                {
                  if (index1 >= j2 - num10 + num8 + 1)
                    Main.tile[index3, index1].active(false);
                }
                else
                  Main.tile[index3, index1].active(false);
              }
              --num11;
              index3 += num6;
            }
            int num14 = index3 - num6;
            int minValue = num14;
            int maxValue = num13;
            if (num14 > num13)
            {
              minValue = num13;
              maxValue = num14;
            }
            int contain = WorldGen.genRand.Next(3);
            switch (contain)
            {
              case 0:
                contain = 857;
                break;
              case 1:
                contain = 848;
                break;
              case 2:
                contain = 934;
                break;
            }
            WorldGen.AddBuriedChest((minValue + maxValue) / 2, j2, contain, false, 1, false, (ushort) 0);
            int num15 = WorldGen.genRand.Next(1, 10);
            for (int index1 = 0; index1 < num15; ++index1)
              WorldGen.PlaceSmallPile(WorldGen.genRand.Next(minValue, maxValue), j2 + num8, WorldGen.genRand.Next(16, 19), 1, (ushort) 185);
            WorldGen.PlaceTile(minValue + 2, j2 - num10 + num8 + 1, 91, true, false, -1, WorldGen.genRand.Next(4, 7));
            WorldGen.PlaceTile(minValue + 3, j2 - num10 + num8, 91, true, false, -1, WorldGen.genRand.Next(4, 7));
            WorldGen.PlaceTile(maxValue - 2, j2 - num10 + num8 + 1, 91, true, false, -1, WorldGen.genRand.Next(4, 7));
            WorldGen.PlaceTile(maxValue - 3, j2 - num10 + num8, 91, true, false, -1, WorldGen.genRand.Next(4, 7));
            for (int x = minValue; x <= maxValue; ++x)
              WorldGen.PlacePot(x, j2 + num8, (ushort) 28, WorldGen.genRand.Next(25, 28));
          }
          if (flag3)
          {
            flag3 = false;
            num6 *= -1;
            num9 = WorldGen.genRand.Next(15, 20);
          }
          else if (flag2)
          {
            num9 = WorldGen.genRand.Next(10, 15);
          }
          else
          {
            num6 *= -1;
            num9 = WorldGen.genRand.Next(20, 40);
          }
        }
        if (j2 >= num5 - num8)
          flag5 = false;
      }
      int num16 = WorldGen.genRand.Next(100, 200);
      int num17 = WorldGen.genRand.Next(500, 800);
      bool flag6 = true;
      int num18 = num8;
      int num19 = WorldGen.genRand.Next(10, 50);
      if (num6 == 1)
        index3 -= num18;
      int num20 = WorldGen.genRand.Next(5, 10);
      while (flag6)
      {
        --num16;
        --num17;
        --num19;
        for (int index1 = index3 - num20 - WorldGen.genRand.Next(0, 2); index1 <= index3 + num18 + num20 + WorldGen.genRand.Next(0, 2); ++index1)
        {
          int index2 = j2;
          if (index1 >= index3 && index1 <= index3 + num18)
          {
            Main.tile[index1, index2].active(false);
          }
          else
          {
            Main.tile[index1, index2].type = num1;
            Main.tile[index1, index2].active(true);
            Main.tile[index1, index2].halfBrick(false);
            Main.tile[index1, index2].slope((byte) 0);
          }
          if (index1 >= index3 - 1 && index1 <= index3 + 1 + num18)
            Main.tile[index1, index2].wall = (ushort) 34;
        }
        ++j2;
        index3 += num6;
        if (num16 <= 0)
        {
          flag6 = false;
          for (int index1 = index3 + 1; index1 <= index3 + num18 - 1; ++index1)
          {
            if (Main.tile[index1, j2].active())
              flag6 = true;
          }
        }
        if (num19 < 0)
        {
          num19 = WorldGen.genRand.Next(10, 50);
          num6 *= -1;
        }
        if (num17 <= 0)
          flag6 = false;
      }
      return true;
    }

    public static bool GrowLivingTree(int i, int j, bool patch = false)
    {
      int index1 = 0;
      int[] numArray1 = new int[1000];
      int[] numArray2 = new int[1000];
      int[] numArray3 = new int[1000];
      int[] numArray4 = new int[1000];
      int index2 = 0;
      int[] numArray5 = new int[2000];
      int[] numArray6 = new int[2000];
      bool[] flagArray = new bool[2000];
      if (!WorldGen.SolidTile(i, j + 1, false) || Main.tile[i, j].active() || Main.tile[i, j + 1].type != (ushort) 0 && Main.tile[i, j + 1].type != (ushort) 2 && (Main.tile[i, j + 1].type != (ushort) 1 && Main.tile[i, j + 1].type != (ushort) 40) && !TileID.Sets.Ore[(int) Main.tile[i, j + 1].type] || j < 150)
        return false;
      int num1 = i - WorldGen.genRand.Next(2, 3);
      int num2 = i + WorldGen.genRand.Next(2, 3);
      if (WorldGen.genRand.Next(5) == 0)
      {
        if (WorldGen.genRand.Next(2) == 0)
          --num1;
        else
          ++num2;
      }
      int num3 = num2 - num1;
      bool flag1 = num3 >= 4;
      int num4 = i - 50;
      int num5 = i + 50;
      if (patch)
      {
        num4 = i - 20;
        num5 = i + 20;
        num1 = i - WorldGen.genRand.Next(1, 3);
        num2 = i + WorldGen.genRand.Next(1, 3);
        flag1 = num3 >= 4;
      }
      for (int index3 = num4; index3 <= num5; ++index3)
      {
        for (int index4 = 5; index4 < j - 5; ++index4)
        {
          if (Main.tile[index3, index4].active())
          {
            if (!patch)
              return false;
            switch (Main.tile[index3, index4].type)
            {
              case 0:
              case 1:
              case 2:
              case 191:
              case 192:
                continue;
              default:
                return false;
            }
          }
        }
      }
      int num6 = num1;
      int num7 = num2;
      int minl = num1;
      int minr = num2;
      bool flag2 = true;
      int num8 = WorldGen.genRand.Next(-8, -4);
      int num9 = WorldGen.genRand.Next(2);
      int index5 = j;
      int num10 = WorldGen.genRand.Next(5, 15);
      Main.tileSolid[48] = false;
      while (flag2)
      {
        ++num8;
        if (num8 > num10)
        {
          num10 = WorldGen.genRand.Next(5, 15);
          num8 = 0;
          numArray2[index1] = index5 + WorldGen.genRand.Next(5);
          if (WorldGen.genRand.Next(5) == 0)
            num9 = num9 != 0 ? 0 : 1;
          if (num9 == 0)
          {
            numArray3[index1] = -1;
            numArray1[index1] = num1;
            numArray4[index1] = num2 - num1;
            if (WorldGen.genRand.Next(2) == 0)
              ++num1;
            ++num6;
            num9 = 1;
          }
          else
          {
            numArray3[index1] = 1;
            numArray1[index1] = num2;
            numArray4[index1] = num2 - num1;
            if (WorldGen.genRand.Next(2) == 0)
              --num2;
            --num7;
            num9 = 0;
          }
          if (num6 == num7)
            flag2 = false;
          ++index1;
        }
        for (int index3 = num1; index3 <= num2; ++index3)
        {
          Main.tile[index3, index5].type = (ushort) 191;
          Main.tile[index3, index5].active(true);
          Main.tile[index3, index5].halfBrick(false);
        }
        --index5;
      }
      for (int index3 = 0; index3 < index1 - 1; ++index3)
      {
        int index4 = numArray1[index3] + numArray3[index3];
        int index6 = numArray2[index3];
        int num11 = (int) ((double) numArray4[index3] * (1.0 + (double) WorldGen.genRand.Next(20, 30) * 0.100000001490116));
        Main.tile[index4, index6 + 1].type = (ushort) 191;
        Main.tile[index4, index6 + 1].active(true);
        Main.tile[index4, index6 + 1].halfBrick(false);
        int num12 = WorldGen.genRand.Next(3, 5);
        while (num11 > 0)
        {
          --num11;
          Main.tile[index4, index6].type = (ushort) 191;
          Main.tile[index4, index6].active(true);
          Main.tile[index4, index6].halfBrick(false);
          if (WorldGen.genRand.Next(10) == 0)
          {
            if (WorldGen.genRand.Next(2) == 0)
              --index6;
            else
              ++index6;
          }
          else
            index4 += numArray3[index3];
          if (num12 > 0)
            --num12;
          else if (WorldGen.genRand.Next(2) == 0)
          {
            num12 = WorldGen.genRand.Next(2, 5);
            if (WorldGen.genRand.Next(2) == 0)
            {
              Main.tile[index4, index6].type = (ushort) 191;
              Main.tile[index4, index6].active(true);
              Main.tile[index4, index6].halfBrick(false);
              Main.tile[index4, index6 - 1].type = (ushort) 191;
              Main.tile[index4, index6 - 1].active(true);
              Main.tile[index4, index6 - 1].halfBrick(false);
              numArray5[index2] = index4;
              numArray6[index2] = index6;
              ++index2;
            }
            else
            {
              Main.tile[index4, index6].type = (ushort) 191;
              Main.tile[index4, index6].active(true);
              Main.tile[index4, index6].halfBrick(false);
              Main.tile[index4, index6 + 1].type = (ushort) 191;
              Main.tile[index4, index6 + 1].active(true);
              Main.tile[index4, index6 + 1].halfBrick(false);
              numArray5[index2] = index4;
              numArray6[index2] = index6;
              ++index2;
            }
          }
          if (num11 == 0)
          {
            numArray5[index2] = index4;
            numArray6[index2] = index6;
            ++index2;
          }
        }
      }
      int index7 = (num1 + num2) / 2;
      int index8 = index5;
      int num13 = WorldGen.genRand.Next(num3 * 3, num3 * 5);
      int num14 = 0;
      int num15 = 0;
      for (; num13 > 0; --num13)
      {
        Main.tile[index7, index8].type = (ushort) 191;
        Main.tile[index7, index8].active(true);
        Main.tile[index7, index8].halfBrick(false);
        if (num14 > 0)
          --num14;
        if (num15 > 0)
          --num15;
        for (int index3 = -1; index3 < 2; ++index3)
        {
          if (index3 != 0 && (index3 < 0 && num14 == 0 || index3 > 0 && num15 == 0) && WorldGen.genRand.Next(2) == 0)
          {
            int index4 = index7;
            int index6 = index8;
            int num11 = WorldGen.genRand.Next(num3, num3 * 3);
            if (index3 < 0)
              num14 = WorldGen.genRand.Next(3, 5);
            if (index3 > 0)
              num15 = WorldGen.genRand.Next(3, 5);
            int num12 = 0;
            while (num11 > 0)
            {
              --num11;
              index4 += index3;
              Main.tile[index4, index6].type = (ushort) 191;
              Main.tile[index4, index6].active(true);
              Main.tile[index4, index6].halfBrick(false);
              if (num11 == 0)
              {
                numArray5[index2] = index4;
                numArray6[index2] = index6;
                flagArray[index2] = true;
                ++index2;
              }
              if (WorldGen.genRand.Next(5) == 0)
              {
                if (WorldGen.genRand.Next(2) == 0)
                  --index6;
                else
                  ++index6;
                Main.tile[index4, index6].type = (ushort) 191;
                Main.tile[index4, index6].active(true);
                Main.tile[index4, index6].halfBrick(false);
              }
              if (num12 > 0)
                --num12;
              else if (WorldGen.genRand.Next(3) == 0)
              {
                num12 = WorldGen.genRand.Next(2, 4);
                int index9 = index4;
                int num16 = index6;
                int index10 = WorldGen.genRand.Next(2) != 0 ? num16 + 1 : num16 - 1;
                Main.tile[index9, index10].type = (ushort) 191;
                Main.tile[index9, index10].active(true);
                Main.tile[index9, index10].halfBrick(false);
                numArray5[index2] = index9;
                numArray6[index2] = index10;
                flagArray[index2] = true;
                int index11 = index2 + 1;
                numArray5[index11] = index9 + WorldGen.genRand.Next(-5, 6);
                numArray6[index11] = index10 + WorldGen.genRand.Next(-5, 6);
                flagArray[index11] = true;
                index2 = index11 + 1;
              }
            }
          }
        }
        numArray5[index2] = index7;
        numArray6[index2] = index8;
        ++index2;
        if (WorldGen.genRand.Next(4) == 0)
        {
          if (WorldGen.genRand.Next(2) == 0)
            --index7;
          else
            ++index7;
          Main.tile[index7, index8].type = (ushort) 191;
          Main.tile[index7, index8].active(true);
          Main.tile[index7, index8].halfBrick(false);
        }
        --index8;
      }
      for (int i1 = minl; i1 <= minr; ++i1)
      {
        int num11 = WorldGen.genRand.Next(1, 6);
        int j1 = j + 1;
        while (num11 > 0)
        {
          if (WorldGen.SolidTile(i1, j1, false))
            --num11;
          Main.tile[i1, j1].type = (ushort) 191;
          Main.tile[i1, j1].active(true);
          Main.tile[i1, j1].halfBrick(false);
          ++j1;
        }
        int num12 = j1;
        int num16 = WorldGen.genRand.Next(2, num3 + 1);
        for (int index3 = 0; index3 < num16; ++index3)
        {
          int index4 = num12;
          int num17 = (minl + minr) / 2;
          int num18 = 1;
          int num19 = i1 >= num17 ? 1 : -1;
          if (i1 == num17 || num3 > 6 && (i1 == num17 - 1 || i1 == num17 + 1))
            num19 = 0;
          int num20 = num19;
          int index6 = i1;
          int num21 = WorldGen.genRand.Next((int) ((double) num3 * 3.5), num3 * 6);
          while (num21 > 0)
          {
            --num21;
            index6 += num19;
            if (Main.tile[index6, index4].wall != (ushort) 244)
            {
              Main.tile[index6, index4].type = (ushort) 191;
              Main.tile[index6, index4].active(true);
              Main.tile[index6, index4].halfBrick(false);
            }
            index4 += num18;
            if (Main.tile[index6, index4].wall != (ushort) 244)
            {
              Main.tile[index6, index4].type = (ushort) 191;
              Main.tile[index6, index4].active(true);
              Main.tile[index6, index4].halfBrick(false);
            }
            if (!Main.tile[index6, index4 + 1].active())
            {
              num19 = 0;
              num18 = 1;
            }
            if (WorldGen.genRand.Next(3) == 0)
              num19 = num20 >= 0 ? (num20 <= 0 ? WorldGen.genRand.Next(-1, 2) : (num19 != 0 ? 0 : 1)) : (num19 != 0 ? 0 : -1);
            if (WorldGen.genRand.Next(3) == 0)
              num18 = num18 != 0 ? 0 : 1;
          }
        }
      }
      for (int index3 = 0; index3 < index2; ++index3)
      {
        int num11 = (int) ((double) WorldGen.genRand.Next(5, 8) * (1.0 + (double) num3 * 0.0500000007450581));
        if (flagArray[index3])
          num11 = WorldGen.genRand.Next(6, 12) + num3;
        int num12 = numArray5[index3] - num11 * 2;
        int num16 = numArray5[index3] + num11 * 2;
        int num17 = numArray6[index3] - num11 * 2;
        int num18 = numArray6[index3] + num11 * 2;
        float num19 = (float) (2.0 - (double) WorldGen.genRand.Next(5) * 0.100000001490116);
        for (int i1 = num12; i1 <= num16; ++i1)
        {
          for (int index4 = num17; index4 <= num18; ++index4)
          {
            if (Main.tile[i1, index4].type != (ushort) 191)
            {
              if (flagArray[index3])
              {
                if ((double) (new Vector2((float) numArray5[index3], (float) numArray6[index3]) - new Vector2((float) i1, (float) index4)).Length() < (double) num11 * 0.9)
                {
                  Main.tile[i1, index4].type = (ushort) 192;
                  Main.tile[i1, index4].active(true);
                  Main.tile[i1, index4].halfBrick(false);
                }
              }
              else if ((double) Math.Abs(numArray5[index3] - i1) + (double) Math.Abs(numArray6[index3] - index4) * (double) num19 < (double) num11)
              {
                Main.tile[i1, index4].type = (ushort) 192;
                Main.tile[i1, index4].active(true);
                Main.tile[i1, index4].halfBrick(false);
              }
            }
          }
          if (WorldGen.genRand.Next(30) == 0)
          {
            int j1 = num17;
            if (!Main.tile[i1, j1].active())
            {
              while (!Main.tile[i1, j1 + 1].active() && j1 < num18)
                ++j1;
              if (Main.tile[i1, j1 + 1].type == (ushort) 192)
                WorldGen.PlaceTile(i1, j1, 187, true, false, -1, WorldGen.genRand.Next(50, 52));
            }
          }
          if (!flagArray[index3] && WorldGen.genRand.Next(15) == 0)
          {
            int j1 = num18;
            int num20 = j1 + 100;
            if (!Main.tile[i1, j1].active())
            {
              while (!Main.tile[i1, j1 + 1].active() && j1 < num20)
                ++j1;
              if (Main.tile[i1, j1 + 1].type != (ushort) 192)
              {
                if (WorldGen.genRand.Next(2) == 0)
                {
                  WorldGen.PlaceTile(i1, j1, 187, true, false, -1, WorldGen.genRand.Next(47, 50));
                }
                else
                {
                  int Y = WorldGen.genRand.Next(2);
                  int X = 72;
                  if (Y == 1)
                    X = WorldGen.genRand.Next(59, 62);
                  WorldGen.PlaceSmallPile(i1, j1, X, Y, (ushort) 185);
                }
              }
            }
          }
        }
      }
      if (flag1)
      {
        bool flag3 = false;
        for (int j1 = j; j1 < j + 20 && (double) j1 < Main.worldSurface - 2.0; ++j1)
        {
          for (int i1 = minl; i1 <= minr; ++i1)
          {
            if (Main.tile[i1, j1].wall == (ushort) 0 && !WorldGen.SolidTile(i1, j1, false))
              flag3 = true;
          }
        }
        if (!flag3)
          WorldGen.GrowLivingTree_MakePassage(j, num3, ref minl, ref minr, patch);
      }
      Main.tileSolid[48] = true;
      return true;
    }

    public static bool GrowDungeonTree(int i, int j, bool patch = false)
    {
      int index1 = 0;
      int[] numArray1 = new int[1000];
      int[] numArray2 = new int[1000];
      int[] numArray3 = new int[1000];
      int[] numArray4 = new int[1000];
      int index2 = 0;
      int[] numArray5 = new int[2000];
      int[] numArray6 = new int[2000];
      bool[] flagArray = new bool[2000];
      int num1 = i - WorldGen.genRand.Next(2, 3);
      int num2 = i + WorldGen.genRand.Next(2, 3);
      if (WorldGen.genRand.Next(5) == 0)
      {
        if (WorldGen.genRand.Next(2) == 0)
          --num1;
        else
          ++num2;
      }
      int num3 = num2 - num1;
      int num4 = num1;
      int num5 = num2;
      int minl = num1;
      int minr = num2;
      bool flag = true;
      int num6 = WorldGen.genRand.Next(-8, -4);
      int num7 = WorldGen.genRand.Next(2);
      int index3 = j;
      int num8 = WorldGen.genRand.Next(5, 15);
      Main.tileSolid[48] = false;
      while (flag)
      {
        ++num6;
        if (num6 > num8)
        {
          num8 = WorldGen.genRand.Next(5, 15);
          num6 = 0;
          numArray2[index1] = index3 + WorldGen.genRand.Next(5);
          if (WorldGen.genRand.Next(5) == 0)
            num7 = num7 != 0 ? 0 : 1;
          if (num7 == 0)
          {
            numArray3[index1] = -1;
            numArray1[index1] = num1;
            numArray4[index1] = num2 - num1;
            if (WorldGen.genRand.Next(2) == 0)
              ++num1;
            ++num4;
            num7 = 1;
          }
          else
          {
            numArray3[index1] = 1;
            numArray1[index1] = num2;
            numArray4[index1] = num2 - num1;
            if (WorldGen.genRand.Next(2) == 0)
              --num2;
            --num5;
            num7 = 0;
          }
          if (num4 == num5)
            flag = false;
          ++index1;
        }
        for (int index4 = num1; index4 <= num2; ++index4)
        {
          Main.tile[index4, index3].type = (ushort) 191;
          Main.tile[index4, index3].active(true);
          Main.tile[index4, index3].halfBrick(false);
          Main.tile[index4, index3].color((byte) 28);
        }
        --index3;
      }
      for (int index4 = 0; index4 < index1 - 1; ++index4)
      {
        int index5 = numArray1[index4] + numArray3[index4];
        int index6 = numArray2[index4];
        int num9 = (int) ((double) numArray4[index4] * (1.0 + (double) WorldGen.genRand.Next(20, 30) * 0.100000001490116));
        Main.tile[index5, index6 + 1].type = (ushort) 191;
        Main.tile[index5, index6 + 1].active(true);
        Main.tile[index5, index6 + 1].halfBrick(false);
        Main.tile[index5, index6 + 1].color((byte) 28);
        int num10 = WorldGen.genRand.Next(3, 5);
        while (num9 > 0)
        {
          --num9;
          Main.tile[index5, index6].type = (ushort) 191;
          Main.tile[index5, index6].active(true);
          Main.tile[index5, index6].halfBrick(false);
          Main.tile[index5, index6].color((byte) 28);
          if (WorldGen.genRand.Next(10) == 0)
          {
            if (WorldGen.genRand.Next(2) == 0)
              --index6;
            else
              ++index6;
          }
          else
            index5 += numArray3[index4];
          if (num10 > 0)
            --num10;
          else if (WorldGen.genRand.Next(2) == 0)
          {
            num10 = WorldGen.genRand.Next(2, 5);
            if (WorldGen.genRand.Next(2) == 0)
            {
              Main.tile[index5, index6].type = (ushort) 191;
              Main.tile[index5, index6].active(true);
              Main.tile[index5, index6].halfBrick(false);
              Main.tile[index5, index6].color((byte) 28);
              Main.tile[index5, index6 - 1].type = (ushort) 191;
              Main.tile[index5, index6 - 1].active(true);
              Main.tile[index5, index6 - 1].halfBrick(false);
              Main.tile[index5, index6 - 1].color((byte) 28);
              numArray5[index2] = index5;
              numArray6[index2] = index6;
              ++index2;
            }
            else
            {
              Main.tile[index5, index6].type = (ushort) 191;
              Main.tile[index5, index6].active(true);
              Main.tile[index5, index6].halfBrick(false);
              Main.tile[index5, index6].color((byte) 28);
              Main.tile[index5, index6 + 1].type = (ushort) 191;
              Main.tile[index5, index6 + 1].active(true);
              Main.tile[index5, index6 + 1].halfBrick(false);
              Main.tile[index5, index6 + 1].color((byte) 28);
              numArray5[index2] = index5;
              numArray6[index2] = index6;
              ++index2;
            }
          }
          if (num9 == 0)
          {
            numArray5[index2] = index5;
            numArray6[index2] = index6;
            ++index2;
          }
        }
      }
      int index7 = (num1 + num2) / 2;
      int index8 = index3;
      int num11 = WorldGen.genRand.Next(num3 * 3, num3 * 5);
      int num12 = 0;
      int num13 = 0;
      for (; num11 > 0; --num11)
      {
        Main.tile[index7, index8].type = (ushort) 191;
        Main.tile[index7, index8].active(true);
        Main.tile[index7, index8].halfBrick(false);
        Main.tile[index7, index8].color((byte) 28);
        if (num12 > 0)
          --num12;
        if (num13 > 0)
          --num13;
        for (int index4 = -1; index4 < 2; ++index4)
        {
          if (index4 != 0 && (index4 < 0 && num12 == 0 || index4 > 0 && num13 == 0) && WorldGen.genRand.Next(2) == 0)
          {
            int index5 = index7;
            int index6 = index8;
            int num9 = WorldGen.genRand.Next(num3, num3 * 3);
            if (index4 < 0)
              num12 = WorldGen.genRand.Next(3, 5);
            if (index4 > 0)
              num13 = WorldGen.genRand.Next(3, 5);
            int num10 = 0;
            while (num9 > 0)
            {
              --num9;
              index5 += index4;
              Main.tile[index5, index6].type = (ushort) 191;
              Main.tile[index5, index6].active(true);
              Main.tile[index5, index6].halfBrick(false);
              Main.tile[index5, index6].color((byte) 28);
              if (num9 == 0)
              {
                numArray5[index2] = index5;
                numArray6[index2] = index6;
                flagArray[index2] = true;
                ++index2;
              }
              if (WorldGen.genRand.Next(5) == 0)
              {
                if (WorldGen.genRand.Next(2) == 0)
                  --index6;
                else
                  ++index6;
                Main.tile[index5, index6].type = (ushort) 191;
                Main.tile[index5, index6].active(true);
                Main.tile[index5, index6].halfBrick(false);
                Main.tile[index5, index6].color((byte) 28);
              }
              if (num10 > 0)
                --num10;
              else if (WorldGen.genRand.Next(3) == 0)
              {
                num10 = WorldGen.genRand.Next(2, 4);
                int index9 = index5;
                int num14 = index6;
                int index10 = WorldGen.genRand.Next(2) != 0 ? num14 + 1 : num14 - 1;
                Main.tile[index9, index10].type = (ushort) 191;
                Main.tile[index9, index10].active(true);
                Main.tile[index9, index10].halfBrick(false);
                Main.tile[index9, index10].color((byte) 28);
                numArray5[index2] = index9;
                numArray6[index2] = index10;
                flagArray[index2] = true;
                int index11 = index2 + 1;
                numArray5[index11] = index9 + WorldGen.genRand.Next(-5, 6);
                numArray6[index11] = index10 + WorldGen.genRand.Next(-5, 6);
                flagArray[index11] = true;
                index2 = index11 + 1;
              }
            }
          }
        }
        numArray5[index2] = index7;
        numArray6[index2] = index8;
        ++index2;
        if (WorldGen.genRand.Next(4) == 0)
        {
          if (WorldGen.genRand.Next(2) == 0)
            --index7;
          else
            ++index7;
          Main.tile[index7, index8].type = (ushort) 191;
          Main.tile[index7, index8].active(true);
          Main.tile[index7, index8].halfBrick(false);
          Main.tile[index7, index8].color((byte) 28);
        }
        --index8;
      }
      for (int i1 = minl; i1 <= minr; ++i1)
      {
        int num9 = WorldGen.genRand.Next(1, 6);
        int j1 = j + 1;
        while (num9 > 0)
        {
          if (WorldGen.SolidTile(i1, j1, false))
            --num9;
          Main.tile[i1, j1].type = (ushort) 191;
          Main.tile[i1, j1].active(true);
          Main.tile[i1, j1].halfBrick(false);
          ++j1;
        }
        int num10 = j1;
        int num14 = WorldGen.genRand.Next(2, num3 + 1);
        for (int index4 = 0; index4 < num14; ++index4)
        {
          int index5 = num10;
          int num15 = (minl + minr) / 2;
          int num16 = 1;
          int num17 = i1 >= num15 ? 1 : -1;
          if (i1 == num15 || num3 > 6 && (i1 == num15 - 1 || i1 == num15 + 1))
            num17 = 0;
          int num18 = num17;
          int index6 = i1;
          int num19 = WorldGen.genRand.Next((int) ((double) num3 * 3.5), num3 * 6);
          while (num19 > 0)
          {
            --num19;
            index6 += num17;
            if (Main.tile[index6, index5].wall != (ushort) 244)
            {
              Main.tile[index6, index5].type = (ushort) 191;
              Main.tile[index6, index5].active(true);
              Main.tile[index6, index5].halfBrick(false);
            }
            index5 += num16;
            if (Main.tile[index6, index5].wall != (ushort) 244)
            {
              Main.tile[index6, index5].type = (ushort) 191;
              Main.tile[index6, index5].active(true);
              Main.tile[index6, index5].halfBrick(false);
            }
            if (!Main.tile[index6, index5 + 1].active())
            {
              num17 = 0;
              num16 = 1;
            }
            if (WorldGen.genRand.Next(3) == 0)
              num17 = num18 >= 0 ? (num18 <= 0 ? WorldGen.genRand.Next(-1, 2) : (num17 != 0 ? 0 : 1)) : (num17 != 0 ? 0 : -1);
            if (WorldGen.genRand.Next(3) == 0)
              num16 = num16 != 0 ? 0 : 1;
          }
        }
      }
      for (int index4 = 0; index4 < index2; ++index4)
      {
        int num9 = (int) ((double) WorldGen.genRand.Next(5, 8) * (1.0 + (double) num3 * 0.0500000007450581));
        if (flagArray[index4])
          num9 = WorldGen.genRand.Next(6, 12) + num3;
        int num10 = numArray5[index4] - num9 * 2;
        int num14 = numArray5[index4] + num9 * 2;
        int num15 = numArray6[index4] - num9 * 2;
        int num16 = numArray6[index4] + num9 * 2;
        float num17 = (float) (2.0 - (double) WorldGen.genRand.Next(5) * 0.100000001490116);
        for (int index5 = num10; index5 <= num14; ++index5)
        {
          for (int index6 = num15; index6 <= num16; ++index6)
          {
            if (Main.tile[index5, index6].type != (ushort) 191)
            {
              if (flagArray[index4])
              {
                if ((double) (new Vector2((float) numArray5[index4], (float) numArray6[index4]) - new Vector2((float) index5, (float) index6)).Length() < (double) num9 * 0.9)
                {
                  Main.tile[index5, index6].type = (ushort) 192;
                  Main.tile[index5, index6].active(true);
                  Main.tile[index5, index6].halfBrick(false);
                  Main.tile[index5, index6].color((byte) 28);
                }
              }
              else if ((double) Math.Abs(numArray5[index4] - index5) + (double) Math.Abs(numArray6[index4] - index6) * (double) num17 < (double) num9)
              {
                Main.tile[index5, index6].type = (ushort) 192;
                Main.tile[index5, index6].active(true);
                Main.tile[index5, index6].halfBrick(false);
                Main.tile[index5, index6].color((byte) 28);
              }
            }
          }
        }
      }
      WorldGen.GrowDungeonTree_MakePassage(j, num3, ref minl, ref minr, patch);
      Main.tileSolid[48] = true;
      return true;
    }

    private static bool GrowLivingTree_HorizontalTunnel(int i, int j)
    {
      int num1 = i;
      int y = j;
      int num2 = num1;
      int num3 = num1;
      int num4 = 80;
      bool flag1 = false;
      int num5 = 1;
      if (WorldGen.genRand.Next(2) == 0)
        num5 *= -1;
      for (int index1 = 0; index1 < 2; ++index1)
      {
        bool flag2 = false;
        if (num2 == num1 && num5 > 0)
        {
          for (int x = num1 + 5; x < num1 + num4; ++x)
          {
            if (!WorldGen.InWorld(x, y, 10))
              return false;
            if ((double) y < Main.worldSurface)
            {
              int index2 = y - 7;
              while (index2 <= y + 7 && Main.tile[x, index2].wall != (ushort) 0)
                ++index2;
            }
            if (Main.tile[x, j].type == (ushort) 48)
            {
              flag1 = true;
              break;
            }
            if (Main.tile[x, j].type == (ushort) 191)
            {
              for (int index2 = y - 2; index2 <= y; ++index2)
              {
                if (Main.tile[x + 2, index2].wall != (ushort) 244)
                  flag2 = true;
              }
              if (!flag2)
              {
                index1 = 2;
                num3 = x + 2;
                break;
              }
              break;
            }
            if (!Main.tile[x, j].active())
            {
              bool flag3 = true;
              for (int index2 = y - 2; index2 <= y; ++index2)
              {
                if ((double) y < Main.worldSurface + 3.0 && (Main.tile[x + 1, index2].wall == (ushort) 0 || Main.tile[x + 2, index2].wall == (ushort) 0 || Main.tile[x + 3, index2].wall == (ushort) 0))
                  return false;
                if (Main.tile[x, index2].active() || Main.tile[x + 1, index2].active() || Main.tile[x + 2, index2].active())
                  flag3 = false;
              }
              if (flag3)
              {
                index1 = 2;
                num3 = x;
                break;
              }
            }
          }
        }
        bool flag4 = false;
        if (num3 == num1 && num5 < 0)
        {
          for (int x = num1 - 5; x > num1 - num4; --x)
          {
            if (!WorldGen.InWorld(x, y, 10))
              return false;
            if ((double) y < Main.worldSurface)
            {
              int index2 = y - 7;
              while (index2 <= y + 7 && Main.tile[x, index2].wall != (ushort) 0)
                ++index2;
            }
            if (Main.tile[x, j].type == (ushort) 48)
            {
              flag1 = true;
              break;
            }
            if (Main.tile[x, y].type == (ushort) 191)
            {
              for (int index2 = y - 2; index2 <= y; ++index2)
              {
                if (Main.tile[x - 3, index2].wall != (ushort) 244)
                  flag4 = true;
              }
              if (!flag4)
              {
                index1 = 2;
                num2 = x - 2;
                break;
              }
              break;
            }
            if (!Main.tile[x, j].active())
            {
              bool flag3 = true;
              for (int index2 = y - 2; index2 <= y; ++index2)
              {
                if ((double) y < Main.worldSurface + 3.0 && (Main.tile[x - 1, index2].wall == (ushort) 0 || Main.tile[x - 2, index2].wall == (ushort) 0 || Main.tile[x - 3, index2].wall == (ushort) 0))
                  return false;
                if (Main.tile[x, index2].active() || Main.tile[x - 1, index2].active() || Main.tile[x - 2, index2].active())
                  flag3 = false;
              }
              if (flag3)
              {
                index1 = 2;
                num2 = x;
                break;
              }
            }
          }
        }
        num5 *= -1;
      }
      if (num2 == num3)
        return false;
      bool flag5 = false;
      bool flag6 = false;
      for (int j1 = y - 5; j1 <= y + 1; ++j1)
      {
        for (int i1 = num2; i1 <= num3; ++i1)
        {
          int num6 = 2;
          if (Math.Abs(i1 - num3) > 3 && Math.Abs(i1 - num2) > 3)
            num6 = 4;
          if (Main.tile[i1, j1].wall != (ushort) 244 && Main.tile[i1, j1].type != (ushort) 19 && (Main.tile[i1, j1].type != (ushort) 15 && Main.tile[i1, j1].type != (ushort) 304) && (Main.tile[i1, j1].type != (ushort) 21 && Main.tile[i1, j1].type != (ushort) 10))
          {
            if (!Main.wallDungeon[(int) Main.tile[i1, j1].wall] && (!Main.tile[i1, j1].active() || !Main.wallDungeon[(int) Main.tile[i1, j1 - 1].wall] && !Main.wallDungeon[(int) Main.tile[i1, j1 + 1].wall]))
            {
              Main.tile[i1, j1].active(true);
              Main.tile[i1, j1].type = (ushort) 191;
              Main.tile[i1, j1].halfBrick(false);
            }
            if (Main.tile[i1, j1 - 1].type == (ushort) 40)
              Main.tile[i1, j1 - 1].type = (ushort) 0;
            if (Main.tile[i1, j1 + 1].type == (ushort) 40)
              Main.tile[i1, j1 + 1].type = (ushort) 0;
          }
          if (j1 >= y - num6 && j1 <= y && (Main.tile[i1, j1].type != (ushort) 19 && Main.tile[i1, j1].type != (ushort) 15) && (Main.tile[i1, j1].type != (ushort) 304 && Main.tile[i1, j1].type != (ushort) 21 && (Main.tile[i1, j1].type != (ushort) 10 && Main.tile[i1, j1 - 1].type != (ushort) 15)) && (Main.tile[i1, j1 - 1].type != (ushort) 304 && Main.tile[i1, j1 - 1].type != (ushort) 21 && (Main.tile[i1, j1 - 1].type != (ushort) 10 && Main.tile[i1, j1 + 1].type != (ushort) 10)))
          {
            if (!Main.wallDungeon[(int) Main.tile[i1, j1].wall])
              Main.tile[i1, j1].wall = (ushort) 244;
            Main.tile[i1, j1].liquid = (byte) 0;
            Main.tile[i1, j1].active(false);
          }
          if (j1 == y)
          {
            int style = 7;
            if (Main.wallDungeon[(int) Main.tile[i1, j1].wall] || Main.wallDungeon[(int) Main.tile[i1, j1 - 1].wall] || Main.wallDungeon[(int) Main.tile[i1, j1 - 2].wall])
              style = 13;
            if (i1 <= num2 + 4 && !flag5)
            {
              if (Main.tile[i1 - 1, j1].type == (ushort) 10 || Main.tile[i1 + 1, j1].type == (ushort) 10)
                flag5 = true;
              else if (WorldGen.genRand.Next(3) == 0)
              {
                WorldGen.PlaceTile(i1, j1, 10, true, false, -1, style);
                if (Main.tile[i1, j1].type == (ushort) 10)
                  flag5 = true;
              }
            }
            if (i1 >= num3 - 4 && !flag6)
            {
              if (Main.tile[i1 - 1, j1].type == (ushort) 10 || Main.tile[i1 + 1, j1].type == (ushort) 10)
                flag6 = true;
              else if (WorldGen.genRand.Next(3) == 0)
              {
                WorldGen.PlaceTile(i1, j1, 10, true, false, -1, style);
                if (Main.tile[i1, j1].type == (ushort) 10)
                  flag6 = true;
              }
            }
          }
        }
      }
      return true;
    }

    private static void GrowDungeonTree_MakePassage(
      int j,
      int W,
      ref int minl,
      ref int minr,
      bool noSecretRoom = false)
    {
      int num1 = minl;
      int num2 = minr;
      int num3 = (minl + minr) / 2;
      int num4 = 5;
      int j1 = j - 6;
      int num5 = 0;
      bool flag = true;
      WorldGen.genRand.Next(5, 16);
label_1:
      int num6;
      int style;
      while (true)
      {
        int num7;
        do
        {
          do
          {
            ++j1;
            if (j1 <= WorldGen.dungeonY - 5)
            {
              num6 = (minl + minr) / 2;
              int num8 = 1;
              if (j1 > j && W <= 4)
                ++num8;
              for (int i = minl - num8; i <= minr + num8; ++i)
              {
                if (i > num6 - 2 && i <= num6 + 1)
                {
                  if (j1 > j - 4)
                  {
                    if (Main.tile[i, j1].type != (ushort) 19 && Main.tile[i, j1].type != (ushort) 15 && (Main.tile[i, j1].type != (ushort) 304 && Main.tile[i, j1].type != (ushort) 21) && (Main.tile[i, j1].type != (ushort) 10 && Main.tile[i, j1 - 1].type != (ushort) 15 && (Main.tile[i, j1 - 1].type != (ushort) 304 && Main.tile[i, j1 - 1].type != (ushort) 21)) && (Main.tile[i, j1 - 1].type != (ushort) 10 && Main.tile[i, j1 + 1].type != (ushort) 10))
                      Main.tile[i, j1].active(false);
                    if (!Main.wallDungeon[(int) Main.tile[i, j1].wall])
                      Main.tile[i, j1].wall = (ushort) 244;
                    if (!Main.wallDungeon[(int) Main.tile[i - 1, j1].wall] && (Main.tile[i - 1, j1].wall > (ushort) 0 || (double) j1 >= Main.worldSurface))
                      Main.tile[i - 1, j1].wall = (ushort) 244;
                    if (!Main.wallDungeon[(int) Main.tile[i + 1, j1].wall] && (Main.tile[i + 1, j1].wall > (ushort) 0 || (double) j1 >= Main.worldSurface))
                      Main.tile[i + 1, j1].wall = (ushort) 244;
                    if (j1 == j && i > num6 - 2 && i <= num6 + 1)
                    {
                      Main.tile[i, j1 + 1].active(false);
                      WorldGen.PlaceTile(i, j1 + 1, 19, true, false, -1, 23);
                    }
                  }
                }
                else
                {
                  if (Main.tile[i, j1].type != (ushort) 15 && Main.tile[i, j1].type != (ushort) 304 && (Main.tile[i, j1].type != (ushort) 21 && Main.tile[i, j1].type != (ushort) 10) && (Main.tile[i - 1, j1].type != (ushort) 10 && Main.tile[i + 1, j1].type != (ushort) 10))
                  {
                    if (!Main.wallDungeon[(int) Main.tile[i, j1].wall])
                    {
                      Main.tile[i, j1].type = (ushort) 191;
                      Main.tile[i, j1].active(true);
                      Main.tile[i, j1].halfBrick(false);
                    }
                    if (Main.tile[i - 1, j1].type == (ushort) 40)
                      Main.tile[i - 1, j1].type = (ushort) 0;
                    if (Main.tile[i + 1, j1].type == (ushort) 40)
                      Main.tile[i + 1, j1].type = (ushort) 0;
                  }
                  if (j1 <= j && j1 > j - 4 && (i > minl - num8 && i <= minr + num8 - 1))
                    Main.tile[i, j1].wall = (ushort) 244;
                }
                if (!WorldGen.gen)
                {
                  WorldGen.SquareTileFrame(i, j1, true);
                  WorldGen.SquareWallFrame(i, j1, true);
                }
              }
              ++num5;
            }
            else
              goto label_50;
          }
          while (num5 < 6);
          num5 = 0;
          num7 = WorldGen.genRand.Next(3);
          if (num7 == 0)
            num7 = -1;
          if (flag)
            num7 = 2;
          if (num7 == -1 && Main.tile[minl - num4, j1].wall == (ushort) 244)
            num7 = 1;
          else if (num7 == 1 && Main.tile[minr + num4, j1].wall == (ushort) 244)
            num7 = -1;
          if (num7 == 2)
          {
            flag = false;
            style = 23;
            if (Main.wallDungeon[(int) Main.tile[minl, j1 + 1].wall] || Main.wallDungeon[(int) Main.tile[minl + 1, j1 + 1].wall] || Main.wallDungeon[(int) Main.tile[minl + 2, j1 + 1].wall])
              style = 12;
          }
          else
            goto label_49;
        }
        while (!WorldGen.SolidTile(minl - 1, j1 + 1, false) && !WorldGen.SolidTile(minr + 1, j1 + 1, false) && style == 12);
        break;
label_49:
        minl += num7;
        minr += num7;
      }
      for (int i = minl; i <= minr; ++i)
      {
        if (i > num6 - 2 && i <= num6 + 1)
        {
          Main.tile[i, j1 + 1].active(false);
          WorldGen.PlaceTile(i, j1 + 1, 19, true, false, -1, style);
        }
      }
      goto label_1;
label_50:
      minl = num1;
      minr = num2;
      int num9 = (minl + minr) / 2;
      for (int index1 = minl; index1 <= minr; ++index1)
      {
        for (int index2 = j - 3; index2 <= j; ++index2)
        {
          Main.tile[index1, index2].active(false);
          if (!Main.wallDungeon[(int) Main.tile[index1, index2].wall])
            Main.tile[index1, index2].wall = (ushort) 244;
        }
      }
    }

    private static void GrowLivingTree_MakePassage(
      int j,
      int W,
      ref int minl,
      ref int minr,
      bool noSecretRoom = false)
    {
      bool flag1 = noSecretRoom;
      int num1 = minl;
      int num2 = minr;
      bool flag2 = false;
      int num3 = (minl + minr) / 2;
      int num4 = 5;
      int index1 = j - 6;
      int num5 = 50;
      int num6 = WorldGen.genRand.Next(400, 700);
      int num7 = 0;
      bool flag3 = true;
      int num8 = WorldGen.genRand.Next(5, 16);
      while (num6 > 0)
      {
        ++index1;
        --num6;
        --num5;
        int i1 = (minl + minr) / 2;
        if (!Main.tile[minl, index1].active() && Main.tile[minl, index1].wall == (ushort) 244 && (!Main.tile[minr, index1].active() && Main.tile[minr, index1].wall == (ushort) 244))
          break;
        int num9 = 1;
        if (index1 > j && W <= 4)
          ++num9;
        for (int i2 = minl - num9; i2 <= minr + num9; ++i2)
        {
          if (Main.wallDungeon[(int) Main.tile[i2, index1].wall])
          {
            flag1 = true;
            flag2 = true;
          }
          if (i2 > i1 - 2 && i2 <= i1 + 1)
          {
            if (index1 > j - 4)
            {
              if (Main.tile[i2, index1].type != (ushort) 19 && Main.tile[i2, index1].type != (ushort) 15 && (Main.tile[i2, index1].type != (ushort) 304 && Main.tile[i2, index1].type != (ushort) 21) && (Main.tile[i2, index1].type != (ushort) 10 && Main.tile[i2, index1 - 1].type != (ushort) 15 && (Main.tile[i2, index1 - 1].type != (ushort) 304 && Main.tile[i2, index1 - 1].type != (ushort) 21)) && (Main.tile[i2, index1 - 1].type != (ushort) 10 && Main.tile[i2, index1 + 1].type != (ushort) 10))
                Main.tile[i2, index1].active(false);
              if (!Main.wallDungeon[(int) Main.tile[i2, index1].wall])
                Main.tile[i2, index1].wall = (ushort) 244;
              if (!Main.wallDungeon[(int) Main.tile[i2 - 1, index1].wall] && (Main.tile[i2 - 1, index1].wall > (ushort) 0 || (double) index1 >= Main.worldSurface))
                Main.tile[i2 - 1, index1].wall = (ushort) 244;
              if (!Main.wallDungeon[(int) Main.tile[i2 + 1, index1].wall] && (Main.tile[i2 + 1, index1].wall > (ushort) 0 || (double) index1 >= Main.worldSurface))
                Main.tile[i2 + 1, index1].wall = (ushort) 244;
              if (index1 == j && i2 > i1 - 2 && i2 <= i1 + 1)
              {
                Main.tile[i2, index1 + 1].active(false);
                WorldGen.PlaceTile(i2, index1 + 1, 19, true, false, -1, 23);
              }
            }
          }
          else
          {
            if (Main.tile[i2, index1].type != (ushort) 15 && Main.tile[i2, index1].type != (ushort) 304 && (Main.tile[i2, index1].type != (ushort) 21 && Main.tile[i2, index1].type != (ushort) 10) && (Main.tile[i2 - 1, index1].type != (ushort) 10 && Main.tile[i2 + 1, index1].type != (ushort) 10))
            {
              if (!Main.wallDungeon[(int) Main.tile[i2, index1].wall])
              {
                Main.tile[i2, index1].type = (ushort) 191;
                Main.tile[i2, index1].active(true);
                Main.tile[i2, index1].halfBrick(false);
              }
              if (Main.tile[i2 - 1, index1].type == (ushort) 40)
                Main.tile[i2 - 1, index1].type = (ushort) 0;
              if (Main.tile[i2 + 1, index1].type == (ushort) 40)
                Main.tile[i2 + 1, index1].type = (ushort) 0;
            }
            if (index1 <= j && index1 > j - 4 && (i2 > minl - num9 && i2 <= minr + num9 - 1))
              Main.tile[i2, index1].wall = (ushort) 244;
          }
          if (!WorldGen.gen)
          {
            WorldGen.SquareTileFrame(i2, index1, true);
            WorldGen.SquareWallFrame(i2, index1, true);
          }
        }
        ++num7;
        if (num7 >= 6)
        {
          num7 = 0;
          int num10 = WorldGen.genRand.Next(3);
          if (num10 == 0)
            num10 = -1;
          if (flag3)
            num10 = 2;
          if (num10 == -1 && Main.tile[minl - num4, index1].wall == (ushort) 244)
            num10 = 1;
          else if (num10 == 1 && Main.tile[minr + num4, index1].wall == (ushort) 244)
            num10 = -1;
          if (num10 == 2)
          {
            flag3 = false;
            int style = 23;
            if (Main.wallDungeon[(int) Main.tile[minl, index1 + 1].wall] || Main.wallDungeon[(int) Main.tile[minl + 1, index1 + 1].wall] || Main.wallDungeon[(int) Main.tile[minl + 2, index1 + 1].wall])
              style = 12;
            for (int i2 = minl; i2 <= minr; ++i2)
            {
              if (i2 > i1 - 2 && i2 <= i1 + 1)
              {
                Main.tile[i2, index1 + 1].active(false);
                WorldGen.PlaceTile(i2, index1 + 1, 19, true, false, -1, style);
              }
            }
          }
          else
          {
            minl += num10;
            minr += num10;
          }
          if (noSecretRoom)
          {
            --num8;
            if (num8 <= 0)
              num8 = !WorldGen.GrowLivingTree_HorizontalTunnel(i1, index1) ? WorldGen.genRand.Next(2, 11) : WorldGen.genRand.Next(5, 21);
          }
          if (num5 <= 0 && !flag1)
          {
            flag1 = true;
            WorldGen.GrowLivingTreePassageRoom(minl, minr, index1);
          }
        }
        if (flag2)
        {
          bool flag4 = true;
          for (int i2 = minl; i2 <= minr; ++i2)
          {
            for (int j1 = index1 + 1; j1 <= index1 + 2; ++j1)
            {
              if (WorldGen.SolidTile(i2, j1, false))
                flag4 = false;
            }
          }
          if (flag4)
            num6 = 0;
        }
        else if (num5 <= 0)
        {
          bool flag4 = true;
          for (int i2 = minl; i2 <= minr; ++i2)
          {
            for (int j1 = index1 + 1; j1 <= index1 + 4; ++j1)
            {
              if (WorldGen.SolidTile(i2, j1, false))
                flag4 = false;
            }
          }
          if (flag4)
            num6 = 0;
        }
      }
      minl = num1;
      minr = num2;
      int num11 = (minl + minr) / 2;
      for (int index2 = minl; index2 <= minr; ++index2)
      {
        for (int index3 = j - 3; index3 <= j; ++index3)
        {
          Main.tile[index2, index3].active(false);
          bool flag4 = true;
          for (int index4 = index2 - 1; index4 <= index2 + 1; ++index4)
          {
            for (int index5 = index3 - 1; index5 <= index3 + 1; ++index5)
            {
              if (!Main.tile[index4, index5].active() && Main.tile[index4, index5].wall == (ushort) 0)
                flag4 = false;
            }
          }
          if (flag4 && !Main.wallDungeon[(int) Main.tile[index2, index3].wall])
            Main.tile[index2, index3].wall = (ushort) 244;
        }
      }
    }

    private static void GrowLivingTreePassageRoom(int minl, int minr, int Y)
    {
      int num1 = WorldGen.genRand.Next(2);
      if (num1 == 0)
        num1 = -1;
      int num2 = Y - 2;
      int num3 = Y;
      int num4 = (minl + minr) / 2;
      if (num1 < 0)
        --num4;
      if (num1 > 0)
        ++num4;
      int num5 = WorldGen.genRand.Next(15, 30);
      int num6 = num4 + num5;
      if (num1 < 0)
      {
        num6 = num4;
        num4 -= num5;
      }
      for (int index1 = num4; index1 < num6; ++index1)
      {
        for (int index2 = Y - 20; index2 < Y + 10; ++index2)
        {
          if (Main.tile[index1, index2].wall == (ushort) 0 && !Main.tile[index1, index2].active() && (double) index2 < Main.worldSurface)
            return;
        }
      }
      WorldGen.dMinX = num4;
      WorldGen.dMaxX = num6;
      if (num1 < 0)
        WorldGen.dMinX -= 40;
      else
        WorldGen.dMaxX += 40;
      for (int index1 = num4; index1 <= num6; ++index1)
      {
        for (int index2 = num2 - 2; index2 <= num3 + 2; ++index2)
        {
          if (Main.tile[index1 - 1, index2].type == (ushort) 40)
            Main.tile[index1 - 1, index2].type = (ushort) 0;
          if (Main.tile[index1 + 1, index2].type == (ushort) 40)
            Main.tile[index1 + 1, index2].type = (ushort) 0;
          if (Main.tile[index1, index2 - 1].type == (ushort) 40)
            Main.tile[index1, index2 - 1].type = (ushort) 0;
          if (Main.tile[index1, index2 + 1].type == (ushort) 40)
            Main.tile[index1, index2 + 1].type = (ushort) 0;
          if (Main.tile[index1, index2].wall != (ushort) 244 && Main.tile[index1, index2].type != (ushort) 19)
          {
            Main.tile[index1, index2].active(true);
            Main.tile[index1, index2].type = (ushort) 191;
            Main.tile[index1, index2].halfBrick(false);
          }
          if (index2 >= num2 && index2 <= num3)
          {
            Main.tile[index1, index2].liquid = (byte) 0;
            Main.tile[index1, index2].wall = (ushort) 244;
            Main.tile[index1, index2].active(false);
          }
        }
      }
      int i1 = (minl + minr) / 2 + 3 * num1;
      int j = Y;
      WorldGen.PlaceTile(i1, j, 10, true, false, -1, 7);
      int num7 = WorldGen.genRand.Next(5, 9);
      int num8 = WorldGen.genRand.Next(4, 6);
      int num9;
      int num10;
      if (num1 < 0)
      {
        num9 = num4 + num7;
        num10 = num4 - num7;
      }
      else
      {
        num10 = num6 - num7;
        num9 = num6 + num7;
      }
      int num11 = num3 - num8;
      for (int index1 = num10 - 2; index1 <= num9 + 2; ++index1)
      {
        for (int index2 = num11 - 2; index2 <= num3 + 2; ++index2)
        {
          if (Main.tile[index1 - 1, index2].type == (ushort) 40)
            Main.tile[index1 - 1, index2].type = (ushort) 40;
          if (Main.tile[index1 + 1, index2].type == (ushort) 40)
            Main.tile[index1 + 1, index2].type = (ushort) 40;
          if (Main.tile[index1, index2 - 1].type == (ushort) 40)
            Main.tile[index1, index2 - 1].type = (ushort) 40;
          if (Main.tile[index1, index2 + 1].type == (ushort) 40)
            Main.tile[index1, index2 + 1].type = (ushort) 40;
          if (Main.tile[index1, index2].wall != (ushort) 244 && Main.tile[index1, index2].type != (ushort) 19)
          {
            Main.tile[index1, index2].active(true);
            Main.tile[index1, index2].type = (ushort) 191;
            Main.tile[index1, index2].halfBrick(false);
          }
          if (index2 >= num11 && index2 <= num3 && (index1 >= num10 && index1 <= num9))
          {
            Main.tile[index1, index2].liquid = (byte) 0;
            Main.tile[index1, index2].wall = (ushort) 244;
            Main.tile[index1, index2].active(false);
          }
        }
      }
      int i2 = num10 - 2;
      if (num1 < 0)
        i2 = num9 + 2;
      WorldGen.PlaceTile(i2, j, 10, true, false, -1, 7);
      int i3 = num9;
      if (num1 < 0)
        i3 = num10;
      int maxValue = 2;
      if (WorldGen.genRand.Next(maxValue) == 0)
      {
        maxValue += 2;
        WorldGen.PlaceTile(i3, Y, 15, true, false, -1, 5);
        if (num1 < 0)
        {
          Main.tile[i3, Y - 1].frameX += (short) 18;
          Main.tile[i3, Y].frameX += (short) 18;
        }
      }
      int i4 = num9 - 2;
      if (num1 < 0)
        i4 = num10 + 2;
      WorldGen.PlaceTile(i4, Y, 304, true, false, -1, 0);
      int i5 = num9 - 4;
      if (num1 < 0)
        i5 = num10 + 4;
      if (WorldGen.genRand.Next(maxValue) == 0)
      {
        WorldGen.PlaceTile(i5, Y, 15, true, false, -1, 5);
        if (num1 > 0)
        {
          Main.tile[i5, Y - 1].frameX += (short) 18;
          Main.tile[i5, Y].frameX += (short) 18;
        }
      }
      int i6 = num9 - 7;
      if (num1 < 0)
        i6 = num10 + 8;
      int contain = 832;
      if (WorldGen.genRand.Next(3) == 0)
        contain = 4281;
      WorldGen.AddBuriedChest(i6, Y, contain, false, 12, false, (ushort) 0);
    }

    public static void TreeGrowFXCheck(int x, int y)
    {
      int treeHeight = 1;
      int passStyle = -1;
      Tile topTile = (Tile) null;
      for (int index = -1; index > -100; --index)
      {
        Tile tile = Main.tile[x, y + index];
        if (tile.active() && TileID.Sets.GetsCheckedForLeaves[(int) tile.type])
        {
          topTile = tile;
          ++treeHeight;
        }
        else
          break;
      }
      for (int index = 1; index < 5; ++index)
      {
        Tile t = Main.tile[x, y + index];
        if (t.active() && TileID.Sets.GetsCheckedForLeaves[(int) t.type])
        {
          ++treeHeight;
        }
        else
        {
          WorldGen.GetTreeLeaf(x, topTile, t, ref treeHeight, out int _, out passStyle);
          break;
        }
      }
      if (treeHeight <= 0 || passStyle <= 0)
        return;
      if (Main.netMode == 2)
        NetMessage.SendData(112, -1, -1, (NetworkText) null, 1, (float) x, (float) y, (float) treeHeight, passStyle, 0, 0);
      if (Main.netMode != 0)
        return;
      WorldGen.TreeGrowFX(x, y, treeHeight, passStyle, false);
    }

    public static void GetTreeLeaf(
      int x,
      Tile topTile,
      Tile t,
      ref int treeHeight,
      out int treeFrame,
      out int passStyle)
    {
      treeFrame = 0;
      passStyle = -1;
      if (topTile.frameX == (short) 22 || topTile.frameX == (short) 44 || topTile.frameX == (short) 66)
      {
        if (topTile.frameY == (short) 220)
          treeFrame = 1;
        else if (topTile.frameY == (short) 242)
          treeFrame = 2;
      }
      if (topTile.frameX == (short) 44 || topTile.frameX == (short) 66)
      {
        if (topTile.frameY == (short) 220)
          treeFrame = 1;
        else if (topTile.frameY == (short) 242)
          treeFrame = 2;
      }
      switch (topTile.type)
      {
        case 583:
        case 584:
        case 585:
        case 586:
        case 587:
        case 588:
        case 589:
          passStyle = 1249 + ((int) topTile.type - 583);
          break;
        case 596:
          passStyle = 1248;
          break;
        case 616:
          passStyle = 1257;
          break;
      }
      if (passStyle > -1)
        return;
      switch (t.type)
      {
        case 2:
        case 477:
          passStyle = 910;
          break;
        case 23:
        case 400:
          passStyle = 915;
          break;
        case 53:
          passStyle = 911;
          break;
        case 60:
          passStyle = 914;
          break;
        case 70:
          passStyle = 912;
          break;
        case 109:
        case 492:
          int num1 = 917;
          if (WorldGen.GetHollowTreeFoliageStyle() != 20)
          {
            if (x % 3 == 1)
              treeFrame += 3;
            if (x % 3 == 2)
              treeFrame += 6;
            switch (treeFrame)
            {
              case 0:
                passStyle = 2;
                break;
              case 1:
                passStyle = 1;
                break;
              case 2:
                passStyle = 7;
                break;
              case 3:
                passStyle = 4;
                break;
              case 4:
                passStyle = 5;
                break;
              case 5:
                passStyle = 6;
                break;
              case 6:
                passStyle = 3;
                break;
              case 7:
                passStyle = 8;
                break;
              case 8:
                passStyle = 0;
                break;
            }
          }
          else
          {
            int num2 = 196;
            if (x % 6 == 1)
              treeFrame += 3;
            else if (x % 6 == 2)
              treeFrame += 6;
            else if (x % 6 == 3)
              treeFrame += 9;
            else if (x % 6 == 4)
              treeFrame += 12;
            else if (x % 6 == 5)
              treeFrame += 15;
            switch (treeFrame)
            {
              case 0:
                passStyle = num2;
                break;
              case 1:
                passStyle = num2;
                break;
              case 2:
                passStyle = num2;
                break;
              case 3:
                passStyle = num2 + 1;
                break;
              case 4:
                passStyle = num2 + 2;
                break;
              case 5:
                passStyle = num2 + 1;
                break;
              case 6:
                passStyle = num2 + 3;
                break;
              case 7:
                passStyle = num2 + 4;
                break;
              case 8:
                passStyle = num2 + 5;
                break;
              case 9:
                passStyle = num2 + 6;
                break;
              case 10:
                passStyle = num2 + 6;
                break;
              case 11:
                passStyle = num2 + 6;
                break;
              case 12:
                passStyle = num2 + 7;
                break;
              case 13:
                passStyle = num2 + 7;
                break;
              case 14:
                passStyle = num2 + 7;
                break;
              case 15:
                passStyle = num2 + 8;
                break;
              case 16:
                passStyle = num2 + 8;
                break;
              case 17:
                passStyle = num2 + 8;
                break;
            }
          }
          passStyle += num1;
          treeHeight += 5;
          break;
        case 116:
          passStyle = 919;
          break;
        case 147:
          passStyle = 913;
          break;
        case 199:
        case 234:
          passStyle = 916;
          break;
      }
    }

    public static void TreeGrowFX(int x, int y, int height, int treeGore, bool hitTree = false)
    {
      Vector2 vector2_1 = new Vector2((float) x, (float) y) * 16f + new Vector2(8f, 8f);
      int Type = treeGore;
      int num1 = 4;
      int maxValue = 2;
      for (int index1 = 0; index1 > -height; --index1)
      {
        if (index1 > -height / 2 && Main.rand.Next(3) != 0)
        {
          for (int index2 = 0; index2 < 5; ++index2)
            Dust.NewDust(vector2_1 + new Vector2(-16f, (float) (index1 * 16)) + Utils.RandomVector2(Main.rand, -20f, 20f), 4, 4, num1 + Main.rand.Next(maxValue), 0.0f, -4f, 100, new Color(), 1f);
        }
        else
        {
          float max = 10f;
          Vector2 vector2_2 = new Vector2(5f, 7f);
          Gore.NewGore(vector2_1 + new Vector2(-16f, (float) (index1 * 16)) - vector2_2, Utils.RandomVector2(Main.rand, -max, max), Type, (float) (0.699999988079071 + (double) Main.rand.NextFloat() * 0.600000023841858));
          Gore.NewGore(vector2_1 + new Vector2(0.0f, (float) (index1 * 16)) - vector2_2, Utils.RandomVector2(Main.rand, -max, max), Type, (float) (0.699999988079071 + (double) Main.rand.NextFloat() * 0.600000023841858));
          Gore.NewGore(vector2_1 + new Vector2(16f, (float) (index1 * 16)) - vector2_2, Utils.RandomVector2(Main.rand, -max, max), Type, (float) (0.699999988079071 + (double) Main.rand.NextFloat() * 0.600000023841858));
          if (index1 == -height + 1)
          {
            int num2 = 20;
            if (hitTree)
              num2 = 5;
            for (int index2 = 0; index2 < num2; ++index2)
              Gore.NewGore(vector2_1 + new Vector2(0.0f, (float) (index1 * 16 - 40)) + Utils.RandomVector2(Main.rand, -40f, 40f) - vector2_2, Utils.RandomVector2(Main.rand, -10f, 10f), Type, (float) (0.699999988079071 + (double) Main.rand.NextFloat() * 0.600000023841858));
          }
        }
      }
    }

    public static bool IsTileALeafyTreeTop(int i, int j)
    {
      Tile tileSafely = Framing.GetTileSafely(i, j);
      return tileSafely.active() && TileID.Sets.GetsCheckedForLeaves[(int) tileSafely.type] && (tileSafely.type == (ushort) 323 && tileSafely.frameX >= (short) 88 || tileSafely.frameX == (short) 22 && tileSafely.frameY >= (short) 198 && tileSafely.frameY <= (short) 242);
    }

    public static bool IsTileTypeFitForTree(ushort type)
    {
      if (type <= (ushort) 70)
      {
        if (type <= (ushort) 23)
        {
          if (type != (ushort) 2 && type != (ushort) 23)
            goto label_8;
        }
        else if (type != (ushort) 60 && type != (ushort) 70)
          goto label_8;
      }
      else if (type <= (ushort) 147)
      {
        if (type != (ushort) 109 && type != (ushort) 147)
          goto label_8;
      }
      else if (type != (ushort) 199 && type != (ushort) 477 && type != (ushort) 492)
        goto label_8;
      return true;
label_8:
      return false;
    }

    public static bool GrowTree(int i, int y)
    {
      int index1 = y;
      while (Main.tile[i, index1].type == (ushort) 20)
        ++index1;
      if ((Main.tile[i - 1, index1 - 1].liquid != (byte) 0 || Main.tile[i, index1 - 1].liquid != (byte) 0 || Main.tile[i + 1, index1 - 1].liquid != (byte) 0) && !WorldGen.notTheBees || (!Main.tile[i, index1].nactive() || Main.tile[i, index1].halfBrick() || (Main.tile[i, index1].slope() != (byte) 0 || !WorldGen.IsTileTypeFitForTree(Main.tile[i, index1].type))) || Main.tile[i, index1 - 1].wall != (ushort) 0 && Main.tile[i, index1 - 1].wall != (ushort) 106 && Main.tile[i, index1 - 1].wall != (ushort) 107 && ((Main.tile[i, index1 - 1].wall < (ushort) 138 || Main.tile[i, index1 - 1].wall > (ushort) 141) && (Main.tile[i, index1 - 1].wall != (ushort) 145 && Main.tile[i, index1 - 1].wall != (ushort) 150)) && (Main.tile[i, index1 - 1].wall != (ushort) 152 && Main.tile[i, index1 - 1].wall != (ushort) 80) || (!Main.tile[i - 1, index1].active() || !WorldGen.IsTileTypeFitForTree(Main.tile[i - 1, index1].type)) && (!Main.tile[i + 1, index1].active() || !WorldGen.IsTileTypeFitForTree(Main.tile[i + 1, index1].type)))
        return false;
      byte color = Main.tile[i, index1].color();
      int num1 = 2;
      int num2 = WorldGen.genRand.Next(5, 17);
      int num3 = num2 + 4;
      if (Main.tile[i, index1].type == (ushort) 60)
        num3 += 5;
      bool flag1 = false;
      if (Main.tile[i, index1].type == (ushort) 70 && WorldGen.EmptyTileCheck(i - num1, i + num1, index1 - num3, index1 - 3, 20) && WorldGen.EmptyTileCheck(i - 1, i + 1, index1 - 2, index1 - 1, 20))
        flag1 = true;
      if (WorldGen.EmptyTileCheck(i - num1, i + num1, index1 - num3, index1 - 1, 20))
        flag1 = true;
      if (!flag1)
        return false;
      bool flag2 = false;
      bool flag3 = false;
      for (int index2 = index1 - num2; index2 < index1; ++index2)
      {
        Main.tile[i, index2].frameNumber((byte) WorldGen.genRand.Next(3));
        Main.tile[i, index2].active(true);
        Main.tile[i, index2].type = (ushort) 5;
        Main.tile[i, index2].color(color);
        int num4 = WorldGen.genRand.Next(3);
        int num5 = WorldGen.genRand.Next(10);
        if (index2 == index1 - 1 || index2 == index1 - num2)
          num5 = 0;
        while (((num5 == 5 ? 1 : (num5 == 7 ? 1 : 0)) & (flag2 ? 1 : 0)) != 0 || ((num5 == 6 ? 1 : (num5 == 7 ? 1 : 0)) & (flag3 ? 1 : 0)) != 0)
          num5 = WorldGen.genRand.Next(10);
        flag2 = false;
        flag3 = false;
        if (num5 == 5 || num5 == 7)
          flag2 = true;
        if (num5 == 6 || num5 == 7)
          flag3 = true;
        switch (num5)
        {
          case 1:
            if (num4 == 0)
            {
              Main.tile[i, index2].frameX = (short) 0;
              Main.tile[i, index2].frameY = (short) 66;
            }
            if (num4 == 1)
            {
              Main.tile[i, index2].frameX = (short) 0;
              Main.tile[i, index2].frameY = (short) 88;
            }
            if (num4 == 2)
            {
              Main.tile[i, index2].frameX = (short) 0;
              Main.tile[i, index2].frameY = (short) 110;
              break;
            }
            break;
          case 2:
            if (num4 == 0)
            {
              Main.tile[i, index2].frameX = (short) 22;
              Main.tile[i, index2].frameY = (short) 0;
            }
            if (num4 == 1)
            {
              Main.tile[i, index2].frameX = (short) 22;
              Main.tile[i, index2].frameY = (short) 22;
            }
            if (num4 == 2)
            {
              Main.tile[i, index2].frameX = (short) 22;
              Main.tile[i, index2].frameY = (short) 44;
              break;
            }
            break;
          case 3:
            if (num4 == 0)
            {
              Main.tile[i, index2].frameX = (short) 44;
              Main.tile[i, index2].frameY = (short) 66;
            }
            if (num4 == 1)
            {
              Main.tile[i, index2].frameX = (short) 44;
              Main.tile[i, index2].frameY = (short) 88;
            }
            if (num4 == 2)
            {
              Main.tile[i, index2].frameX = (short) 44;
              Main.tile[i, index2].frameY = (short) 110;
              break;
            }
            break;
          case 4:
            if (num4 == 0)
            {
              Main.tile[i, index2].frameX = (short) 22;
              Main.tile[i, index2].frameY = (short) 66;
            }
            if (num4 == 1)
            {
              Main.tile[i, index2].frameX = (short) 22;
              Main.tile[i, index2].frameY = (short) 88;
            }
            if (num4 == 2)
            {
              Main.tile[i, index2].frameX = (short) 22;
              Main.tile[i, index2].frameY = (short) 110;
              break;
            }
            break;
          case 5:
            if (num4 == 0)
            {
              Main.tile[i, index2].frameX = (short) 88;
              Main.tile[i, index2].frameY = (short) 0;
            }
            if (num4 == 1)
            {
              Main.tile[i, index2].frameX = (short) 88;
              Main.tile[i, index2].frameY = (short) 22;
            }
            if (num4 == 2)
            {
              Main.tile[i, index2].frameX = (short) 88;
              Main.tile[i, index2].frameY = (short) 44;
              break;
            }
            break;
          case 6:
            if (num4 == 0)
            {
              Main.tile[i, index2].frameX = (short) 66;
              Main.tile[i, index2].frameY = (short) 66;
            }
            if (num4 == 1)
            {
              Main.tile[i, index2].frameX = (short) 66;
              Main.tile[i, index2].frameY = (short) 88;
            }
            if (num4 == 2)
            {
              Main.tile[i, index2].frameX = (short) 66;
              Main.tile[i, index2].frameY = (short) 110;
              break;
            }
            break;
          case 7:
            if (num4 == 0)
            {
              Main.tile[i, index2].frameX = (short) 110;
              Main.tile[i, index2].frameY = (short) 66;
            }
            if (num4 == 1)
            {
              Main.tile[i, index2].frameX = (short) 110;
              Main.tile[i, index2].frameY = (short) 88;
            }
            if (num4 == 2)
            {
              Main.tile[i, index2].frameX = (short) 110;
              Main.tile[i, index2].frameY = (short) 110;
              break;
            }
            break;
          default:
            if (num4 == 0)
            {
              Main.tile[i, index2].frameX = (short) 0;
              Main.tile[i, index2].frameY = (short) 0;
            }
            if (num4 == 1)
            {
              Main.tile[i, index2].frameX = (short) 0;
              Main.tile[i, index2].frameY = (short) 22;
            }
            if (num4 == 2)
            {
              Main.tile[i, index2].frameX = (short) 0;
              Main.tile[i, index2].frameY = (short) 44;
              break;
            }
            break;
        }
        if (num5 == 5 || num5 == 7)
        {
          Main.tile[i - 1, index2].active(true);
          Main.tile[i - 1, index2].type = (ushort) 5;
          Main.tile[i - 1, index2].color(color);
          int num6 = WorldGen.genRand.Next(3);
          if (WorldGen.genRand.Next(3) < 2)
          {
            if (num6 == 0)
            {
              Main.tile[i - 1, index2].frameX = (short) 44;
              Main.tile[i - 1, index2].frameY = (short) 198;
            }
            if (num6 == 1)
            {
              Main.tile[i - 1, index2].frameX = (short) 44;
              Main.tile[i - 1, index2].frameY = (short) 220;
            }
            if (num6 == 2)
            {
              Main.tile[i - 1, index2].frameX = (short) 44;
              Main.tile[i - 1, index2].frameY = (short) 242;
            }
          }
          else
          {
            if (num6 == 0)
            {
              Main.tile[i - 1, index2].frameX = (short) 66;
              Main.tile[i - 1, index2].frameY = (short) 0;
            }
            if (num6 == 1)
            {
              Main.tile[i - 1, index2].frameX = (short) 66;
              Main.tile[i - 1, index2].frameY = (short) 22;
            }
            if (num6 == 2)
            {
              Main.tile[i - 1, index2].frameX = (short) 66;
              Main.tile[i - 1, index2].frameY = (short) 44;
            }
          }
        }
        if (num5 == 6 || num5 == 7)
        {
          Main.tile[i + 1, index2].active(true);
          Main.tile[i + 1, index2].type = (ushort) 5;
          Main.tile[i + 1, index2].color(color);
          int num6 = WorldGen.genRand.Next(3);
          if (WorldGen.genRand.Next(3) < 2)
          {
            if (num6 == 0)
            {
              Main.tile[i + 1, index2].frameX = (short) 66;
              Main.tile[i + 1, index2].frameY = (short) 198;
            }
            if (num6 == 1)
            {
              Main.tile[i + 1, index2].frameX = (short) 66;
              Main.tile[i + 1, index2].frameY = (short) 220;
            }
            if (num6 == 2)
            {
              Main.tile[i + 1, index2].frameX = (short) 66;
              Main.tile[i + 1, index2].frameY = (short) 242;
            }
          }
          else
          {
            if (num6 == 0)
            {
              Main.tile[i + 1, index2].frameX = (short) 88;
              Main.tile[i + 1, index2].frameY = (short) 66;
            }
            if (num6 == 1)
            {
              Main.tile[i + 1, index2].frameX = (short) 88;
              Main.tile[i + 1, index2].frameY = (short) 88;
            }
            if (num6 == 2)
            {
              Main.tile[i + 1, index2].frameX = (short) 88;
              Main.tile[i + 1, index2].frameY = (short) 110;
            }
          }
        }
      }
      int num7 = WorldGen.genRand.Next(3);
      bool flag4 = false;
      bool flag5 = false;
      if (Main.tile[i - 1, index1].nactive() && !Main.tile[i - 1, index1].halfBrick() && (Main.tile[i - 1, index1].slope() == (byte) 0 && WorldGen.IsTileTypeFitForTree(Main.tile[i - 1, index1].type)))
        flag4 = true;
      if (Main.tile[i + 1, index1].nactive() && !Main.tile[i + 1, index1].halfBrick() && (Main.tile[i + 1, index1].slope() == (byte) 0 && WorldGen.IsTileTypeFitForTree(Main.tile[i + 1, index1].type)))
        flag5 = true;
      if (!flag4)
      {
        if (num7 == 0)
          num7 = 2;
        if (num7 == 1)
          num7 = 3;
      }
      if (!flag5)
      {
        if (num7 == 0)
          num7 = 1;
        if (num7 == 2)
          num7 = 3;
      }
      if (flag4 && !flag5)
        num7 = 2;
      if (flag5 && !flag4)
        num7 = 1;
      if (num7 == 0 || num7 == 1)
      {
        Main.tile[i + 1, index1 - 1].active(true);
        Main.tile[i + 1, index1 - 1].type = (ushort) 5;
        Main.tile[i + 1, index1 - 1].color(color);
        int num4 = WorldGen.genRand.Next(3);
        if (num4 == 0)
        {
          Main.tile[i + 1, index1 - 1].frameX = (short) 22;
          Main.tile[i + 1, index1 - 1].frameY = (short) 132;
        }
        if (num4 == 1)
        {
          Main.tile[i + 1, index1 - 1].frameX = (short) 22;
          Main.tile[i + 1, index1 - 1].frameY = (short) 154;
        }
        if (num4 == 2)
        {
          Main.tile[i + 1, index1 - 1].frameX = (short) 22;
          Main.tile[i + 1, index1 - 1].frameY = (short) 176;
        }
      }
      if (num7 == 0 || num7 == 2)
      {
        Main.tile[i - 1, index1 - 1].active(true);
        Main.tile[i - 1, index1 - 1].type = (ushort) 5;
        Main.tile[i - 1, index1 - 1].color(color);
        int num4 = WorldGen.genRand.Next(3);
        if (num4 == 0)
        {
          Main.tile[i - 1, index1 - 1].frameX = (short) 44;
          Main.tile[i - 1, index1 - 1].frameY = (short) 132;
        }
        if (num4 == 1)
        {
          Main.tile[i - 1, index1 - 1].frameX = (short) 44;
          Main.tile[i - 1, index1 - 1].frameY = (short) 154;
        }
        if (num4 == 2)
        {
          Main.tile[i - 1, index1 - 1].frameX = (short) 44;
          Main.tile[i - 1, index1 - 1].frameY = (short) 176;
        }
      }
      int num8 = WorldGen.genRand.Next(3);
      switch (num7)
      {
        case 0:
          if (num8 == 0)
          {
            Main.tile[i, index1 - 1].frameX = (short) 88;
            Main.tile[i, index1 - 1].frameY = (short) 132;
          }
          if (num8 == 1)
          {
            Main.tile[i, index1 - 1].frameX = (short) 88;
            Main.tile[i, index1 - 1].frameY = (short) 154;
          }
          if (num8 == 2)
          {
            Main.tile[i, index1 - 1].frameX = (short) 88;
            Main.tile[i, index1 - 1].frameY = (short) 176;
            break;
          }
          break;
        case 1:
          if (num8 == 0)
          {
            Main.tile[i, index1 - 1].frameX = (short) 0;
            Main.tile[i, index1 - 1].frameY = (short) 132;
          }
          if (num8 == 1)
          {
            Main.tile[i, index1 - 1].frameX = (short) 0;
            Main.tile[i, index1 - 1].frameY = (short) 154;
          }
          if (num8 == 2)
          {
            Main.tile[i, index1 - 1].frameX = (short) 0;
            Main.tile[i, index1 - 1].frameY = (short) 176;
            break;
          }
          break;
        case 2:
          if (num8 == 0)
          {
            Main.tile[i, index1 - 1].frameX = (short) 66;
            Main.tile[i, index1 - 1].frameY = (short) 132;
          }
          if (num8 == 1)
          {
            Main.tile[i, index1 - 1].frameX = (short) 66;
            Main.tile[i, index1 - 1].frameY = (short) 154;
          }
          if (num8 == 2)
          {
            Main.tile[i, index1 - 1].frameX = (short) 66;
            Main.tile[i, index1 - 1].frameY = (short) 176;
            break;
          }
          break;
      }
      if (WorldGen.genRand.Next(13) != 0)
      {
        int num4 = WorldGen.genRand.Next(3);
        if (num4 == 0)
        {
          Main.tile[i, index1 - num2].frameX = (short) 22;
          Main.tile[i, index1 - num2].frameY = (short) 198;
        }
        if (num4 == 1)
        {
          Main.tile[i, index1 - num2].frameX = (short) 22;
          Main.tile[i, index1 - num2].frameY = (short) 220;
        }
        if (num4 == 2)
        {
          Main.tile[i, index1 - num2].frameX = (short) 22;
          Main.tile[i, index1 - num2].frameY = (short) 242;
        }
      }
      else
      {
        int num4 = WorldGen.genRand.Next(3);
        if (num4 == 0)
        {
          Main.tile[i, index1 - num2].frameX = (short) 0;
          Main.tile[i, index1 - num2].frameY = (short) 198;
        }
        if (num4 == 1)
        {
          Main.tile[i, index1 - num2].frameX = (short) 0;
          Main.tile[i, index1 - num2].frameY = (short) 220;
        }
        if (num4 == 2)
        {
          Main.tile[i, index1 - num2].frameX = (short) 0;
          Main.tile[i, index1 - num2].frameY = (short) 242;
        }
      }
      WorldGen.RangeFrame(i - 2, index1 - num2 - 1, i + 2, index1 + 1);
      if (Main.netMode == 2)
        NetMessage.SendTileSquare(-1, i, (int) ((double) index1 - (double) num2 * 0.5), num2 + 1, TileChangeType.None);
      return true;
    }

    public static bool DefaultTreeWallTest(int wallType)
    {
      switch (wallType)
      {
        case 0:
        case 80:
        case 106:
        case 107:
        case 138:
        case 139:
        case 140:
        case 141:
        case 145:
        case 150:
        case 152:
        case 245:
        case 315:
          return true;
        default:
          return false;
      }
    }

    public static bool GemTreeWallTest(int wallType)
    {
      if (WorldGen.DefaultTreeWallTest(wallType))
        return true;
      switch (wallType)
      {
        case 2:
        case 54:
        case 55:
        case 56:
        case 57:
        case 58:
        case 59:
        case 61:
        case 185:
        case 196:
        case 197:
        case 198:
        case 199:
        case 208:
        case 209:
        case 210:
        case 211:
        case 212:
        case 213:
        case 214:
        case 215:
          return true;
        default:
          return false;
      }
    }

    public static bool GemTreeGroundTest(int tileType)
    {
      return tileType >= 0 && (TileID.Sets.Conversion.Stone[tileType] || TileID.Sets.Conversion.Moss[tileType]);
    }

    public static bool VanityTreeGroundTest(int tileType)
    {
      return tileType >= 0 && TileID.Sets.Conversion.Grass[tileType];
    }

    public static bool TryGrowingTreeByType(int treeTileType, int checkedX, int checkedY)
    {
      bool flag = false;
      switch (treeTileType)
      {
        case 5:
          flag = WorldGen.GrowTree(checkedX, checkedY);
          break;
        case 583:
          flag = WorldGen.GrowTreeWithSettings(checkedX, checkedY, WorldGen.GrowTreeSettings.Profiles.GemTree_Topaz);
          break;
        case 584:
          flag = WorldGen.GrowTreeWithSettings(checkedX, checkedY, WorldGen.GrowTreeSettings.Profiles.GemTree_Amethyst);
          break;
        case 585:
          flag = WorldGen.GrowTreeWithSettings(checkedX, checkedY, WorldGen.GrowTreeSettings.Profiles.GemTree_Sappphire);
          break;
        case 586:
          flag = WorldGen.GrowTreeWithSettings(checkedX, checkedY, WorldGen.GrowTreeSettings.Profiles.GemTree_Emerald);
          break;
        case 587:
          flag = WorldGen.GrowTreeWithSettings(checkedX, checkedY, WorldGen.GrowTreeSettings.Profiles.GemTree_Ruby);
          break;
        case 588:
          flag = WorldGen.GrowTreeWithSettings(checkedX, checkedY, WorldGen.GrowTreeSettings.Profiles.GemTree_Diamond);
          break;
        case 589:
          flag = WorldGen.GrowTreeWithSettings(checkedX, checkedY, WorldGen.GrowTreeSettings.Profiles.GemTree_Amber);
          break;
        case 596:
          flag = WorldGen.GrowTreeWithSettings(checkedX, checkedY, WorldGen.GrowTreeSettings.Profiles.VanityTree_Sakura);
          break;
        case 616:
          flag = WorldGen.GrowTreeWithSettings(checkedX, checkedY, WorldGen.GrowTreeSettings.Profiles.VanityTree_Willow);
          break;
      }
      return flag;
    }

    public static bool GrowTreeWithSettings(
      int checkedX,
      int checkedY,
      WorldGen.GrowTreeSettings settings)
    {
      int index1 = checkedY;
      while ((int) Main.tile[checkedX, index1].type == (int) settings.SaplingTileType)
        ++index1;
      if (Main.tile[checkedX - 1, index1 - 1].liquid != (byte) 0 || Main.tile[checkedX, index1 - 1].liquid != (byte) 0 || Main.tile[checkedX + 1, index1 - 1].liquid != (byte) 0)
        return false;
      Tile tile1 = Main.tile[checkedX, index1];
      if ((!tile1.nactive() || tile1.halfBrick() ? 0 : (tile1.slope() == (byte) 0 ? 1 : 0)) == 0)
        return false;
      bool flag1 = settings.WallTest((int) Main.tile[checkedX, index1 - 1].wall);
      if (!settings.GroundTest((int) tile1.type) || !flag1 || (!Main.tile[checkedX - 1, index1].active() || !settings.GroundTest((int) Main.tile[checkedX - 1, index1].type) ? (!Main.tile[checkedX + 1, index1].active() ? 0 : (settings.GroundTest((int) Main.tile[checkedX + 1, index1].type) ? 1 : 0)) : 1) == 0)
        return false;
      byte color = Main.tile[checkedX, index1].color();
      int num1 = 2;
      int num2 = WorldGen.genRand.Next(settings.TreeHeightMin, settings.TreeHeightMax + 1);
      int num3 = num2 + settings.TreeTopPaddingNeeded;
      if (!WorldGen.EmptyTileCheck(checkedX - num1, checkedX + num1, index1 - num3, index1 - 1, 20))
        return false;
      bool flag2 = false;
      bool flag3 = false;
      for (int index2 = index1 - num2; index2 < index1; ++index2)
      {
        Tile tile2 = Main.tile[checkedX, index2];
        tile2.frameNumber((byte) WorldGen.genRand.Next(3));
        tile2.active(true);
        tile2.type = settings.TreeTileType;
        tile2.color(color);
        int num4 = WorldGen.genRand.Next(3);
        int num5 = WorldGen.genRand.Next(10);
        if (index2 == index1 - 1 || index2 == index1 - num2)
          num5 = 0;
        while (((num5 == 5 ? 1 : (num5 == 7 ? 1 : 0)) & (flag2 ? 1 : 0)) != 0 || ((num5 == 6 ? 1 : (num5 == 7 ? 1 : 0)) & (flag3 ? 1 : 0)) != 0)
          num5 = WorldGen.genRand.Next(10);
        flag2 = false;
        flag3 = false;
        if (num5 == 5 || num5 == 7)
          flag2 = true;
        if (num5 == 6 || num5 == 7)
          flag3 = true;
        switch (num5)
        {
          case 1:
            if (num4 == 0)
            {
              tile2.frameX = (short) 0;
              tile2.frameY = (short) 66;
            }
            if (num4 == 1)
            {
              tile2.frameX = (short) 0;
              tile2.frameY = (short) 88;
            }
            if (num4 == 2)
            {
              tile2.frameX = (short) 0;
              tile2.frameY = (short) 110;
              break;
            }
            break;
          case 2:
            if (num4 == 0)
            {
              tile2.frameX = (short) 22;
              tile2.frameY = (short) 0;
            }
            if (num4 == 1)
            {
              tile2.frameX = (short) 22;
              tile2.frameY = (short) 22;
            }
            if (num4 == 2)
            {
              tile2.frameX = (short) 22;
              tile2.frameY = (short) 44;
              break;
            }
            break;
          case 3:
            if (num4 == 0)
            {
              tile2.frameX = (short) 44;
              tile2.frameY = (short) 66;
            }
            if (num4 == 1)
            {
              tile2.frameX = (short) 44;
              tile2.frameY = (short) 88;
            }
            if (num4 == 2)
            {
              tile2.frameX = (short) 44;
              tile2.frameY = (short) 110;
              break;
            }
            break;
          case 4:
            if (num4 == 0)
            {
              tile2.frameX = (short) 22;
              tile2.frameY = (short) 66;
            }
            if (num4 == 1)
            {
              tile2.frameX = (short) 22;
              tile2.frameY = (short) 88;
            }
            if (num4 == 2)
            {
              tile2.frameX = (short) 22;
              tile2.frameY = (short) 110;
              break;
            }
            break;
          case 5:
            if (num4 == 0)
            {
              tile2.frameX = (short) 88;
              tile2.frameY = (short) 0;
            }
            if (num4 == 1)
            {
              tile2.frameX = (short) 88;
              tile2.frameY = (short) 22;
            }
            if (num4 == 2)
            {
              tile2.frameX = (short) 88;
              tile2.frameY = (short) 44;
              break;
            }
            break;
          case 6:
            if (num4 == 0)
            {
              tile2.frameX = (short) 66;
              tile2.frameY = (short) 66;
            }
            if (num4 == 1)
            {
              tile2.frameX = (short) 66;
              tile2.frameY = (short) 88;
            }
            if (num4 == 2)
            {
              tile2.frameX = (short) 66;
              tile2.frameY = (short) 110;
              break;
            }
            break;
          case 7:
            if (num4 == 0)
            {
              tile2.frameX = (short) 110;
              tile2.frameY = (short) 66;
            }
            if (num4 == 1)
            {
              tile2.frameX = (short) 110;
              tile2.frameY = (short) 88;
            }
            if (num4 == 2)
            {
              tile2.frameX = (short) 110;
              tile2.frameY = (short) 110;
              break;
            }
            break;
          default:
            if (num4 == 0)
            {
              tile2.frameX = (short) 0;
              tile2.frameY = (short) 0;
            }
            if (num4 == 1)
            {
              tile2.frameX = (short) 0;
              tile2.frameY = (short) 22;
            }
            if (num4 == 2)
            {
              tile2.frameX = (short) 0;
              tile2.frameY = (short) 44;
              break;
            }
            break;
        }
        if (num5 == 5 || num5 == 7)
        {
          Tile tile3 = Main.tile[checkedX - 1, index2];
          tile3.active(true);
          tile3.type = settings.TreeTileType;
          tile3.color(color);
          int num6 = WorldGen.genRand.Next(3);
          if (WorldGen.genRand.Next(3) < 2)
          {
            if (num6 == 0)
            {
              tile3.frameX = (short) 44;
              tile3.frameY = (short) 198;
            }
            if (num6 == 1)
            {
              tile3.frameX = (short) 44;
              tile3.frameY = (short) 220;
            }
            if (num6 == 2)
            {
              tile3.frameX = (short) 44;
              tile3.frameY = (short) 242;
            }
          }
          else
          {
            if (num6 == 0)
            {
              tile3.frameX = (short) 66;
              tile3.frameY = (short) 0;
            }
            if (num6 == 1)
            {
              tile3.frameX = (short) 66;
              tile3.frameY = (short) 22;
            }
            if (num6 == 2)
            {
              tile3.frameX = (short) 66;
              tile3.frameY = (short) 44;
            }
          }
        }
        if (num5 == 6 || num5 == 7)
        {
          Tile tile3 = Main.tile[checkedX + 1, index2];
          tile3.active(true);
          tile3.type = settings.TreeTileType;
          tile3.color(color);
          int num6 = WorldGen.genRand.Next(3);
          if (WorldGen.genRand.Next(3) < 2)
          {
            if (num6 == 0)
            {
              tile3.frameX = (short) 66;
              tile3.frameY = (short) 198;
            }
            if (num6 == 1)
            {
              tile3.frameX = (short) 66;
              tile3.frameY = (short) 220;
            }
            if (num6 == 2)
            {
              tile3.frameX = (short) 66;
              tile3.frameY = (short) 242;
            }
          }
          else
          {
            if (num6 == 0)
            {
              tile3.frameX = (short) 88;
              tile3.frameY = (short) 66;
            }
            if (num6 == 1)
            {
              tile3.frameX = (short) 88;
              tile3.frameY = (short) 88;
            }
            if (num6 == 2)
            {
              tile3.frameX = (short) 88;
              tile3.frameY = (short) 110;
            }
          }
        }
      }
      bool flag4 = false;
      bool flag5 = false;
      if (Main.tile[checkedX - 1, index1].nactive() && !Main.tile[checkedX - 1, index1].halfBrick() && (Main.tile[checkedX - 1, index1].slope() == (byte) 0 && WorldGen.IsTileTypeFitForTree(Main.tile[checkedX - 1, index1].type)))
        flag4 = true;
      if (Main.tile[checkedX + 1, index1].nactive() && !Main.tile[checkedX + 1, index1].halfBrick() && (Main.tile[checkedX + 1, index1].slope() == (byte) 0 && WorldGen.IsTileTypeFitForTree(Main.tile[checkedX + 1, index1].type)))
        flag5 = true;
      if (WorldGen.genRand.Next(3) == 0)
        flag4 = false;
      if (WorldGen.genRand.Next(3) == 0)
        flag5 = false;
      if (flag5)
      {
        Main.tile[checkedX + 1, index1 - 1].active(true);
        Main.tile[checkedX + 1, index1 - 1].type = settings.TreeTileType;
        Main.tile[checkedX + 1, index1 - 1].color(color);
        int num4 = WorldGen.genRand.Next(3);
        if (num4 == 0)
        {
          Main.tile[checkedX + 1, index1 - 1].frameX = (short) 22;
          Main.tile[checkedX + 1, index1 - 1].frameY = (short) 132;
        }
        if (num4 == 1)
        {
          Main.tile[checkedX + 1, index1 - 1].frameX = (short) 22;
          Main.tile[checkedX + 1, index1 - 1].frameY = (short) 154;
        }
        if (num4 == 2)
        {
          Main.tile[checkedX + 1, index1 - 1].frameX = (short) 22;
          Main.tile[checkedX + 1, index1 - 1].frameY = (short) 176;
        }
      }
      if (flag4)
      {
        Main.tile[checkedX - 1, index1 - 1].active(true);
        Main.tile[checkedX - 1, index1 - 1].type = settings.TreeTileType;
        Main.tile[checkedX - 1, index1 - 1].color(color);
        int num4 = WorldGen.genRand.Next(3);
        if (num4 == 0)
        {
          Main.tile[checkedX - 1, index1 - 1].frameX = (short) 44;
          Main.tile[checkedX - 1, index1 - 1].frameY = (short) 132;
        }
        if (num4 == 1)
        {
          Main.tile[checkedX - 1, index1 - 1].frameX = (short) 44;
          Main.tile[checkedX - 1, index1 - 1].frameY = (short) 154;
        }
        if (num4 == 2)
        {
          Main.tile[checkedX - 1, index1 - 1].frameX = (short) 44;
          Main.tile[checkedX - 1, index1 - 1].frameY = (short) 176;
        }
      }
      int num7 = WorldGen.genRand.Next(3);
      if (flag4 & flag5)
      {
        if (num7 == 0)
        {
          Main.tile[checkedX, index1 - 1].frameX = (short) 88;
          Main.tile[checkedX, index1 - 1].frameY = (short) 132;
        }
        if (num7 == 1)
        {
          Main.tile[checkedX, index1 - 1].frameX = (short) 88;
          Main.tile[checkedX, index1 - 1].frameY = (short) 154;
        }
        if (num7 == 2)
        {
          Main.tile[checkedX, index1 - 1].frameX = (short) 88;
          Main.tile[checkedX, index1 - 1].frameY = (short) 176;
        }
      }
      else if (flag4)
      {
        if (num7 == 0)
        {
          Main.tile[checkedX, index1 - 1].frameX = (short) 0;
          Main.tile[checkedX, index1 - 1].frameY = (short) 132;
        }
        if (num7 == 1)
        {
          Main.tile[checkedX, index1 - 1].frameX = (short) 0;
          Main.tile[checkedX, index1 - 1].frameY = (short) 154;
        }
        if (num7 == 2)
        {
          Main.tile[checkedX, index1 - 1].frameX = (short) 0;
          Main.tile[checkedX, index1 - 1].frameY = (short) 176;
        }
      }
      else if (flag5)
      {
        if (num7 == 0)
        {
          Main.tile[checkedX, index1 - 1].frameX = (short) 66;
          Main.tile[checkedX, index1 - 1].frameY = (short) 132;
        }
        if (num7 == 1)
        {
          Main.tile[checkedX, index1 - 1].frameX = (short) 66;
          Main.tile[checkedX, index1 - 1].frameY = (short) 154;
        }
        if (num7 == 2)
        {
          Main.tile[checkedX, index1 - 1].frameX = (short) 66;
          Main.tile[checkedX, index1 - 1].frameY = (short) 176;
        }
      }
      if (WorldGen.genRand.Next(13) != 0)
      {
        int num4 = WorldGen.genRand.Next(3);
        if (num4 == 0)
        {
          Main.tile[checkedX, index1 - num2].frameX = (short) 22;
          Main.tile[checkedX, index1 - num2].frameY = (short) 198;
        }
        if (num4 == 1)
        {
          Main.tile[checkedX, index1 - num2].frameX = (short) 22;
          Main.tile[checkedX, index1 - num2].frameY = (short) 220;
        }
        if (num4 == 2)
        {
          Main.tile[checkedX, index1 - num2].frameX = (short) 22;
          Main.tile[checkedX, index1 - num2].frameY = (short) 242;
        }
      }
      else
      {
        int num4 = WorldGen.genRand.Next(3);
        if (num4 == 0)
        {
          Main.tile[checkedX, index1 - num2].frameX = (short) 0;
          Main.tile[checkedX, index1 - num2].frameY = (short) 198;
        }
        if (num4 == 1)
        {
          Main.tile[checkedX, index1 - num2].frameX = (short) 0;
          Main.tile[checkedX, index1 - num2].frameY = (short) 220;
        }
        if (num4 == 2)
        {
          Main.tile[checkedX, index1 - num2].frameX = (short) 0;
          Main.tile[checkedX, index1 - num2].frameY = (short) 242;
        }
      }
      WorldGen.RangeFrame(checkedX - 2, index1 - num2 - 1, checkedX + 2, index1 + 1);
      if (Main.netMode == 2)
        NetMessage.SendTileSquare(-1, checkedX, (int) ((double) index1 - (double) num2 * 0.5), num2 + 1, TileChangeType.None);
      return true;
    }

    public static void GrowUndergroundTree(int i, int y)
    {
      int index1 = y;
      if (Main.tile[i, index1].type != (ushort) 60 || !Main.tile[i, index1].nactive() || (Main.tile[i, index1].halfBrick() || Main.tile[i, index1].slope() != (byte) 0) || Main.tile[i, index1].type != (ushort) 60 || (!Main.tile[i - 1, index1].active() || Main.tile[i - 1, index1].type != (ushort) 60) && (!Main.tile[i + 1, index1].active() || Main.tile[i + 1, index1].type != (ushort) 60))
        return;
      int num1 = 1;
      int num2 = WorldGen.genRand.Next(5, 15);
      int num3 = num2 + 2;
      if (Main.tile[i, index1].type == (ushort) 60)
        num3 += 5;
      if (!WorldGen.EmptyTileCheck(i - num1, i + num1, index1 - num3, index1 - 1, 20))
        return;
      bool flag1 = false;
      bool flag2 = false;
      for (int index2 = index1 - num2; index2 < index1; ++index2)
      {
        Main.tile[i, index2].frameNumber((byte) WorldGen.genRand.Next(3));
        Main.tile[i, index2].active(true);
        Main.tile[i, index2].type = (ushort) 5;
        int num4 = WorldGen.genRand.Next(3);
        int num5 = WorldGen.genRand.Next(10);
        if (index2 == index1 - 1 || index2 == index1 - num2)
          num5 = 0;
        while (((num5 == 5 ? 1 : (num5 == 7 ? 1 : 0)) & (flag1 ? 1 : 0)) != 0 || ((num5 == 6 ? 1 : (num5 == 7 ? 1 : 0)) & (flag2 ? 1 : 0)) != 0)
          num5 = WorldGen.genRand.Next(10);
        flag1 = false;
        flag2 = false;
        if (num5 == 5 || num5 == 7)
          flag1 = true;
        if (num5 == 6 || num5 == 7)
          flag2 = true;
        switch (num5)
        {
          case 1:
            if (num4 == 0)
            {
              Main.tile[i, index2].frameX = (short) 0;
              Main.tile[i, index2].frameY = (short) 66;
            }
            if (num4 == 1)
            {
              Main.tile[i, index2].frameX = (short) 0;
              Main.tile[i, index2].frameY = (short) 88;
            }
            if (num4 == 2)
            {
              Main.tile[i, index2].frameX = (short) 0;
              Main.tile[i, index2].frameY = (short) 110;
              break;
            }
            break;
          case 2:
            if (num4 == 0)
            {
              Main.tile[i, index2].frameX = (short) 22;
              Main.tile[i, index2].frameY = (short) 0;
            }
            if (num4 == 1)
            {
              Main.tile[i, index2].frameX = (short) 22;
              Main.tile[i, index2].frameY = (short) 22;
            }
            if (num4 == 2)
            {
              Main.tile[i, index2].frameX = (short) 22;
              Main.tile[i, index2].frameY = (short) 44;
              break;
            }
            break;
          case 3:
            if (num4 == 0)
            {
              Main.tile[i, index2].frameX = (short) 44;
              Main.tile[i, index2].frameY = (short) 66;
            }
            if (num4 == 1)
            {
              Main.tile[i, index2].frameX = (short) 44;
              Main.tile[i, index2].frameY = (short) 88;
            }
            if (num4 == 2)
            {
              Main.tile[i, index2].frameX = (short) 44;
              Main.tile[i, index2].frameY = (short) 110;
              break;
            }
            break;
          case 4:
            if (num4 == 0)
            {
              Main.tile[i, index2].frameX = (short) 22;
              Main.tile[i, index2].frameY = (short) 66;
            }
            if (num4 == 1)
            {
              Main.tile[i, index2].frameX = (short) 22;
              Main.tile[i, index2].frameY = (short) 88;
            }
            if (num4 == 2)
            {
              Main.tile[i, index2].frameX = (short) 22;
              Main.tile[i, index2].frameY = (short) 110;
              break;
            }
            break;
          case 5:
            if (num4 == 0)
            {
              Main.tile[i, index2].frameX = (short) 88;
              Main.tile[i, index2].frameY = (short) 0;
            }
            if (num4 == 1)
            {
              Main.tile[i, index2].frameX = (short) 88;
              Main.tile[i, index2].frameY = (short) 22;
            }
            if (num4 == 2)
            {
              Main.tile[i, index2].frameX = (short) 88;
              Main.tile[i, index2].frameY = (short) 44;
              break;
            }
            break;
          case 6:
            if (num4 == 0)
            {
              Main.tile[i, index2].frameX = (short) 66;
              Main.tile[i, index2].frameY = (short) 66;
            }
            if (num4 == 1)
            {
              Main.tile[i, index2].frameX = (short) 66;
              Main.tile[i, index2].frameY = (short) 88;
            }
            if (num4 == 2)
            {
              Main.tile[i, index2].frameX = (short) 66;
              Main.tile[i, index2].frameY = (short) 110;
              break;
            }
            break;
          case 7:
            if (num4 == 0)
            {
              Main.tile[i, index2].frameX = (short) 110;
              Main.tile[i, index2].frameY = (short) 66;
            }
            if (num4 == 1)
            {
              Main.tile[i, index2].frameX = (short) 110;
              Main.tile[i, index2].frameY = (short) 88;
            }
            if (num4 == 2)
            {
              Main.tile[i, index2].frameX = (short) 110;
              Main.tile[i, index2].frameY = (short) 110;
              break;
            }
            break;
          default:
            if (num4 == 0)
            {
              Main.tile[i, index2].frameX = (short) 0;
              Main.tile[i, index2].frameY = (short) 0;
            }
            if (num4 == 1)
            {
              Main.tile[i, index2].frameX = (short) 0;
              Main.tile[i, index2].frameY = (short) 22;
            }
            if (num4 == 2)
            {
              Main.tile[i, index2].frameX = (short) 0;
              Main.tile[i, index2].frameY = (short) 44;
              break;
            }
            break;
        }
        if (num5 == 5 || num5 == 7)
        {
          Main.tile[i - 1, index2].active(true);
          Main.tile[i - 1, index2].type = (ushort) 5;
          int num6 = WorldGen.genRand.Next(3);
          if (WorldGen.genRand.Next(3) < 2)
          {
            if (num6 == 0)
            {
              Main.tile[i - 1, index2].frameX = (short) 44;
              Main.tile[i - 1, index2].frameY = (short) 198;
            }
            if (num6 == 1)
            {
              Main.tile[i - 1, index2].frameX = (short) 44;
              Main.tile[i - 1, index2].frameY = (short) 220;
            }
            if (num6 == 2)
            {
              Main.tile[i - 1, index2].frameX = (short) 44;
              Main.tile[i - 1, index2].frameY = (short) 242;
            }
          }
          else
          {
            if (num6 == 0)
            {
              Main.tile[i - 1, index2].frameX = (short) 66;
              Main.tile[i - 1, index2].frameY = (short) 0;
            }
            if (num6 == 1)
            {
              Main.tile[i - 1, index2].frameX = (short) 66;
              Main.tile[i - 1, index2].frameY = (short) 22;
            }
            if (num6 == 2)
            {
              Main.tile[i - 1, index2].frameX = (short) 66;
              Main.tile[i - 1, index2].frameY = (short) 44;
            }
          }
        }
        if (num5 == 6 || num5 == 7)
        {
          Main.tile[i + 1, index2].active(true);
          Main.tile[i + 1, index2].type = (ushort) 5;
          int num6 = WorldGen.genRand.Next(3);
          if (WorldGen.genRand.Next(3) < 2)
          {
            if (num6 == 0)
            {
              Main.tile[i + 1, index2].frameX = (short) 66;
              Main.tile[i + 1, index2].frameY = (short) 198;
            }
            if (num6 == 1)
            {
              Main.tile[i + 1, index2].frameX = (short) 66;
              Main.tile[i + 1, index2].frameY = (short) 220;
            }
            if (num6 == 2)
            {
              Main.tile[i + 1, index2].frameX = (short) 66;
              Main.tile[i + 1, index2].frameY = (short) 242;
            }
          }
          else
          {
            if (num6 == 0)
            {
              Main.tile[i + 1, index2].frameX = (short) 88;
              Main.tile[i + 1, index2].frameY = (short) 66;
            }
            if (num6 == 1)
            {
              Main.tile[i + 1, index2].frameX = (short) 88;
              Main.tile[i + 1, index2].frameY = (short) 88;
            }
            if (num6 == 2)
            {
              Main.tile[i + 1, index2].frameX = (short) 88;
              Main.tile[i + 1, index2].frameY = (short) 110;
            }
          }
        }
      }
      int num7 = WorldGen.genRand.Next(3);
      bool flag3 = false;
      bool flag4 = false;
      if (Main.tile[i - 1, index1].nactive() && !Main.tile[i - 1, index1].halfBrick() && Main.tile[i - 1, index1].slope() == (byte) 0 && (Main.tile[i - 1, index1].type == (ushort) 2 || Main.tile[i - 1, index1].type == (ushort) 23 || (Main.tile[i - 1, index1].type == (ushort) 60 || Main.tile[i - 1, index1].type == (ushort) 109) || Main.tile[i - 1, index1].type == (ushort) 147))
        flag3 = true;
      if (Main.tile[i + 1, index1].nactive() && !Main.tile[i + 1, index1].halfBrick() && Main.tile[i + 1, index1].slope() == (byte) 0 && (Main.tile[i + 1, index1].type == (ushort) 2 || Main.tile[i + 1, index1].type == (ushort) 23 || (Main.tile[i + 1, index1].type == (ushort) 60 || Main.tile[i + 1, index1].type == (ushort) 109) || Main.tile[i + 1, index1].type == (ushort) 147))
        flag4 = true;
      if (!flag3)
      {
        if (num7 == 0)
          num7 = 2;
        if (num7 == 1)
          num7 = 3;
      }
      if (!flag4)
      {
        if (num7 == 0)
          num7 = 1;
        if (num7 == 2)
          num7 = 3;
      }
      if (flag3 && !flag4)
        num7 = 2;
      if (flag4 && !flag3)
        num7 = 1;
      if (num7 == 0 || num7 == 1)
      {
        Main.tile[i + 1, index1 - 1].active(true);
        Main.tile[i + 1, index1 - 1].type = (ushort) 5;
        int num4 = WorldGen.genRand.Next(3);
        if (num4 == 0)
        {
          Main.tile[i + 1, index1 - 1].frameX = (short) 22;
          Main.tile[i + 1, index1 - 1].frameY = (short) 132;
        }
        if (num4 == 1)
        {
          Main.tile[i + 1, index1 - 1].frameX = (short) 22;
          Main.tile[i + 1, index1 - 1].frameY = (short) 154;
        }
        if (num4 == 2)
        {
          Main.tile[i + 1, index1 - 1].frameX = (short) 22;
          Main.tile[i + 1, index1 - 1].frameY = (short) 176;
        }
      }
      if (num7 == 0 || num7 == 2)
      {
        Main.tile[i - 1, index1 - 1].active(true);
        Main.tile[i - 1, index1 - 1].type = (ushort) 5;
        int num4 = WorldGen.genRand.Next(3);
        if (num4 == 0)
        {
          Main.tile[i - 1, index1 - 1].frameX = (short) 44;
          Main.tile[i - 1, index1 - 1].frameY = (short) 132;
        }
        if (num4 == 1)
        {
          Main.tile[i - 1, index1 - 1].frameX = (short) 44;
          Main.tile[i - 1, index1 - 1].frameY = (short) 154;
        }
        if (num4 == 2)
        {
          Main.tile[i - 1, index1 - 1].frameX = (short) 44;
          Main.tile[i - 1, index1 - 1].frameY = (short) 176;
        }
      }
      int num8 = WorldGen.genRand.Next(3);
      switch (num7)
      {
        case 0:
          if (num8 == 0)
          {
            Main.tile[i, index1 - 1].frameX = (short) 88;
            Main.tile[i, index1 - 1].frameY = (short) 132;
          }
          if (num8 == 1)
          {
            Main.tile[i, index1 - 1].frameX = (short) 88;
            Main.tile[i, index1 - 1].frameY = (short) 154;
          }
          if (num8 == 2)
          {
            Main.tile[i, index1 - 1].frameX = (short) 88;
            Main.tile[i, index1 - 1].frameY = (short) 176;
            break;
          }
          break;
        case 1:
          if (num8 == 0)
          {
            Main.tile[i, index1 - 1].frameX = (short) 0;
            Main.tile[i, index1 - 1].frameY = (short) 132;
          }
          if (num8 == 1)
          {
            Main.tile[i, index1 - 1].frameX = (short) 0;
            Main.tile[i, index1 - 1].frameY = (short) 154;
          }
          if (num8 == 2)
          {
            Main.tile[i, index1 - 1].frameX = (short) 0;
            Main.tile[i, index1 - 1].frameY = (short) 176;
            break;
          }
          break;
        case 2:
          if (num8 == 0)
          {
            Main.tile[i, index1 - 1].frameX = (short) 66;
            Main.tile[i, index1 - 1].frameY = (short) 132;
          }
          if (num8 == 1)
          {
            Main.tile[i, index1 - 1].frameX = (short) 66;
            Main.tile[i, index1 - 1].frameY = (short) 154;
          }
          if (num8 == 2)
          {
            Main.tile[i, index1 - 1].frameX = (short) 66;
            Main.tile[i, index1 - 1].frameY = (short) 176;
            break;
          }
          break;
      }
      if (WorldGen.genRand.Next(8) != 0)
      {
        int num4 = WorldGen.genRand.Next(3);
        if (num4 == 0)
        {
          Main.tile[i, index1 - num2].frameX = (short) 22;
          Main.tile[i, index1 - num2].frameY = (short) 198;
        }
        if (num4 == 1)
        {
          Main.tile[i, index1 - num2].frameX = (short) 22;
          Main.tile[i, index1 - num2].frameY = (short) 220;
        }
        if (num4 == 2)
        {
          Main.tile[i, index1 - num2].frameX = (short) 22;
          Main.tile[i, index1 - num2].frameY = (short) 242;
        }
      }
      else
      {
        int num4 = WorldGen.genRand.Next(3);
        if (num4 == 0)
        {
          Main.tile[i, index1 - num2].frameX = (short) 0;
          Main.tile[i, index1 - num2].frameY = (short) 198;
        }
        if (num4 == 1)
        {
          Main.tile[i, index1 - num2].frameX = (short) 0;
          Main.tile[i, index1 - num2].frameY = (short) 220;
        }
        if (num4 == 2)
        {
          Main.tile[i, index1 - num2].frameX = (short) 0;
          Main.tile[i, index1 - num2].frameY = (short) 242;
        }
      }
      WorldGen.RangeFrame(i - 2, index1 - num2 - 1, i + 2, index1 + 1);
      if (Main.netMode != 2 || WorldGen.gen)
        return;
      NetMessage.SendTileSquare(-1, i, (int) ((double) index1 - (double) num2 * 0.5), num2 + 1, TileChangeType.None);
    }

    public static bool GrowShroom(int i, int y)
    {
      int index1 = y;
      if (Main.tile[i - 1, index1 - 1].lava() || Main.tile[i - 1, index1 - 1].lava() || (Main.tile[i + 1, index1 - 1].lava() || !Main.tile[i, index1].nactive()) || (Main.tile[i, index1].type != (ushort) 70 || Main.tile[i, index1 - 1].wall != (ushort) 0 || (!Main.tile[i - 1, index1].active() || Main.tile[i - 1, index1].type != (ushort) 70)) || (!Main.tile[i + 1, index1].active() || Main.tile[i + 1, index1].type != (ushort) 70 || (!WorldGen.EmptyTileCheck(i - 2, i + 2, index1 - 13, index1 - 3, 71) || !WorldGen.EmptyTileCheck(i - 1, i + 1, index1 - 3, index1 - 1, 71))))
        return false;
      if (WorldGen.gen && WorldGen.genRand.Next(3) != 0)
      {
        Main.tile[i, index1].halfBrick(false);
        Main.tile[i, index1].slope((byte) 0);
      }
      if (Main.tile[i, index1].halfBrick() || Main.tile[i, index1].slope() != (byte) 0)
        return false;
      int num1 = WorldGen.genRand.Next(4, 11);
      for (int index2 = index1 - num1; index2 < index1; ++index2)
      {
        Main.tile[i, index2].frameNumber((byte) WorldGen.genRand.Next(3));
        Main.tile[i, index2].active(true);
        Main.tile[i, index2].type = (ushort) 72;
        int num2 = WorldGen.genRand.Next(3);
        if (num2 == 0)
        {
          Main.tile[i, index2].frameX = (short) 0;
          Main.tile[i, index2].frameY = (short) 0;
        }
        if (num2 == 1)
        {
          Main.tile[i, index2].frameX = (short) 0;
          Main.tile[i, index2].frameY = (short) 18;
        }
        if (num2 == 2)
        {
          Main.tile[i, index2].frameX = (short) 0;
          Main.tile[i, index2].frameY = (short) 36;
        }
      }
      int num3 = WorldGen.genRand.Next(3);
      if (num3 == 0)
      {
        Main.tile[i, index1 - num1].frameX = (short) 36;
        Main.tile[i, index1 - num1].frameY = (short) 0;
      }
      if (num3 == 1)
      {
        Main.tile[i, index1 - num1].frameX = (short) 36;
        Main.tile[i, index1 - num1].frameY = (short) 18;
      }
      if (num3 == 2)
      {
        Main.tile[i, index1 - num1].frameX = (short) 36;
        Main.tile[i, index1 - num1].frameY = (short) 36;
      }
      WorldGen.RangeFrame(i - 2, index1 - num1 - 1, i + 2, index1 + 1);
      if (Main.netMode == 2)
        NetMessage.SendTileSquare(-1, i, (int) ((double) index1 - (double) num1 * 0.5), num1 + 1, TileChangeType.None);
      return true;
    }

    public static void AddTrees()
    {
      float num1 = (float) (0.100000001490116 + (double) WorldGen.genRand.NextFloat() * 0.349999994039536);
      float num2 = (float) (0.100000001490116 + (double) WorldGen.genRand.NextFloat() * 0.349999994039536);
      for (int index1 = 1; index1 < Main.maxTilesX - 1; ++index1)
      {
        for (int index2 = 20; (double) index2 < Main.worldSurface; ++index2)
        {
          if (index1 < 380)
          {
            if ((double) WorldGen.genRand.NextFloat() < (double) num1 && Main.tile[index1, index2].liquid == (byte) 0)
              WorldGen.GrowPalmTree(index1, index2);
          }
          else if (index1 > Main.maxTilesX - 380 && (double) WorldGen.genRand.NextFloat() < (double) num2 && Main.tile[index1, index2].liquid == (byte) 0)
            WorldGen.GrowPalmTree(index1, index2);
          int maxValue = 20;
          if (WorldGen.drunkWorldGen)
            maxValue /= 3;
          if (Main.tile[index1, index2].type == (ushort) 2 && WorldGen.genRand.Next(maxValue) == 0)
          {
            if (WorldGen.genRand.Next(2) == 0)
              WorldGen.GrowTreeWithSettings(index1, index2, WorldGen.GrowTreeSettings.Profiles.VanityTree_Willow);
            else
              WorldGen.GrowTreeWithSettings(index1, index2, WorldGen.GrowTreeSettings.Profiles.VanityTree_Sakura);
          }
          else
            WorldGen.GrowTree(index1, index2);
        }
        if (WorldGen.genRand.Next(3) == 0)
          ++index1;
        if (WorldGen.genRand.Next(4) == 0)
          ++index1;
      }
    }

    public static void ExplodeMine(int i, int j)
    {
      int type = (int) Main.tile[i, j].type;
      WorldGen.KillTile(i, j, false, false, true);
      NetMessage.SendTileSquare(-1, i, j, 1, TileChangeType.None);
      Projectile.NewProjectile((float) (i * 16 + 8), (float) (j * 16 + 8), 0.0f, 0.0f, 164, 250, 10f, Main.myPlayer, 0.0f, 0.0f);
    }

    public static bool EmptyTileCheck(int startX, int endX, int startY, int endY, int ignoreID = -1)
    {
      if (startX < 0 || endX >= Main.maxTilesX || (startY < 0 || endY >= Main.maxTilesY))
        return false;
      bool flag = false;
      if (ignoreID != -1 && TileID.Sets.CommonSapling[ignoreID])
        flag = true;
label_20:
      for (int index1 = startX; index1 < endX + 1; ++index1)
      {
        for (int index2 = startY; index2 < endY + 1; ++index2)
        {
          if (Main.tile[index1, index2].active())
          {
            switch (ignoreID)
            {
              case -1:
                return false;
              case 11:
                if (Main.tile[index1, index2].type != (ushort) 11)
                  return false;
                continue;
              case 71:
                if (Main.tile[index1, index2].type != (ushort) 71)
                  return false;
                continue;
              default:
                if (flag)
                {
                  if (!TileID.Sets.CommonSapling[(int) Main.tile[index1, index2].type])
                  {
                    switch (Main.tile[index1, index2].type)
                    {
                      case 3:
                      case 24:
                      case 32:
                      case 61:
                      case 62:
                      case 69:
                      case 71:
                      case 73:
                      case 74:
                      case 82:
                      case 83:
                      case 84:
                      case 110:
                      case 113:
                      case 201:
                      case 233:
                      case 352:
                      case 485:
                      case 529:
                      case 530:
                        continue;
                      default:
                        return false;
                    }
                  }
                  else
                    goto label_20;
                }
                else
                  continue;
            }
          }
        }
      }
      return true;
    }

    public static void StartHardmode()
    {
      if (Main.netMode == 1 || Main.hardMode)
        return;
      Main.hardMode = true;
      ThreadPool.QueueUserWorkItem(new WaitCallback(WorldGen.smCallBack), (object) 1);
    }

    public static void smCallBack(object threadContext)
    {
      WorldGen.IsGeneratingHardMode = true;
      if (Main.rand == null)
        Main.rand = new UnifiedRandom((int) DateTime.Now.Ticks);
      float num1 = (float) WorldGen.genRand.Next(300, 400) * (1f / 1000f);
      float num2 = (float) WorldGen.genRand.Next(200, 300) * (1f / 1000f);
      int i1 = (int) ((double) Main.maxTilesX * (double) num1);
      int i2 = (int) ((double) Main.maxTilesX * (1.0 - (double) num1));
      int num3 = 1;
      if (WorldGen.genRand.Next(2) == 0)
      {
        i2 = (int) ((double) Main.maxTilesX * (double) num1);
        i1 = (int) ((double) Main.maxTilesX * (1.0 - (double) num1));
        num3 = -1;
      }
      int num4 = 1;
      if (WorldGen.dungeonX < Main.maxTilesX / 2)
        num4 = -1;
      if (num4 < 0)
      {
        if (i2 < i1)
          i2 = (int) ((double) Main.maxTilesX * (double) num2);
        else
          i1 = (int) ((double) Main.maxTilesX * (double) num2);
      }
      else if (i2 > i1)
        i2 = (int) ((double) Main.maxTilesX * (1.0 - (double) num2));
      else
        i1 = (int) ((double) Main.maxTilesX * (1.0 - (double) num2));
      WorldGen.GERunner(i1, 0, (float) (3 * num3), 5f, true);
      WorldGen.GERunner(i2, 0, (float) (3 * -num3), 5f, false);
      int num5 = (int) (25.0 * (double) ((float) Main.maxTilesX / 4200f));
      ShapeData data = new ShapeData();
      int num6 = 0;
      while (num5 > 0)
      {
        if (++num6 % 15000 == 0)
          --num5;
        Point point = WorldGen.RandomWorldPoint((int) Main.worldSurface - 100, 1, 190, 1);
        Tile tile1 = Main.tile[point.X, point.Y];
        Tile tile2 = Main.tile[point.X, point.Y - 1];
        ushort type = 0;
        if (TileID.Sets.Crimson[(int) tile1.type])
          type = (ushort) (192 + WorldGen.genRand.Next(4));
        else if (TileID.Sets.Corrupt[(int) tile1.type])
          type = (ushort) (188 + WorldGen.genRand.Next(4));
        else if (TileID.Sets.Hallow[(int) tile1.type])
          type = (ushort) (200 + WorldGen.genRand.Next(4));
        if (tile1.active() && type != (ushort) 0 && !tile2.active())
        {
          bool flag = WorldUtils.Gen(new Point(point.X, point.Y - 1), (GenShape) new ShapeFloodFill(1000), Actions.Chain((GenAction) new Modifiers.IsNotSolid(), (GenAction) new Modifiers.OnlyWalls(new ushort[31]
          {
            (ushort) 0,
            (ushort) 54,
            (ushort) 55,
            (ushort) 56,
            (ushort) 57,
            (ushort) 58,
            (ushort) 59,
            (ushort) 61,
            (ushort) 185,
            (ushort) 212,
            (ushort) 213,
            (ushort) 214,
            (ushort) 215,
            (ushort) 2,
            (ushort) 196,
            (ushort) 197,
            (ushort) 198,
            (ushort) 199,
            (ushort) 15,
            (ushort) 40,
            (ushort) 71,
            (ushort) 64,
            (ushort) 204,
            (ushort) 205,
            (ushort) 206,
            (ushort) 207,
            (ushort) 208,
            (ushort) 209,
            (ushort) 210,
            (ushort) 211,
            (ushort) 71
          }), new Actions.Blank().Output(data)));
          if (data.Count > 50 & flag)
          {
            WorldUtils.Gen(new Point(point.X, point.Y), (GenShape) new ModShapes.OuterOutline(data, true, true), (GenAction) new Actions.PlaceWall(type, true));
            --num5;
          }
          data.Clear();
        }
      }
      switch (Main.netMode)
      {
        case 0:
          Main.NewText(Lang.misc[15].Value, (byte) 50, byte.MaxValue, (byte) 130);
          break;
        case 2:
          ChatHelper.BroadcastChatMessage(NetworkText.FromKey(Lang.misc[15].Key), new Color(50, (int) byte.MaxValue, 130), -1);
          break;
      }
      AchievementsHelper.NotifyProgressionEvent(9);
      if (Main.netMode == 2)
        Netplay.ResetSections();
      WorldGen.IsGeneratingHardMode = false;
    }

    public static bool PlaceDoor(int i, int j, int type, int style = 0)
    {
      int num1 = style / 36;
      int num2 = style % 36;
      int num3 = 54 * num1;
      int num4 = 54 * num2;
      try
      {
        if (!Main.tile[i, j - 2].nactive() || !Main.tileSolid[(int) Main.tile[i, j - 2].type] || !WorldGen.SolidTile(i, j + 2, false))
          return false;
        Main.tile[i, j - 1].active(true);
        Main.tile[i, j - 1].type = (ushort) 10;
        Main.tile[i, j - 1].frameY = (short) num4;
        Main.tile[i, j - 1].frameX = (short) (num3 + WorldGen.genRand.Next(3) * 18);
        Main.tile[i, j].active(true);
        Main.tile[i, j].type = (ushort) 10;
        Main.tile[i, j].frameY = (short) (num4 + 18);
        Main.tile[i, j].frameX = (short) (num3 + WorldGen.genRand.Next(3) * 18);
        Main.tile[i, j + 1].active(true);
        Main.tile[i, j + 1].type = (ushort) 10;
        Main.tile[i, j + 1].frameY = (short) (num4 + 36);
        Main.tile[i, j + 1].frameX = (short) (num3 + WorldGen.genRand.Next(3) * 18);
        return true;
      }
      catch
      {
        return false;
      }
    }

    public static bool CloseDoor(int i, int j, bool forced = false)
    {
      int num1 = 0;
      int num2 = i;
      if (Main.tile[i, j] == null)
        Main.tile[i, j] = new Tile();
      int frameX = (int) Main.tile[i, j].frameX;
      Tile tile = Main.tile[i, j];
      if (tile.type != (ushort) 11)
        return false;
      int frameY = (int) tile.frameY;
      int num3 = 0;
      int num4 = 0;
      while (frameY >= 54)
      {
        frameY -= 54;
        ++num3;
      }
      if (frameX >= 72)
      {
        int num5 = num3 + 36 * (frameX / 72);
        num4 += 54 * (frameX / 72);
      }
      int y = j - frameY / 18;
      switch (frameX % 72)
      {
        case 0:
          num2 = i;
          num1 = 1;
          break;
        case 18:
          num2 = i - 1;
          num1 = 1;
          break;
        case 36:
          num2 = i + 1;
          num1 = -1;
          break;
        case 54:
          num2 = i;
          num1 = -1;
          break;
      }
      int num6 = num2;
      if (num1 == -1)
        num6 = num2 - 1;
      if (!forced)
      {
        for (int j1 = y; j1 < y + 3; ++j1)
        {
          if (!Collision.EmptyTile(num2, j1, true))
            return false;
        }
      }
      for (int index1 = num6; index1 < num6 + 2; ++index1)
      {
        for (int index2 = y; index2 < y + 3; ++index2)
        {
          if (index1 == num2)
          {
            if (Main.tile[index1, index2] == null)
              Main.tile[index1, index2] = new Tile();
            Main.tile[index1, index2].type = (ushort) 10;
            Main.tile[index1, index2].frameX = (short) (WorldGen.genRand.Next(3) * 18 + num4);
          }
          else
          {
            if (Main.tile[index1, index2] == null)
              Main.tile[index1, index2] = new Tile();
            Main.tile[index1, index2].active(false);
          }
        }
      }
      if (Main.netMode != 1 && Wiring.running)
      {
        Wiring.SkipWire(num2, y);
        Wiring.SkipWire(num2, y + 1);
        Wiring.SkipWire(num2, y + 2);
      }
      for (int i1 = num2 - 1; i1 <= num2 + 1; ++i1)
      {
        for (int j1 = y - 1; j1 <= y + 2; ++j1)
          WorldGen.TileFrame(i1, j1, false, false);
      }
      SoundEngine.PlaySound(9, i * 16, j * 16, 1, 1f, 0.0f);
      return true;
    }

    public static bool AddLifeCrystal(int i, int j)
    {
      for (int index = j; index < Main.maxTilesY; ++index)
      {
        if (Main.tile[i, index].active() && Main.tileSolid[(int) Main.tile[i, index].type])
        {
          int endX = i;
          int endY = index - 1;
          if (Main.tile[endX, endY - 1].lava() || Main.tile[endX - 1, endY - 1].lava() || (!WorldGen.EmptyTileCheck(endX - 1, endX, endY - 1, endY, -1) || Main.wallDungeon[(int) Main.tile[endX, endY].wall]))
            return false;
          Tile tile1 = Main.tile[endX - 1, endY + 1];
          Tile tile2 = Main.tile[endX, endY + 1];
          if (!tile1.nactive() || !Main.tileSolid[(int) tile1.type] || (!tile2.nactive() || !Main.tileSolid[(int) tile2.type]))
            return false;
          if (tile1.blockType() != 0)
          {
            tile1.slope((byte) 0);
            tile1.halfBrick(false);
          }
          if (tile2.blockType() != 0)
          {
            tile2.slope((byte) 0);
            tile2.halfBrick(false);
          }
          Main.tile[endX - 1, endY - 1].active(true);
          Main.tile[endX - 1, endY - 1].type = (ushort) 12;
          Main.tile[endX - 1, endY - 1].frameX = (short) 0;
          Main.tile[endX - 1, endY - 1].frameY = (short) 0;
          Main.tile[endX, endY - 1].active(true);
          Main.tile[endX, endY - 1].type = (ushort) 12;
          Main.tile[endX, endY - 1].frameX = (short) 18;
          Main.tile[endX, endY - 1].frameY = (short) 0;
          Main.tile[endX - 1, endY].active(true);
          Main.tile[endX - 1, endY].type = (ushort) 12;
          Main.tile[endX - 1, endY].frameX = (short) 0;
          Main.tile[endX - 1, endY].frameY = (short) 18;
          Main.tile[endX, endY].active(true);
          Main.tile[endX, endY].type = (ushort) 12;
          Main.tile[endX, endY].frameX = (short) 18;
          Main.tile[endX, endY].frameY = (short) 18;
          return true;
        }
      }
      return false;
    }

    public static void AddShadowOrb(int x, int y)
    {
      if (x < 10 || x > Main.maxTilesX - 10 || (y < 10 || y > Main.maxTilesY - 10))
        return;
      for (int index1 = x - 1; index1 < x + 1; ++index1)
      {
        for (int index2 = y - 1; index2 < y + 1; ++index2)
        {
          if (Main.tile[index1, index2].active() && Main.tile[index1, index2].type == (ushort) 31)
            return;
        }
      }
      short num = 0;
      if (WorldGen.crimson)
        num += (short) 36;
      Main.tile[x - 1, y - 1].active(true);
      Main.tile[x - 1, y - 1].type = (ushort) 31;
      Main.tile[x - 1, y - 1].frameX = num;
      Main.tile[x - 1, y - 1].frameY = (short) 0;
      Main.tile[x, y - 1].active(true);
      Main.tile[x, y - 1].type = (ushort) 31;
      Main.tile[x, y - 1].frameX = (short) (18 + (int) num);
      Main.tile[x, y - 1].frameY = (short) 0;
      Main.tile[x - 1, y].active(true);
      Main.tile[x - 1, y].type = (ushort) 31;
      Main.tile[x - 1, y].frameX = num;
      Main.tile[x - 1, y].frameY = (short) 18;
      Main.tile[x, y].active(true);
      Main.tile[x, y].type = (ushort) 31;
      Main.tile[x, y].frameX = (short) (18 + (int) num);
      Main.tile[x, y].frameY = (short) 18;
    }

    public static void AddHellHouses()
    {
      int num1 = (int) ((double) Main.maxTilesX * 0.25);
      for (int i = 100; i < Main.maxTilesX - 100; ++i)
      {
        if ((!WorldGen.drunkWorldGen || i <= num1 || i >= Main.maxTilesX - num1) && (WorldGen.drunkWorldGen || i >= num1 && i <= Main.maxTilesX - num1))
        {
          int j = Main.maxTilesY - 40;
          while (Main.tile[i, j].active() || Main.tile[i, j].liquid > (byte) 0)
            --j;
          if (Main.tile[i, j + 1].active())
          {
            ushort tileType = (ushort) WorldGen.genRand.Next(75, 77);
            byte wallType = 13;
            if (WorldGen.genRand.Next(5) > 0)
              tileType = (ushort) 75;
            if (tileType == (ushort) 75)
              wallType = (byte) 14;
            if (WorldGen.getGoodWorldGen)
              tileType = (ushort) 76;
            WorldGen.HellFort(i, j, tileType, wallType);
            i += WorldGen.genRand.Next(30, 130);
            if (WorldGen.genRand.Next(10) == 0)
              i += WorldGen.genRand.Next(0, 200);
          }
        }
      }
      float num2 = (float) (Main.maxTilesX / 4200);
      for (int index1 = 0; (double) index1 < 200.0 * (double) num2; ++index1)
      {
        int num3 = 0;
        bool flag1 = false;
        while (!flag1)
        {
          ++num3;
          int index2 = WorldGen.genRand.Next((int) ((double) Main.maxTilesX * 0.2), (int) ((double) Main.maxTilesX * 0.8));
          int j = WorldGen.genRand.Next(Main.maxTilesY - 300, Main.maxTilesY - 20);
          if (Main.tile[index2, j].active() && (Main.tile[index2, j].type == (ushort) 75 || Main.tile[index2, j].type == (ushort) 76))
          {
            int num4 = 0;
            if (Main.tile[index2 - 1, j].wall > (ushort) 0)
              num4 = -1;
            else if (Main.tile[index2 + 1, j].wall > (ushort) 0)
              num4 = 1;
            if (!Main.tile[index2 + num4, j].active() && !Main.tile[index2 + num4, j + 1].active())
            {
              bool flag2 = false;
              for (int index3 = index2 - 8; index3 < index2 + 8; ++index3)
              {
                for (int index4 = j - 8; index4 < j + 8; ++index4)
                {
                  if (Main.tile[index3, index4].active() && Main.tile[index3, index4].type == (ushort) 4)
                  {
                    flag2 = true;
                    break;
                  }
                }
              }
              if (!flag2)
              {
                WorldGen.PlaceTile(index2 + num4, j, 4, true, true, -1, 7);
                flag1 = true;
              }
            }
          }
          if (num3 > 1000)
            flag1 = true;
        }
      }
      float num5 = 4200000f / (float) Main.maxTilesX;
      for (int index1 = 0; (double) index1 < (double) num5; ++index1)
      {
        int num3 = 0;
        int i1 = WorldGen.genRand.Next(num1, Main.maxTilesX - num1);
        int j = WorldGen.genRand.Next(Main.maxTilesY - 250, Main.maxTilesY - 20);
        while (Main.tile[i1, j].wall != (ushort) 13 && Main.tile[i1, j].wall != (ushort) 14 || Main.tile[i1, j].active())
        {
          i1 = WorldGen.genRand.Next(num1, Main.maxTilesX - num1);
          j = WorldGen.genRand.Next(Main.maxTilesY - 250, Main.maxTilesY - 20);
          if (WorldGen.drunkWorldGen)
            i1 = WorldGen.genRand.Next(2) != 0 ? WorldGen.genRand.Next(Main.maxTilesX - num1, Main.maxTilesX - 50) : WorldGen.genRand.Next(50, num1);
          ++num3;
          if (num3 > 100000)
            break;
        }
        if (num3 <= 100000 && (Main.tile[i1, j].wall == (ushort) 13 || Main.tile[i1, j].wall == (ushort) 14) && !Main.tile[i1, j].active())
        {
          while (!WorldGen.SolidTile(i1, j, false) && j < Main.maxTilesY - 20)
            ++j;
          int index2 = j - 1;
          int i2 = i1;
          int i3 = i1;
          while (!Main.tile[i2, index2].active() && WorldGen.SolidTile(i2, index2 + 1, false))
            --i2;
          int num4 = i2 + 1;
          while (!Main.tile[i3, index2].active() && WorldGen.SolidTile(i3, index2 + 1, false))
            ++i3;
          int num6 = i3 - 1;
          int num7 = num6 - num4;
          int index3 = (num6 + num4) / 2;
          if (!Main.tile[index3, index2].active() && (Main.tile[index3, index2].wall == (ushort) 13 || Main.tile[index3, index2].wall == (ushort) 14) && WorldGen.SolidTile(index3, index2 + 1, false))
          {
            int style1 = 16;
            int style2 = 13;
            int style3 = 14;
            int style4 = 49;
            int style5 = 4;
            int style6 = 8;
            int style7 = 15;
            int style8 = 9;
            int style9 = 10;
            int style10 = 17;
            int style11 = 25;
            int style12 = 25;
            int style13 = 23;
            int style14 = 25;
            int num8 = WorldGen.genRand.Next(13);
            int num9 = 0;
            int num10 = 0;
            if (num8 == 0)
            {
              num9 = 5;
              num10 = 4;
            }
            if (num8 == 1)
            {
              num9 = 4;
              num10 = 3;
            }
            if (num8 == 2)
            {
              num9 = 3;
              num10 = 5;
            }
            if (num8 == 3)
            {
              num9 = 4;
              num10 = 6;
            }
            if (num8 == 4)
            {
              num9 = 3;
              num10 = 3;
            }
            if (num8 == 5)
            {
              num9 = 5;
              num10 = 3;
            }
            if (num8 == 6)
            {
              num9 = 5;
              num10 = 4;
            }
            if (num8 == 7)
            {
              num9 = 5;
              num10 = 4;
            }
            if (num8 == 8)
            {
              num9 = 5;
              num10 = 4;
            }
            if (num8 == 9)
            {
              num9 = 3;
              num10 = 5;
            }
            if (num8 == 10)
            {
              num9 = 5;
              num10 = 3;
            }
            if (num8 == 11)
            {
              num9 = 2;
              num10 = 4;
            }
            if (num8 == 12)
            {
              num9 = 3;
              num10 = 3;
            }
            for (int index4 = index3 - num9; index4 <= index3 + num9; ++index4)
            {
              for (int index5 = index2 - num10; index5 <= index2; ++index5)
              {
                if (Main.tile[index4, index5].active())
                {
                  num8 = -1;
                  break;
                }
              }
            }
            if ((double) num7 < (double) num9 * 1.75)
              num8 = -1;
            switch (num8)
            {
              case 0:
                WorldGen.PlaceTile(index3, index2, 14, true, false, -1, style2);
                int num11 = WorldGen.genRand.Next(6);
                if (num11 < 3)
                  WorldGen.PlaceTile(index3 + num11, index2 - 2, 33, true, false, -1, style12);
                if (Main.tile[index3, index2].active())
                {
                  if (!Main.tile[index3 - 2, index2].active())
                  {
                    WorldGen.PlaceTile(index3 - 2, index2, 15, true, false, -1, style1);
                    if (Main.tile[index3 - 2, index2].active())
                    {
                      Main.tile[index3 - 2, index2].frameX += (short) 18;
                      Main.tile[index3 - 2, index2 - 1].frameX += (short) 18;
                    }
                  }
                  if (!Main.tile[index3 + 2, index2].active())
                  {
                    WorldGen.PlaceTile(index3 + 2, index2, 15, true, false, -1, style1);
                    continue;
                  }
                  continue;
                }
                continue;
              case 1:
                WorldGen.PlaceTile(index3, index2, 18, true, false, -1, style3);
                int num12 = WorldGen.genRand.Next(4);
                if (num12 < 2)
                  WorldGen.PlaceTile(index3 + num12, index2 - 1, 33, true, false, -1, style12);
                if (Main.tile[index3, index2].active())
                {
                  if (WorldGen.genRand.Next(2) == 0)
                  {
                    if (!Main.tile[index3 - 1, index2].active())
                    {
                      WorldGen.PlaceTile(index3 - 1, index2, 15, true, false, -1, style1);
                      if (Main.tile[index3 - 1, index2].active())
                      {
                        Main.tile[index3 - 1, index2].frameX += (short) 18;
                        Main.tile[index3 - 1, index2 - 1].frameX += (short) 18;
                        continue;
                      }
                      continue;
                    }
                    continue;
                  }
                  if (!Main.tile[index3 + 2, index2].active())
                  {
                    WorldGen.PlaceTile(index3 + 2, index2, 15, true, false, -1, style1);
                    continue;
                  }
                  continue;
                }
                continue;
              case 2:
                WorldGen.PlaceTile(index3, index2, 105, true, false, -1, style4);
                continue;
              case 3:
                WorldGen.PlaceTile(index3, index2, 101, true, false, -1, style5);
                continue;
              case 4:
                if (WorldGen.genRand.Next(2) == 0)
                {
                  WorldGen.PlaceTile(index3, index2, 15, true, false, -1, style1);
                  Main.tile[index3, index2].frameX += (short) 18;
                  Main.tile[index3, index2 - 1].frameX += (short) 18;
                  continue;
                }
                WorldGen.PlaceTile(index3, index2, 15, true, false, -1, style1);
                continue;
              case 5:
                if (WorldGen.genRand.Next(2) == 0)
                {
                  WorldGen.Place4x2(index3, index2, (ushort) 79, 1, style6);
                  continue;
                }
                WorldGen.Place4x2(index3, index2, (ushort) 79, -1, style6);
                continue;
              case 6:
                WorldGen.PlaceTile(index3, index2, 87, true, false, -1, style7);
                continue;
              case 7:
                WorldGen.PlaceTile(index3, index2, 88, true, false, -1, style8);
                continue;
              case 8:
                WorldGen.PlaceTile(index3, index2, 89, true, false, -1, style9);
                continue;
              case 9:
                WorldGen.PlaceTile(index3, index2, 104, true, false, -1, style10);
                continue;
              case 10:
                if (WorldGen.genRand.Next(2) == 0)
                {
                  WorldGen.Place4x2(index3, index2, (ushort) 90, 1, style14);
                  continue;
                }
                WorldGen.Place4x2(index3, index2, (ushort) 90, -1, style14);
                continue;
              case 11:
                WorldGen.PlaceTile(index3, index2, 93, true, false, -1, style13);
                continue;
              case 12:
                WorldGen.PlaceTile(index3, index2, 100, true, false, -1, style11);
                continue;
              default:
                continue;
            }
          }
        }
      }
      float num13 = 420000f / (float) Main.maxTilesX;
      for (int index1 = 0; (double) index1 < (double) num13; ++index1)
      {
        int num3 = 0;
        int index2 = WorldGen.genRand.Next(num1, Main.maxTilesX - num1);
        int index3 = WorldGen.genRand.Next(Main.maxTilesY - 250, Main.maxTilesY - 20);
        while (Main.tile[index2, index3].wall != (ushort) 13 && Main.tile[index2, index3].wall != (ushort) 14 || Main.tile[index2, index3].active())
        {
          index2 = WorldGen.genRand.Next(num1, Main.maxTilesX - num1);
          index3 = WorldGen.genRand.Next(Main.maxTilesY - 250, Main.maxTilesY - 20);
          if (WorldGen.drunkWorldGen)
            index2 = WorldGen.genRand.Next(2) != 0 ? WorldGen.genRand.Next(Main.maxTilesX - num1, Main.maxTilesX - 50) : WorldGen.genRand.Next(50, num1);
          ++num3;
          if (num3 > 100000)
            break;
        }
        if (num3 <= 100000)
        {
          for (int index4 = 0; index4 < 2; ++index4)
          {
            int index5 = index2;
            int index6 = index2;
            while (!Main.tile[index5, index3].active() && (Main.tile[index5, index3].wall == (ushort) 13 || Main.tile[index5, index3].wall == (ushort) 14))
              --index5;
            int num4 = index5 + 1;
            while (!Main.tile[index6, index3].active() && (Main.tile[index6, index3].wall == (ushort) 13 || Main.tile[index6, index3].wall == (ushort) 14))
              ++index6;
            int num6 = index6 - 1;
            index2 = (num4 + num6) / 2;
            int index7 = index3;
            int index8 = index3;
            while (!Main.tile[index2, index7].active() && (Main.tile[index2, index7].wall == (ushort) 13 || Main.tile[index2, index7].wall == (ushort) 14))
              --index7;
            int num7 = index7 + 1;
            while (!Main.tile[index2, index8].active() && (Main.tile[index2, index8].wall == (ushort) 13 || Main.tile[index2, index8].wall == (ushort) 14))
              ++index8;
            int num8 = index8 - 1;
            index3 = (num7 + num8) / 2;
          }
          int index9 = index2;
          int index10 = index2;
          while (!Main.tile[index9, index3].active() && !Main.tile[index9, index3 - 1].active() && !Main.tile[index9, index3 + 1].active())
            --index9;
          int num9 = index9 + 1;
          while (!Main.tile[index10, index3].active() && !Main.tile[index10, index3 - 1].active() && !Main.tile[index10, index3 + 1].active())
            ++index10;
          int num10 = index10 - 1;
          int index11 = index3;
          int index12 = index3;
          while (!Main.tile[index2, index11].active() && !Main.tile[index2 - 1, index11].active() && !Main.tile[index2 + 1, index11].active())
            --index11;
          int num11 = index11 + 1;
          while (!Main.tile[index2, index12].active() && !Main.tile[index2 - 1, index12].active() && !Main.tile[index2 + 1, index12].active())
            ++index12;
          int num12 = index12 - 1;
          int num14 = (num9 + num10) / 2;
          int num15 = (num11 + num12) / 2;
          int num16 = num10 - num9;
          int num17 = num12 - num11;
          if (num16 > 7 && num17 > 5)
          {
            int num4 = 0;
            if (WorldGen.nearPicture2(num14, num15))
              num4 = -1;
            if (num4 == 0)
            {
              Vector2 vector2 = WorldGen.randHellPicture();
              int x = (int) vector2.X;
              int y = (int) vector2.Y;
              if (!WorldGen.nearPicture(num14, num15))
                WorldGen.PlaceTile(num14, num15, x, true, false, -1, y);
            }
          }
        }
      }
      int[] numArray = new int[3]
      {
        WorldGen.genRand.Next(16, 22),
        WorldGen.genRand.Next(16, 22),
        WorldGen.genRand.Next(16, 22)
      };
      while (numArray[1] == numArray[0])
        numArray[1] = WorldGen.genRand.Next(16, 22);
      while (numArray[2] == numArray[0] || numArray[2] == numArray[1])
        numArray[2] = WorldGen.genRand.Next(16, 22);
      float num18 = 420000f / (float) Main.maxTilesX;
      for (int index1 = 0; (double) index1 < (double) num18; ++index1)
      {
        int num3 = 0;
        int i;
        int j1;
        do
        {
          i = WorldGen.genRand.Next(num1, Main.maxTilesX - num1);
          j1 = WorldGen.genRand.Next(Main.maxTilesY - 250, Main.maxTilesY - 20);
          if (WorldGen.drunkWorldGen)
            i = WorldGen.genRand.Next(2) != 0 ? WorldGen.genRand.Next(Main.maxTilesX - num1, Main.maxTilesX - 50) : WorldGen.genRand.Next(50, num1);
          ++num3;
        }
        while (num3 <= 100000 && (Main.tile[i, j1].wall != (ushort) 13 && Main.tile[i, j1].wall != (ushort) 14 || Main.tile[i, j1].active()));
        if (num3 <= 100000)
        {
          while (!WorldGen.SolidTile(i, j1, false) && j1 > 10)
            --j1;
          int j2 = j1 + 1;
          if (Main.tile[i, j2].wall == (ushort) 13 || Main.tile[i, j2].wall == (ushort) 14)
          {
            int num4 = WorldGen.genRand.Next(3);
            int style1 = 32;
            int style2 = 32;
            int num6;
            int num7;
            switch (num4)
            {
              case 1:
                num6 = 3;
                num7 = 3;
                break;
              case 2:
                num6 = 1;
                num7 = 2;
                break;
              default:
                num6 = 1;
                num7 = 3;
                break;
            }
            for (int index2 = i - 1; index2 <= i + num6; ++index2)
            {
              for (int index3 = j2; index3 <= j2 + num7; ++index3)
              {
                Tile tile = Main.tile[i, j2];
                if (index2 < i || index2 == i + num6)
                {
                  if (tile.active())
                  {
                    switch (tile.type)
                    {
                      case 10:
                      case 11:
                      case 34:
                      case 42:
                      case 91:
                        num4 = -1;
                        continue;
                      default:
                        continue;
                    }
                  }
                }
                else if (tile.active())
                  num4 = -1;
              }
            }
            switch (num4)
            {
              case 0:
                WorldGen.PlaceTile(i, j2, 91, true, false, -1, numArray[WorldGen.genRand.Next(3)]);
                continue;
              case 1:
                WorldGen.PlaceTile(i, j2, 34, true, false, -1, style1);
                continue;
              case 2:
                WorldGen.PlaceTile(i, j2, 42, true, false, -1, style2);
                continue;
              default:
                continue;
            }
          }
        }
      }
    }

    public static void HellFort(int i, int j, ushort tileType = 75, byte wallType = 14)
    {
      int[] numArray1 = new int[5];
      int[] numArray2 = new int[5];
      int[] numArray3 = new int[10];
      int[] numArray4 = new int[10];
      int minValue1 = 8;
      int maxValue1 = 20;
      if (WorldGen.drunkWorldGen)
      {
        minValue1 /= 2;
        maxValue1 *= 2;
      }
      numArray1[2] = i - WorldGen.genRand.Next(minValue1 / 2, maxValue1 / 2);
      numArray2[2] = i + WorldGen.genRand.Next(minValue1 / 2, maxValue1 / 2);
      numArray1[3] = numArray2[2];
      numArray2[3] = numArray1[3] + WorldGen.genRand.Next(minValue1, maxValue1);
      numArray1[4] = numArray2[3];
      numArray2[4] = numArray1[4] + WorldGen.genRand.Next(minValue1, maxValue1);
      numArray2[1] = numArray1[2];
      numArray1[1] = numArray2[1] - WorldGen.genRand.Next(minValue1, maxValue1);
      numArray2[0] = numArray1[1];
      numArray1[0] = numArray2[0] - WorldGen.genRand.Next(minValue1, maxValue1);
      int minValue2 = 6;
      int maxValue2 = 12;
      numArray3[3] = j - WorldGen.genRand.Next(minValue2, maxValue2);
      numArray4[3] = j;
      for (int index = 4; index < 10; ++index)
      {
        numArray3[index] = numArray4[index - 1];
        numArray4[index] = numArray3[index] + WorldGen.genRand.Next(minValue2, maxValue2);
      }
      for (int index = 2; index >= 0; --index)
      {
        numArray4[index] = numArray3[index + 1];
        numArray3[index] = numArray4[index] - WorldGen.genRand.Next(minValue2, maxValue2);
      }
      bool flag1 = false;
      bool flag2 = false;
      bool[,] flagArray1 = new bool[5, 10];
      int num1 = 3;
      int num2 = 3;
      for (int index1 = 0; index1 < 2; ++index1)
      {
        if (WorldGen.genRand.Next(3) == 0 || WorldGen.drunkWorldGen)
        {
          flag1 = true;
          int index2 = WorldGen.genRand.Next(10);
          if (index2 < num1)
            num1 = index2;
          if (index2 > num2)
            num2 = index2;
          int index3 = 1;
          if (WorldGen.genRand.Next(2) == 0 || WorldGen.drunkWorldGen)
          {
            flagArray1[0, index2] = true;
            flagArray1[1, index2] = true;
            index3 = 0;
          }
          else
            flagArray1[1, index2] = true;
          int num3 = WorldGen.genRand.Next(2);
          if (num3 == 0)
            num3 = -1;
          for (int index4 = WorldGen.genRand.Next(10); index4 > 0 && index2 >= 0 && index2 < 10; index2 += num3)
            flagArray1[index3, index2] = true;
        }
        if (WorldGen.genRand.Next(3) == 0 || WorldGen.drunkWorldGen)
        {
          flag2 = true;
          int index2 = WorldGen.genRand.Next(10);
          if (index2 < num1)
            num1 = index2;
          if (index2 > num2)
            num2 = index2;
          int index3 = 3;
          if (WorldGen.genRand.Next(2) == 0 || WorldGen.drunkWorldGen)
          {
            flagArray1[3, index2] = true;
            flagArray1[4, index2] = true;
            index3 = 4;
          }
          else
            flagArray1[3, index2] = true;
          int num3 = WorldGen.genRand.Next(2);
          if (num3 == 0)
            num3 = -1;
          for (int index4 = WorldGen.genRand.Next(10); index4 > 0 && index2 >= 0 && index2 < 10; index2 += num3)
            flagArray1[index3, index2] = true;
        }
      }
      for (int index1 = 0; index1 < 5; ++index1)
      {
        int index2 = numArray1[index1];
        bool flag3 = false;
        if (index2 < 10 || index2 > Main.maxTilesX - 10)
        {
          flag3 = true;
        }
        else
        {
          for (int underworldLayer = Main.UnderworldLayer; underworldLayer < Main.maxTilesY; ++underworldLayer)
          {
            if (Main.tile[index2, underworldLayer].wall > (ushort) 0)
              flag3 = true;
          }
        }
        if (flag3)
        {
          for (int index3 = 0; index3 < 10; ++index3)
            flagArray1[index1, index3] = false;
        }
      }
      int num4 = WorldGen.genRand.Next(10);
      if (num4 < num1)
        num1 = num4;
      int num5 = WorldGen.genRand.Next(10);
      if (num5 > num2)
        num2 = num5;
      if (!flag1 && !flag2)
      {
        while (num2 - num1 < 5)
        {
          int num3 = WorldGen.genRand.Next(10);
          if (num3 < num1)
            num1 = num3;
          int num6 = WorldGen.genRand.Next(10);
          if (num6 > num2)
            num2 = num6;
        }
      }
      for (int index = num1; index <= num2; ++index)
        flagArray1[2, index] = true;
      for (int index1 = 0; index1 < 5; ++index1)
      {
        for (int index2 = 0; index2 < 10; ++index2)
        {
          if (flagArray1[index1, index2] && (numArray3[index2] < Main.UnderworldLayer || numArray4[index2] > Main.maxTilesY - 20))
            flagArray1[index1, index2] = false;
        }
      }
      for (int index1 = 0; index1 < 5; ++index1)
      {
        for (int index2 = 0; index2 < 10; ++index2)
        {
          if (flagArray1[index1, index2])
          {
            for (int index3 = numArray1[index1]; index3 <= numArray2[index1]; ++index3)
            {
              for (int index4 = numArray3[index2]; index4 <= numArray4[index2] && (index3 >= 10 && index3 <= Main.maxTilesX - 10); ++index4)
              {
                Main.tile[index3, index4].liquid = (byte) 0;
                if (index3 == numArray1[index1] || index3 == numArray2[index1] || (index4 == numArray3[index2] || index4 == numArray4[index2]))
                {
                  Main.tile[index3, index4].active(true);
                  Main.tile[index3, index4].type = tileType;
                  Main.tile[index3, index4].halfBrick(false);
                  Main.tile[index3, index4].slope((byte) 0);
                }
                else
                {
                  Main.tile[index3, index4].wall = (ushort) wallType;
                  Main.tile[index3, index4].active(false);
                }
              }
            }
          }
        }
      }
      int style1 = 19;
      int style2 = 13;
      for (int index1 = 0; index1 < 4; ++index1)
      {
        bool[] flagArray2 = new bool[10];
        bool flag3 = false;
        for (int index2 = 0; index2 < 10; ++index2)
        {
          if (flagArray1[index1, index2] && flagArray1[index1 + 1, index2])
          {
            flagArray2[index2] = true;
            flag3 = true;
          }
        }
        while (flag3)
        {
          int index2 = WorldGen.genRand.Next(10);
          if (flagArray2[index2])
          {
            flag3 = false;
            Main.tile[numArray2[index1], numArray4[index2] - 1].active(false);
            Main.tile[numArray2[index1], numArray4[index2] - 2].active(false);
            Main.tile[numArray2[index1], numArray4[index2] - 3].active(false);
            Main.tile[numArray2[index1], numArray4[index2] - 1].wall = (ushort) wallType;
            Main.tile[numArray2[index1], numArray4[index2] - 2].wall = (ushort) wallType;
            Main.tile[numArray2[index1], numArray4[index2] - 3].wall = (ushort) wallType;
            WorldGen.PlaceTile(numArray2[index1], numArray4[index2] - 1, 10, true, false, -1, style1);
          }
        }
      }
      for (int index1 = 0; index1 < 5; ++index1)
      {
        for (int index2 = 0; index2 < 10; ++index2)
        {
          if (flagArray1[index1, index2])
          {
            if (index2 > 0 && flagArray1[index1, index2 - 1])
            {
              int num3 = WorldGen.genRand.Next(numArray1[index1] + 2, numArray2[index1] - 1);
              int num6 = WorldGen.genRand.Next(numArray1[index1] + 2, numArray2[index1] - 1);
              int num7 = 0;
              while (num6 - num3 < 2 || num6 - num3 > 5)
              {
                num3 = WorldGen.genRand.Next(numArray1[index1] + 2, numArray2[index1] - 1);
                num6 = WorldGen.genRand.Next(numArray1[index1] + 2, numArray2[index1] - 1);
                ++num7;
                if (num7 > 10000)
                  break;
              }
              if (num7 <= 10000)
              {
                for (int i1 = num3; i1 <= num6 && (i1 >= 20 && i1 <= Main.maxTilesX - 20); ++i1)
                {
                  Main.tile[i1, numArray3[index2]].active(false);
                  WorldGen.PlaceTile(i1, numArray3[index2], 19, true, true, -1, style2);
                  Main.tile[i1, numArray3[index2]].wall = (ushort) wallType;
                }
              }
              else
                break;
            }
            if (index1 < 4 && flagArray1[index1 + 1, index2] && WorldGen.genRand.Next(3) == 0)
            {
              Main.tile[numArray2[index1], numArray4[index2] - 1].active(false);
              Main.tile[numArray2[index1], numArray4[index2] - 2].active(false);
              Main.tile[numArray2[index1], numArray4[index2] - 3].active(false);
              Main.tile[numArray2[index1], numArray4[index2] - 1].wall = (ushort) wallType;
              Main.tile[numArray2[index1], numArray4[index2] - 2].wall = (ushort) wallType;
              Main.tile[numArray2[index1], numArray4[index2] - 3].wall = (ushort) wallType;
              WorldGen.PlaceTile(numArray2[index1], numArray4[index2] - 1, 10, true, false, -1, style1);
            }
          }
        }
      }
      bool flag4 = false;
      for (int index1 = 0; index1 < 5; ++index1)
      {
        bool[] flagArray2 = new bool[10];
        for (int index2 = 0; index2 < 10; ++index2)
        {
          if (flagArray1[index1, index2])
          {
            flag4 = true;
            flagArray2[index2] = true;
          }
        }
        if (flag4)
        {
          bool flag3 = false;
          for (int index2 = 0; index2 < 10; ++index2)
          {
            if (flagArray2[index2])
            {
              if (!Main.tile[numArray1[index1] - 1, numArray4[index2] - 1].active() && !Main.tile[numArray1[index1] - 1, numArray4[index2] - 2].active() && (!Main.tile[numArray1[index1] - 1, numArray4[index2] - 3].active() && Main.tile[numArray1[index1] - 1, numArray4[index2] - 1].liquid == (byte) 0) && (Main.tile[numArray1[index1] - 1, numArray4[index2] - 2].liquid == (byte) 0 && Main.tile[numArray1[index1] - 1, numArray4[index2] - 3].liquid == (byte) 0))
                flag3 = true;
              else
                flagArray2[index2] = false;
            }
          }
          while (flag3)
          {
            int index2 = WorldGen.genRand.Next(10);
            if (flagArray2[index2])
            {
              flag3 = false;
              Main.tile[numArray1[index1], numArray4[index2] - 1].active(false);
              Main.tile[numArray1[index1], numArray4[index2] - 2].active(false);
              Main.tile[numArray1[index1], numArray4[index2] - 3].active(false);
              WorldGen.PlaceTile(numArray1[index1], numArray4[index2] - 1, 10, true, false, -1, style1);
            }
          }
          break;
        }
      }
      bool flag5 = false;
      for (int index1 = 4; index1 >= 0; --index1)
      {
        bool[] flagArray2 = new bool[10];
        for (int index2 = 0; index2 < 10; ++index2)
        {
          if (flagArray1[index1, index2])
          {
            flag5 = true;
            flagArray2[index2] = true;
          }
        }
        if (flag5)
        {
          bool flag3 = false;
          for (int index2 = 0; index2 < 10; ++index2)
          {
            if (flagArray2[index2])
            {
              if (index1 >= 20 && index1 <= Main.maxTilesX - 20)
              {
                if (!Main.tile[numArray2[index1] + 1, numArray4[index2] - 1].active() && !Main.tile[numArray2[index1] + 1, numArray4[index2] - 2].active() && (!Main.tile[numArray2[index1] + 1, numArray4[index2] - 3].active() && Main.tile[numArray2[index1] + 1, numArray4[index2] - 1].liquid == (byte) 0) && (Main.tile[numArray2[index1] + 1, numArray4[index2] - 2].liquid == (byte) 0 && Main.tile[numArray2[index1] + 1, numArray4[index2] - 3].liquid == (byte) 0))
                  flag3 = true;
                else
                  flagArray2[index2] = false;
              }
              else
                break;
            }
          }
          while (flag3)
          {
            int index2 = WorldGen.genRand.Next(10);
            if (flagArray2[index2])
            {
              flag3 = false;
              Main.tile[numArray2[index1], numArray4[index2] - 1].active(false);
              Main.tile[numArray2[index1], numArray4[index2] - 2].active(false);
              Main.tile[numArray2[index1], numArray4[index2] - 3].active(false);
              WorldGen.PlaceTile(numArray2[index1], numArray4[index2] - 1, 10, true, false, -1, style1);
            }
          }
          break;
        }
      }
      bool flag6 = false;
      for (int index1 = 0; index1 < 10; ++index1)
      {
        bool[] flagArray2 = new bool[10];
        for (int index2 = 0; index2 < 5; ++index2)
        {
          if (flagArray1[index2, index1])
          {
            flag6 = true;
            flagArray2[index2] = true;
          }
        }
        if (flag6)
        {
          bool flag3 = true;
          while (flag3)
          {
            int index2 = WorldGen.genRand.Next(5);
            if (flagArray2[index2])
            {
              int num3 = WorldGen.genRand.Next(numArray1[index2] + 2, numArray2[index2] - 1);
              int num6 = WorldGen.genRand.Next(numArray1[index2] + 2, numArray2[index2] - 1);
              int num7 = 0;
              while (num6 - num3 < 2 || num6 - num3 > 5)
              {
                num3 = WorldGen.genRand.Next(numArray1[index2] + 2, numArray2[index2] - 1);
                num6 = WorldGen.genRand.Next(numArray1[index2] + 2, numArray2[index2] - 1);
                ++num7;
                if (num7 > 10000)
                  break;
              }
              if (num7 > 10000)
                break;
              for (int index3 = num3; index3 <= num6 && (index3 >= 10 && index3 <= Main.maxTilesX - 10); ++index3)
              {
                if (Main.tile[index3, numArray3[index1] - 1].active() || Main.tile[index3, numArray3[index1] - 1].liquid > (byte) 0)
                  flag3 = false;
              }
              if (flag3)
              {
                for (int i1 = num3; i1 <= num6 && (i1 >= 10 && i1 <= Main.maxTilesX - 10); ++i1)
                {
                  Main.tile[i1, numArray3[index1]].active(false);
                  WorldGen.PlaceTile(i1, numArray3[index1], 19, true, true, -1, style2);
                }
              }
              flag3 = false;
            }
          }
          break;
        }
      }
    }

    public static void HellHouse(int i, int j, byte type = 76, byte wall = 13)
    {
      int width = WorldGen.genRand.Next(8, 20);
      int num1 = WorldGen.genRand.Next(1, 3);
      int num2 = WorldGen.genRand.Next(4, 13);
      int i1 = i;
      int j1 = j;
      for (int index = 0; index < num1; ++index)
      {
        int height = WorldGen.genRand.Next(5, 9);
        WorldGen.HellRoom(i1, j1, width, height, type, wall);
        j1 -= height;
      }
      int j2 = j;
      for (int index = 0; index < num2; ++index)
      {
        int height = WorldGen.genRand.Next(5, 9);
        j2 += height;
        WorldGen.HellRoom(i1, j2, width, height, type, wall);
      }
      for (int index1 = i - width / 2; index1 <= i + width / 2; ++index1)
      {
        int index2 = j;
        while (index2 < Main.maxTilesY && (Main.tile[index1, index2].active() && (Main.tile[index1, index2].type == (ushort) 76 || Main.tile[index1, index2].type == (ushort) 75) || (Main.tile[i, index2].wall == (ushort) 13 || Main.tile[i, index2].wall == (ushort) 14)))
          ++index2;
        int num3 = 6 + WorldGen.genRand.Next(3);
        while (index2 < Main.maxTilesY && !Main.tile[index1, index2].active())
        {
          --num3;
          Main.tile[index1, index2].active(true);
          Main.tile[index1, index2].type = (ushort) 57;
          ++index2;
          if (num3 <= 0)
            break;
        }
      }
      int index3 = j;
      while (index3 < Main.maxTilesY && (Main.tile[i, index3].active() && (Main.tile[i, index3].type == (ushort) 76 || Main.tile[i, index3].type == (ushort) 75) || (Main.tile[i, index3].wall == (ushort) 13 || Main.tile[i, index3].wall == (ushort) 14)))
        ++index3;
      int index4 = index3 - 1;
      int maxValue = index4;
      while (Main.tile[i, index4].active() && (Main.tile[i, index4].type == (ushort) 76 || Main.tile[i, index4].type == (ushort) 75) || (Main.tile[i, index4].wall == (ushort) 13 || Main.tile[i, index4].wall == (ushort) 14))
      {
        --index4;
        if (Main.tile[i, index4].active() && (Main.tile[i, index4].type == (ushort) 76 || Main.tile[i, index4].type == (ushort) 75))
        {
          int num3 = WorldGen.genRand.Next(i - width / 2 + 1, i + width / 2 - 1);
          int num4 = WorldGen.genRand.Next(i - width / 2 + 1, i + width / 2 - 1);
          if (num3 > num4)
          {
            int num5 = num3;
            num3 = num4;
            num4 = num5;
          }
          if (num3 == num4)
          {
            if (num3 < i)
              ++num4;
            else
              --num3;
          }
          for (int index1 = num3; index1 <= num4; ++index1)
          {
            if (Main.tile[index1, index4 - 1].wall == (ushort) 13)
              Main.tile[index1, index4].wall = (ushort) 13;
            if (Main.tile[index1, index4 - 1].wall == (ushort) 14)
              Main.tile[index1, index4].wall = (ushort) 14;
            Main.tile[index1, index4].type = (ushort) 19;
            Main.tile[index1, index4].active(true);
          }
          --index4;
        }
      }
      int minValue = index4;
      float num6 = (float) ((maxValue - minValue) * width) * 0.02f;
      for (int index1 = 0; (double) index1 < (double) num6; ++index1)
      {
        int num3 = WorldGen.genRand.Next(i - width / 2, i + width / 2 + 1);
        int num4 = WorldGen.genRand.Next(minValue, maxValue);
        int num5 = WorldGen.genRand.Next(3, 8);
        for (int index2 = num3 - num5; index2 <= num3 + num5; ++index2)
        {
          for (int index5 = num4 - num5; index5 <= num4 + num5; ++index5)
          {
            double num7 = (double) Math.Abs(index2 - num3);
            float num8 = (float) Math.Abs(index5 - num4);
            if (Math.Sqrt(num7 * num7 + (double) num8 * (double) num8) < (double) num5 * 0.4)
            {
              try
              {
                if (Main.tile[index2, index5].type == (ushort) 76 || Main.tile[index2, index5].type == (ushort) 19)
                  Main.tile[index2, index5].active(false);
                Main.tile[index2, index5].wall = (ushort) 0;
              }
              catch
              {
              }
            }
          }
        }
      }
    }

    public static void HellRoom(int i, int j, int width, int height, byte type = 76, byte wall = 13)
    {
      if (j > Main.maxTilesY - 40)
        return;
      for (int index1 = i - width / 2; index1 <= i + width / 2; ++index1)
      {
        for (int index2 = j - height; index2 <= j; ++index2)
        {
          try
          {
            Main.tile[index1, index2].active(true);
            Main.tile[index1, index2].type = (ushort) type;
            Main.tile[index1, index2].liquid = (byte) 0;
            Main.tile[index1, index2].lava(false);
          }
          catch
          {
          }
        }
      }
      for (int index1 = i - width / 2 + 1; index1 <= i + width / 2 - 1; ++index1)
      {
        for (int index2 = j - height + 1; index2 <= j - 1; ++index2)
        {
          try
          {
            Main.tile[index1, index2].active(false);
            Main.tile[index1, index2].wall = (ushort) wall;
            Main.tile[index1, index2].liquid = (byte) 0;
            Main.tile[index1, index2].lava(false);
          }
          catch
          {
          }
        }
      }
    }

    public static void templeCleaner(int x, int y)
    {
      int index1 = x;
      int index2 = y;
      int num = 0;
      if (Main.tile[x + 1, y].active() && Main.tile[x + 1, y].type == (ushort) 226)
        ++num;
      if (Main.tile[x - 1, y].active() && Main.tile[x - 1, y].type == (ushort) 226)
        ++num;
      if (Main.tile[x, y + 1].active() && Main.tile[x, y + 1].type == (ushort) 226)
        ++num;
      if (Main.tile[x, y - 1].active() && Main.tile[x, y - 1].type == (ushort) 226)
        ++num;
      if (Main.tile[x, y].active() && Main.tile[x, y].type == (ushort) 226)
      {
        if (num > 1)
          return;
        Main.tile[index1, index2].active(false);
        Main.tile[index1, index2].wall = (ushort) 87;
      }
      else
      {
        if (Main.tile[x, y].active() || num != 3)
          return;
        Main.tile[index1, index2].active(true);
        Main.tile[index1, index2].type = (ushort) 226;
        Main.tile[index1, index2].liquid = (byte) 0;
        Main.tile[index1, index2].slope((byte) 0);
        Main.tile[index1, index2].halfBrick(false);
      }
    }

    public static Vector2 templePather(Vector2 templePath, int destX, int destY)
    {
      int x = (int) templePath.X;
      int y = (int) templePath.Y;
      int num1 = WorldGen.genRand.Next(5, 20);
      int num2 = WorldGen.genRand.Next(2, 5);
      while (num1 > 0 && (x != destX || y != destY))
      {
        --num1;
        if (x > destX)
          --x;
        if (x < destX)
          ++x;
        if (y > destY)
          --y;
        if (y < destY)
          ++y;
        for (int index1 = x - num2; index1 < x + num2; ++index1)
        {
          for (int index2 = y - num2; index2 < y + num2; ++index2)
          {
            Main.tile[index1, index2].active(false);
            Main.tile[index1, index2].wall = (ushort) 87;
          }
        }
      }
      return new Vector2((float) x, (float) y);
    }

    public static void outerTempled(int x, int y)
    {
      if (Main.tile[x, y].active() & Main.tile[x, y].type == (ushort) 226 || Main.tile[x, y].wall == (ushort) 87)
        return;
      int num = 6;
      for (int index1 = x - num; index1 <= x + num; ++index1)
      {
        for (int index2 = y - num; index2 <= y + num; ++index2)
        {
          if (!Main.tile[index1, index2].active() && Main.tile[index1, index2].wall == (ushort) 87)
          {
            int index3 = x;
            int index4 = y;
            Main.tile[index3, index4].active(true);
            Main.tile[index3, index4].type = (ushort) 226;
            Main.tile[index3, index4].liquid = (byte) 0;
            Main.tile[index3, index4].slope((byte) 0);
            Main.tile[index3, index4].halfBrick(false);
            return;
          }
        }
      }
    }

    public static void makeTemple(int x, int y)
    {
      Microsoft.Xna.Framework.Rectangle[] rectangleArray = new Microsoft.Xna.Framework.Rectangle[100];
      float num1 = (float) (Main.maxTilesX / 4200);
      int maxValue = WorldGen.genRand.Next((int) ((double) num1 * 10.0), (int) ((double) num1 * 16.0));
      if (WorldGen.drunkWorldGen)
        maxValue *= 3;
      if (WorldGen.getGoodWorldGen)
        maxValue *= 3;
      int num2 = 1;
      if (WorldGen.genRand.Next(2) == 0)
        num2 = -1;
      int num3 = num2;
      int num4 = x;
      int num5 = y;
      int num6 = x;
      int num7 = y;
      int num8 = WorldGen.genRand.Next(1, 3);
      int num9 = 0;
      for (int index1 = 0; index1 < maxValue; ++index1)
      {
        ++num9;
        int num10 = num2;
        int num11 = num6;
        int num12 = num7;
        bool flag = true;
        int width1 = 0;
        int height1 = 0;
        int num13 = -10;
        Microsoft.Xna.Framework.Rectangle rectangle = new Microsoft.Xna.Framework.Rectangle(num11 - width1 / 2, num12 - height1 / 2, width1, height1);
        while (flag)
        {
          int num14 = num6;
          int num15 = num7;
          int width2 = WorldGen.genRand.Next(25, 50);
          int height2 = WorldGen.genRand.Next(20, 35);
          if (height2 > width2)
            height2 = width2;
          if (index1 == maxValue - 1)
          {
            int num16 = WorldGen.genRand.Next(55, 65);
            int num17 = WorldGen.genRand.Next(45, 50);
            if (num17 > num16)
              num17 = num16;
            width2 = (int) ((double) num16 * 1.6);
            height2 = (int) ((double) num17 * 1.35);
            num15 += WorldGen.genRand.Next(5, 10);
          }
          if (num9 > num8)
          {
            num12 = num15 + (WorldGen.genRand.Next(height2 + 1, height2 + 3) + num13);
            num11 = num14 + WorldGen.genRand.Next(-5, 6);
            num10 = num2 * -1;
          }
          else
          {
            num11 = num14 + (WorldGen.genRand.Next(width2 + 1, width2 + 3) + num13) * num10;
            num12 = num15 + WorldGen.genRand.Next(-5, 6);
          }
          flag = false;
          rectangle = new Microsoft.Xna.Framework.Rectangle(num11 - width2 / 2, num12 - height2 / 2, width2, height2);
          for (int index2 = 0; index2 < index1; ++index2)
          {
            if (rectangle.Intersects(rectangleArray[index2]))
              flag = true;
            if (WorldGen.genRand.Next(100) == 0)
              ++num13;
          }
        }
        if (num9 > num8)
        {
          ++num8;
          num9 = 1;
        }
        rectangleArray[index1] = rectangle;
        num2 = num10;
        num6 = num11;
        num7 = num12;
      }
      for (int index1 = 0; index1 < maxValue; ++index1)
      {
        for (int index2 = 0; index2 < 2; ++index2)
        {
          for (int index3 = 0; index3 < maxValue; ++index3)
          {
            for (int index4 = 0; index4 < 2; ++index4)
            {
              int x1 = rectangleArray[index1].X;
              if (index2 == 1)
                x1 += rectangleArray[index1].Width - 1;
              int y1 = rectangleArray[index1].Y;
              int num10 = y1 + rectangleArray[index1].Height;
              int x2 = rectangleArray[index3].X;
              if (index4 == 1)
                x2 += rectangleArray[index3].Width - 1;
              int y2 = rectangleArray[index3].Y;
              int num11 = y2 + rectangleArray[index3].Height;
              while (x1 != x2 || y1 != y2 || num10 != num11)
              {
                if (x1 < x2)
                  ++x1;
                if (x1 > x2)
                  --x1;
                if (y1 < y2)
                  ++y1;
                if (y1 > y2)
                  --y1;
                if (num10 < num11)
                  ++num10;
                if (num10 > num11)
                  --num10;
                int index5 = x1;
                for (int index6 = y1; index6 < num10; ++index6)
                {
                  Main.tile[index5, index6].active(true);
                  Main.tile[index5, index6].type = (ushort) 226;
                  Main.tile[index5, index6].liquid = (byte) 0;
                  Main.tile[index5, index6].slope((byte) 0);
                  Main.tile[index5, index6].halfBrick(false);
                }
              }
            }
          }
        }
      }
      for (int index1 = 0; index1 < maxValue; ++index1)
      {
        if (true)
        {
          for (int x1 = rectangleArray[index1].X; x1 < rectangleArray[index1].X + rectangleArray[index1].Width; ++x1)
          {
            for (int y1 = rectangleArray[index1].Y; y1 < rectangleArray[index1].Y + rectangleArray[index1].Height; ++y1)
            {
              Main.tile[x1, y1].active(true);
              Main.tile[x1, y1].type = (ushort) 226;
              Main.tile[x1, y1].liquid = (byte) 0;
              Main.tile[x1, y1].slope((byte) 0);
              Main.tile[x1, y1].halfBrick(false);
            }
          }
          int x2 = rectangleArray[index1].X;
          int num10 = x2 + rectangleArray[index1].Width;
          int y2 = rectangleArray[index1].Y;
          int num11 = y2 + rectangleArray[index1].Height;
          int num12 = x2 + WorldGen.genRand.Next(3, 8);
          int num13 = num10 - WorldGen.genRand.Next(3, 8);
          int num14 = y2 + WorldGen.genRand.Next(3, 8);
          int num15 = num11 - WorldGen.genRand.Next(3, 8);
          int num16 = num12;
          int num17 = num13;
          int num18 = num14;
          int num19 = num15;
          int num20 = (num12 + num13) / 2;
          int num21 = (num14 + num15) / 2;
          for (int index2 = num12; index2 < num13; ++index2)
          {
            for (int index3 = num14; index3 < num15; ++index3)
            {
              if (WorldGen.genRand.Next(20) == 0)
                num18 += WorldGen.genRand.Next(-1, 2);
              if (WorldGen.genRand.Next(20) == 0)
                num19 += WorldGen.genRand.Next(-1, 2);
              if (WorldGen.genRand.Next(20) == 0)
                num16 += WorldGen.genRand.Next(-1, 2);
              if (WorldGen.genRand.Next(20) == 0)
                num17 += WorldGen.genRand.Next(-1, 2);
              if (num16 < num12)
                num16 = num12;
              if (num17 > num13)
                num17 = num13;
              if (num18 < num14)
                num18 = num14;
              if (num19 > num15)
                num19 = num15;
              if (num16 > num20)
                num16 = num20;
              if (num17 < num20)
                num17 = num20;
              if (num18 > num21)
                num18 = num21;
              if (num19 < num21)
                num19 = num21;
              if (index2 >= num16 && index2 < num17 & index3 >= num18 && index3 <= num19)
              {
                Main.tile[index2, index3].active(false);
                Main.tile[index2, index3].wall = (ushort) 87;
              }
            }
          }
          for (int index2 = num15; index2 > num14; --index2)
          {
            for (int index3 = num13; index3 > num12; --index3)
            {
              if (WorldGen.genRand.Next(20) == 0)
                num18 += WorldGen.genRand.Next(-1, 2);
              if (WorldGen.genRand.Next(20) == 0)
                num19 += WorldGen.genRand.Next(-1, 2);
              if (WorldGen.genRand.Next(20) == 0)
                num16 += WorldGen.genRand.Next(-1, 2);
              if (WorldGen.genRand.Next(20) == 0)
                num17 += WorldGen.genRand.Next(-1, 2);
              if (num16 < num12)
                num16 = num12;
              if (num17 > num13)
                num17 = num13;
              if (num18 < num14)
                num18 = num14;
              if (num19 > num15)
                num19 = num15;
              if (num16 > num20)
                num16 = num20;
              if (num17 < num20)
                num17 = num20;
              if (num18 > num21)
                num18 = num21;
              if (num19 < num21)
                num19 = num21;
              if (index3 >= num16 && index3 < num17 & index2 >= num18 && index2 <= num19)
              {
                Main.tile[index3, index2].active(false);
                Main.tile[index3, index2].wall = (ushort) 87;
              }
            }
          }
        }
      }
      Vector2 templePath = new Vector2((float) num4, (float) num5);
      for (int index1 = 0; index1 < maxValue; ++index1)
      {
        Microsoft.Xna.Framework.Rectangle rectangle = rectangleArray[index1];
        rectangle.X += 8;
        rectangle.Y += 8;
        rectangle.Width -= 16;
        rectangle.Height -= 16;
        bool flag1 = true;
        while (flag1)
        {
          int destX = WorldGen.genRand.Next(rectangle.X, rectangle.X + rectangle.Width);
          int destY = WorldGen.genRand.Next(rectangle.Y, rectangle.Y + rectangle.Height);
          if (index1 == maxValue - 1)
          {
            destX = rectangle.X + rectangle.Width / 2 + WorldGen.genRand.Next(-10, 10);
            destY = rectangle.Y + rectangle.Height / 2 + WorldGen.genRand.Next(-10, 10);
          }
          templePath = WorldGen.templePather(templePath, destX, destY);
          if ((double) templePath.X == (double) destX && (double) templePath.Y == (double) destY)
            flag1 = false;
        }
        if (index1 < maxValue - 1)
        {
          if (WorldGen.genRand.Next(3) != 0)
          {
            int index2 = index1 + 1;
            if (rectangleArray[index2].Y >= rectangleArray[index1].Y + rectangleArray[index1].Height)
            {
              rectangle.X = rectangleArray[index2].X;
              if (index1 == 0)
              {
                if (num2 > 0)
                  rectangle.X += (int) ((double) rectangleArray[index2].Width * 0.8);
                else
                  rectangle.X += (int) ((double) rectangleArray[index2].Width * 0.2);
              }
              else if (rectangleArray[index2].X < rectangleArray[index1].X)
                rectangle.X += (int) ((double) rectangleArray[index2].Width * 0.2);
              else
                rectangle.X += (int) ((double) rectangleArray[index2].Width * 0.8);
              rectangle.Y = rectangleArray[index2].Y;
            }
            else
            {
              rectangle.X = (rectangleArray[index1].X + rectangleArray[index1].Width / 2 + rectangleArray[index2].X + rectangleArray[index2].Width / 2) / 2;
              rectangle.Y = (int) ((double) rectangleArray[index2].Y + (double) rectangleArray[index2].Height * 0.8);
            }
            int x1 = rectangle.X;
            int y1 = rectangle.Y;
            bool flag2 = true;
            while (flag2)
            {
              int destX = WorldGen.genRand.Next(x1 - 6, x1 + 7);
              int destY = WorldGen.genRand.Next(y1 - 6, y1 + 7);
              templePath = WorldGen.templePather(templePath, destX, destY);
              if ((double) templePath.X == (double) destX && (double) templePath.Y == (double) destY)
                flag2 = false;
            }
          }
          else
          {
            int index2 = index1 + 1;
            int num10 = (rectangleArray[index1].X + rectangleArray[index1].Width / 2 + rectangleArray[index2].X + rectangleArray[index2].Width / 2) / 2;
            int num11 = (rectangleArray[index1].Y + rectangleArray[index1].Height / 2 + rectangleArray[index2].Y + rectangleArray[index2].Height / 2) / 2;
            bool flag2 = true;
            while (flag2)
            {
              int destX = WorldGen.genRand.Next(num10 - 6, num10 + 7);
              int destY = WorldGen.genRand.Next(num11 - 6, num11 + 7);
              templePath = WorldGen.templePather(templePath, destX, destY);
              if ((double) templePath.X == (double) destX && (double) templePath.Y == (double) destY)
                flag2 = false;
            }
          }
        }
      }
      int num22 = Main.maxTilesX - 20;
      int num23 = 20;
      int num24 = Main.maxTilesY - 20;
      int num25 = 20;
      for (int index = 0; index < maxValue; ++index)
      {
        if (rectangleArray[index].X < num22)
          num22 = rectangleArray[index].X;
        if (rectangleArray[index].X + rectangleArray[index].Width > num23)
          num23 = rectangleArray[index].X + rectangleArray[index].Width;
        if (rectangleArray[index].Y < num24)
          num24 = rectangleArray[index].Y;
        if (rectangleArray[index].Y + rectangleArray[index].Height > num25)
          num25 = rectangleArray[index].Y + rectangleArray[index].Height;
      }
      int num26 = num22 - 10;
      int num27 = num23 + 10;
      int num28 = num24 - 10;
      int num29 = num25 + 10;
      for (int x1 = num26; x1 < num27; ++x1)
      {
        for (int y1 = num28; y1 < num29; ++y1)
          WorldGen.outerTempled(x1, y1);
      }
      for (int x1 = num27; x1 >= num26; --x1)
      {
        for (int y1 = num28; y1 < num29 / 2; ++y1)
          WorldGen.outerTempled(x1, y1);
      }
      for (int y1 = num28; y1 < num29; ++y1)
      {
        for (int x1 = num26; x1 < num27; ++x1)
          WorldGen.outerTempled(x1, y1);
      }
      for (int y1 = num29; y1 >= num28; --y1)
      {
        for (int x1 = num26; x1 < num27; ++x1)
          WorldGen.outerTempled(x1, y1);
      }
      int num30 = -num3;
      Vector2 vector2 = new Vector2((float) num4, (float) num5);
      int num31 = WorldGen.genRand.Next(2, 5);
      bool flag3 = true;
      int num32 = 0;
      int num33 = WorldGen.genRand.Next(9, 14);
      while (flag3)
      {
        ++num32;
        if (num32 >= num33)
        {
          num32 = 0;
          --vector2.Y;
        }
        vector2.X += (float) num30;
        int x1 = (int) vector2.X;
        flag3 = false;
        for (int index = (int) vector2.Y - num31; (double) index < (double) vector2.Y + (double) num31; ++index)
        {
          if (Main.tile[x1, index].wall == (ushort) 87 || Main.tile[x1, index].active() && Main.tile[x1, index].type == (ushort) 226)
            flag3 = true;
          if (Main.tile[x1, index].active() && Main.tile[x1, index].type == (ushort) 226)
          {
            Main.tile[x1, index].active(false);
            Main.tile[x1, index].wall = (ushort) 87;
          }
        }
      }
      int i1 = num4;
      int index7 = num5;
      while (!Main.tile[i1, index7].active())
        ++index7;
      int j1 = index7 - 4;
      int index8 = j1;
      while (Main.tile[i1, index8].active() && Main.tile[i1, index8].type == (ushort) 226 || Main.tile[i1, index8].wall == (ushort) 87)
        --index8;
      int num34 = index8 + 2;
      for (int index1 = i1 - 1; index1 <= i1 + 1; ++index1)
      {
        for (int index2 = num34; index2 <= j1; ++index2)
        {
          Main.tile[index1, index2].active(true);
          Main.tile[index1, index2].type = (ushort) 226;
          Main.tile[index1, index2].liquid = (byte) 0;
          Main.tile[index1, index2].slope((byte) 0);
          Main.tile[index1, index2].halfBrick(false);
        }
      }
      for (int index1 = i1 - 4; index1 <= i1 + 4; ++index1)
      {
        for (int index2 = j1 - 1; index2 < j1 + 3; ++index2)
        {
          Main.tile[index1, index2].active(false);
          Main.tile[index1, index2].wall = (ushort) 87;
        }
      }
      for (int index1 = i1 - 1; index1 <= i1 + 1; ++index1)
      {
        for (int index2 = j1 - 5; index2 <= j1 + 8; ++index2)
        {
          Main.tile[index1, index2].active(true);
          Main.tile[index1, index2].type = (ushort) 226;
          Main.tile[index1, index2].liquid = (byte) 0;
          Main.tile[index1, index2].slope((byte) 0);
          Main.tile[index1, index2].halfBrick(false);
        }
      }
      for (int index1 = i1 - 3; index1 <= i1 + 3; ++index1)
      {
        for (int index2 = j1 - 2; index2 < j1 + 3; ++index2)
        {
          if (index2 >= j1 || index1 < num4 - 1 || index1 > num4 + 1)
          {
            Main.tile[index1, index2].active(false);
            Main.tile[index1, index2].wall = (ushort) 87;
          }
        }
      }
      WorldGen.PlaceTile(i1, j1, 10, true, false, -1, 11);
      for (int x1 = num26; x1 < num27; ++x1)
      {
        for (int y1 = num28; y1 < num29; ++y1)
          WorldGen.templeCleaner(x1, y1);
      }
      for (int y1 = num29; y1 >= num28; --y1)
      {
        for (int x1 = num27; x1 >= num26; --x1)
          WorldGen.templeCleaner(x1, y1);
      }
      for (int index1 = num26; index1 < num27; ++index1)
      {
        for (int index2 = num28; index2 < num29; ++index2)
        {
          bool flag1 = true;
          for (int index3 = index1 - 1; index3 <= index1 + 1; ++index3)
          {
            for (int index4 = index2 - 1; index4 <= index2 + 1; ++index4)
            {
              if ((!Main.tile[index3, index4].active() || Main.tile[index3, index4].type != (ushort) 226) && Main.tile[index3, index4].wall != (ushort) 87)
              {
                flag1 = false;
                break;
              }
            }
          }
          if (flag1)
            Main.tile[index1, index2].wall = (ushort) 87;
        }
      }
      int num35 = 0;
      Microsoft.Xna.Framework.Rectangle rectangle1 = rectangleArray[maxValue - 1];
      int num36 = rectangle1.Width / 2;
      int num37 = rectangle1.Height / 2;
      do
      {
        ++num35;
        int i2 = rectangle1.X + num36 + 15 - WorldGen.genRand.Next(30);
        int j2 = rectangle1.Y + num37 + 15 - WorldGen.genRand.Next(30);
        WorldGen.PlaceTile(i2, j2, 237, false, false, -1, 0);
        if (Main.tile[i2, j2].type == (ushort) 237)
        {
          WorldGen.lAltarX = i2 - (int) Main.tile[i2, j2].frameX / 18;
          WorldGen.lAltarY = j2 - (int) Main.tile[i2, j2].frameY / 18;
          goto label_296;
        }
      }
      while (num35 < 1000);
      int num38 = rectangle1.X + num36;
      int num39 = rectangle1.Y + num37;
      int index9 = num38 + WorldGen.genRand.Next(-10, 11);
      int index10 = num39 + WorldGen.genRand.Next(-10, 11);
      while (!Main.tile[index9, index10].active())
        ++index10;
      Main.tile[index9 - 1, index10].active(true);
      Main.tile[index9 - 1, index10].slope((byte) 0);
      Main.tile[index9 - 1, index10].halfBrick(false);
      Main.tile[index9 - 1, index10].type = (ushort) 226;
      Main.tile[index9, index10].active(true);
      Main.tile[index9, index10].slope((byte) 0);
      Main.tile[index9, index10].halfBrick(false);
      Main.tile[index9, index10].type = (ushort) 226;
      Main.tile[index9 + 1, index10].active(true);
      Main.tile[index9 + 1, index10].slope((byte) 0);
      Main.tile[index9 + 1, index10].halfBrick(false);
      Main.tile[index9 + 1, index10].type = (ushort) 226;
      int num40 = index10 - 2;
      int num41 = index9 - 1;
      for (int index1 = -1; index1 <= 3; ++index1)
      {
        for (int index2 = -1; index2 <= 1; ++index2)
        {
          x = num41 + index1;
          y = num40 + index2;
          Main.tile[x, y].active(false);
        }
      }
      WorldGen.lAltarX = num41;
      WorldGen.lAltarY = num40;
      for (int index1 = 0; index1 <= 2; ++index1)
      {
        for (int index2 = 0; index2 <= 1; ++index2)
        {
          x = num41 + index1;
          y = num40 + index2;
          Main.tile[x, y].active(true);
          Main.tile[x, y].type = (ushort) 237;
          Main.tile[x, y].frameX = (short) (index1 * 18);
          Main.tile[x, y].frameY = (short) (index2 * 18);
        }
      }
      for (int index1 = 0; index1 <= 2; ++index1)
      {
        for (int index2 = 0; index2 <= 1; ++index2)
        {
          x = num41 + index1;
          y = num40 + index2;
          WorldGen.SquareTileFrame(x, y, true);
        }
      }
label_296:
      float num42 = (float) maxValue * 1.1f * (float) (1.0 + (double) WorldGen.genRand.Next(-25, 26) * 0.00999999977648258);
      if (WorldGen.drunkWorldGen)
        num42 *= 1.5f;
      int num43 = 0;
      while ((double) num42 > 0.0)
      {
        ++num43;
        int index1 = WorldGen.genRand.Next(maxValue);
        int index2 = WorldGen.genRand.Next(rectangleArray[index1].X, rectangleArray[index1].X + rectangleArray[index1].Width);
        int index3 = WorldGen.genRand.Next(rectangleArray[index1].Y, rectangleArray[index1].Y + rectangleArray[index1].Height);
        if (Main.tile[index2, index3].wall == (ushort) 87 && !Main.tile[index2, index3].active())
        {
          bool flag1 = false;
          if (WorldGen.genRand.Next(2) == 0)
          {
            int num10 = 1;
            if (WorldGen.genRand.Next(2) == 0)
              num10 = -1;
            while (!Main.tile[index2, index3].active())
              index3 += num10;
            int num11 = index3 - num10;
            int num12 = WorldGen.genRand.Next(2);
            int num13 = WorldGen.genRand.Next(3, 10);
            bool flag2 = true;
            for (int index4 = index2 - num13; index4 < index2 + num13; ++index4)
            {
              for (int index5 = num11 - num13; index5 < num11 + num13; ++index5)
              {
                if (Main.tile[index4, index5].active() && (Main.tile[index4, index5].type == (ushort) 10 || Main.tile[index4, index5].type == (ushort) 237))
                {
                  flag2 = false;
                  break;
                }
              }
            }
            if (flag2)
            {
              for (int i2 = index2 - num13; i2 < index2 + num13; ++i2)
              {
                for (int j2 = num11 - num13; j2 < num11 + num13; ++j2)
                {
                  if (WorldGen.SolidTile(i2, j2, false) && Main.tile[i2, j2].type != (ushort) 232 && !WorldGen.SolidTile(i2, j2 - num10, false))
                  {
                    Main.tile[i2, j2].type = (ushort) 232;
                    flag1 = true;
                    if (num12 == 0)
                    {
                      Main.tile[i2, j2 - 1].type = (ushort) 232;
                      Main.tile[i2, j2 - 1].active(true);
                      if (WorldGen.drunkWorldGen)
                      {
                        Main.tile[i2, j2 - 2].type = (ushort) 232;
                        Main.tile[i2, j2 - 2].active(true);
                      }
                    }
                    else
                    {
                      Main.tile[i2, j2 + 1].type = (ushort) 232;
                      Main.tile[i2, j2 + 1].active(true);
                      if (WorldGen.drunkWorldGen)
                      {
                        Main.tile[i2, j2 + 2].type = (ushort) 232;
                        Main.tile[i2, j2 + 2].active(true);
                      }
                    }
                    ++num12;
                    if (num12 > 1)
                      num12 = 0;
                  }
                }
              }
            }
            if (flag1)
            {
              num43 = 0;
              --num42;
            }
          }
          else
          {
            int num10 = 1;
            if (WorldGen.genRand.Next(2) == 0)
              num10 = -1;
            while (!Main.tile[index2, index3].active())
              index2 += num10;
            int num11 = index2 - num10;
            int num12 = WorldGen.genRand.Next(2);
            int num13 = WorldGen.genRand.Next(3, 10);
            bool flag2 = true;
            for (int index4 = num11 - num13; index4 < num11 + num13; ++index4)
            {
              for (int index5 = index3 - num13; index5 < index3 + num13; ++index5)
              {
                if (Main.tile[index4, index5].active() && Main.tile[index4, index5].type == (ushort) 10)
                {
                  flag2 = false;
                  break;
                }
              }
            }
            if (flag2)
            {
              for (int i2 = num11 - num13; i2 < num11 + num13; ++i2)
              {
                for (int j2 = index3 - num13; j2 < index3 + num13; ++j2)
                {
                  if (WorldGen.SolidTile(i2, j2, false) && Main.tile[i2, j2].type != (ushort) 232 && !WorldGen.SolidTile(i2 - num10, j2, false))
                  {
                    Main.tile[i2, j2].type = (ushort) 232;
                    flag1 = true;
                    if (num12 == 0)
                    {
                      Main.tile[i2 - 1, j2].type = (ushort) 232;
                      Main.tile[i2 - 1, j2].active(true);
                      if (WorldGen.drunkWorldGen)
                      {
                        Main.tile[i2 - 2, j2].type = (ushort) 232;
                        Main.tile[i2 - 2, j2].active(true);
                      }
                    }
                    else
                    {
                      Main.tile[i2 + 1, j2].type = (ushort) 232;
                      Main.tile[i2 + 1, j2].active(true);
                      if (WorldGen.drunkWorldGen)
                      {
                        Main.tile[i2 - 2, j2].type = (ushort) 232;
                        Main.tile[i2 - 2, j2].active(true);
                      }
                    }
                    ++num12;
                    if (num12 > 1)
                      num12 = 0;
                  }
                }
              }
            }
            if (flag1)
            {
              num43 = 0;
              --num42;
            }
          }
        }
        if (num43 > 1000)
        {
          num43 = 0;
          --num42;
        }
      }
      WorldGen.tLeft = num26;
      WorldGen.tRight = num27;
      WorldGen.tTop = num28;
      WorldGen.tBottom = num29;
      WorldGen.tRooms = maxValue;
    }

    public static void templePart2()
    {
      int tLeft = WorldGen.tLeft;
      int tRight = WorldGen.tRight;
      int tTop = WorldGen.tTop;
      int tBottom = WorldGen.tBottom;
      int tRooms = WorldGen.tRooms;
      float num1 = (float) tRooms * 1.9f * (float) (1.0 + (double) WorldGen.genRand.Next(-15, 16) * 0.00999999977648258);
      int num2 = 0;
      while ((double) num1 > 0.0)
      {
        int x2 = WorldGen.genRand.Next(tLeft, tRight);
        int y2 = WorldGen.genRand.Next(tTop, tBottom);
        if (Main.tile[x2, y2].wall == (ushort) 87 && !Main.tile[x2, y2].active())
        {
          if (WorldGen.mayanTrap(x2, y2))
          {
            --num1;
            num2 = 0;
          }
          else
            ++num2;
        }
        else
          ++num2;
        if (num2 > 100)
        {
          num2 = 0;
          --num1;
        }
      }
      Main.tileSolid[232] = false;
      float num3 = (float) tRooms * 0.35f * (float) (1.0 + (double) WorldGen.genRand.Next(-15, 16) * 0.00999999977648258);
      int contain = 1293;
      int num4 = 0;
      while ((double) num3 > 0.0)
      {
        int i = WorldGen.genRand.Next(tLeft, tRight);
        int j = WorldGen.genRand.Next(tTop, tBottom);
        if (Main.tile[i, j].wall == (ushort) 87 && !Main.tile[i, j].active() && WorldGen.AddBuriedChest(i, j, contain, true, 16, false, (ushort) 0))
        {
          --num3;
          num4 = 0;
        }
        ++num4;
        if (num4 > 10000)
          break;
      }
      float num5 = (float) tRooms * 1.25f * (float) (1.0 + (double) WorldGen.genRand.Next(-25, 36) * 0.00999999977648258);
      int num6 = 0;
      while ((double) num5 > 0.0)
      {
        ++num6;
        int index1 = WorldGen.genRand.Next(tLeft, tRight);
        int index2 = WorldGen.genRand.Next(tTop, tBottom);
        if (Main.tile[index1, index2].wall == (ushort) 87 && !Main.tile[index1, index2].active())
        {
          int i = index1;
          int index3 = index2;
          while (!Main.tile[i, index3].active())
          {
            ++index3;
            if (index3 > tBottom)
              break;
          }
          int j = index3 - 1;
          if (j <= tBottom)
          {
            WorldGen.PlaceTile(i, j, 105, true, false, -1, WorldGen.genRand.Next(43, 46));
            if (Main.tile[i, j].type == (ushort) 105)
              --num5;
          }
        }
      }
      float num7 = (float) tRooms * 1.35f * (float) (1.0 + (double) WorldGen.genRand.Next(-15, 26) * 0.00999999977648258);
      int num8 = 0;
      while ((double) num7 > 0.0)
      {
        ++num8;
        int index1 = WorldGen.genRand.Next(tLeft, tRight);
        int index2 = WorldGen.genRand.Next(tTop, tBottom);
        if (Main.tile[index1, index2].wall == (ushort) 87 && !Main.tile[index1, index2].active())
        {
          int i = index1;
          int index3 = index2;
          while (!Main.tile[i, index3].active())
          {
            ++index3;
            if (index3 > tBottom)
              break;
          }
          int j = index3 - 1;
          if (j <= tBottom)
          {
            switch (WorldGen.genRand.Next(3))
            {
              case 0:
                WorldGen.PlaceTile(i, j, 18, true, false, -1, 10);
                if (Main.tile[i, j].type == (ushort) 18)
                {
                  --num7;
                  break;
                }
                break;
              case 1:
                WorldGen.PlaceTile(i, j, 14, true, false, -1, 9);
                if (Main.tile[i, j].type == (ushort) 14)
                {
                  --num7;
                  break;
                }
                break;
              case 2:
                WorldGen.PlaceTile(i, j, 15, true, false, -1, 12);
                if (Main.tile[i, j].type == (ushort) 15)
                {
                  --num7;
                  break;
                }
                break;
            }
          }
        }
        if (num8 > 10000)
          break;
      }
      Main.tileSolid[232] = true;
    }

    public static bool nearPicture(int x, int y)
    {
      for (int index1 = x - 4; index1 <= x + 3; ++index1)
      {
        for (int index2 = y - 3; index2 <= y + 2; ++index2)
        {
          if (Main.tile[index1, index2].active())
            return true;
        }
      }
      return false;
    }

    public static bool nearPicture2(int x, int y)
    {
      if (Main.tile[x, y].wall != (ushort) 7 && Main.tile[x, y].wall != (ushort) 8 && Main.tile[x, y].wall != (ushort) 9)
      {
        for (int index1 = x - 8; index1 <= x + 8; ++index1)
        {
          for (int index2 = y - 5; index2 <= y + 5; ++index2)
          {
            if (Main.tile[index1, index2].active() && (Main.tile[index1, index2].type == (ushort) 240 || Main.tile[index1, index2].type == (ushort) 241 || Main.tile[index1, index2].type == (ushort) 242))
              return true;
          }
        }
      }
      else
      {
        for (int index1 = x - 15; index1 <= x + 15; ++index1)
        {
          for (int index2 = y - 10; index2 <= y + 10; ++index2)
          {
            if (Main.tile[index1, index2].active() && (Main.tile[index1, index2].type == (ushort) 240 || Main.tile[index1, index2].type == (ushort) 241 || Main.tile[index1, index2].type == (ushort) 242))
              return true;
          }
        }
      }
      return false;
    }

    public static void MakeDungeon(int x, int y)
    {
      WorldGen.dEnteranceX = 0;
      WorldGen.numDRooms = 0;
      WorldGen.numDDoors = 0;
      WorldGen.numDungeonPlatforms = 0;
      int num1 = WorldGen.genRand.Next(3);
      WorldGen.genRand.Next(3);
      ushort tileType;
      int wallType1;
      switch (num1)
      {
        case 0:
          tileType = (ushort) 41;
          wallType1 = 7;
          WorldGen.crackedType = (ushort) 481;
          break;
        case 1:
          tileType = (ushort) 43;
          wallType1 = 8;
          WorldGen.crackedType = (ushort) 482;
          break;
        default:
          tileType = (ushort) 44;
          wallType1 = 9;
          WorldGen.crackedType = (ushort) 483;
          break;
      }
      Main.tileSolid[(int) WorldGen.crackedType] = false;
      WorldGen.dungeonLake = true;
      WorldGen.numDDoors = 0;
      WorldGen.numDungeonPlatforms = 0;
      WorldGen.numDRooms = 0;
      WorldGen.dungeonX = x;
      WorldGen.dungeonY = y;
      WorldGen.dMinX = x;
      WorldGen.dMaxX = x;
      WorldGen.dMinY = y;
      WorldGen.dMaxY = y;
      WorldGen.dxStrength1 = (double) WorldGen.genRand.Next(25, 30);
      WorldGen.dyStrength1 = (double) WorldGen.genRand.Next(20, 25);
      WorldGen.dxStrength2 = (double) WorldGen.genRand.Next(35, 50);
      WorldGen.dyStrength2 = (double) WorldGen.genRand.Next(10, 15);
      float num2 = (float) (Main.maxTilesX / 60);
      float num3 = num2 + (float) WorldGen.genRand.Next(0, (int) ((double) num2 / 3.0));
      float num4 = num3;
      int num5 = 5;
      WorldGen.DungeonRoom(WorldGen.dungeonX, WorldGen.dungeonY, tileType, wallType1);
      while ((double) num3 > 0.0)
      {
        if (WorldGen.dungeonX < WorldGen.dMinX)
          WorldGen.dMinX = WorldGen.dungeonX;
        if (WorldGen.dungeonX > WorldGen.dMaxX)
          WorldGen.dMaxX = WorldGen.dungeonX;
        if (WorldGen.dungeonY > WorldGen.dMaxY)
          WorldGen.dMaxY = WorldGen.dungeonY;
        --num3;
        Main.statusText = Lang.gen[58].Value + " " + (object) (int) (((double) num4 - (double) num3) / (double) num4 * 60.0) + "%";
        if (num5 > 0)
          --num5;
        if (num5 == 0 & WorldGen.genRand.Next(3) == 0)
        {
          num5 = 5;
          if (WorldGen.genRand.Next(2) == 0)
          {
            int dungeonX = WorldGen.dungeonX;
            int dungeonY = WorldGen.dungeonY;
            WorldGen.DungeonHalls(WorldGen.dungeonX, WorldGen.dungeonY, tileType, wallType1, false);
            if (WorldGen.genRand.Next(2) == 0)
              WorldGen.DungeonHalls(WorldGen.dungeonX, WorldGen.dungeonY, tileType, wallType1, false);
            WorldGen.DungeonRoom(WorldGen.dungeonX, WorldGen.dungeonY, tileType, wallType1);
            WorldGen.dungeonX = dungeonX;
            WorldGen.dungeonY = dungeonY;
          }
          else
            WorldGen.DungeonRoom(WorldGen.dungeonX, WorldGen.dungeonY, tileType, wallType1);
        }
        else
          WorldGen.DungeonHalls(WorldGen.dungeonX, WorldGen.dungeonY, tileType, wallType1, false);
      }
      WorldGen.DungeonRoom(WorldGen.dungeonX, WorldGen.dungeonY, tileType, wallType1);
      int num6 = WorldGen.dRoomX[0];
      int num7 = WorldGen.dRoomY[0];
      for (int index = 0; index < WorldGen.numDRooms; ++index)
      {
        if (WorldGen.dRoomY[index] < num7)
        {
          num6 = WorldGen.dRoomX[index];
          num7 = WorldGen.dRoomY[index];
        }
      }
      WorldGen.dungeonX = num6;
      WorldGen.dungeonY = num7;
      WorldGen.dEnteranceX = num6;
      WorldGen.dSurface = false;
      int num8 = 5;
      if (WorldGen.drunkWorldGen)
        WorldGen.dSurface = true;
      while (!WorldGen.dSurface)
      {
        if (num8 > 0)
          --num8;
        if (num8 == 0 && WorldGen.genRand.Next(5) == 0 && (double) WorldGen.dungeonY > Main.worldSurface + 100.0)
        {
          num8 = 10;
          int dungeonX = WorldGen.dungeonX;
          int dungeonY = WorldGen.dungeonY;
          WorldGen.DungeonHalls(WorldGen.dungeonX, WorldGen.dungeonY, tileType, wallType1, true);
          WorldGen.DungeonRoom(WorldGen.dungeonX, WorldGen.dungeonY, tileType, wallType1);
          WorldGen.dungeonX = dungeonX;
          WorldGen.dungeonY = dungeonY;
        }
        WorldGen.DungeonStairs(WorldGen.dungeonX, WorldGen.dungeonY, tileType, wallType1);
      }
      WorldGen.DungeonEnt(WorldGen.dungeonX, WorldGen.dungeonY, tileType, wallType1);
      Main.statusText = Lang.gen[58].Value + " 65%";
      int num9 = Main.maxTilesX * 2;
      int i1;
      int j1;
      int num10;
      int wallType2;
      for (int index = 0; index < num9; index = (!WorldGen.DungeonPitTrap(i1, j1, (ushort) num10, wallType2) ? index + 1 : index + 1500) + 1)
      {
        i1 = WorldGen.genRand.Next(WorldGen.dMinX, WorldGen.dMaxX);
        int minValue = WorldGen.dMinY;
        if ((double) minValue < Main.worldSurface)
          minValue = (int) Main.worldSurface;
        j1 = WorldGen.genRand.Next(minValue, WorldGen.dMaxY);
        num10 = (int) tileType;
        wallType2 = wallType1;
      }
      for (int index1 = 0; index1 < WorldGen.numDRooms; ++index1)
      {
        for (int index2 = WorldGen.dRoomL[index1]; index2 <= WorldGen.dRoomR[index1]; ++index2)
        {
          if (!Main.tile[index2, WorldGen.dRoomT[index1] - 1].active())
          {
            WorldGen.dungeonPlatformX[WorldGen.numDungeonPlatforms] = index2;
            WorldGen.dungeonPlatformY[WorldGen.numDungeonPlatforms] = WorldGen.dRoomT[index1] - 1;
            ++WorldGen.numDungeonPlatforms;
            break;
          }
        }
        for (int index2 = WorldGen.dRoomL[index1]; index2 <= WorldGen.dRoomR[index1]; ++index2)
        {
          if (!Main.tile[index2, WorldGen.dRoomB[index1] + 1].active())
          {
            WorldGen.dungeonPlatformX[WorldGen.numDungeonPlatforms] = index2;
            WorldGen.dungeonPlatformY[WorldGen.numDungeonPlatforms] = WorldGen.dRoomB[index1] + 1;
            ++WorldGen.numDungeonPlatforms;
            break;
          }
        }
        for (int index2 = WorldGen.dRoomT[index1]; index2 <= WorldGen.dRoomB[index1]; ++index2)
        {
          if (!Main.tile[WorldGen.dRoomL[index1] - 1, index2].active())
          {
            WorldGen.DDoorX[WorldGen.numDDoors] = WorldGen.dRoomL[index1] - 1;
            WorldGen.DDoorY[WorldGen.numDDoors] = index2;
            WorldGen.DDoorPos[WorldGen.numDDoors] = -1;
            ++WorldGen.numDDoors;
            break;
          }
        }
        for (int index2 = WorldGen.dRoomT[index1]; index2 <= WorldGen.dRoomB[index1]; ++index2)
        {
          if (!Main.tile[WorldGen.dRoomR[index1] + 1, index2].active())
          {
            WorldGen.DDoorX[WorldGen.numDDoors] = WorldGen.dRoomR[index1] + 1;
            WorldGen.DDoorY[WorldGen.numDDoors] = index2;
            WorldGen.DDoorPos[WorldGen.numDDoors] = 1;
            ++WorldGen.numDDoors;
            break;
          }
        }
      }
      Main.statusText = Lang.gen[58].Value + " 70%";
      int num11 = 0;
      int num12 = 1000;
      int num13 = 0;
      int num14 = Main.maxTilesX / 100;
      if (WorldGen.getGoodWorldGen)
        num14 *= 3;
      while (num13 < num14)
      {
        ++num11;
        int index1 = WorldGen.genRand.Next(WorldGen.dMinX, WorldGen.dMaxX);
        int index2 = WorldGen.genRand.Next((int) Main.worldSurface + 25, WorldGen.dMaxY);
        if (WorldGen.drunkWorldGen)
          index2 = WorldGen.genRand.Next(WorldGen.dungeonY + 25, WorldGen.dMaxY);
        int num15 = index1;
        if ((int) Main.tile[index1, index2].wall == wallType1 && !Main.tile[index1, index2].active())
        {
          int num16 = 1;
          if (WorldGen.genRand.Next(2) == 0)
            num16 = -1;
          while (!Main.tile[index1, index2].active())
            index2 += num16;
          if (Main.tile[index1 - 1, index2].active() && Main.tile[index1 + 1, index2].active() && ((int) Main.tile[index1 - 1, index2].type != (int) WorldGen.crackedType && !Main.tile[index1 - 1, index2 - num16].active()) && !Main.tile[index1 + 1, index2 - num16].active())
          {
            ++num13;
            for (int index3 = WorldGen.genRand.Next(5, 13); Main.tile[index1 - 1, index2].active() && (int) Main.tile[index1 - 1, index2].type != (int) WorldGen.crackedType && (Main.tile[index1, index2 + num16].active() && Main.tile[index1, index2].active()) && (!Main.tile[index1, index2 - num16].active() && index3 > 0); --index3)
            {
              Main.tile[index1, index2].type = (ushort) 48;
              if (!Main.tile[index1 - 1, index2 - num16].active() && !Main.tile[index1 + 1, index2 - num16].active())
              {
                Main.tile[index1, index2 - num16].Clear(TileDataType.Slope);
                Main.tile[index1, index2 - num16].type = (ushort) 48;
                Main.tile[index1, index2 - num16].active(true);
                Main.tile[index1, index2 - num16 * 2].Clear(TileDataType.Slope);
                Main.tile[index1, index2 - num16 * 2].type = (ushort) 48;
                Main.tile[index1, index2 - num16 * 2].active(true);
              }
              --index1;
            }
            int num17 = WorldGen.genRand.Next(5, 13);
            for (int index3 = num15 + 1; Main.tile[index3 + 1, index2].active() && (int) Main.tile[index3 + 1, index2].type != (int) WorldGen.crackedType && (Main.tile[index3, index2 + num16].active() && Main.tile[index3, index2].active()) && (!Main.tile[index3, index2 - num16].active() && num17 > 0); --num17)
            {
              Main.tile[index3, index2].type = (ushort) 48;
              if (!Main.tile[index3 - 1, index2 - num16].active() && !Main.tile[index3 + 1, index2 - num16].active())
              {
                Main.tile[index3, index2 - num16].Clear(TileDataType.Slope);
                Main.tile[index3, index2 - num16].type = (ushort) 48;
                Main.tile[index3, index2 - num16].active(true);
                Main.tile[index3, index2 - num16 * 2].Clear(TileDataType.Slope);
                Main.tile[index3, index2 - num16 * 2].type = (ushort) 48;
                Main.tile[index3, index2 - num16 * 2].active(true);
              }
              ++index3;
            }
          }
        }
        if (num11 > num12)
        {
          num11 = 0;
          ++num13;
        }
      }
      int num18 = 0;
      int num19 = 1000;
      int num20 = 0;
      Main.statusText = Lang.gen[58].Value + " 75%";
      while (num20 < num14)
      {
        ++num18;
        int index1 = WorldGen.genRand.Next(WorldGen.dMinX, WorldGen.dMaxX);
        int index2 = WorldGen.genRand.Next((int) Main.worldSurface + 25, WorldGen.dMaxY);
        int num15 = index2;
        if ((int) Main.tile[index1, index2].wall == wallType1 && !Main.tile[index1, index2].active())
        {
          int num16 = 1;
          if (WorldGen.genRand.Next(2) == 0)
            num16 = -1;
          while (index1 > 5 && index1 < Main.maxTilesX - 5 && !Main.tile[index1, index2].active())
            index1 += num16;
          if (Main.tile[index1, index2 - 1].active() && Main.tile[index1, index2 + 1].active() && ((int) Main.tile[index1, index2 - 1].type != (int) WorldGen.crackedType && !Main.tile[index1 - num16, index2 - 1].active()) && !Main.tile[index1 - num16, index2 + 1].active())
          {
            ++num20;
            for (int index3 = WorldGen.genRand.Next(5, 13); Main.tile[index1, index2 - 1].active() && (int) Main.tile[index1, index2 - 1].type != (int) WorldGen.crackedType && (Main.tile[index1 + num16, index2].active() && Main.tile[index1, index2].active()) && (!Main.tile[index1 - num16, index2].active() && index3 > 0); --index3)
            {
              Main.tile[index1, index2].type = (ushort) 48;
              if (!Main.tile[index1 - num16, index2 - 1].active() && !Main.tile[index1 - num16, index2 + 1].active())
              {
                Main.tile[index1 - num16, index2].type = (ushort) 48;
                Main.tile[index1 - num16, index2].active(true);
                Main.tile[index1 - num16, index2].Clear(TileDataType.Slope);
                Main.tile[index1 - num16 * 2, index2].type = (ushort) 48;
                Main.tile[index1 - num16 * 2, index2].active(true);
                Main.tile[index1 - num16 * 2, index2].Clear(TileDataType.Slope);
              }
              --index2;
            }
            int num17 = WorldGen.genRand.Next(5, 13);
            for (int index3 = num15 + 1; Main.tile[index1, index3 + 1].active() && (int) Main.tile[index1, index3 + 1].type != (int) WorldGen.crackedType && (Main.tile[index1 + num16, index3].active() && Main.tile[index1, index3].active()) && (!Main.tile[index1 - num16, index3].active() && num17 > 0); --num17)
            {
              Main.tile[index1, index3].type = (ushort) 48;
              if (!Main.tile[index1 - num16, index3 - 1].active() && !Main.tile[index1 - num16, index3 + 1].active())
              {
                Main.tile[index1 - num16, index3].type = (ushort) 48;
                Main.tile[index1 - num16, index3].active(true);
                Main.tile[index1 - num16, index3].Clear(TileDataType.Slope);
                Main.tile[index1 - num16 * 2, index3].type = (ushort) 48;
                Main.tile[index1 - num16 * 2, index3].active(true);
                Main.tile[index1 - num16 * 2, index3].Clear(TileDataType.Slope);
              }
              ++index3;
            }
          }
        }
        if (num18 > num19)
        {
          num18 = 0;
          ++num20;
        }
      }
      Main.statusText = Lang.gen[58].Value + " 80%";
      for (int index1 = 0; index1 < WorldGen.numDDoors; ++index1)
      {
        int num15 = WorldGen.DDoorX[index1] - 10;
        int num16 = WorldGen.DDoorX[index1] + 10;
        int num17 = 100;
        int num21 = 0;
        for (int index2 = num15; index2 < num16; ++index2)
        {
          bool flag1 = true;
          int index3 = WorldGen.DDoorY[index1];
          while (index3 > 10 && !Main.tile[index2, index3].active())
            --index3;
          if (!Main.tileDungeon[(int) Main.tile[index2, index3].type])
            flag1 = false;
          int num22 = index3;
          int index4 = WorldGen.DDoorY[index1];
          while (!Main.tile[index2, index4].active())
            ++index4;
          if (!Main.tileDungeon[(int) Main.tile[index2, index4].type])
            flag1 = false;
          int num23 = index4;
          if (num23 - num22 >= 3)
          {
            int num24 = index2 - 20;
            int num25 = index2 + 20;
            int num26 = num23 - 10;
            int num27 = num23 + 10;
            for (int index5 = num24; index5 < num25; ++index5)
            {
              for (int index6 = num26; index6 < num27; ++index6)
              {
                if (Main.tile[index5, index6].active() && Main.tile[index5, index6].type == (ushort) 10)
                {
                  flag1 = false;
                  break;
                }
              }
            }
            if (flag1)
            {
              for (int index5 = num23 - 3; index5 < num23; ++index5)
              {
                for (int index6 = index2 - 3; index6 <= index2 + 3; ++index6)
                {
                  if (Main.tile[index6, index5].active())
                  {
                    flag1 = false;
                    break;
                  }
                }
              }
            }
            if (flag1 && num23 - num22 < 20)
            {
              bool flag2 = false;
              if (WorldGen.DDoorPos[index1] == 0 && num23 - num22 < num17)
                flag2 = true;
              if (WorldGen.DDoorPos[index1] == -1 && index2 > num21)
                flag2 = true;
              if (WorldGen.DDoorPos[index1] == 1 && (index2 < num21 || num21 == 0))
                flag2 = true;
              if (flag2)
              {
                num21 = index2;
                num17 = num23 - num22;
              }
            }
          }
        }
        if (num17 < 20)
        {
          int i2 = num21;
          int index2 = WorldGen.DDoorY[index1];
          int index3 = index2;
          for (; !Main.tile[i2, index2].active(); ++index2)
            Main.tile[i2, index2].active(false);
          while (!Main.tile[i2, index3].active())
            --index3;
          int j2 = index2 - 1;
          int num22 = index3 + 1;
          for (int index4 = num22; index4 < j2 - 2; ++index4)
          {
            Main.tile[i2, index4].Clear(TileDataType.Slope);
            Main.tile[i2, index4].active(true);
            Main.tile[i2, index4].type = tileType;
          }
          int style = 13;
          if (WorldGen.genRand.Next(3) == 0)
          {
            switch (wallType1)
            {
              case 7:
                style = 16;
                break;
              case 8:
                style = 17;
                break;
              case 9:
                style = 18;
                break;
            }
          }
          WorldGen.PlaceTile(i2, j2, 10, true, false, -1, style);
          int index5 = i2 - 1;
          int index6 = j2 - 3;
          while (!Main.tile[index5, index6].active())
            --index6;
          if (j2 - index6 < j2 - num22 + 5 && Main.tileDungeon[(int) Main.tile[index5, index6].type])
          {
            for (int index4 = j2 - 4 - WorldGen.genRand.Next(3); index4 > index6; --index4)
            {
              Main.tile[index5, index4].Clear(TileDataType.Slope);
              Main.tile[index5, index4].active(true);
              Main.tile[index5, index4].type = tileType;
            }
          }
          int index7 = index5 + 2;
          int index8 = j2 - 3;
          while (!Main.tile[index7, index8].active())
            --index8;
          if (j2 - index8 < j2 - num22 + 5 && Main.tileDungeon[(int) Main.tile[index7, index8].type])
          {
            for (int index4 = j2 - 4 - WorldGen.genRand.Next(3); index4 > index8; --index4)
            {
              Main.tile[index7, index4].active(true);
              Main.tile[index7, index4].Clear(TileDataType.Slope);
              Main.tile[index7, index4].type = tileType;
            }
          }
          int index9 = j2 + 1;
          int num23 = index7 - 1;
          Main.tile[num23 - 1, index9].active(true);
          Main.tile[num23 - 1, index9].type = tileType;
          Main.tile[num23 - 1, index9].Clear(TileDataType.Slope);
          Main.tile[num23 + 1, index9].active(true);
          Main.tile[num23 + 1, index9].type = tileType;
          Main.tile[num23 + 1, index9].Clear(TileDataType.Slope);
        }
      }
      int[] roomWall = new int[3];
      switch (wallType1)
      {
        case 7:
          roomWall[0] = 7;
          roomWall[1] = 94;
          roomWall[2] = 95;
          break;
        case 9:
          roomWall[0] = 9;
          roomWall[1] = 96;
          roomWall[2] = 97;
          break;
        default:
          roomWall[0] = 8;
          roomWall[1] = 98;
          roomWall[2] = 99;
          break;
      }
      for (int index1 = 0; index1 < 5; ++index1)
      {
        for (int index2 = 0; index2 < 3; ++index2)
        {
          int num15 = WorldGen.genRand.Next(40, 240);
          int num16 = WorldGen.genRand.Next(WorldGen.dMinX, WorldGen.dMaxX);
          int num17 = WorldGen.genRand.Next(WorldGen.dMinY, WorldGen.dMaxY);
          for (int x1 = num16 - num15; x1 < num16 + num15; ++x1)
          {
            for (int y1 = num17 - num15; y1 < num17 + num15; ++y1)
            {
              if ((double) y1 > Main.worldSurface)
              {
                double num21 = (double) Math.Abs(num16 - x1);
                float num22 = (float) Math.Abs(num17 - y1);
                if (Math.Sqrt(num21 * num21 + (double) num22 * (double) num22) < (double) num15 * 0.4 && Main.wallDungeon[(int) Main.tile[x1, y1].wall])
                  WorldGen.Spread.WallDungeon(x1, y1, roomWall[index2]);
              }
            }
          }
        }
      }
      Main.statusText = Lang.gen[58].Value + " 85%";
      for (int index1 = 0; index1 < WorldGen.numDungeonPlatforms; ++index1)
      {
        int index2 = WorldGen.dungeonPlatformX[index1];
        int num15 = WorldGen.dungeonPlatformY[index1];
        int num16 = Main.maxTilesX;
        int num17 = 10;
        if ((double) num15 < Main.worldSurface + 50.0)
          num17 = 20;
        for (int index3 = num15 - 5; index3 <= num15 + 5; ++index3)
        {
          int index4 = index2;
          int index5 = index2;
          bool flag1 = false;
          if (Main.tile[index4, index3].active())
          {
            flag1 = true;
          }
          else
          {
            while (!Main.tile[index4, index3].active())
            {
              --index4;
              if (!Main.tileDungeon[(int) Main.tile[index4, index3].type] || index4 == 0)
              {
                flag1 = true;
                break;
              }
            }
            while (!Main.tile[index5, index3].active())
            {
              ++index5;
              if (!Main.tileDungeon[(int) Main.tile[index5, index3].type] || index5 == Main.maxTilesX - 1)
              {
                flag1 = true;
                break;
              }
            }
          }
          if (!flag1 && index5 - index4 <= num17)
          {
            bool flag2 = true;
            int num21 = index2 - num17 / 2 - 2;
            int num22 = index2 + num17 / 2 + 2;
            int num23 = index3 - 5;
            int num24 = index3 + 5;
            for (int index6 = num21; index6 <= num22; ++index6)
            {
              for (int index7 = num23; index7 <= num24; ++index7)
              {
                if (Main.tile[index6, index7].active() && Main.tile[index6, index7].type == (ushort) 19)
                {
                  flag2 = false;
                  break;
                }
              }
            }
            for (int index6 = index3 + 3; index6 >= index3 - 5; --index6)
            {
              if (Main.tile[index2, index6].active())
              {
                flag2 = false;
                break;
              }
            }
            if (flag2)
            {
              num16 = index3;
              break;
            }
          }
        }
        if (num16 > num15 - 10 && num16 < num15 + 10)
        {
          int i2 = index2;
          int j2 = num16;
          int i3 = index2 + 1;
          for (; !Main.tile[i2, j2].active(); --i2)
          {
            Main.tile[i2, j2].active(true);
            Main.tile[i2, j2].type = (ushort) 19;
            Main.tile[i2, j2].Clear(TileDataType.Slope);
            switch (wallType1)
            {
              case 7:
                Main.tile[i2, j2].frameY = (short) 108;
                break;
              case 8:
                Main.tile[i2, j2].frameY = (short) 144;
                break;
              default:
                Main.tile[i2, j2].frameY = (short) 126;
                break;
            }
            WorldGen.TileFrame(i2, j2, false, false);
          }
          for (; !Main.tile[i3, j2].active(); ++i3)
          {
            Main.tile[i3, j2].active(true);
            Main.tile[i3, j2].type = (ushort) 19;
            Main.tile[i3, j2].Clear(TileDataType.Slope);
            switch (wallType1)
            {
              case 7:
                Main.tile[i3, j2].frameY = (short) 108;
                break;
              case 8:
                Main.tile[i3, j2].frameY = (short) 144;
                break;
              default:
                Main.tile[i3, j2].frameY = (short) 126;
                break;
            }
            WorldGen.TileFrame(i3, j2, false, false);
          }
        }
      }
      int num28 = 5;
      if (WorldGen.drunkWorldGen)
        num28 = 6;
      for (int index = 0; index < num28; ++index)
      {
        bool flag = false;
        while (!flag)
        {
          int i2 = WorldGen.genRand.Next(WorldGen.dMinX, WorldGen.dMaxX);
          int j2 = WorldGen.genRand.Next((int) Main.worldSurface, WorldGen.dMaxY);
          if (Main.wallDungeon[(int) Main.tile[i2, j2].wall] && !Main.tile[i2, j2].active())
          {
            ushort chestTileType = 21;
            int contain = 0;
            int Style = 0;
            switch (index)
            {
              case 0:
                Style = 23;
                contain = 1156;
                break;
              case 1:
                if (!WorldGen.crimson)
                {
                  Style = 24;
                  contain = 1571;
                  break;
                }
                Style = 25;
                contain = 1569;
                break;
              case 2:
                Style = 26;
                contain = 1260;
                break;
              case 3:
                Style = 27;
                contain = 1572;
                break;
              case 4:
                chestTileType = (ushort) 467;
                Style = 13;
                contain = 4607;
                break;
              case 5:
                if (WorldGen.crimson)
                {
                  Style = 24;
                  contain = 1571;
                  break;
                }
                Style = 25;
                contain = 1569;
                break;
            }
            flag = WorldGen.AddBuriedChest(i2, j2, contain, false, Style, false, chestTileType);
          }
        }
      }
      int[] numArray = new int[3]
      {
        WorldGen.genRand.Next(9, 13),
        WorldGen.genRand.Next(9, 13),
        0
      };
      while (numArray[1] == numArray[0])
        numArray[1] = WorldGen.genRand.Next(9, 13);
      numArray[2] = WorldGen.genRand.Next(9, 13);
      while (numArray[2] == numArray[0] || numArray[2] == numArray[1])
        numArray[2] = WorldGen.genRand.Next(9, 13);
      Main.statusText = Lang.gen[58].Value + " 90%";
      int num29 = 0;
      int num30 = 1000;
      int num31 = 0;
      while (num31 < Main.maxTilesX / 20)
      {
        ++num29;
        int index1 = WorldGen.genRand.Next(WorldGen.dMinX, WorldGen.dMaxX);
        int j2 = WorldGen.genRand.Next(WorldGen.dMinY, WorldGen.dMaxY);
        bool flag1 = true;
        if (Main.wallDungeon[(int) Main.tile[index1, j2].wall] && !Main.tile[index1, j2].active())
        {
          int num15 = 1;
          if (WorldGen.genRand.Next(2) == 0)
            num15 = -1;
          while (flag1 && !Main.tile[index1, j2].active())
          {
            index1 -= num15;
            if (index1 < 5 || index1 > Main.maxTilesX - 5)
              flag1 = false;
            else if (Main.tile[index1, j2].active() && !Main.tileDungeon[(int) Main.tile[index1, j2].type])
              flag1 = false;
          }
          if (flag1 && Main.tile[index1, j2].active() && (Main.tileDungeon[(int) Main.tile[index1, j2].type] && Main.tile[index1, j2 - 1].active()) && (Main.tileDungeon[(int) Main.tile[index1, j2 - 1].type] && Main.tile[index1, j2 + 1].active() && Main.tileDungeon[(int) Main.tile[index1, j2 + 1].type]))
          {
            int i2 = index1 + num15;
            for (int index2 = i2 - 3; index2 <= i2 + 3; ++index2)
            {
              for (int index3 = j2 - 3; index3 <= j2 + 3; ++index3)
              {
                if (Main.tile[index2, index3].active() && Main.tile[index2, index3].type == (ushort) 19)
                {
                  flag1 = false;
                  break;
                }
              }
            }
            if (flag1 && !Main.tile[i2, j2 - 1].active() & !Main.tile[i2, j2 - 2].active() & !Main.tile[i2, j2 - 3].active())
            {
              int index2 = i2;
              int num16 = i2;
              while (index2 > WorldGen.dMinX && index2 < WorldGen.dMaxX && (!Main.tile[index2, j2].active() && !Main.tile[index2, j2 - 1].active()) && !Main.tile[index2, j2 + 1].active())
                index2 += num15;
              int num17 = Math.Abs(i2 - index2);
              bool flag2 = false;
              if (WorldGen.genRand.Next(2) == 0)
                flag2 = true;
              if (num17 > 5)
              {
                for (int index3 = WorldGen.genRand.Next(1, 4); index3 > 0; --index3)
                {
                  Main.tile[i2, j2].active(true);
                  Main.tile[i2, j2].Clear(TileDataType.Slope);
                  Main.tile[i2, j2].type = (ushort) 19;
                  Main.tile[i2, j2].frameY = (int) Main.tile[i2, j2].wall != roomWall[0] ? ((int) Main.tile[i2, j2].wall != roomWall[1] ? (short) (18 * numArray[2]) : (short) (18 * numArray[1])) : (short) (18 * numArray[0]);
                  WorldGen.TileFrame(i2, j2, false, false);
                  if (flag2)
                  {
                    WorldGen.PlaceTile(i2, j2 - 1, 50, true, false, -1, 0);
                    if (WorldGen.genRand.Next(50) == 0 && (double) j2 > (Main.worldSurface + Main.rockLayer) / 2.0 && Main.tile[i2, j2 - 1].type == (ushort) 50)
                      Main.tile[i2, j2 - 1].frameX = (short) 90;
                  }
                  i2 += num15;
                }
                num29 = 0;
                ++num31;
                if (!flag2 && WorldGen.genRand.Next(2) == 0)
                {
                  int i3 = num16;
                  int j3 = j2 - 1;
                  int Type = 0;
                  if (WorldGen.genRand.Next(4) == 0)
                    Type = 1;
                  switch (Type)
                  {
                    case 0:
                      Type = 13;
                      break;
                    case 1:
                      Type = 49;
                      break;
                  }
                  WorldGen.PlaceTile(i3, j3, Type, true, false, -1, 0);
                  if (Main.tile[i3, j3].type == (ushort) 13)
                    Main.tile[i3, j3].frameX = WorldGen.genRand.Next(2) != 0 ? (short) 36 : (short) 18;
                }
              }
            }
          }
        }
        if (num29 > num30)
        {
          num29 = 0;
          ++num31;
        }
      }
      Main.statusText = Lang.gen[58].Value + " 95%";
      int num32 = 1;
      for (int index = 0; index < WorldGen.numDRooms; ++index)
      {
        int num15 = 0;
        while (num15 < 1000)
        {
          int num16 = (int) ((double) WorldGen.dRoomSize[index] * 0.4);
          int i2 = WorldGen.dRoomX[index] + WorldGen.genRand.Next(-num16, num16 + 1);
          int j2 = WorldGen.dRoomY[index] + WorldGen.genRand.Next(-num16, num16 + 1);
          int Style = 2;
          if (num32 == 1)
            ++num32;
          int contain;
          if (num32 == 2)
            contain = 155;
          else if (num32 == 3)
            contain = 156;
          else if (num32 == 4)
            contain = 157;
          else if (num32 == 5)
            contain = 163;
          else if (num32 == 6)
            contain = 113;
          else if (num32 == 7)
            contain = 3317;
          else if (num32 == 8)
          {
            contain = 327;
            Style = 0;
          }
          else
          {
            contain = 164;
            num32 = 0;
          }
          if ((double) j2 < Main.worldSurface + 50.0)
          {
            contain = 327;
            Style = 0;
          }
          if (contain == 0 && WorldGen.genRand.Next(2) == 0)
          {
            num15 = 1000;
          }
          else
          {
            if (WorldGen.AddBuriedChest(i2, j2, contain, false, Style, false, (ushort) 0))
            {
              num15 += 1000;
              ++num32;
            }
            ++num15;
          }
        }
      }
      WorldGen.dMinX -= 25;
      WorldGen.dMaxX += 25;
      WorldGen.dMinY -= 25;
      WorldGen.dMaxY += 25;
      if (WorldGen.dMinX < 0)
        WorldGen.dMinX = 0;
      if (WorldGen.dMaxX > Main.maxTilesX)
        WorldGen.dMaxX = Main.maxTilesX;
      if (WorldGen.dMinY < 0)
        WorldGen.dMinY = 0;
      if (WorldGen.dMaxY > Main.maxTilesY)
        WorldGen.dMaxY = Main.maxTilesY;
      int failCount = 0;
      int failMax1 = 1000;
      int numAdd1 = 0;
      WorldGen.MakeDungeon_Lights(tileType, ref failCount, failMax1, ref numAdd1, roomWall);
      failCount = 0;
      int failMax2 = 1000;
      int numAdd2 = 0;
      WorldGen.MakeDungeon_Traps(ref failCount, failMax2, ref numAdd2);
      float count1 = WorldGen.MakeDungeon_GroundFurniture(wallType1);
      float count2 = WorldGen.MakeDungeon_Pictures(roomWall, count1);
      WorldGen.MakeDungeon_Banners(roomWall, count2);
    }

    private static void MakeDungeon_Traps(ref int failCount, int failMax, ref int numAdd)
    {
      while (numAdd < Main.maxTilesX / 500)
      {
        ++failCount;
        int x2 = WorldGen.genRand.Next(WorldGen.dMinX, WorldGen.dMaxX);
        int y2 = WorldGen.genRand.Next(WorldGen.dMinY, WorldGen.dMaxY);
        while ((double) y2 < Main.worldSurface)
          y2 = WorldGen.genRand.Next(WorldGen.dMinY, WorldGen.dMaxY);
        if (Main.wallDungeon[(int) Main.tile[x2, y2].wall] && WorldGen.placeTrap(x2, y2, 0))
          failCount = failMax;
        if (failCount > failMax)
        {
          ++numAdd;
          failCount = 0;
        }
      }
    }

    private static void MakeDungeon_Lights(
      ushort tileType,
      ref int failCount,
      int failMax,
      ref int numAdd,
      int[] roomWall)
    {
      int[] numArray = new int[3]
      {
        WorldGen.genRand.Next(7),
        WorldGen.genRand.Next(7),
        0
      };
      while (numArray[1] == numArray[0])
        numArray[1] = WorldGen.genRand.Next(7);
      numArray[2] = WorldGen.genRand.Next(7);
      while (numArray[2] == numArray[0] || numArray[2] == numArray[1])
        numArray[2] = WorldGen.genRand.Next(7);
      while (numAdd < Main.maxTilesX / 150)
      {
        ++failCount;
        int index1 = WorldGen.genRand.Next(WorldGen.dMinX, WorldGen.dMaxX);
        int index2 = WorldGen.genRand.Next(WorldGen.dMinY, WorldGen.dMaxY);
        if (Main.wallDungeon[(int) Main.tile[index1, index2].wall])
        {
          for (int y = index2; y > WorldGen.dMinY; --y)
          {
            if (Main.tile[index1, y - 1].active() && (int) Main.tile[index1, y - 1].type == (int) tileType)
            {
              bool flag1 = false;
              for (int index3 = index1 - 15; index3 < index1 + 15; ++index3)
              {
                for (int index4 = y - 15; index4 < y + 15; ++index4)
                {
                  if (index3 > 0 && index3 < Main.maxTilesX && (index4 > 0 && index4 < Main.maxTilesY) && (Main.tile[index3, index4].type == (ushort) 42 || Main.tile[index3, index4].type == (ushort) 34))
                  {
                    flag1 = true;
                    break;
                  }
                }
              }
              if (Main.tile[index1 - 1, y].active() || Main.tile[index1 + 1, y].active() || (Main.tile[index1 - 1, y + 1].active() || Main.tile[index1 + 1, y + 1].active()) || Main.tile[index1, y + 2].active())
                flag1 = true;
              if (!flag1)
              {
                bool flag2 = false;
                if (!flag2 && WorldGen.genRand.Next(7) == 0)
                {
                  int style = 27;
                  switch (roomWall[0])
                  {
                    case 7:
                      style = 27;
                      break;
                    case 8:
                      style = 28;
                      break;
                    case 9:
                      style = 29;
                      break;
                  }
                  bool flag3 = false;
                  for (int index3 = 0; index3 < 15; ++index3)
                  {
                    if (WorldGen.SolidTile(index1, y + index3, false))
                    {
                      flag3 = true;
                      break;
                    }
                  }
                  if (!flag3)
                    WorldGen.PlaceChand(index1, y, (ushort) 34, style);
                  if (Main.tile[index1, y].type == (ushort) 34)
                  {
                    flag2 = true;
                    failCount = 0;
                    ++numAdd;
                    for (int index3 = 0; index3 < 1000; ++index3)
                    {
                      int i = index1 + WorldGen.genRand.Next(-12, 13);
                      int j = y + WorldGen.genRand.Next(3, 21);
                      if (!Main.tile[i, j].active() && !Main.tile[i, j + 1].active() && (Main.tileDungeon[(int) Main.tile[i - 1, j].type] && Main.tileDungeon[(int) Main.tile[i + 1, j].type]) && Collision.CanHit(new Vector2((float) (i * 16), (float) (j * 16)), 16, 16, new Vector2((float) (index1 * 16), (float) (y * 16 + 1)), 16, 16))
                      {
                        if ((WorldGen.SolidTile(i - 1, j, false) && Main.tile[i - 1, j].type != (ushort) 10 || WorldGen.SolidTile(i + 1, j, false) && Main.tile[i + 1, j].type != (ushort) 10 || WorldGen.SolidTile(i, j + 1, false)) && (Main.wallDungeon[(int) Main.tile[i, j].wall] && (Main.tileDungeon[(int) Main.tile[i - 1, j].type] || Main.tileDungeon[(int) Main.tile[i + 1, j].type])))
                          WorldGen.PlaceTile(i, j, 136, true, false, -1, 0);
                        if (Main.tile[i, j].active())
                        {
                          while (i != index1 || j != y)
                          {
                            Main.tile[i, j].wire(true);
                            if (i > index1)
                              --i;
                            if (i < index1)
                              ++i;
                            Main.tile[i, j].wire(true);
                            if (j > y)
                              --j;
                            if (j < y)
                              ++j;
                            Main.tile[i, j].wire(true);
                          }
                          if (WorldGen.genRand.Next(3) > 0)
                          {
                            Main.tile[index1, y].frameX = (short) 18;
                            Main.tile[index1, y + 1].frameX = (short) 18;
                            break;
                          }
                          break;
                        }
                      }
                    }
                  }
                }
                if (!flag2)
                {
                  int style = numArray[0];
                  if ((int) Main.tile[index1, y].wall == roomWall[1])
                    style = numArray[1];
                  if ((int) Main.tile[index1, y].wall == roomWall[2])
                    style = numArray[2];
                  WorldGen.Place1x2Top(index1, y, (ushort) 42, style);
                  if (Main.tile[index1, y].type == (ushort) 42)
                  {
                    failCount = 0;
                    ++numAdd;
                    for (int index3 = 0; index3 < 1000; ++index3)
                    {
                      int i = index1 + WorldGen.genRand.Next(-12, 13);
                      int j = y + WorldGen.genRand.Next(3, 21);
                      if (!Main.tile[i, j].active() && !Main.tile[i, j + 1].active() && (Main.tile[i - 1, j].type != (ushort) 48 && Main.tile[i + 1, j].type != (ushort) 48) && Collision.CanHit(new Vector2((float) (i * 16), (float) (j * 16)), 16, 16, new Vector2((float) (index1 * 16), (float) (y * 16 + 1)), 16, 16))
                      {
                        if (WorldGen.SolidTile(i - 1, j, false) && Main.tile[i - 1, j].type != (ushort) 10 || WorldGen.SolidTile(i + 1, j, false) && Main.tile[i + 1, j].type != (ushort) 10 || WorldGen.SolidTile(i, j + 1, false))
                          WorldGen.PlaceTile(i, j, 136, true, false, -1, 0);
                        if (Main.tile[i, j].active())
                        {
                          while (i != index1 || j != y)
                          {
                            Main.tile[i, j].wire(true);
                            if (i > index1)
                              --i;
                            if (i < index1)
                              ++i;
                            Main.tile[i, j].wire(true);
                            if (j > y)
                              --j;
                            if (j < y)
                              ++j;
                            Main.tile[i, j].wire(true);
                          }
                          if (WorldGen.genRand.Next(3) > 0)
                          {
                            Main.tile[index1, y].frameX = (short) 18;
                            Main.tile[index1, y + 1].frameX = (short) 18;
                            break;
                          }
                          break;
                        }
                      }
                    }
                    break;
                  }
                  break;
                }
                break;
              }
              break;
            }
          }
        }
        if (failCount > failMax)
        {
          ++numAdd;
          failCount = 0;
        }
      }
    }

    private static float MakeDungeon_Banners(int[] roomWall, float count)
    {
      count = 840000f / (float) Main.maxTilesX;
      for (int index1 = 0; (double) index1 < (double) count; ++index1)
      {
        int i = WorldGen.genRand.Next(WorldGen.dMinX, WorldGen.dMaxX);
        int j1;
        for (j1 = WorldGen.genRand.Next(WorldGen.dMinY, WorldGen.dMaxY); !Main.wallDungeon[(int) Main.tile[i, j1].wall] || Main.tile[i, j1].active(); j1 = WorldGen.genRand.Next(WorldGen.dMinY, WorldGen.dMaxY))
          i = WorldGen.genRand.Next(WorldGen.dMinX, WorldGen.dMaxX);
        while (!WorldGen.SolidTile(i, j1, false) && j1 > 10)
          --j1;
        int j2 = j1 + 1;
        if (Main.wallDungeon[(int) Main.tile[i, j2].wall] && Main.tile[i, j2 - 1].type != (ushort) 48 && (!Main.tile[i, j2].active() && !Main.tile[i, j2 + 1].active()) && (!Main.tile[i, j2 + 2].active() && !Main.tile[i, j2 + 3].active()))
        {
          bool flag = true;
          for (int index2 = i - 1; index2 <= i + 1; ++index2)
          {
            for (int index3 = j2; index3 <= j2 + 3; ++index3)
            {
              if (Main.tile[index2, index3].active() && (Main.tile[index2, index3].type == (ushort) 10 || Main.tile[index2, index3].type == (ushort) 11 || Main.tile[index2, index3].type == (ushort) 91))
                flag = false;
            }
          }
          if (flag)
          {
            int num = 10;
            if ((int) Main.tile[i, j2].wall == roomWall[1])
              num = 12;
            if ((int) Main.tile[i, j2].wall == roomWall[2])
              num = 14;
            int style = num + WorldGen.genRand.Next(2);
            WorldGen.PlaceTile(i, j2, 91, true, false, -1, style);
          }
        }
      }
      return count;
    }

    private static float MakeDungeon_Pictures(int[] roomWall, float count)
    {
      count = 420000f / (float) Main.maxTilesX;
      for (int index1 = 0; (double) index1 < (double) count; ++index1)
      {
        int index2 = WorldGen.genRand.Next(WorldGen.dMinX, WorldGen.dMaxX);
        int index3;
        for (index3 = WorldGen.genRand.Next((int) Main.worldSurface, WorldGen.dMaxY); !Main.wallDungeon[(int) Main.tile[index2, index3].wall] || Main.tile[index2, index3].active(); index3 = WorldGen.genRand.Next((int) Main.worldSurface, WorldGen.dMaxY))
          index2 = WorldGen.genRand.Next(WorldGen.dMinX, WorldGen.dMaxX);
        for (int index4 = 0; index4 < 2; ++index4)
        {
          int index5 = index2;
          int index6 = index2;
          while (!Main.tile[index5, index3].active() && Main.wallDungeon[(int) Main.tile[index5, index3].wall])
            --index5;
          int num1 = index5 + 1;
          while (!Main.tile[index6, index3].active() && Main.wallDungeon[(int) Main.tile[index6, index3].wall])
            ++index6;
          int num2 = index6 - 1;
          index2 = (num1 + num2) / 2;
          int index7 = index3;
          int index8 = index3;
          while (!Main.tile[index2, index7].active() && Main.wallDungeon[(int) Main.tile[index2, index7].wall])
            --index7;
          int num3 = index7 + 1;
          while (!Main.tile[index2, index8].active() && Main.wallDungeon[(int) Main.tile[index2, index8].wall])
            ++index8;
          int num4 = index8 - 1;
          index3 = (num3 + num4) / 2;
        }
        int index9 = index2;
        int index10 = index2;
        while (!Main.tile[index9, index3].active() && !Main.tile[index9, index3 - 1].active() && !Main.tile[index9, index3 + 1].active())
          --index9;
        int num5 = index9 + 1;
        while (!Main.tile[index10, index3].active() && !Main.tile[index10, index3 - 1].active() && !Main.tile[index10, index3 + 1].active())
          ++index10;
        int num6 = index10 - 1;
        int index11 = index3;
        int index12 = index3;
        while (!Main.tile[index2, index11].active() && !Main.tile[index2 - 1, index11].active() && !Main.tile[index2 + 1, index11].active())
          --index11;
        int num7 = index11 + 1;
        while (!Main.tile[index2, index12].active() && !Main.tile[index2 - 1, index12].active() && !Main.tile[index2 + 1, index12].active())
          ++index12;
        int num8 = index12 - 1;
        int index13 = (num5 + num6) / 2;
        int index14 = (num7 + num8) / 2;
        int num9 = num6 - num5;
        int num10 = num8 - num7;
        if (num9 > 7 && num10 > 5)
        {
          bool[] flagArray = new bool[3]
          {
            true,
            false,
            false
          };
          if (num9 > num10 * 3 && num9 > 21)
            flagArray[1] = true;
          if (num10 > num9 * 3 && num10 > 21)
            flagArray[2] = true;
          int index4 = WorldGen.genRand.Next(3);
          if ((int) Main.tile[index13, index14].wall == roomWall[0])
            index4 = 0;
          while (!flagArray[index4])
            index4 = WorldGen.genRand.Next(3);
          if (WorldGen.nearPicture2(index13, index14))
            index4 = -1;
          switch (index4)
          {
            case 0:
              Vector2 vector2_1 = WorldGen.randPictureTile();
              if ((int) Main.tile[index13, index14].wall != roomWall[0])
                vector2_1 = WorldGen.randBoneTile();
              int x1 = (int) vector2_1.X;
              int y1 = (int) vector2_1.Y;
              if (!WorldGen.nearPicture(index13, index14))
              {
                WorldGen.PlaceTile(index13, index14, x1, true, false, -1, y1);
                continue;
              }
              continue;
            case 1:
              Vector2 vector2_2 = WorldGen.randPictureTile();
              if ((int) Main.tile[index13, index14].wall != roomWall[0])
                vector2_2 = WorldGen.randBoneTile();
              int x2 = (int) vector2_2.X;
              int y2 = (int) vector2_2.Y;
              if (!Main.tile[index13, index14].active())
                WorldGen.PlaceTile(index13, index14, x2, true, false, -1, y2);
              int num1 = index13;
              int num2 = index14;
              int index5 = index14;
              for (int index6 = 0; index6 < 2; ++index6)
              {
                index13 += 7;
                int index7 = index5;
                int index8 = index5;
                while (!Main.tile[index13, index7].active() && !Main.tile[index13 - 1, index7].active() && !Main.tile[index13 + 1, index7].active())
                  --index7;
                int num3 = index7 + 1;
                while (!Main.tile[index13, index8].active() && !Main.tile[index13 - 1, index8].active() && !Main.tile[index13 + 1, index8].active())
                  ++index8;
                int num4 = index8 - 1;
                index5 = (num3 + num4) / 2;
                Vector2 vector2_3 = WorldGen.randPictureTile();
                if ((int) Main.tile[index13, index5].wall != roomWall[0])
                  vector2_3 = WorldGen.randBoneTile();
                int x3 = (int) vector2_3.X;
                int y3 = (int) vector2_3.Y;
                if (Math.Abs(num2 - index5) < 4 && !WorldGen.nearPicture(index13, index5))
                  WorldGen.PlaceTile(index13, index5, x3, true, false, -1, y3);
                else
                  break;
              }
              int index15 = index14;
              int index16 = num1;
              for (int index6 = 0; index6 < 2; ++index6)
              {
                index16 -= 7;
                int index7 = index15;
                int index8 = index15;
                while (!Main.tile[index16, index7].active() && !Main.tile[index16 - 1, index7].active() && !Main.tile[index16 + 1, index7].active())
                  --index7;
                int num3 = index7 + 1;
                while (!Main.tile[index16, index8].active() && !Main.tile[index16 - 1, index8].active() && !Main.tile[index16 + 1, index8].active())
                  ++index8;
                int num4 = index8 - 1;
                index15 = (num3 + num4) / 2;
                Vector2 vector2_3 = WorldGen.randPictureTile();
                if ((int) Main.tile[index16, index15].wall != roomWall[0])
                  vector2_3 = WorldGen.randBoneTile();
                int x3 = (int) vector2_3.X;
                int y3 = (int) vector2_3.Y;
                if (Math.Abs(num2 - index15) < 4 && !WorldGen.nearPicture(index16, index15))
                  WorldGen.PlaceTile(index16, index15, x3, true, false, -1, y3);
                else
                  break;
              }
              continue;
            case 2:
              Vector2 vector2_4 = WorldGen.randPictureTile();
              if ((int) Main.tile[index13, index14].wall != roomWall[0])
                vector2_4 = WorldGen.randBoneTile();
              int x4 = (int) vector2_4.X;
              int y4 = (int) vector2_4.Y;
              if (!Main.tile[index13, index14].active())
                WorldGen.PlaceTile(index13, index14, x4, true, false, -1, y4);
              int num11 = index14;
              int num12 = index13;
              int index17 = index13;
              for (int index6 = 0; index6 < 3; ++index6)
              {
                index14 += 7;
                int index7 = index17;
                int index8 = index17;
                while (!Main.tile[index7, index14].active() && !Main.tile[index7, index14 - 1].active() && !Main.tile[index7, index14 + 1].active())
                  --index7;
                int num3 = index7 + 1;
                while (!Main.tile[index8, index14].active() && !Main.tile[index8, index14 - 1].active() && !Main.tile[index8, index14 + 1].active())
                  ++index8;
                int num4 = index8 - 1;
                index17 = (num3 + num4) / 2;
                Vector2 vector2_3 = WorldGen.randPictureTile();
                if ((int) Main.tile[index17, index14].wall != roomWall[0])
                  vector2_3 = WorldGen.randBoneTile();
                int x3 = (int) vector2_3.X;
                int y3 = (int) vector2_3.Y;
                if (Math.Abs(num12 - index17) < 4 && !WorldGen.nearPicture(index17, index14))
                  WorldGen.PlaceTile(index17, index14, x3, true, false, -1, y3);
                else
                  break;
              }
              int index18 = index13;
              int index19 = num11;
              for (int index6 = 0; index6 < 3; ++index6)
              {
                index19 -= 7;
                int index7 = index18;
                int index8 = index18;
                while (!Main.tile[index7, index19].active() && !Main.tile[index7, index19 - 1].active() && !Main.tile[index7, index19 + 1].active())
                  --index7;
                int num3 = index7 + 1;
                while (!Main.tile[index8, index19].active() && !Main.tile[index8, index19 - 1].active() && !Main.tile[index8, index19 + 1].active())
                  ++index8;
                int num4 = index8 - 1;
                index18 = (num3 + num4) / 2;
                Vector2 vector2_3 = WorldGen.randPictureTile();
                if ((int) Main.tile[index18, index19].wall != roomWall[0])
                  vector2_3 = WorldGen.randBoneTile();
                int x3 = (int) vector2_3.X;
                int y3 = (int) vector2_3.Y;
                if (Math.Abs(num12 - index18) < 4 && !WorldGen.nearPicture(index18, index19))
                  WorldGen.PlaceTile(index18, index19, x3, true, false, -1, y3);
                else
                  break;
              }
              continue;
            default:
              continue;
          }
        }
      }
      return count;
    }

    private static float MakeDungeon_GroundFurniture(int wallType)
    {
      float num1 = (float) (2000.0 * (double) Main.maxTilesX / 4200.0);
      int num2 = 1 + Main.maxTilesX / 4200;
      int num3 = 1 + Main.maxTilesX / 4200;
      for (int index1 = 0; (double) index1 < (double) num1; ++index1)
      {
        if (num2 > 0 || num3 > 0)
          --index1;
        int i1 = WorldGen.genRand.Next(WorldGen.dMinX, WorldGen.dMaxX);
        int j;
        for (j = WorldGen.genRand.Next((int) Main.worldSurface + 10, WorldGen.dMaxY); !Main.wallDungeon[(int) Main.tile[i1, j].wall] || Main.tile[i1, j].active(); j = WorldGen.genRand.Next((int) Main.worldSurface + 10, WorldGen.dMaxY))
          i1 = WorldGen.genRand.Next(WorldGen.dMinX, WorldGen.dMaxX);
        if (Main.wallDungeon[(int) Main.tile[i1, j].wall] && !Main.tile[i1, j].active())
        {
          while (!WorldGen.SolidTile(i1, j, false) && j < Main.UnderworldLayer)
            ++j;
          int index2 = j - 1;
          int i2 = i1;
          int i3 = i1;
          while (!Main.tile[i2, index2].active() && WorldGen.SolidTile(i2, index2 + 1, false))
            --i2;
          int num4 = i2 + 1;
          while (!Main.tile[i3, index2].active() && WorldGen.SolidTile(i3, index2 + 1, false))
            ++i3;
          int num5 = i3 - 1;
          int num6 = num5 - num4;
          int index3 = (num5 + num4) / 2;
          if (!Main.tile[index3, index2].active() && Main.wallDungeon[(int) Main.tile[index3, index2].wall] && (WorldGen.SolidTile(index3, index2 + 1, false) && Main.tile[index3, index2 + 1].type != (ushort) 48))
          {
            int style1 = 13;
            int style2 = 10;
            int style3 = 11;
            int style4 = 1;
            int style5 = 46;
            int style6 = 1;
            int style7 = 5;
            int style8 = 11;
            int style9 = 5;
            int style10 = 6;
            int style11 = 21;
            int style12 = 22;
            int style13 = 24;
            int style14 = 30;
            switch (wallType)
            {
              case 8:
                style1 = 14;
                style2 = 11;
                style3 = 12;
                style4 = 2;
                style5 = 47;
                style6 = 2;
                style7 = 6;
                style8 = 12;
                style9 = 6;
                style10 = 7;
                style11 = 22;
                style12 = 23;
                style13 = 25;
                style14 = 31;
                break;
              case 9:
                style1 = 15;
                style2 = 12;
                style3 = 13;
                style4 = 3;
                style5 = 48;
                style6 = 3;
                style7 = 7;
                style8 = 13;
                style9 = 7;
                style10 = 8;
                style11 = 23;
                style12 = 24;
                style13 = 26;
                style14 = 32;
                break;
            }
            if (Main.tile[index3, index2].wall >= (ushort) 94 && Main.tile[index3, index2].wall <= (ushort) 105)
            {
              style1 = 17;
              style2 = 14;
              style3 = 15;
              style4 = -1;
              style5 = -1;
              style6 = 5;
              style7 = -1;
              style8 = -1;
              style9 = -1;
              style10 = -1;
              style11 = -1;
              style12 = -1;
              style13 = -1;
              style14 = -1;
            }
            int num7 = WorldGen.genRand.Next(13);
            if ((num7 == 10 || num7 == 11 || num7 == 12) && WorldGen.genRand.Next(4) != 0)
              num7 = WorldGen.genRand.Next(13);
            while (num7 == 2 && style5 == -1 || num7 == 5 && style7 == -1 || (num7 == 6 && style8 == -1 || num7 == 7 && style9 == -1) || (num7 == 8 && style10 == -1 || num7 == 9 && style11 == -1 || (num7 == 10 && style12 == -1 || num7 == 11 && style13 == -1)) || num7 == 12 && style14 == -1)
              num7 = WorldGen.genRand.Next(13);
            int num8 = 0;
            int num9 = 0;
            if (num7 == 0)
            {
              num8 = 5;
              num9 = 4;
            }
            if (num7 == 1)
            {
              num8 = 4;
              num9 = 3;
            }
            if (num7 == 2)
            {
              num8 = 3;
              num9 = 5;
            }
            if (num7 == 3)
            {
              num8 = 4;
              num9 = 6;
            }
            if (num7 == 4)
            {
              num8 = 3;
              num9 = 3;
            }
            if (num7 == 5)
            {
              num8 = 5;
              num9 = 3;
            }
            if (num7 == 6)
            {
              num8 = 5;
              num9 = 4;
            }
            if (num7 == 7)
            {
              num8 = 5;
              num9 = 4;
            }
            if (num7 == 8)
            {
              num8 = 5;
              num9 = 4;
            }
            if (num7 == 9)
            {
              num8 = 5;
              num9 = 3;
            }
            if (num7 == 10)
            {
              num8 = 2;
              num9 = 4;
            }
            if (num7 == 11)
            {
              num8 = 3;
              num9 = 3;
            }
            if (num7 == 12)
            {
              num8 = 2;
              num9 = 5;
            }
            for (int index4 = index3 - num8; index4 <= index3 + num8; ++index4)
            {
              for (int index5 = index2 - num9; index5 <= index2; ++index5)
              {
                if (Main.tile[index4, index5].active())
                {
                  num7 = -1;
                  break;
                }
              }
            }
            if ((double) num6 < (double) num8 * 1.75)
              num7 = -1;
            if (num2 > 0 || num3 > 0)
            {
              if (num2 > 0)
              {
                WorldGen.PlaceTile(index3, index2, 355, true, false, -1, 0);
                if (Main.tile[index3, index2].type == (ushort) 355)
                  --num2;
              }
              else if (num3 > 0)
              {
                WorldGen.PlaceTile(index3, index2, 354, true, false, -1, 0);
                if (Main.tile[index3, index2].type == (ushort) 354)
                  --num3;
              }
            }
            else
            {
              switch (num7)
              {
                case 0:
                  WorldGen.PlaceTile(index3, index2, 14, true, false, -1, style2);
                  if (Main.tile[index3, index2].active())
                  {
                    if (!Main.tile[index3 - 2, index2].active())
                    {
                      WorldGen.PlaceTile(index3 - 2, index2, 15, true, false, -1, style1);
                      if (Main.tile[index3 - 2, index2].active())
                      {
                        Main.tile[index3 - 2, index2].frameX += (short) 18;
                        Main.tile[index3 - 2, index2 - 1].frameX += (short) 18;
                      }
                    }
                    if (!Main.tile[index3 + 2, index2].active())
                      WorldGen.PlaceTile(index3 + 2, index2, 15, true, false, -1, style1);
                  }
                  for (int i4 = index3 - 1; i4 <= index3 + 1; ++i4)
                  {
                    if (WorldGen.genRand.Next(2) == 0 && !Main.tile[i4, index2 - 2].active())
                    {
                      int num10 = WorldGen.genRand.Next(5);
                      if (style4 != -1 && num10 <= 1 && !Main.tileLighted[(int) Main.tile[i4 - 1, index2 - 2].type])
                        WorldGen.PlaceTile(i4, index2 - 2, 33, true, false, -1, style4);
                      if (num10 == 2 && !Main.tileLighted[(int) Main.tile[i4 - 1, index2 - 2].type])
                        WorldGen.PlaceTile(i4, index2 - 2, 49, true, false, -1, 0);
                      if (num10 == 3)
                        WorldGen.PlaceTile(i4, index2 - 2, 50, true, false, -1, 0);
                      if (num10 == 4)
                        WorldGen.PlaceTile(i4, index2 - 2, 103, true, false, -1, 0);
                    }
                  }
                  continue;
                case 1:
                  WorldGen.PlaceTile(index3, index2, 18, true, false, -1, style3);
                  if (Main.tile[index3, index2].active())
                  {
                    if (WorldGen.genRand.Next(2) == 0)
                    {
                      if (!Main.tile[index3 - 1, index2].active())
                      {
                        WorldGen.PlaceTile(index3 - 1, index2, 15, true, false, -1, style1);
                        if (Main.tile[index3 - 1, index2].active())
                        {
                          Main.tile[index3 - 1, index2].frameX += (short) 18;
                          Main.tile[index3 - 1, index2 - 1].frameX += (short) 18;
                        }
                      }
                    }
                    else if (!Main.tile[index3 + 2, index2].active())
                      WorldGen.PlaceTile(index3 + 2, index2, 15, true, false, -1, style1);
                    for (int i4 = index3; i4 <= index3 + 1; ++i4)
                    {
                      if (WorldGen.genRand.Next(2) == 0 && !Main.tile[i4, index2 - 1].active())
                      {
                        int num10 = WorldGen.genRand.Next(5);
                        if (style4 != -1 && num10 <= 1 && !Main.tileLighted[(int) Main.tile[i4 - 1, index2 - 1].type])
                          WorldGen.PlaceTile(i4, index2 - 1, 33, true, false, -1, style4);
                        if (num10 == 2 && !Main.tileLighted[(int) Main.tile[i4 - 1, index2 - 1].type])
                          WorldGen.PlaceTile(i4, index2 - 1, 49, true, false, -1, 0);
                        if (num10 == 3)
                          WorldGen.PlaceTile(i4, index2 - 1, 50, true, false, -1, 0);
                        if (num10 == 4)
                          WorldGen.PlaceTile(i4, index2 - 1, 103, true, false, -1, 0);
                      }
                    }
                    continue;
                  }
                  continue;
                case 2:
                  WorldGen.PlaceTile(index3, index2, 105, true, false, -1, style5);
                  continue;
                case 3:
                  WorldGen.PlaceTile(index3, index2, 101, true, false, -1, style6);
                  continue;
                case 4:
                  if (WorldGen.genRand.Next(2) == 0)
                  {
                    WorldGen.PlaceTile(index3, index2, 15, true, false, -1, style1);
                    Main.tile[index3, index2].frameX += (short) 18;
                    Main.tile[index3, index2 - 1].frameX += (short) 18;
                    continue;
                  }
                  WorldGen.PlaceTile(index3, index2, 15, true, false, -1, style1);
                  continue;
                case 5:
                  if (WorldGen.genRand.Next(2) == 0)
                  {
                    WorldGen.Place4x2(index3, index2, (ushort) 79, 1, style7);
                    continue;
                  }
                  WorldGen.Place4x2(index3, index2, (ushort) 79, -1, style7);
                  continue;
                case 6:
                  WorldGen.PlaceTile(index3, index2, 87, true, false, -1, style8);
                  continue;
                case 7:
                  WorldGen.PlaceTile(index3, index2, 88, true, false, -1, style9);
                  continue;
                case 8:
                  WorldGen.PlaceTile(index3, index2, 89, true, false, -1, style10);
                  continue;
                case 9:
                  if (WorldGen.genRand.Next(2) == 0)
                  {
                    WorldGen.Place4x2(index3, index2, (ushort) 90, 1, style11);
                    continue;
                  }
                  WorldGen.Place4x2(index3, index2, (ushort) 90, -1, style11);
                  continue;
                case 10:
                  WorldGen.PlaceTile(index3, index2, 93, true, false, -1, style13);
                  continue;
                case 11:
                  WorldGen.PlaceTile(index3, index2, 100, true, false, -1, style12);
                  continue;
                case 12:
                  WorldGen.PlaceTile(index3, index2, 104, true, false, -1, style14);
                  continue;
                default:
                  continue;
              }
            }
          }
        }
      }
      return num1;
    }

    public static Vector2 randBoneTile()
    {
      int num1 = WorldGen.genRand.Next(2);
      int num2 = 0;
      switch (num1)
      {
        case 0:
          num1 = 240;
          num2 = WorldGen.genRand.Next(2);
          switch (num2)
          {
            case 0:
              num2 = 16;
              break;
            case 1:
              num2 = 17;
              break;
          }
          break;
        case 1:
          num1 = 241;
          num2 = WorldGen.genRand.Next(9);
          break;
      }
      return new Vector2((float) num1, (float) num2);
    }

    public static Vector2 randHellPicture()
    {
      int num1 = WorldGen.genRand.Next(4);
      if (num1 == 1)
        num1 = WorldGen.genRand.Next(4);
      int num2;
      int num3;
      if (num1 == 0)
      {
        num2 = 240;
        num3 = WorldGen.genRand.Next(5);
        switch (num3)
        {
          case 0:
            num3 = 27;
            break;
          case 1:
            num3 = 29;
            break;
          case 2:
            num3 = 30;
            break;
          case 3:
            num3 = 31;
            break;
          case 4:
            num3 = 32;
            break;
        }
      }
      else if (num1 == 1)
      {
        num2 = 242;
        num3 = 14;
      }
      else if (num1 == 2)
      {
        num2 = 245;
        num3 = WorldGen.genRand.Next(3);
        switch (num3)
        {
          case 0:
            num3 = 1;
            break;
          case 1:
            num3 = 2;
            break;
          case 2:
            num3 = 4;
            break;
        }
      }
      else
      {
        num2 = 246;
        num3 = WorldGen.genRand.Next(3);
        switch (num3)
        {
          case 0:
            num3 = 0;
            break;
          case 1:
            num3 = 16;
            break;
          case 2:
            num3 = 17;
            break;
        }
      }
      return new Vector2((float) num2, (float) num3);
    }

    public static Vector2 RandHousePictureDesert()
    {
      int num1 = WorldGen.genRand.Next(4);
      int num2;
      int num3;
      if (num1 <= 1)
      {
        num2 = 240;
        num3 = 63 + WorldGen.genRand.Next(6);
      }
      else if (num1 == 2)
      {
        num2 = 245;
        num3 = 7 + WorldGen.genRand.Next(2);
      }
      else
      {
        num2 = 242;
        num3 = 37 + WorldGen.genRand.Next(6);
      }
      return new Vector2((float) num2, (float) num3);
    }

    public static Vector2 randHousePicture()
    {
      int num1 = WorldGen.genRand.Next(4);
      if (num1 >= 3 && WorldGen.genRand.Next(10) != 0)
        num1 = WorldGen.genRand.Next(3);
      int num2;
      int num3;
      if (num1 <= 1)
      {
        num2 = 240;
        int maxValue = 10;
        num3 = WorldGen.genRand.Next(maxValue);
        if (num3 == 9)
          num3 = WorldGen.genRand.Next(maxValue);
        if (num3 == 5)
          num3 = WorldGen.genRand.Next(maxValue);
        if (num3 == 6)
          num3 = WorldGen.genRand.Next(maxValue);
        if (num3 == 0)
          num3 = 26;
        else if (num3 == 1)
          num3 = 28;
        else if (num3 == 2)
          num3 = 20;
        else if (num3 == 3)
          num3 = 21;
        else if (num3 == 4)
          num3 = 22;
        else if (num3 == 5)
          num3 = 24;
        else if (num3 == 6)
          num3 = 25;
        else if (num3 == 7)
          num3 = 33;
        else if (num3 == 8)
          num3 = 34;
        else if (num3 == 9)
          num3 = 35;
      }
      else if (num1 == 2)
      {
        int maxValue = 4;
        num2 = 245;
        num3 = WorldGen.genRand.Next(maxValue);
        if (num3 == 2)
          num3 = WorldGen.genRand.Next(maxValue);
        if (num3 == 0)
          num3 = WorldGen.genRand.Next(maxValue);
        if (num3 == 0)
          num3 = WorldGen.genRand.Next(maxValue);
        if (num3 == 0)
          num3 = WorldGen.genRand.Next(maxValue);
        if (num3 == 0)
          num3 = 0;
        else if (num3 == 1)
          num3 = 3;
        else if (num3 == 2)
          num3 = 5;
        else if (num3 == 3)
          num3 = 6;
      }
      else
      {
        num2 = 246;
        num3 = 1;
      }
      return new Vector2((float) num2, (float) num3);
    }

    public static Vector2 randPictureTile()
    {
      int num1 = WorldGen.genRand.Next(3);
      int num2 = 0;
      if (num1 <= 1)
      {
        int maxValue = 7;
        num1 = 240;
        num2 = WorldGen.genRand.Next(maxValue);
        if (num2 == 6)
          num2 = WorldGen.genRand.Next(maxValue);
        if (num2 == 0)
          num2 = 12;
        else if (num2 == 1)
          num2 = 13;
        else if (num2 == 2)
          num2 = 14;
        else if (num2 == 3)
          num2 = 15;
        else if (num2 == 4)
          num2 = 18;
        else if (num2 == 5)
          num2 = 19;
        else if (num2 == 6)
          num2 = 23;
      }
      else if (num1 == 2)
      {
        num1 = 242;
        num2 = WorldGen.genRand.Next(17);
        if (num2 > 13)
        {
          switch (num2)
          {
            case 14:
              num2 = 15;
              break;
            case 15:
              num2 = 16;
              break;
            case 16:
              num2 = 30;
              break;
          }
        }
      }
      return new Vector2((float) num1, (float) num2);
    }

    public static void DungeonStairs(int i, int j, ushort tileType, int wallType)
    {
      Vector2 zero = Vector2.Zero;
      double num1 = (double) WorldGen.genRand.Next(5, 9);
      int num2 = 1;
      Vector2 vector2;
      vector2.X = (float) i;
      vector2.Y = (float) j;
      int num3 = WorldGen.genRand.Next(10, 30);
      int num4 = i <= WorldGen.dEnteranceX ? 1 : -1;
      if (i > Main.maxTilesX - 400)
        num4 = -1;
      else if (i < 400)
        num4 = 1;
      zero.Y = -1f;
      zero.X = (float) num4;
      if (WorldGen.genRand.Next(3) != 0)
        zero.X *= (float) (1.0 + (double) WorldGen.genRand.Next(0, 200) * 0.00999999977648258);
      else if (WorldGen.genRand.Next(3) == 0)
        zero.X *= (float) WorldGen.genRand.Next(50, 76) * 0.01f;
      else if (WorldGen.genRand.Next(6) == 0)
        zero.Y *= 2f;
      if (WorldGen.dungeonX < Main.maxTilesX / 2 && (double) zero.X < 0.0 && (double) zero.X < 0.5)
        zero.X = -0.5f;
      if (WorldGen.dungeonX > Main.maxTilesX / 2 && (double) zero.X > 0.0 && (double) zero.X > 0.5)
        zero.X = -0.5f;
      if (WorldGen.drunkWorldGen)
      {
        num2 = num4 * -1;
        zero.X *= -1f;
      }
      while (num3 > 0)
      {
        --num3;
        int num5 = (int) ((double) vector2.X - num1 - 4.0 - (double) WorldGen.genRand.Next(6));
        int num6 = (int) ((double) vector2.X + num1 + 4.0 + (double) WorldGen.genRand.Next(6));
        int num7 = (int) ((double) vector2.Y - num1 - 4.0);
        int num8 = (int) ((double) vector2.Y + num1 + 4.0 + (double) WorldGen.genRand.Next(6));
        if (num5 < 0)
          num5 = 0;
        if (num6 > Main.maxTilesX)
          num6 = Main.maxTilesX;
        if (num7 < 0)
          num7 = 0;
        if (num8 > Main.maxTilesY)
          num8 = Main.maxTilesY;
        int num9 = 1;
        if ((double) vector2.X > (double) (Main.maxTilesX / 2))
          num9 = -1;
        int i1 = (int) ((double) vector2.X + WorldGen.dxStrength1 * 0.600000023841858 * (double) num9 + WorldGen.dxStrength2 * (double) num9);
        int num10 = (int) (WorldGen.dyStrength2 * 0.5);
        if ((double) vector2.Y < Main.worldSurface - 5.0 && Main.tile[i1, (int) ((double) vector2.Y - num1 - 6.0 + (double) num10)].wall == (ushort) 0 && (Main.tile[i1, (int) ((double) vector2.Y - num1 - 7.0 + (double) num10)].wall == (ushort) 0 && Main.tile[i1, (int) ((double) vector2.Y - num1 - 8.0 + (double) num10)].wall == (ushort) 0))
        {
          WorldGen.dSurface = true;
          WorldGen.TileRunner(i1, (int) ((double) vector2.Y - num1 - 6.0 + (double) num10), (double) WorldGen.genRand.Next(25, 35), WorldGen.genRand.Next(10, 20), -1, false, 0.0f, -1f, false, true, -1);
        }
        for (int index1 = num5; index1 < num6; ++index1)
        {
          for (int index2 = num7; index2 < num8; ++index2)
          {
            Main.tile[index1, index2].liquid = (byte) 0;
            if (!Main.wallDungeon[(int) Main.tile[index1, index2].wall])
            {
              Main.tile[index1, index2].wall = (ushort) 0;
              Main.tile[index1, index2].active(true);
              Main.tile[index1, index2].type = tileType;
            }
          }
        }
        for (int index1 = num5 + 1; index1 < num6 - 1; ++index1)
        {
          for (int index2 = num7 + 1; index2 < num8 - 1; ++index2)
            Main.tile[index1, index2].wall = (ushort) wallType;
        }
        int num11 = 0;
        if (WorldGen.genRand.Next((int) num1) == 0)
          num11 = WorldGen.genRand.Next(1, 3);
        int num12 = (int) ((double) vector2.X - num1 * 0.5 - (double) num11);
        int num13 = (int) ((double) vector2.X + num1 * 0.5 + (double) num11);
        int num14 = (int) ((double) vector2.Y - num1 * 0.5 - (double) num11);
        int num15 = (int) ((double) vector2.Y + num1 * 0.5 + (double) num11);
        if (num12 < 0)
          num12 = 0;
        if (num13 > Main.maxTilesX)
          num13 = Main.maxTilesX;
        if (num14 < 0)
          num14 = 0;
        if (num15 > Main.maxTilesY)
          num15 = Main.maxTilesY;
        for (int i2 = num12; i2 < num13; ++i2)
        {
          for (int j1 = num14; j1 < num15; ++j1)
          {
            Main.tile[i2, j1].active(false);
            WorldGen.PlaceWall(i2, j1, wallType, true);
          }
        }
        if (WorldGen.dSurface)
          num3 = 0;
        vector2 += zero;
        if ((double) vector2.Y < Main.worldSurface)
          zero.Y *= 0.98f;
      }
      WorldGen.dungeonX = (int) vector2.X;
      WorldGen.dungeonY = (int) vector2.Y;
    }

    public static bool PlaceSandTrap(int i, int j)
    {
      int num1 = 6;
      int num2 = 4;
      int num3 = 25;
      int i1 = i;
      int index1 = j;
      while (!Main.tile[i1, index1].active() && index1 < Main.UnderworldLayer)
        ++index1;
      if (!Main.tileSolid[(int) Main.tile[i1, index1].type] || Main.tile[i1, index1].halfBrick() || Main.tile[i1, index1].topSlope() || Main.tile[i1, index1].type != (ushort) 53 && Main.tile[i1, index1].type != (ushort) 397 && Main.tile[i1, index1].type != (ushort) 396 || Main.tile[i1, index1].wall != (ushort) 216 && Main.tile[i1, index1].wall != (ushort) 187)
        return false;
      int j1 = index1 - 1;
      int num4 = -1;
      int num5 = WorldGen.genRand.Next(6, 12);
      int num6 = WorldGen.genRand.Next(6, 14);
      for (int index2 = i1 - num3; index2 <= i1 + num3; ++index2)
      {
        for (int index3 = j1 - num3; index3 < j1 + num3; ++index3)
        {
          if (Main.tile[index2, index3].wire() || TileID.Sets.BasicChest[(int) Main.tile[index2, index3].type] || (TileID.Sets.Paintings[(int) Main.tile[index2, index3].type] || Main.tile[index2, index3].type == (ushort) 10) || (Main.tile[index2, index3].type == (ushort) 19 || Main.tile[index2, index3].type == (ushort) 15 || Main.tile[index2, index3].type == (ushort) 219))
            return false;
        }
      }
      for (int index2 = i1 - 2; index2 <= i1 + 2; ++index2)
      {
        for (int index3 = j1 + 1; index3 <= j1 + 3; ++index3)
        {
          if (!Main.tile[index2, index3].active() || !Main.tileSolid[(int) Main.tile[index2, index3].type])
            return false;
        }
      }
      for (int index2 = j1; index2 > j1 - 30; --index2)
      {
        if (Main.tile[i1, index2].active())
        {
          if (Main.tile[i1, index2].type != (ushort) 396)
            return false;
          num4 = index2;
          break;
        }
      }
      if (num4 <= -1 || j1 - num4 < num6 + num2)
        return false;
      int num7 = 0;
      int index4 = (j1 + num4) / 2;
      for (int index2 = i1 - num5; index2 <= i1 + num5; ++index2)
      {
        if (Main.tile[index2, index4].active() && Main.tileSolid[(int) Main.tile[index2, index4].type])
          return false;
        for (int index3 = num4 - num6; index3 <= num4; ++index3)
        {
          if (Main.tile[index2, index3].active())
          {
            if (TileID.Sets.Ore[(int) Main.tile[index2, index3].type] || Main.tile[index2, index3].type == (ushort) 404)
              return false;
            if (Main.tileSolid[(int) Main.tile[index2, index3].type])
              ++num7;
          }
        }
      }
      float num8 = (float) ((num5 * 2 + 1) * (num6 + 1)) * 0.75f;
      if ((double) num7 < (double) num8)
        return false;
      for (int index2 = i1 - num5 - 1; index2 <= i1 + num5 + 1; ++index2)
      {
        for (int index3 = num4 - num6; index3 <= num4; ++index3)
        {
          bool flag = false;
          if (Main.tile[index2, index3].active() && Main.tileSolid[(int) Main.tile[index2, index3].type])
            flag = true;
          if (index3 == num4)
          {
            Main.tile[index2, index3].slope((byte) 0);
            Main.tile[index2, index3].halfBrick(false);
            if (!flag)
            {
              Main.tile[index2, index3].active(true);
              Main.tile[index2, index3].type = (ushort) 396;
            }
          }
          else if (index3 == num4 - num6)
          {
            Main.tile[index2, index3].ClearTile();
            Main.tile[index2, index3].active(true);
            Main.tile[index2, index3].type = !flag || !Main.tile[index2, index3 - 1].active() || !Main.tileSolid[(int) Main.tile[index2, index3 - 1].type] ? (ushort) 396 : (ushort) 397;
          }
          else if (index2 == i1 - num5 - 1 || index2 == i1 + num5 + 1)
          {
            if (!flag)
            {
              Main.tile[index2, index3].ClearTile();
              Main.tile[index2, index3].active(true);
              Main.tile[index2, index3].type = (ushort) 396;
            }
            else
            {
              Main.tile[index2, index3].slope((byte) 0);
              Main.tile[index2, index3].halfBrick(false);
            }
          }
          else
          {
            Main.tile[index2, index3].ClearTile();
            Main.tile[index2, index3].active(true);
            Main.tile[index2, index3].type = (ushort) 53;
          }
        }
      }
      for (int index2 = (int) ((double) num4 - (double) num6 * 0.666000008583069); (double) index2 <= (double) num4 - (double) num6 * 0.333; ++index2)
      {
        if ((double) index2 < (double) num4 - (double) num6 * 0.400000005960464)
        {
          if (Main.tile[i1 - num5 - 2, index2].bottomSlope())
            Main.tile[i1 - num5 - 2, index2].slope((byte) 0);
        }
        else if ((double) index2 > (double) num4 - (double) num6 * 0.600000023841858)
        {
          if (Main.tile[i1 - num5 - 2, index2].topSlope())
            Main.tile[i1 - num5 - 2, index2].slope((byte) 0);
          Main.tile[i1 - num5 - 2, index2].halfBrick(false);
        }
        else
        {
          Main.tile[i1 - num5 - 2, index2].halfBrick(false);
          Main.tile[i1 - num5 - 2, index2].slope((byte) 0);
        }
        if (!Main.tile[i1 - num5 - 2, index2].active() || !Main.tileSolid[(int) Main.tile[i1 - num5 - 2, index2].type])
        {
          Main.tile[i1 - num5 - 2, index2].active(true);
          Main.tile[i1 - num5 - 2, index2].type = (ushort) 396;
        }
        if (!Main.tile[i1 + num5 + 2, index2].active() || !Main.tileSolid[(int) Main.tile[i1 + num5 + 2, index2].type])
        {
          Main.tile[i1 + num5 + 2, index2].active(true);
          Main.tile[i1 + num5 + 2, index2].type = (ushort) 396;
        }
      }
      for (int index2 = num4 - num6; index2 <= num4; ++index2)
      {
        Main.tile[i1 - num5 - 2, index2].slope((byte) 0);
        Main.tile[i1 - num5 - 2, index2].halfBrick(false);
        Main.tile[i1 - num5 - 1, index2].slope((byte) 0);
        Main.tile[i1 - num5 - 1, index2].halfBrick(false);
        Main.tile[i1 - num5 + 1, index2].slope((byte) 0);
        Main.tile[i1 - num5 + 1, index2].halfBrick(false);
        Main.tile[i1 - num5 + 2, index2].slope((byte) 0);
        Main.tile[i1 - num5 + 2, index2].halfBrick(false);
      }
      for (int index2 = i1 - num5 - 1; index2 < i1 + num5 + 1; ++index2)
      {
        int index3 = j1 - num6 - 1;
        if (Main.tile[index2, index3].bottomSlope())
          Main.tile[index2, index3].slope((byte) 0);
        Main.tile[index2, index3].halfBrick(false);
      }
      WorldGen.KillTile(i1 - 2, j1, false, false, false);
      WorldGen.KillTile(i1 - 1, j1, false, false, false);
      WorldGen.KillTile(i1 + 1, j1, false, false, false);
      WorldGen.KillTile(i1 + 2, j1, false, false, false);
      WorldGen.PlaceTile(i1, j1, 135, true, false, -1, 7);
      for (int i2 = i1 - num5; i2 <= i1 + num5; ++i2)
      {
        int num9 = j1;
        if ((double) i2 < (double) i1 - (double) num5 * 0.8 || (double) i2 > (double) i1 + (double) num5 * 0.8)
          num9 = j1 - 3;
        else if ((double) i2 < (double) i1 - (double) num5 * 0.6 || (double) i2 > (double) i1 + (double) num5 * 0.6)
          num9 = j1 - 2;
        else if ((double) i2 < (double) i1 - (double) num5 * 0.4 || (double) i2 > (double) i1 + (double) num5 * 0.4)
          num9 = j1 - 1;
        for (int j2 = num4; j2 <= j1; ++j2)
        {
          if (i2 == i1 && j2 <= j1)
            Main.tile[i1, j2].wire(true);
          if (Main.tile[i2, j2].active() && Main.tileSolid[(int) Main.tile[i2, j2].type])
          {
            if (j2 < num4 + num1 - 4)
            {
              Main.tile[i2, j2].actuator(true);
              Main.tile[i2, j2].wire(true);
            }
            else if (j2 < num9)
              WorldGen.KillTile(i2, j2, false, false, false);
          }
        }
      }
      return true;
    }

    public static bool DungeonPitTrap(int i, int j, ushort tileType, int wallType)
    {
      int num1 = 30;
      int i1 = i;
      int index1 = j;
      int num2 = index1;
      int num3 = WorldGen.genRand.Next(8, 19);
      int num4 = WorldGen.genRand.Next(19, 46);
      int num5 = num3 + WorldGen.genRand.Next(6, 10);
      int num6 = num4 + WorldGen.genRand.Next(6, 10);
      if (!Main.wallDungeon[(int) Main.tile[i1, index1].wall] || Main.tile[i1, index1].active())
        return false;
      for (int j1 = index1; j1 < Main.maxTilesY; ++j1)
      {
        if (j1 > Main.maxTilesY - 300)
          return false;
        if (Main.tile[i1, j1].active() && WorldGen.SolidTile(i1, j1, false))
        {
          if (Main.tile[i1, j1].type == (ushort) 48)
            return false;
          index1 = j1;
          break;
        }
      }
      if (!Main.wallDungeon[(int) Main.tile[i1 - num3, index1].wall] || !Main.wallDungeon[(int) Main.tile[i1 + num3, index1].wall])
        return false;
      for (int index2 = index1; index2 < index1 + num1; ++index2)
      {
        bool flag = true;
        for (int index3 = i1 - num3; index3 <= i1 + num3; ++index3)
        {
          Tile tile = Main.tile[index3, index2];
          if (tile.active() && Main.tileDungeon[(int) tile.type])
            flag = false;
        }
        if (flag)
        {
          index1 = index2;
          break;
        }
      }
      for (int index2 = i1 - num3; index2 <= i1 + num3; ++index2)
      {
        for (int index3 = index1; index3 <= index1 + num4; ++index3)
        {
          Tile tile = Main.tile[index2, index3];
          if (tile.active() && (Main.tileDungeon[(int) tile.type] || (int) tile.type == (int) WorldGen.crackedType))
            return false;
        }
      }
      bool flag1 = false;
      if (WorldGen.dungeonLake)
      {
        flag1 = true;
        WorldGen.dungeonLake = false;
      }
      else if (WorldGen.genRand.Next(8) == 0)
        flag1 = true;
      for (int index2 = i1 - num3; index2 <= i1 + num3; ++index2)
      {
        for (int index3 = num2; index3 <= index1 + num4; ++index3)
        {
          if (Main.tileDungeon[(int) Main.tile[index2, index3].type])
          {
            Main.tile[index2, index3].type = WorldGen.crackedType;
            Main.tile[index2, index3].wall = (ushort) wallType;
          }
        }
      }
      for (int index2 = i1 - num5; index2 <= i1 + num5; ++index2)
      {
        for (int index3 = num2; index3 <= index1 + num6; ++index3)
        {
          Main.tile[index2, index3].lava(false);
          Main.tile[index2, index3].liquid = (byte) 0;
          if (!Main.wallDungeon[(int) Main.tile[index2, index3].wall] && (int) Main.tile[index2, index3].type != (int) WorldGen.crackedType)
          {
            Main.tile[index2, index3].Clear(TileDataType.Slope);
            Main.tile[index2, index3].type = tileType;
            Main.tile[index2, index3].active(true);
            if (index2 > i1 - num5 && index2 < i1 + num5 && index3 < index1 + num6)
              Main.tile[index2, index3].wall = (ushort) wallType;
          }
        }
      }
      for (int index2 = i1 - num3; index2 <= i1 + num3; ++index2)
      {
        for (int index3 = num2; index3 <= index1 + num4; ++index3)
        {
          if ((int) Main.tile[index2, index3].type != (int) WorldGen.crackedType)
          {
            if (flag1)
              Main.tile[index2, index3].liquid = byte.MaxValue;
            if (index2 == i1 - num3 || index2 == i1 + num3 || index3 == index1 + num4)
              Main.tile[index2, index3].type = (ushort) 48;
            else if (index2 == i1 - num3 + 1 && index3 % 2 == 0 || index2 == i1 + num3 - 1 && index3 % 2 == 0 || index3 == index1 + num4 - 1 && index2 % 2 == 0)
              Main.tile[index2, index3].type = (ushort) 48;
            else
              Main.tile[index2, index3].active(false);
          }
        }
      }
      return true;
    }

    public static void DungeonHalls(int i, int j, ushort tileType, int wallType, bool forceX = false)
    {
      Vector2 zero1 = Vector2.Zero;
      double num1 = (double) WorldGen.genRand.Next(4, 6);
      double num2 = num1;
      Vector2 zero2 = Vector2.Zero;
      Vector2 zero3 = Vector2.Zero;
      Vector2 vector2;
      vector2.X = (float) i;
      vector2.Y = (float) j;
      int num3 = WorldGen.genRand.Next(35, 80);
      bool flag1 = false;
      if (WorldGen.genRand.Next(5) == 0)
        flag1 = true;
      if (forceX)
      {
        num3 += 20;
        WorldGen.lastDungeonHall = Vector2.Zero;
      }
      else if (WorldGen.genRand.Next(5) == 0)
      {
        num1 *= 2.0;
        num3 /= 2;
      }
      bool flag2 = false;
      bool flag3 = false;
      bool flag4 = true;
      while (!flag2)
      {
        bool flag5 = false;
        int num4;
        if (flag4 && !forceX)
        {
          bool flag6 = true;
          bool flag7 = true;
          bool flag8 = true;
          bool flag9 = true;
          int num5 = num3;
          bool flag10 = false;
          for (int index1 = j; index1 > j - num5; --index1)
          {
            int index2 = i;
            if ((int) Main.tile[index2, index1].wall == wallType)
            {
              if (flag10)
              {
                flag6 = false;
                break;
              }
            }
            else
              flag10 = true;
          }
          bool flag11 = false;
          for (int index1 = j; index1 < j + num5; ++index1)
          {
            int index2 = i;
            if ((int) Main.tile[index2, index1].wall == wallType)
            {
              if (flag11)
              {
                flag7 = false;
                break;
              }
            }
            else
              flag11 = true;
          }
          bool flag12 = false;
          for (int index1 = i; index1 > i - num5; --index1)
          {
            int index2 = j;
            if ((int) Main.tile[index1, index2].wall == wallType)
            {
              if (flag12)
              {
                flag8 = false;
                break;
              }
            }
            else
              flag12 = true;
          }
          bool flag13 = false;
          for (int index1 = i; index1 < i + num5; ++index1)
          {
            int index2 = j;
            if ((int) Main.tile[index1, index2].wall == wallType)
            {
              if (flag13)
              {
                flag9 = false;
                break;
              }
            }
            else
              flag13 = true;
          }
          if (!flag8 && !flag9 && (!flag6 && !flag7))
          {
            num4 = WorldGen.genRand.Next(2) != 0 ? 1 : -1;
            if (WorldGen.genRand.Next(2) == 0)
              flag5 = true;
          }
          else
          {
            WorldGen.genRand.Next(4);
            int num6;
            do
            {
              num6 = WorldGen.genRand.Next(4);
            }
            while (!(num6 == 0 & flag6) && !(num6 == 1 & flag7) && (!(num6 == 2 & flag8) && !(num6 == 3 & flag9)));
            switch (num6)
            {
              case 0:
                num4 = -1;
                break;
              case 1:
                num4 = 1;
                break;
              default:
                flag5 = true;
                num4 = num6 != 2 ? 1 : -1;
                break;
            }
          }
        }
        else
        {
          num4 = WorldGen.genRand.Next(2) != 0 ? 1 : -1;
          if (WorldGen.genRand.Next(2) == 0)
            flag5 = true;
        }
        flag4 = false;
        if (forceX)
          flag5 = true;
        if (flag5)
        {
          zero2.Y = 0.0f;
          zero2.X = (float) num4;
          zero3.Y = 0.0f;
          zero3.X = (float) -num4;
          zero1.Y = 0.0f;
          zero1.X = (float) num4;
          if (WorldGen.genRand.Next(3) == 0)
            zero1.Y = WorldGen.genRand.Next(2) != 0 ? 0.2f : -0.2f;
        }
        else
        {
          ++num1;
          zero1.Y = (float) num4;
          zero1.X = 0.0f;
          zero2.X = 0.0f;
          zero2.Y = (float) num4;
          zero3.X = 0.0f;
          zero3.Y = (float) -num4;
          if (WorldGen.genRand.Next(3) != 0)
          {
            flag3 = true;
            zero1.X = WorldGen.genRand.Next(2) != 0 ? (float) -WorldGen.genRand.Next(10, 20) * 0.1f : (float) WorldGen.genRand.Next(10, 20) * 0.1f;
          }
          else if (WorldGen.genRand.Next(2) == 0)
            zero1.X = WorldGen.genRand.Next(2) != 0 ? (float) -WorldGen.genRand.Next(20, 40) * 0.01f : (float) WorldGen.genRand.Next(20, 40) * 0.01f;
          else
            num3 /= 2;
        }
        if (WorldGen.lastDungeonHall != zero3)
          flag2 = true;
      }
      int num7 = 0;
      if (!forceX)
      {
        if ((double) vector2.X > (double) (WorldGen.lastMaxTilesX - 200))
        {
          int num4 = -1;
          zero2.Y = 0.0f;
          zero2.X = (float) num4;
          zero1.Y = 0.0f;
          zero1.X = (float) num4;
          if (WorldGen.genRand.Next(3) == 0)
            zero1.Y = WorldGen.genRand.Next(2) != 0 ? 0.2f : -0.2f;
        }
        else if ((double) vector2.X < 200.0)
        {
          int num4 = 1;
          zero2.Y = 0.0f;
          zero2.X = (float) num4;
          zero1.Y = 0.0f;
          zero1.X = (float) num4;
          if (WorldGen.genRand.Next(3) == 0)
            zero1.Y = WorldGen.genRand.Next(2) != 0 ? 0.2f : -0.2f;
        }
        else if ((double) vector2.Y > (double) (WorldGen.lastMaxTilesY - 300))
        {
          int num4 = -1;
          ++num1;
          zero1.Y = (float) num4;
          zero1.X = 0.0f;
          zero2.X = 0.0f;
          zero2.Y = (float) num4;
          if (WorldGen.genRand.Next(2) == 0)
            zero1.X = WorldGen.genRand.Next(2) != 0 ? (float) -WorldGen.genRand.Next(20, 50) * 0.01f : (float) WorldGen.genRand.Next(20, 50) * 0.01f;
        }
        else if ((double) vector2.Y < Main.rockLayer + 100.0)
        {
          int num4 = 1;
          ++num1;
          zero1.Y = (float) num4;
          zero1.X = 0.0f;
          zero2.X = 0.0f;
          zero2.Y = (float) num4;
          if (WorldGen.genRand.Next(3) != 0)
          {
            flag3 = true;
            zero1.X = WorldGen.genRand.Next(2) != 0 ? (float) -WorldGen.genRand.Next(10, 20) * 0.1f : (float) WorldGen.genRand.Next(10, 20) * 0.1f;
          }
          else if (WorldGen.genRand.Next(2) == 0)
            zero1.X = WorldGen.genRand.Next(2) != 0 ? (float) WorldGen.genRand.Next(20, 50) * 0.01f : (float) WorldGen.genRand.Next(20, 50) * 0.01f;
        }
        else if ((double) vector2.X < (double) (Main.maxTilesX / 2) && (double) vector2.X > (double) Main.maxTilesX * 0.25)
        {
          int num4 = -1;
          zero2.Y = 0.0f;
          zero2.X = (float) num4;
          zero1.Y = 0.0f;
          zero1.X = (float) num4;
          if (WorldGen.genRand.Next(3) == 0)
            zero1.Y = WorldGen.genRand.Next(2) != 0 ? 0.2f : -0.2f;
        }
        else if ((double) vector2.X > (double) (Main.maxTilesX / 2) && (double) vector2.X < (double) Main.maxTilesX * 0.75)
        {
          int num4 = 1;
          zero2.Y = 0.0f;
          zero2.X = (float) num4;
          zero1.Y = 0.0f;
          zero1.X = (float) num4;
          if (WorldGen.genRand.Next(3) == 0)
            zero1.Y = WorldGen.genRand.Next(2) != 0 ? 0.2f : -0.2f;
        }
      }
      if ((double) zero2.Y == 0.0)
      {
        WorldGen.DDoorX[WorldGen.numDDoors] = (int) vector2.X;
        WorldGen.DDoorY[WorldGen.numDDoors] = (int) vector2.Y;
        WorldGen.DDoorPos[WorldGen.numDDoors] = 0;
        ++WorldGen.numDDoors;
      }
      else
      {
        WorldGen.dungeonPlatformX[WorldGen.numDungeonPlatforms] = (int) vector2.X;
        WorldGen.dungeonPlatformY[WorldGen.numDungeonPlatforms] = (int) vector2.Y;
        ++WorldGen.numDungeonPlatforms;
      }
      WorldGen.lastDungeonHall = zero2;
      if ((double) Math.Abs(zero1.X) > (double) Math.Abs(zero1.Y) && WorldGen.genRand.Next(3) != 0)
        num1 = (double) (int) (num2 * ((double) WorldGen.genRand.Next(110, 150) * 0.01));
      while (num3 > 0)
      {
        ++num7;
        if ((double) zero2.X > 0.0 && (double) vector2.X > (double) (Main.maxTilesX - 100))
          num3 = 0;
        else if ((double) zero2.X < 0.0 && (double) vector2.X < 100.0)
          num3 = 0;
        else if ((double) zero2.Y > 0.0 && (double) vector2.Y > (double) (Main.maxTilesY - 100))
          num3 = 0;
        else if ((double) zero2.Y < 0.0 && (double) vector2.Y < Main.rockLayer + 50.0)
          num3 = 0;
        --num3;
        int num4 = (int) ((double) vector2.X - num1 - 4.0 - (double) WorldGen.genRand.Next(6));
        int num5 = (int) ((double) vector2.X + num1 + 4.0 + (double) WorldGen.genRand.Next(6));
        int num6 = (int) ((double) vector2.Y - num1 - 4.0 - (double) WorldGen.genRand.Next(6));
        int num8 = (int) ((double) vector2.Y + num1 + 4.0 + (double) WorldGen.genRand.Next(6));
        if (num4 < 0)
          num4 = 0;
        if (num5 > Main.maxTilesX)
          num5 = Main.maxTilesX;
        if (num6 < 0)
          num6 = 0;
        if (num8 > Main.maxTilesY)
          num8 = Main.maxTilesY;
        for (int index1 = num4; index1 < num5; ++index1)
        {
          for (int index2 = num6; index2 < num8; ++index2)
          {
            if (index1 < WorldGen.dMinX)
              WorldGen.dMinX = index1;
            if (index1 > WorldGen.dMaxX)
              WorldGen.dMaxX = index1;
            if (index2 > WorldGen.dMaxY)
              WorldGen.dMaxY = index2;
            Main.tile[index1, index2].liquid = (byte) 0;
            if (!Main.wallDungeon[(int) Main.tile[index1, index2].wall])
            {
              Main.tile[index1, index2].active(true);
              Main.tile[index1, index2].type = tileType;
              Main.tile[index1, index2].Clear(TileDataType.Slope);
            }
          }
        }
        for (int index1 = num4 + 1; index1 < num5 - 1; ++index1)
        {
          for (int index2 = num6 + 1; index2 < num8 - 1; ++index2)
            Main.tile[index1, index2].wall = (ushort) wallType;
        }
        int num9 = 0;
        if ((double) zero1.Y == 0.0 && WorldGen.genRand.Next((int) num1 + 1) == 0)
          num9 = WorldGen.genRand.Next(1, 3);
        else if ((double) zero1.X == 0.0 && WorldGen.genRand.Next((int) num1 - 1) == 0)
          num9 = WorldGen.genRand.Next(1, 3);
        else if (WorldGen.genRand.Next((int) num1 * 3) == 0)
          num9 = WorldGen.genRand.Next(1, 3);
        int num10 = (int) ((double) vector2.X - num1 * 0.5 - (double) num9);
        int num11 = (int) ((double) vector2.X + num1 * 0.5 + (double) num9);
        int num12 = (int) ((double) vector2.Y - num1 * 0.5 - (double) num9);
        int num13 = (int) ((double) vector2.Y + num1 * 0.5 + (double) num9);
        if (num10 < 0)
          num10 = 0;
        if (num11 > Main.maxTilesX)
          num11 = Main.maxTilesX;
        if (num12 < 0)
          num12 = 0;
        if (num13 > Main.maxTilesY)
          num13 = Main.maxTilesY;
        for (int index1 = num10; index1 < num11; ++index1)
        {
          for (int index2 = num12; index2 < num13; ++index2)
          {
            Main.tile[index1, index2].Clear(TileDataType.Slope);
            if (flag1)
            {
              if (Main.tile[index1, index2].active() || (int) Main.tile[index1, index2].wall != wallType)
              {
                Main.tile[index1, index2].active(true);
                Main.tile[index1, index2].type = WorldGen.crackedType;
              }
            }
            else
              Main.tile[index1, index2].active(false);
            Main.tile[index1, index2].Clear(TileDataType.Slope);
            Main.tile[index1, index2].wall = (ushort) wallType;
          }
        }
        vector2 += zero1;
        if (flag3 && num7 > WorldGen.genRand.Next(10, 20))
        {
          num7 = 0;
          zero1.X *= -1f;
        }
      }
      WorldGen.dungeonX = (int) vector2.X;
      WorldGen.dungeonY = (int) vector2.Y;
      if ((double) zero2.Y == 0.0)
      {
        WorldGen.DDoorX[WorldGen.numDDoors] = (int) vector2.X;
        WorldGen.DDoorY[WorldGen.numDDoors] = (int) vector2.Y;
        WorldGen.DDoorPos[WorldGen.numDDoors] = 0;
        ++WorldGen.numDDoors;
      }
      else
      {
        WorldGen.dungeonPlatformX[WorldGen.numDungeonPlatforms] = (int) vector2.X;
        WorldGen.dungeonPlatformY[WorldGen.numDungeonPlatforms] = (int) vector2.Y;
        ++WorldGen.numDungeonPlatforms;
      }
    }

    public static void DungeonRoom(int i, int j, ushort tileType, int wallType)
    {
      double num1 = (double) WorldGen.genRand.Next(15, 30);
      Vector2 vector2_1;
      vector2_1.X = (float) WorldGen.genRand.Next(-10, 11) * 0.1f;
      vector2_1.Y = (float) WorldGen.genRand.Next(-10, 11) * 0.1f;
      Vector2 vector2_2;
      vector2_2.X = (float) i;
      vector2_2.Y = (float) j - (float) num1 / 2f;
      int num2 = WorldGen.genRand.Next(10, 20);
      double num3 = (double) vector2_2.X;
      double num4 = (double) vector2_2.X;
      double num5 = (double) vector2_2.Y;
      double num6 = (double) vector2_2.Y;
      while (num2 > 0)
      {
        --num2;
        int num7 = (int) ((double) vector2_2.X - num1 * 0.800000011920929 - 5.0);
        int num8 = (int) ((double) vector2_2.X + num1 * 0.800000011920929 + 5.0);
        int num9 = (int) ((double) vector2_2.Y - num1 * 0.800000011920929 - 5.0);
        int num10 = (int) ((double) vector2_2.Y + num1 * 0.800000011920929 + 5.0);
        if (num7 < 0)
          num7 = 0;
        if (num8 > Main.maxTilesX)
          num8 = Main.maxTilesX;
        if (num9 < 0)
          num9 = 0;
        if (num10 > Main.maxTilesY)
          num10 = Main.maxTilesY;
        for (int index1 = num7; index1 < num8; ++index1)
        {
          for (int index2 = num9; index2 < num10; ++index2)
          {
            if (index1 < WorldGen.dMinX)
              WorldGen.dMinX = index1;
            if (index1 > WorldGen.dMaxX)
              WorldGen.dMaxX = index1;
            if (index2 > WorldGen.dMaxY)
              WorldGen.dMaxY = index2;
            Main.tile[index1, index2].liquid = (byte) 0;
            if (!Main.wallDungeon[(int) Main.tile[index1, index2].wall])
            {
              Main.tile[index1, index2].Clear(TileDataType.Slope);
              Main.tile[index1, index2].active(true);
              Main.tile[index1, index2].type = tileType;
            }
          }
        }
        for (int index1 = num7 + 1; index1 < num8 - 1; ++index1)
        {
          for (int index2 = num9 + 1; index2 < num10 - 1; ++index2)
            Main.tile[index1, index2].wall = (ushort) wallType;
        }
        int num11 = (int) ((double) vector2_2.X - num1 * 0.5);
        int num12 = (int) ((double) vector2_2.X + num1 * 0.5);
        int num13 = (int) ((double) vector2_2.Y - num1 * 0.5);
        int num14 = (int) ((double) vector2_2.Y + num1 * 0.5);
        if (num11 < 0)
          num11 = 0;
        if (num12 > Main.maxTilesX)
          num12 = Main.maxTilesX;
        if (num13 < 0)
          num13 = 0;
        if (num14 > Main.maxTilesY)
          num14 = Main.maxTilesY;
        if ((double) num11 < num3)
          num3 = (double) num11;
        if ((double) num12 > num4)
          num4 = (double) num12;
        if ((double) num13 < num5)
          num5 = (double) num13;
        if ((double) num14 > num6)
          num6 = (double) num14;
        for (int index1 = num11; index1 < num12; ++index1)
        {
          for (int index2 = num13; index2 < num14; ++index2)
          {
            Main.tile[index1, index2].active(false);
            Main.tile[index1, index2].wall = (ushort) wallType;
          }
        }
        vector2_2 += vector2_1;
        vector2_1.X += (float) WorldGen.genRand.Next(-10, 11) * 0.05f;
        vector2_1.Y += (float) WorldGen.genRand.Next(-10, 11) * 0.05f;
        if ((double) vector2_1.X > 1.0)
          vector2_1.X = 1f;
        if ((double) vector2_1.X < -1.0)
          vector2_1.X = -1f;
        if ((double) vector2_1.Y > 1.0)
          vector2_1.Y = 1f;
        if ((double) vector2_1.Y < -1.0)
          vector2_1.Y = -1f;
      }
      WorldGen.dRoomX[WorldGen.numDRooms] = (int) vector2_2.X;
      WorldGen.dRoomY[WorldGen.numDRooms] = (int) vector2_2.Y;
      WorldGen.dRoomSize[WorldGen.numDRooms] = (int) num1;
      WorldGen.dRoomL[WorldGen.numDRooms] = (int) num3;
      WorldGen.dRoomR[WorldGen.numDRooms] = (int) num4;
      WorldGen.dRoomT[WorldGen.numDRooms] = (int) num5;
      WorldGen.dRoomB[WorldGen.numDRooms] = (int) num6;
      WorldGen.dRoomTreasure[WorldGen.numDRooms] = false;
      ++WorldGen.numDRooms;
    }

    public static void DungeonEnt(int i, int j, ushort tileType, int wallType)
    {
      int num1 = 60;
      for (int index1 = i - num1; index1 < i + num1; ++index1)
      {
        for (int index2 = j - num1; index2 < j + num1; ++index2)
        {
          Main.tile[index1, index2].liquid = (byte) 0;
          Main.tile[index1, index2].lava(false);
          Main.tile[index1, index2].Clear(TileDataType.Slope);
        }
      }
      double dxStrength1 = WorldGen.dxStrength1;
      double dyStrength1 = WorldGen.dyStrength1;
      Vector2 vector2;
      vector2.X = (float) i;
      vector2.Y = (float) j - (float) dyStrength1 / 2f;
      WorldGen.dMinY = (int) vector2.Y;
      int num2 = 1;
      if (i > Main.maxTilesX / 2)
        num2 = -1;
      if (WorldGen.drunkWorldGen || WorldGen.getGoodWorldGen)
        num2 *= -1;
      int num3 = (int) ((double) vector2.X - dxStrength1 * 0.600000023841858 - (double) WorldGen.genRand.Next(2, 5));
      int num4 = (int) ((double) vector2.X + dxStrength1 * 0.600000023841858 + (double) WorldGen.genRand.Next(2, 5));
      int num5 = (int) ((double) vector2.Y - dyStrength1 * 0.600000023841858 - (double) WorldGen.genRand.Next(2, 5));
      int num6 = (int) ((double) vector2.Y + dyStrength1 * 0.600000023841858 + (double) WorldGen.genRand.Next(8, 16));
      if (num3 < 0)
        num3 = 0;
      if (num4 > Main.maxTilesX)
        num4 = Main.maxTilesX;
      if (num5 < 0)
        num5 = 0;
      if (num6 > Main.maxTilesY)
        num6 = Main.maxTilesY;
      for (int index1 = num3; index1 < num4; ++index1)
      {
        for (int index2 = num5; index2 < num6; ++index2)
        {
          Main.tile[index1, index2].liquid = (byte) 0;
          if ((int) Main.tile[index1, index2].wall != wallType)
          {
            Main.tile[index1, index2].wall = (ushort) 0;
            if (index1 > num3 + 1 && index1 < num4 - 2 && (index2 > num5 + 1 && index2 < num6 - 2))
              Main.tile[index1, index2].wall = (ushort) wallType;
            Main.tile[index1, index2].active(true);
            Main.tile[index1, index2].type = tileType;
            Main.tile[index1, index2].Clear(TileDataType.Slope);
          }
        }
      }
      int num7 = num3;
      int num8 = num3 + 5 + WorldGen.genRand.Next(4);
      int num9 = num5 - 3 - WorldGen.genRand.Next(3);
      int num10 = num5;
      for (int index1 = num7; index1 < num8; ++index1)
      {
        for (int index2 = num9; index2 < num10; ++index2)
        {
          Main.tile[index1, index2].liquid = (byte) 0;
          if ((int) Main.tile[index1, index2].wall != wallType)
          {
            Main.tile[index1, index2].active(true);
            Main.tile[index1, index2].type = tileType;
            Main.tile[index1, index2].Clear(TileDataType.Slope);
          }
        }
      }
      int num11 = num4 - 5 - WorldGen.genRand.Next(4);
      int num12 = num4;
      int num13 = num5 - 3 - WorldGen.genRand.Next(3);
      int num14 = num5;
      for (int index1 = num11; index1 < num12; ++index1)
      {
        for (int index2 = num13; index2 < num14; ++index2)
        {
          Main.tile[index1, index2].liquid = (byte) 0;
          if ((int) Main.tile[index1, index2].wall != wallType)
          {
            Main.tile[index1, index2].active(true);
            Main.tile[index1, index2].type = tileType;
            Main.tile[index1, index2].Clear(TileDataType.Slope);
          }
        }
      }
      int num15 = 1 + WorldGen.genRand.Next(2);
      int num16 = 2 + WorldGen.genRand.Next(4);
      int num17 = 0;
      for (int index1 = num3; index1 < num4; ++index1)
      {
        for (int index2 = num5 - num15; index2 < num5; ++index2)
        {
          Main.tile[index1, index2].liquid = (byte) 0;
          if ((int) Main.tile[index1, index2].wall != wallType)
          {
            Main.tile[index1, index2].active(true);
            Main.tile[index1, index2].type = tileType;
            Main.tile[index1, index2].Clear(TileDataType.Slope);
          }
        }
        ++num17;
        if (num17 >= num16)
        {
          index1 += num16;
          num17 = 0;
        }
      }
      for (int index1 = num3; index1 < num4; ++index1)
      {
        for (int index2 = num6; (double) index2 < Main.worldSurface; ++index2)
        {
          Main.tile[index1, index2].liquid = (byte) 0;
          if (!Main.wallDungeon[(int) Main.tile[index1, index2].wall])
          {
            Main.tile[index1, index2].active(true);
            Main.tile[index1, index2].type = tileType;
          }
          if (index1 > num3 && index1 < num4 - 1)
            Main.tile[index1, index2].wall = (ushort) wallType;
          Main.tile[index1, index2].Clear(TileDataType.Slope);
        }
      }
      int num18 = (int) ((double) vector2.X - dxStrength1 * 0.600000023841858);
      int num19 = (int) ((double) vector2.X + dxStrength1 * 0.600000023841858);
      int num20 = (int) ((double) vector2.Y - dyStrength1 * 0.600000023841858);
      int num21 = (int) ((double) vector2.Y + dyStrength1 * 0.600000023841858);
      if (num18 < 0)
        num18 = 0;
      if (num19 > Main.maxTilesX)
        num19 = Main.maxTilesX;
      if (num20 < 0)
        num20 = 0;
      if (num21 > Main.maxTilesY)
        num21 = Main.maxTilesY;
      for (int index1 = num18; index1 < num19; ++index1)
      {
        for (int index2 = num20; index2 < num21; ++index2)
        {
          Main.tile[index1, index2].liquid = (byte) 0;
          Main.tile[index1, index2].wall = (ushort) wallType;
          Main.tile[index1, index2].Clear(TileDataType.Slope);
        }
      }
      int num22 = (int) ((double) vector2.X - dxStrength1 * 0.6 - 1.0);
      int num23 = (int) ((double) vector2.X + dxStrength1 * 0.6 + 1.0);
      int num24 = (int) ((double) vector2.Y - dyStrength1 * 0.6 - 1.0);
      int num25 = (int) ((double) vector2.Y + dyStrength1 * 0.6 + 1.0);
      if (num22 < 0)
        num22 = 0;
      if (num23 > Main.maxTilesX)
        num23 = Main.maxTilesX;
      if (num24 < 0)
        num24 = 0;
      if (num25 > Main.maxTilesY)
        num25 = Main.maxTilesY;
      if (WorldGen.drunkWorldGen)
        num22 -= 4;
      for (int index1 = num22; index1 < num23; ++index1)
      {
        for (int index2 = num24; index2 < num25; ++index2)
        {
          Main.tile[index1, index2].liquid = (byte) 0;
          Main.tile[index1, index2].wall = (ushort) wallType;
          Main.tile[index1, index2].Clear(TileDataType.Slope);
        }
      }
      int num26 = (int) ((double) vector2.X - dxStrength1 * 0.5);
      int num27 = (int) ((double) vector2.X + dxStrength1 * 0.5);
      int num28 = (int) ((double) vector2.Y - dyStrength1 * 0.5);
      int num29 = (int) ((double) vector2.Y + dyStrength1 * 0.5);
      if (num26 < 0)
        num26 = 0;
      if (num27 > Main.maxTilesX)
        num27 = Main.maxTilesX;
      if (num28 < 0)
        num28 = 0;
      if (num29 > Main.maxTilesY)
        num29 = Main.maxTilesY;
      for (int index1 = num26; index1 < num27; ++index1)
      {
        for (int index2 = num28; index2 < num29; ++index2)
        {
          Main.tile[index1, index2].liquid = (byte) 0;
          Main.tile[index1, index2].active(false);
          Main.tile[index1, index2].wall = (ushort) wallType;
        }
      }
      int x = (int) vector2.X;
      int index3 = num29;
      for (int index1 = 0; index1 < 20; ++index1)
      {
        int index2 = (int) vector2.X - index1;
        if (!Main.tile[index2, index3].active() && Main.wallDungeon[(int) Main.tile[index2, index3].wall])
        {
          WorldGen.dungeonPlatformX[WorldGen.numDungeonPlatforms] = index2;
          WorldGen.dungeonPlatformY[WorldGen.numDungeonPlatforms] = index3;
          ++WorldGen.numDungeonPlatforms;
          break;
        }
        int index4 = (int) vector2.X + index1;
        if (!Main.tile[index4, index3].active() && Main.wallDungeon[(int) Main.tile[index4, index3].wall])
        {
          WorldGen.dungeonPlatformX[WorldGen.numDungeonPlatforms] = index4;
          WorldGen.dungeonPlatformY[WorldGen.numDungeonPlatforms] = index3;
          ++WorldGen.numDungeonPlatforms;
          break;
        }
      }
      vector2.X += (float) (dxStrength1 * 0.600000023841858) * (float) num2;
      vector2.Y += (float) dyStrength1 * 0.5f;
      double dxStrength2 = WorldGen.dxStrength2;
      double dyStrength2 = WorldGen.dyStrength2;
      vector2.X += (float) (dxStrength2 * 0.550000011920929) * (float) num2;
      vector2.Y -= (float) dyStrength2 * 0.5f;
      int num30 = (int) ((double) vector2.X - dxStrength2 * 0.600000023841858 - (double) WorldGen.genRand.Next(1, 3));
      int num31 = (int) ((double) vector2.X + dxStrength2 * 0.600000023841858 + (double) WorldGen.genRand.Next(1, 3));
      int num32 = (int) ((double) vector2.Y - dyStrength2 * 0.600000023841858 - (double) WorldGen.genRand.Next(1, 3));
      int num33 = (int) ((double) vector2.Y + dyStrength2 * 0.600000023841858 + (double) WorldGen.genRand.Next(6, 16));
      if (num30 < 0)
        num30 = 0;
      if (num31 > Main.maxTilesX)
        num31 = Main.maxTilesX;
      if (num32 < 0)
        num32 = 0;
      if (num33 > Main.maxTilesY)
        num33 = Main.maxTilesY;
      for (int index1 = num30; index1 < num31; ++index1)
      {
        for (int index2 = num32; index2 < num33; ++index2)
        {
          Main.tile[index1, index2].liquid = (byte) 0;
          if ((int) Main.tile[index1, index2].wall != wallType)
          {
            bool flag = true;
            if (num2 < 0)
            {
              if ((double) index1 < (double) vector2.X - dxStrength2 * 0.5)
                flag = false;
            }
            else if ((double) index1 > (double) vector2.X + dxStrength2 * 0.5 - 1.0)
              flag = false;
            if (flag)
            {
              Main.tile[index1, index2].wall = (ushort) 0;
              Main.tile[index1, index2].active(true);
              Main.tile[index1, index2].type = tileType;
              Main.tile[index1, index2].Clear(TileDataType.Slope);
            }
          }
        }
      }
      for (int index1 = num30; index1 < num31; ++index1)
      {
        for (int index2 = num33; (double) index2 < Main.worldSurface; ++index2)
        {
          Main.tile[index1, index2].liquid = (byte) 0;
          if (!Main.wallDungeon[(int) Main.tile[index1, index2].wall])
          {
            Main.tile[index1, index2].active(true);
            Main.tile[index1, index2].type = tileType;
          }
          Main.tile[index1, index2].wall = (ushort) wallType;
          Main.tile[index1, index2].Clear(TileDataType.Slope);
        }
      }
      int num34 = (int) ((double) vector2.X - dxStrength2 * 0.5);
      int num35 = (int) ((double) vector2.X + dxStrength2 * 0.5);
      int num36 = num34;
      if (num2 < 0)
        ++num36;
      int num37 = num36 + 5 + WorldGen.genRand.Next(4);
      int num38 = num32 - 3 - WorldGen.genRand.Next(3);
      int num39 = num32;
      for (int index1 = num36; index1 < num37; ++index1)
      {
        for (int index2 = num38; index2 < num39; ++index2)
        {
          Main.tile[index1, index2].liquid = (byte) 0;
          if ((int) Main.tile[index1, index2].wall != wallType)
          {
            Main.tile[index1, index2].active(true);
            Main.tile[index1, index2].type = tileType;
            Main.tile[index1, index2].Clear(TileDataType.Slope);
          }
        }
      }
      int num40 = num35 - 5 - WorldGen.genRand.Next(4);
      int num41 = num35;
      int num42 = num32 - 3 - WorldGen.genRand.Next(3);
      int num43 = num32;
      for (int index1 = num40; index1 < num41; ++index1)
      {
        for (int index2 = num42; index2 < num43; ++index2)
        {
          Main.tile[index1, index2].liquid = (byte) 0;
          if ((int) Main.tile[index1, index2].wall != wallType)
          {
            Main.tile[index1, index2].active(true);
            Main.tile[index1, index2].type = tileType;
            Main.tile[index1, index2].Clear(TileDataType.Slope);
          }
        }
      }
      int num44 = 1 + WorldGen.genRand.Next(2);
      int num45 = 2 + WorldGen.genRand.Next(4);
      int num46 = 0;
      if (num2 < 0)
        ++num35;
      for (int index1 = num34 + 1; index1 < num35 - 1; ++index1)
      {
        for (int index2 = num32 - num44; index2 < num32; ++index2)
        {
          Main.tile[index1, index2].liquid = (byte) 0;
          if ((int) Main.tile[index1, index2].wall != wallType)
          {
            Main.tile[index1, index2].active(true);
            Main.tile[index1, index2].type = tileType;
            Main.tile[index1, index2].Clear(TileDataType.Slope);
          }
        }
        ++num46;
        if (num46 >= num45)
        {
          index1 += num45;
          num46 = 0;
        }
      }
      if (!WorldGen.drunkWorldGen)
      {
        int num47 = (int) ((double) vector2.X - dxStrength2 * 0.6);
        int num48 = (int) ((double) vector2.X + dxStrength2 * 0.6);
        int num49 = (int) ((double) vector2.Y - dyStrength2 * 0.6);
        int num50 = (int) ((double) vector2.Y + dyStrength2 * 0.6);
        if (num47 < 0)
          num47 = 0;
        if (num48 > Main.maxTilesX)
          num48 = Main.maxTilesX;
        if (num49 < 0)
          num49 = 0;
        if (num50 > Main.maxTilesY)
          num50 = Main.maxTilesY;
        for (int index1 = num47; index1 < num48; ++index1)
        {
          for (int index2 = num49; index2 < num50; ++index2)
          {
            Main.tile[index1, index2].liquid = (byte) 0;
            Main.tile[index1, index2].wall = (ushort) 0;
          }
        }
      }
      int num51 = (int) ((double) vector2.X - dxStrength2 * 0.5);
      int num52 = (int) ((double) vector2.X + dxStrength2 * 0.5);
      int num53 = (int) ((double) vector2.Y - dyStrength2 * 0.5);
      int num54 = (int) ((double) vector2.Y + dyStrength2 * 0.5);
      if (num51 < 0)
        num51 = 0;
      if (num52 > Main.maxTilesX)
        num52 = Main.maxTilesX;
      if (num53 < 0)
        num53 = 0;
      if (num54 > Main.maxTilesY)
        num54 = Main.maxTilesY;
      for (int index1 = num51; index1 < num52; ++index1)
      {
        for (int index2 = num53; index2 < num54; ++index2)
        {
          Main.tile[index1, index2].liquid = (byte) 0;
          Main.tile[index1, index2].active(false);
          Main.tile[index1, index2].wall = (ushort) 0;
        }
      }
      Main.dungeonX = (int) vector2.X;
      Main.dungeonY = num54;
      int index5 = NPC.NewNPC(Main.dungeonX * 16 + 8, Main.dungeonY * 16, 37, 0, 0.0f, 0.0f, 0.0f, 0.0f, (int) byte.MaxValue);
      Main.npc[index5].homeless = false;
      Main.npc[index5].homeTileX = Main.dungeonX;
      Main.npc[index5].homeTileY = Main.dungeonY;
      if (WorldGen.drunkWorldGen)
      {
        int worldSurface = (int) Main.worldSurface;
        while (Main.tile[WorldGen.dungeonX, worldSurface].active() || Main.tile[WorldGen.dungeonX, worldSurface].wall > (ushort) 0 || (Main.tile[WorldGen.dungeonX, worldSurface - 1].active() || Main.tile[WorldGen.dungeonX, worldSurface - 1].wall > (ushort) 0) || (Main.tile[WorldGen.dungeonX, worldSurface - 2].active() || Main.tile[WorldGen.dungeonX, worldSurface - 2].wall > (ushort) 0 || (Main.tile[WorldGen.dungeonX, worldSurface - 3].active() || Main.tile[WorldGen.dungeonX, worldSurface - 3].wall > (ushort) 0)) || (Main.tile[WorldGen.dungeonX, worldSurface - 4].active() || Main.tile[WorldGen.dungeonX, worldSurface - 4].wall > (ushort) 0))
        {
          --worldSurface;
          if (worldSurface < 50)
            break;
        }
        if (worldSurface > 50)
          WorldGen.GrowDungeonTree(WorldGen.dungeonX, worldSurface, false);
      }
      if (!WorldGen.drunkWorldGen)
      {
        int num47 = 100;
        if (num2 == 1)
        {
          int num48 = 0;
          for (int index1 = num52; index1 < num52 + num47; ++index1)
          {
            ++num48;
            for (int index2 = num54 + num48; index2 < num54 + num47; ++index2)
            {
              Main.tile[index1, index2].liquid = (byte) 0;
              Main.tile[index1, index2 - 1].liquid = (byte) 0;
              Main.tile[index1, index2 - 2].liquid = (byte) 0;
              Main.tile[index1, index2 - 3].liquid = (byte) 0;
              if (!Main.wallDungeon[(int) Main.tile[index1, index2].wall] && Main.tile[index1, index2].wall != (ushort) 3 && Main.tile[index1, index2].wall != (ushort) 83)
              {
                Main.tile[index1, index2].active(true);
                Main.tile[index1, index2].type = tileType;
                Main.tile[index1, index2].Clear(TileDataType.Slope);
              }
            }
          }
        }
        else
        {
          int num48 = 0;
          for (int index1 = num51; index1 > num51 - num47; --index1)
          {
            ++num48;
            for (int index2 = num54 + num48; index2 < num54 + num47; ++index2)
            {
              Main.tile[index1, index2].liquid = (byte) 0;
              Main.tile[index1, index2 - 1].liquid = (byte) 0;
              Main.tile[index1, index2 - 2].liquid = (byte) 0;
              Main.tile[index1, index2 - 3].liquid = (byte) 0;
              if (!Main.wallDungeon[(int) Main.tile[index1, index2].wall] && Main.tile[index1, index2].wall != (ushort) 3 && Main.tile[index1, index2].wall != (ushort) 83)
              {
                Main.tile[index1, index2].active(true);
                Main.tile[index1, index2].type = tileType;
                Main.tile[index1, index2].Clear(TileDataType.Slope);
              }
            }
          }
        }
      }
      int num55 = 1 + WorldGen.genRand.Next(2);
      int num56 = 2 + WorldGen.genRand.Next(4);
      int num57 = 0;
      int num58 = (int) ((double) vector2.X - dxStrength2 * 0.5);
      int num59 = (int) ((double) vector2.X + dxStrength2 * 0.5);
      int num60;
      int num61;
      if (WorldGen.drunkWorldGen)
      {
        if (num2 == 1)
        {
          num60 = num59 - 1;
          num61 = num58 - 1;
        }
        else
        {
          num61 = num58 + 1;
          num60 = num59 + 1;
        }
      }
      else
      {
        num61 = num58 + 2;
        num60 = num59 - 2;
      }
      for (int i1 = num61; i1 < num60; ++i1)
      {
        for (int j1 = num53; j1 < num54 + 1; ++j1)
          WorldGen.PlaceWall(i1, j1, wallType, true);
        if (!WorldGen.drunkWorldGen)
        {
          ++num57;
          if (num57 >= num56)
          {
            i1 += num56 * 2;
            num57 = 0;
          }
        }
      }
      if (WorldGen.drunkWorldGen)
      {
        int num47 = (int) ((double) vector2.X - dxStrength2 * 0.5);
        int num48 = (int) ((double) vector2.X + dxStrength2 * 0.5);
        if (num2 == 1)
          num47 = num48 - 3;
        else
          num48 = num47 + 3;
        for (int index1 = num47; index1 < num48; ++index1)
        {
          for (int index2 = num53; index2 < num54 + 1; ++index2)
          {
            Main.tile[index1, index2].active(true);
            Main.tile[index1, index2].type = tileType;
            Main.tile[index1, index2].Clear(TileDataType.Slope);
          }
        }
      }
      vector2.X -= (float) (dxStrength2 * 0.600000023841858) * (float) num2;
      vector2.Y += (float) dyStrength2 * 0.5f;
      double num62 = 15.0;
      double num63 = 3.0;
      vector2.Y -= (float) num63 * 0.5f;
      int num64 = (int) ((double) vector2.X - num62 * 0.5);
      int num65 = (int) ((double) vector2.X + num62 * 0.5);
      int num66 = (int) ((double) vector2.Y - num63 * 0.5);
      int num67 = (int) ((double) vector2.Y + num63 * 0.5);
      if (num64 < 0)
        num64 = 0;
      if (num65 > Main.maxTilesX)
        num65 = Main.maxTilesX;
      if (num66 < 0)
        num66 = 0;
      if (num67 > Main.maxTilesY)
        num67 = Main.maxTilesY;
      for (int index1 = num64; index1 < num65; ++index1)
      {
        for (int index2 = num66; index2 < num67; ++index2)
          Main.tile[index1, index2].active(false);
      }
      if (num2 < 0)
        --vector2.X;
      WorldGen.PlaceTile((int) vector2.X, (int) vector2.Y + 1, 10, true, false, -1, 13);
    }

    public static bool AddBuriedChest(
      Point point,
      int contain = 0,
      bool notNearOtherChests = false,
      int Style = -1)
    {
      return WorldGen.AddBuriedChest(point.X, point.Y, contain, notNearOtherChests, Style, false, (ushort) 0);
    }

    public static bool IsChestRigged(int x, int y)
    {
      return Main.tile[x, y].type == (ushort) 467 && (int) Main.tile[x, y].frameX / 36 == 4;
    }

    private static bool IsUndergroundDesert(int x, int y)
    {
      if ((double) y < Main.worldSurface || (double) x < (double) Main.maxTilesX * 0.15 || (double) x > (double) Main.maxTilesX * 0.85)
        return false;
      int num = 15;
      for (int index1 = x - num; index1 <= x + num; ++index1)
      {
        for (int index2 = y - num; index2 <= y + num; ++index2)
        {
          if (Main.tile[index1, index2].wall == (ushort) 187 || Main.tile[index1, index2].wall == (ushort) 216)
            return true;
        }
      }
      return false;
    }

    private static bool IsDungeon(int x, int y)
    {
      return (double) y >= Main.worldSurface && x >= 0 && (x <= Main.maxTilesX && Main.wallDungeon[(int) Main.tile[x, y].wall]);
    }

    public static bool AddBuriedChest(
      int i,
      int j,
      int contain = 0,
      bool notNearOtherChests = false,
      int Style = -1,
      bool trySlope = false,
      ushort chestTileType = 0)
    {
      if (chestTileType == (ushort) 0)
        chestTileType = (ushort) 21;
      bool flag1 = false;
      bool flag2 = false;
      bool flag3 = false;
      bool flag4 = false;
      bool flag5 = false;
      bool flag6 = false;
      bool flag7 = false;
      bool flag8 = false;
      int maxValue = 15;
      for (int index1 = j; index1 < Main.maxTilesY - 10; ++index1)
      {
        int num1 = -1;
        int num2 = -1;
        if (trySlope && Main.tile[i, index1].active() && (Main.tileSolid[(int) Main.tile[i, index1].type] && !Main.tileSolidTop[(int) Main.tile[i, index1].type]))
        {
          if (Style == 17)
          {
            int num3 = 30;
            for (int x = i - num3; x <= i + num3; ++x)
            {
              for (int y = index1 - num3; y <= index1 + num3; ++y)
              {
                if (!WorldGen.InWorld(x, y, 5) || Main.tile[x, y].active() && (Main.tile[x, y].type == (ushort) 21 || Main.tile[x, y].type == (ushort) 467))
                  return false;
              }
            }
          }
          if (Main.tile[i - 1, index1].topSlope())
          {
            num1 = (int) Main.tile[i - 1, index1].slope();
            Main.tile[i - 1, index1].slope((byte) 0);
          }
          if (Main.tile[i, index1].topSlope())
          {
            num2 = (int) Main.tile[i, index1].slope();
            Main.tile[i, index1].slope((byte) 0);
          }
        }
        int num4 = 2;
        for (int index2 = i - num4; index2 <= i + num4; ++index2)
        {
          for (int index3 = index1 - num4; index3 <= index1 + num4; ++index3)
          {
            if (Main.tile[index2, index3].active() && (TileID.Sets.Boulders[(int) Main.tile[index2, index3].type] || Main.tile[index2, index3].type == (ushort) 26 || Main.tile[index2, index3].type == (ushort) 237))
              return false;
          }
        }
        if (WorldGen.SolidTile(i, index1, false))
        {
          bool flag9 = false;
          int num3 = i;
          int num5 = index1;
          int style = 0;
          if ((double) num5 >= Main.worldSurface + 25.0 || contain > 0)
            style = 1;
          if (Style >= 0)
            style = Style;
          if (contain == 0 && (double) num5 >= Main.worldSurface + 25.0 && (num5 <= Main.maxTilesY - 205 && WorldGen.IsUndergroundDesert(i, index1)))
          {
            flag2 = true;
            style = 10;
            chestTileType = (ushort) 467;
            int num6 = -1;
            int num7 = -1;
            for (int index2 = (int) Main.worldSurface - 100; index2 < Main.maxTilesY - 200; ++index2)
            {
              for (int index3 = 100; index3 < Main.maxTilesX - 100; ++index3)
              {
                if (Main.tile[index3, index2].wall == (ushort) 216 || Main.tile[index3, index2].wall == (ushort) 187)
                {
                  if (num6 == -1)
                    num6 = index2;
                  num7 = index2;
                  break;
                }
              }
            }
            if (num5 > (num6 * 3 + num7 * 4) / 7)
              contain = (int) Utils.SelectRandom<short>(WorldGen.genRand, (short) 4061, (short) 4062, (short) 4276);
            else
              contain = (int) Utils.SelectRandom<short>(WorldGen.genRand, (short) 4056, (short) 4055, (short) 4262, (short) 4263);
            if (WorldGen.getGoodWorldGen && WorldGen.genRand.Next(maxValue) == 0)
              contain = 52;
          }
          if (chestTileType == (ushort) 21 && (style == 11 || contain == 0 && (double) num5 >= Main.worldSurface + 25.0 && num5 <= Main.maxTilesY - 205 && (Main.tile[i, index1].type == (ushort) 147 || Main.tile[i, index1].type == (ushort) 161 || Main.tile[i, index1].type == (ushort) 162)))
          {
            flag1 = true;
            style = 11;
            switch (WorldGen.genRand.Next(6))
            {
              case 0:
                contain = 670;
                break;
              case 1:
                contain = 724;
                break;
              case 2:
                contain = 950;
                break;
              case 3:
                contain = 1319;
                break;
              case 4:
                contain = 987;
                break;
              default:
                contain = 1579;
                break;
            }
            if (WorldGen.genRand.Next(20) == 0)
              contain = 997;
            if (WorldGen.genRand.Next(50) == 0)
              contain = 669;
            if (WorldGen.getGoodWorldGen && WorldGen.genRand.Next(maxValue) == 0)
              contain = 52;
          }
          if (chestTileType == (ushort) 21 && (Style == 10 || contain == 211 || (contain == 212 || contain == 213) || contain == 753))
          {
            flag3 = true;
            style = 10;
            if (WorldGen.getGoodWorldGen && WorldGen.genRand.Next(maxValue) == 0)
              contain = 52;
          }
          if (chestTileType == (ushort) 21 && num5 > Main.maxTilesY - 205 && contain == 0)
          {
            flag7 = true;
            if (WorldGen.hellChest == WorldGen.hellChestItem[1])
            {
              contain = 220;
              style = 4;
              flag9 = true;
            }
            else if (WorldGen.hellChest == WorldGen.hellChestItem[2])
            {
              contain = 112;
              style = 4;
              flag9 = true;
            }
            else if (WorldGen.hellChest == WorldGen.hellChestItem[3])
            {
              contain = 218;
              style = 4;
              flag9 = true;
            }
            else if (WorldGen.hellChest == WorldGen.hellChestItem[4])
            {
              contain = 274;
              style = 4;
              flag9 = true;
            }
            else if (WorldGen.hellChest == WorldGen.hellChestItem[5])
            {
              contain = 3019;
              style = 4;
              flag9 = true;
            }
            else
            {
              contain = 5010;
              style = 4;
              flag9 = true;
            }
            if (WorldGen.getGoodWorldGen && WorldGen.genRand.Next(maxValue) == 0)
              contain = 52;
          }
          if (chestTileType == (ushort) 21 && style == 17)
          {
            flag4 = true;
            if (WorldGen.getGoodWorldGen && WorldGen.genRand.Next(maxValue) == 0)
              contain = 52;
          }
          if (chestTileType == (ushort) 21 && style == 12)
          {
            flag5 = true;
            if (WorldGen.getGoodWorldGen && WorldGen.genRand.Next(maxValue) == 0)
              contain = 52;
          }
          if (chestTileType == (ushort) 21 && style == 32)
          {
            flag6 = true;
            if (WorldGen.getGoodWorldGen && WorldGen.genRand.Next(maxValue) == 0)
              contain = 52;
          }
          if (chestTileType == (ushort) 21 && style != 0 && WorldGen.IsDungeon(i, index1))
          {
            flag8 = true;
            if (WorldGen.getGoodWorldGen && WorldGen.genRand.Next(maxValue) == 0)
              contain = 52;
          }
          int index4 = chestTileType != (ushort) 467 ? WorldGen.PlaceChest(num3 - 1, num5 - 1, chestTileType, notNearOtherChests, style) : WorldGen.PlaceChest(num3 - 1, num5 - 1, chestTileType, notNearOtherChests, style);
          if (index4 >= 0)
          {
            if (flag9)
            {
              ++WorldGen.hellChest;
              if (WorldGen.hellChest > 4)
                WorldGen.hellChest = 0;
            }
            Chest chest = Main.chest[index4];
            int index2 = 0;
            while (index2 == 0)
            {
              if (style == 0 && (double) num5 < Main.worldSurface + 25.0 || contain == 848)
              {
                if (contain > 0)
                {
                  chest.item[index2].SetDefaults(contain);
                  chest.item[index2].Prefix(-1);
                  ++index2;
                  switch (contain)
                  {
                    case 832:
                      chest.item[index2].SetDefaults(933);
                      ++index2;
                      if (WorldGen.genRand.Next(10) == 0)
                      {
                        int Type = WorldGen.genRand.Next(2);
                        switch (Type)
                        {
                          case 0:
                            Type = 4429;
                            break;
                          case 1:
                            Type = 4427;
                            break;
                        }
                        chest.item[index2].SetDefaults(Type);
                        ++index2;
                        break;
                      }
                      break;
                    case 848:
                      chest.item[index2].SetDefaults(866);
                      ++index2;
                      break;
                  }
                }
                else
                {
                  int num6 = WorldGen.genRand.Next(12);
                  if (num6 == 0)
                  {
                    chest.item[index2].SetDefaults(280);
                    chest.item[index2].Prefix(-1);
                  }
                  if (num6 == 1)
                  {
                    chest.item[index2].SetDefaults(281);
                    chest.item[index2].Prefix(-1);
                  }
                  if (num6 == 2)
                  {
                    chest.item[index2].SetDefaults(284);
                    chest.item[index2].Prefix(-1);
                  }
                  if (num6 == 3)
                  {
                    chest.item[index2].SetDefaults(282);
                    chest.item[index2].stack = WorldGen.genRand.Next(40, 75);
                  }
                  if (num6 == 4)
                  {
                    chest.item[index2].SetDefaults(279);
                    chest.item[index2].stack = WorldGen.genRand.Next(150, 300);
                  }
                  if (num6 == 5)
                  {
                    chest.item[index2].SetDefaults(285);
                    chest.item[index2].Prefix(-1);
                  }
                  if (num6 == 6)
                  {
                    chest.item[index2].SetDefaults(953);
                    chest.item[index2].Prefix(-1);
                  }
                  if (num6 == 7)
                  {
                    chest.item[index2].SetDefaults(946);
                    chest.item[index2].Prefix(-1);
                  }
                  if (num6 == 8)
                  {
                    chest.item[index2].SetDefaults(3068);
                    chest.item[index2].Prefix(-1);
                  }
                  if (num6 == 9)
                  {
                    chest.item[index2].SetDefaults(3069);
                    chest.item[index2].Prefix(-1);
                  }
                  if (num6 == 10)
                  {
                    chest.item[index2].SetDefaults(3084);
                    chest.item[index2].Prefix(-1);
                  }
                  if (num6 == 11)
                  {
                    chest.item[index2].SetDefaults(4341);
                    chest.item[index2].Prefix(-1);
                  }
                  ++index2;
                }
                if (WorldGen.genRand.Next(6) == 0)
                {
                  chest.item[index2].SetDefaults(3093);
                  chest.item[index2].stack = 1;
                  if (WorldGen.genRand.Next(5) == 0)
                    chest.item[index2].stack += WorldGen.genRand.Next(2);
                  if (WorldGen.genRand.Next(10) == 0)
                    chest.item[index2].stack += WorldGen.genRand.Next(3);
                  ++index2;
                }
                if (WorldGen.genRand.Next(6) == 0)
                {
                  chest.item[index2].SetDefaults(4345);
                  chest.item[index2].stack = 1;
                  if (WorldGen.genRand.Next(5) == 0)
                    chest.item[index2].stack += WorldGen.genRand.Next(2);
                  if (WorldGen.genRand.Next(10) == 0)
                    chest.item[index2].stack += WorldGen.genRand.Next(3);
                  ++index2;
                }
                if (WorldGen.genRand.Next(3) == 0)
                {
                  chest.item[index2].SetDefaults(168);
                  chest.item[index2].stack = WorldGen.genRand.Next(3, 6);
                  ++index2;
                }
                if (WorldGen.genRand.Next(2) == 0)
                {
                  int num6 = WorldGen.genRand.Next(2);
                  int num7 = WorldGen.genRand.Next(8) + 3;
                  if (num6 == 0)
                    chest.item[index2].SetDefaults(WorldGen.copperBar);
                  if (num6 == 1)
                    chest.item[index2].SetDefaults(WorldGen.ironBar);
                  chest.item[index2].stack = num7;
                  ++index2;
                }
                if (WorldGen.genRand.Next(2) == 0)
                {
                  int num6 = WorldGen.genRand.Next(50, 101);
                  chest.item[index2].SetDefaults(965);
                  chest.item[index2].stack = num6;
                  ++index2;
                }
                if (WorldGen.genRand.Next(3) != 0)
                {
                  int num6 = WorldGen.genRand.Next(2);
                  int num7 = WorldGen.genRand.Next(26) + 25;
                  if (num6 == 0)
                    chest.item[index2].SetDefaults(40);
                  if (num6 == 1)
                    chest.item[index2].SetDefaults(42);
                  chest.item[index2].stack = num7;
                  ++index2;
                }
                if (WorldGen.genRand.Next(2) == 0)
                {
                  int num6 = WorldGen.genRand.Next(3) + 3;
                  chest.item[index2].SetDefaults(28);
                  chest.item[index2].stack = num6;
                  ++index2;
                }
                if (WorldGen.genRand.Next(3) != 0)
                {
                  chest.item[index2].SetDefaults(2350);
                  chest.item[index2].stack = WorldGen.genRand.Next(3, 6);
                  ++index2;
                }
                if (WorldGen.genRand.Next(3) > 0)
                {
                  int num6 = WorldGen.genRand.Next(6);
                  int num7 = WorldGen.genRand.Next(1, 3);
                  if (num6 == 0)
                    chest.item[index2].SetDefaults(292);
                  if (num6 == 1)
                    chest.item[index2].SetDefaults(298);
                  if (num6 == 2)
                    chest.item[index2].SetDefaults(299);
                  if (num6 == 3)
                    chest.item[index2].SetDefaults(290);
                  if (num6 == 4)
                    chest.item[index2].SetDefaults(2322);
                  if (num6 == 5)
                    chest.item[index2].SetDefaults(2325);
                  chest.item[index2].stack = num7;
                  ++index2;
                }
                if (WorldGen.genRand.Next(2) == 0)
                {
                  int num6 = WorldGen.genRand.Next(2);
                  int num7 = WorldGen.genRand.Next(11) + 10;
                  if (num6 == 0)
                    chest.item[index2].SetDefaults(8);
                  if (num6 == 1)
                    chest.item[index2].SetDefaults(31);
                  chest.item[index2].stack = num7;
                  ++index2;
                }
                if (WorldGen.genRand.Next(2) == 0)
                {
                  chest.item[index2].SetDefaults(72);
                  chest.item[index2].stack = WorldGen.genRand.Next(10, 30);
                  ++index2;
                }
                if (WorldGen.genRand.Next(2) == 0)
                {
                  chest.item[index2].SetDefaults(9);
                  chest.item[index2].stack = WorldGen.genRand.Next(50, 100);
                  ++index2;
                }
              }
              else if ((double) num5 < Main.rockLayer)
              {
                if (contain > 0)
                {
                  if (contain == 832)
                  {
                    chest.item[index2].SetDefaults(933);
                    ++index2;
                  }
                  chest.item[index2].SetDefaults(contain);
                  chest.item[index2].Prefix(-1);
                  ++index2;
                  if (flag4 && WorldGen.genRand.Next(2) == 0)
                  {
                    chest.item[index2].SetDefaults(4460);
                    ++index2;
                  }
                  if (flag5 && WorldGen.genRand.Next(10) == 0)
                  {
                    int Type = WorldGen.genRand.Next(2);
                    switch (Type)
                    {
                      case 0:
                        Type = 4429;
                        break;
                      case 1:
                        Type = 4427;
                        break;
                    }
                    chest.item[index2].SetDefaults(Type);
                    ++index2;
                  }
                  if (flag8 && (!WorldGen.generatedShadowKey || WorldGen.genRand.Next(3) == 0))
                  {
                    WorldGen.generatedShadowKey = true;
                    chest.item[index2].SetDefaults(329);
                    ++index2;
                  }
                }
                else
                {
                  switch (WorldGen.genRand.Next(6))
                  {
                    case 0:
                      chest.item[index2].SetDefaults(49);
                      chest.item[index2].Prefix(-1);
                      break;
                    case 1:
                      chest.item[index2].SetDefaults(50);
                      chest.item[index2].Prefix(-1);
                      break;
                    case 2:
                      chest.item[index2].SetDefaults(53);
                      chest.item[index2].Prefix(-1);
                      break;
                    case 3:
                      chest.item[index2].SetDefaults(54);
                      chest.item[index2].Prefix(-1);
                      break;
                    case 4:
                      chest.item[index2].SetDefaults(5011);
                      chest.item[index2].Prefix(-1);
                      break;
                    default:
                      chest.item[index2].SetDefaults(975);
                      chest.item[index2].Prefix(-1);
                      break;
                  }
                  ++index2;
                  if (WorldGen.genRand.Next(20) == 0)
                  {
                    chest.item[index2].SetDefaults(997);
                    chest.item[index2].Prefix(-1);
                    ++index2;
                  }
                  else if (WorldGen.genRand.Next(20) == 0)
                  {
                    chest.item[index2].SetDefaults(930);
                    chest.item[index2].Prefix(-1);
                    int index3 = index2 + 1;
                    chest.item[index3].SetDefaults(931);
                    chest.item[index3].stack = WorldGen.genRand.Next(26) + 25;
                    index2 = index3 + 1;
                  }
                  if (flag6 && WorldGen.genRand.Next(2) == 0)
                  {
                    chest.item[index2].SetDefaults(4450);
                    ++index2;
                  }
                  if (flag6 && WorldGen.genRand.Next(3) == 0)
                  {
                    chest.item[index2].SetDefaults(4779);
                    int index3 = index2 + 1;
                    chest.item[index3].SetDefaults(4780);
                    int index5 = index3 + 1;
                    chest.item[index5].SetDefaults(4781);
                    index2 = index5 + 1;
                  }
                }
                if (flag2)
                {
                  if (WorldGen.genRand.Next(3) == 0)
                  {
                    chest.item[index2].SetDefaults(4423);
                    chest.item[index2].stack = WorldGen.genRand.Next(10, 20);
                    ++index2;
                  }
                }
                else if (WorldGen.genRand.Next(3) == 0)
                {
                  chest.item[index2].SetDefaults(166);
                  chest.item[index2].stack = WorldGen.genRand.Next(10, 20);
                  ++index2;
                }
                if (WorldGen.genRand.Next(5) == 0)
                {
                  chest.item[index2].SetDefaults(52);
                  ++index2;
                }
                if (WorldGen.genRand.Next(3) == 0)
                {
                  int num6 = WorldGen.genRand.Next(50, 101);
                  chest.item[index2].SetDefaults(965);
                  chest.item[index2].stack = num6;
                  ++index2;
                }
                if (WorldGen.genRand.Next(2) == 0)
                {
                  int num6 = WorldGen.genRand.Next(2);
                  int num7 = WorldGen.genRand.Next(10) + 5;
                  if (num6 == 0)
                    chest.item[index2].SetDefaults(WorldGen.ironBar);
                  if (num6 == 1)
                    chest.item[index2].SetDefaults(WorldGen.silverBar);
                  chest.item[index2].stack = num7;
                  ++index2;
                }
                if (WorldGen.genRand.Next(2) == 0)
                {
                  int num6 = WorldGen.genRand.Next(2);
                  int num7 = WorldGen.genRand.Next(25) + 25;
                  if (num6 == 0)
                    chest.item[index2].SetDefaults(40);
                  if (num6 == 1)
                    chest.item[index2].SetDefaults(42);
                  chest.item[index2].stack = num7;
                  ++index2;
                }
                if (WorldGen.genRand.Next(2) == 0)
                {
                  int num6 = WorldGen.genRand.Next(3) + 3;
                  chest.item[index2].SetDefaults(28);
                  chest.item[index2].stack = num6;
                  ++index2;
                }
                if (WorldGen.genRand.Next(3) > 0)
                {
                  int num6 = WorldGen.genRand.Next(9);
                  int num7 = WorldGen.genRand.Next(1, 3);
                  if (num6 == 0)
                    chest.item[index2].SetDefaults(289);
                  if (num6 == 1)
                    chest.item[index2].SetDefaults(298);
                  if (num6 == 2)
                    chest.item[index2].SetDefaults(299);
                  if (num6 == 3)
                    chest.item[index2].SetDefaults(290);
                  if (num6 == 4)
                    chest.item[index2].SetDefaults(303);
                  if (num6 == 5)
                    chest.item[index2].SetDefaults(291);
                  if (num6 == 6)
                    chest.item[index2].SetDefaults(304);
                  if (num6 == 7)
                    chest.item[index2].SetDefaults(2322);
                  if (num6 == 8)
                    chest.item[index2].SetDefaults(2329);
                  chest.item[index2].stack = num7;
                  ++index2;
                }
                if (WorldGen.genRand.Next(3) != 0)
                {
                  int num6 = WorldGen.genRand.Next(2, 5);
                  chest.item[index2].SetDefaults(2350);
                  chest.item[index2].stack = num6;
                  ++index2;
                }
                if (WorldGen.genRand.Next(2) == 0)
                {
                  int num6 = WorldGen.genRand.Next(11) + 10;
                  if (style == 11)
                    chest.item[index2].SetDefaults(974);
                  else
                    chest.item[index2].SetDefaults(8);
                  chest.item[index2].stack = num6;
                  ++index2;
                }
                if (WorldGen.genRand.Next(2) == 0)
                {
                  chest.item[index2].SetDefaults(72);
                  chest.item[index2].stack = WorldGen.genRand.Next(50, 90);
                  ++index2;
                }
              }
              else if (num5 < Main.maxTilesY - 250)
              {
                if (contain > 0)
                {
                  chest.item[index2].SetDefaults(contain);
                  chest.item[index2].Prefix(-1);
                  ++index2;
                  if (flag1 && WorldGen.genRand.Next(5) == 0)
                  {
                    chest.item[index2].SetDefaults(3199);
                    ++index2;
                  }
                  if (flag2)
                  {
                    if (WorldGen.genRand.Next(7) == 0)
                    {
                      chest.item[index2].SetDefaults(4346);
                      ++index2;
                    }
                    if (WorldGen.genRand.Next(15) == 0)
                    {
                      chest.item[index2].SetDefaults(4066);
                      ++index2;
                    }
                  }
                  if (flag3 && WorldGen.genRand.Next(6) == 0)
                  {
                    Item[] objArray1 = chest.item;
                    int index3 = index2;
                    int num6 = index3 + 1;
                    objArray1[index3].SetDefaults(3360);
                    Item[] objArray2 = chest.item;
                    int index5 = num6;
                    index2 = index5 + 1;
                    objArray2[index5].SetDefaults(3361);
                  }
                  if (flag3 && WorldGen.genRand.Next(10) == 0)
                    chest.item[index2++].SetDefaults(4426);
                  if (flag4 && WorldGen.genRand.Next(2) == 0)
                  {
                    chest.item[index2].SetDefaults(4460);
                    ++index2;
                  }
                  if (flag8 && (!WorldGen.generatedShadowKey || WorldGen.genRand.Next(3) == 0))
                  {
                    WorldGen.generatedShadowKey = true;
                    chest.item[index2].SetDefaults(329);
                    ++index2;
                  }
                }
                else
                {
                  int num6 = WorldGen.genRand.Next(7);
                  if (WorldGen.genRand.Next(40) == 0 && num5 > WorldGen.lavaLine)
                  {
                    chest.item[index2].SetDefaults(906);
                    chest.item[index2].Prefix(-1);
                  }
                  else if (WorldGen.genRand.Next(15) == 0)
                  {
                    chest.item[index2].SetDefaults(997);
                    chest.item[index2].Prefix(-1);
                  }
                  else
                  {
                    if (num6 == 0)
                    {
                      chest.item[index2].SetDefaults(49);
                      chest.item[index2].Prefix(-1);
                    }
                    if (num6 == 1)
                    {
                      chest.item[index2].SetDefaults(50);
                      chest.item[index2].Prefix(-1);
                    }
                    if (num6 == 2)
                    {
                      chest.item[index2].SetDefaults(53);
                      chest.item[index2].Prefix(-1);
                    }
                    if (num6 == 3)
                    {
                      chest.item[index2].SetDefaults(54);
                      chest.item[index2].Prefix(-1);
                    }
                    if (num6 == 4)
                    {
                      chest.item[index2].SetDefaults(5011);
                      chest.item[index2].Prefix(-1);
                    }
                    if (num6 == 5)
                    {
                      chest.item[index2].SetDefaults(975);
                      chest.item[index2].Prefix(-1);
                    }
                    if (num6 == 6)
                    {
                      chest.item[index2].SetDefaults(930);
                      chest.item[index2].Prefix(-1);
                      ++index2;
                      chest.item[index2].SetDefaults(931);
                      chest.item[index2].stack = WorldGen.genRand.Next(26) + 25;
                    }
                  }
                  ++index2;
                  if (flag6 && WorldGen.genRand.Next(2) == 0)
                  {
                    chest.item[index2].SetDefaults(4450);
                    ++index2;
                  }
                  if (flag6 && WorldGen.genRand.Next(3) == 0)
                  {
                    chest.item[index2].SetDefaults(4779);
                    int index3 = index2 + 1;
                    chest.item[index3].SetDefaults(4780);
                    int index5 = index3 + 1;
                    chest.item[index5].SetDefaults(4781);
                    index2 = index5 + 1;
                  }
                }
                if (WorldGen.genRand.Next(5) == 0)
                {
                  chest.item[index2].SetDefaults(43);
                  ++index2;
                }
                if (WorldGen.genRand.Next(3) == 0)
                {
                  chest.item[index2].SetDefaults(167);
                  ++index2;
                }
                if (WorldGen.genRand.Next(4) == 0)
                {
                  chest.item[index2].SetDefaults(51);
                  chest.item[index2].stack = WorldGen.genRand.Next(26) + 25;
                  ++index2;
                }
                if (WorldGen.genRand.Next(2) == 0)
                {
                  int num6 = WorldGen.genRand.Next(2);
                  int num7 = WorldGen.genRand.Next(8) + 3;
                  if (num6 == 0)
                    chest.item[index2].SetDefaults(WorldGen.goldBar);
                  if (num6 == 1)
                    chest.item[index2].SetDefaults(WorldGen.silverBar);
                  chest.item[index2].stack = num7;
                  ++index2;
                }
                if (WorldGen.genRand.Next(2) == 0)
                {
                  int num6 = WorldGen.genRand.Next(2);
                  int num7 = WorldGen.genRand.Next(26) + 25;
                  if (num6 == 0)
                    chest.item[index2].SetDefaults(41);
                  if (num6 == 1)
                    chest.item[index2].SetDefaults(279);
                  chest.item[index2].stack = num7;
                  ++index2;
                }
                if (WorldGen.genRand.Next(2) == 0)
                {
                  int num6 = WorldGen.genRand.Next(3) + 3;
                  chest.item[index2].SetDefaults(188);
                  chest.item[index2].stack = num6;
                  ++index2;
                }
                if (WorldGen.genRand.Next(3) > 0)
                {
                  int num6 = WorldGen.genRand.Next(6);
                  int num7 = WorldGen.genRand.Next(1, 3);
                  if (num6 == 0)
                    chest.item[index2].SetDefaults(296);
                  if (num6 == 1)
                    chest.item[index2].SetDefaults(295);
                  if (num6 == 2)
                    chest.item[index2].SetDefaults(299);
                  if (num6 == 3)
                    chest.item[index2].SetDefaults(302);
                  if (num6 == 4)
                    chest.item[index2].SetDefaults(303);
                  if (num6 == 5)
                    chest.item[index2].SetDefaults(305);
                  chest.item[index2].stack = num7;
                  ++index2;
                }
                if (WorldGen.genRand.Next(3) > 1)
                {
                  int num6 = WorldGen.genRand.Next(6);
                  int num7 = WorldGen.genRand.Next(1, 3);
                  if (num6 == 0)
                    chest.item[index2].SetDefaults(301);
                  if (num6 == 1)
                    chest.item[index2].SetDefaults(297);
                  if (num6 == 2)
                    chest.item[index2].SetDefaults(304);
                  if (num6 == 3)
                    chest.item[index2].SetDefaults(2329);
                  if (num6 == 4)
                    chest.item[index2].SetDefaults(2351);
                  if (num6 == 5)
                    chest.item[index2].SetDefaults(2326);
                  chest.item[index2].stack = num7;
                  ++index2;
                }
                if (WorldGen.genRand.Next(2) == 0)
                {
                  int num6 = WorldGen.genRand.Next(2, 5);
                  chest.item[index2].SetDefaults(2350);
                  chest.item[index2].stack = num6;
                  ++index2;
                }
                if (WorldGen.genRand.Next(2) == 0)
                {
                  int num6 = WorldGen.genRand.Next(2);
                  int num7 = WorldGen.genRand.Next(15) + 15;
                  if (num6 == 0)
                  {
                    if (style == 11)
                      chest.item[index2].SetDefaults(974);
                    else
                      chest.item[index2].SetDefaults(8);
                  }
                  if (num6 == 1)
                    chest.item[index2].SetDefaults(282);
                  chest.item[index2].stack = num7;
                  ++index2;
                }
                if (WorldGen.genRand.Next(2) == 0)
                {
                  chest.item[index2].SetDefaults(73);
                  chest.item[index2].stack = WorldGen.genRand.Next(1, 3);
                  ++index2;
                }
              }
              else
              {
                if (contain > 0)
                {
                  chest.item[index2].SetDefaults(contain);
                  chest.item[index2].Prefix(-1);
                  ++index2;
                  if (flag7 && WorldGen.genRand.Next(10) == 0)
                  {
                    chest.item[index2].SetDefaults(4443);
                    ++index2;
                  }
                  if (flag7 && WorldGen.genRand.Next(10) == 0)
                  {
                    chest.item[index2].SetDefaults(4737);
                    ++index2;
                  }
                  else if (flag7 && WorldGen.genRand.Next(10) == 0)
                  {
                    chest.item[index2].SetDefaults(4551);
                    ++index2;
                  }
                }
                else
                {
                  int num6 = WorldGen.genRand.Next(4);
                  if (num6 == 0)
                  {
                    chest.item[index2].SetDefaults(49);
                    chest.item[index2].Prefix(-1);
                  }
                  if (num6 == 1)
                  {
                    chest.item[index2].SetDefaults(50);
                    chest.item[index2].Prefix(-1);
                  }
                  if (num6 == 2)
                  {
                    chest.item[index2].SetDefaults(53);
                    chest.item[index2].Prefix(-1);
                  }
                  if (num6 == 3)
                  {
                    chest.item[index2].SetDefaults(54);
                    chest.item[index2].Prefix(-1);
                  }
                  ++index2;
                }
                if (WorldGen.genRand.Next(3) == 0)
                {
                  chest.item[index2].SetDefaults(167);
                  ++index2;
                }
                if (WorldGen.genRand.Next(2) == 0)
                {
                  int num6 = WorldGen.genRand.Next(2);
                  int num7 = WorldGen.genRand.Next(15) + 15;
                  if (num6 == 0)
                    chest.item[index2].SetDefaults(117);
                  if (num6 == 1)
                    chest.item[index2].SetDefaults(WorldGen.goldBar);
                  chest.item[index2].stack = num7;
                  ++index2;
                }
                if (WorldGen.genRand.Next(2) == 0)
                {
                  int num6 = WorldGen.genRand.Next(2);
                  int num7 = WorldGen.genRand.Next(25) + 50;
                  if (num6 == 0)
                    chest.item[index2].SetDefaults(265);
                  if (num6 == 1)
                  {
                    if (WorldGen.SavedOreTiers.Silver == 168)
                      chest.item[index2].SetDefaults(4915);
                    else
                      chest.item[index2].SetDefaults(278);
                  }
                  chest.item[index2].stack = num7;
                  ++index2;
                }
                if (WorldGen.genRand.Next(2) == 0)
                {
                  int num6 = WorldGen.genRand.Next(6) + 15;
                  chest.item[index2].SetDefaults(227);
                  chest.item[index2].stack = num6;
                  ++index2;
                }
                if (WorldGen.genRand.Next(4) > 0)
                {
                  int num6 = WorldGen.genRand.Next(8);
                  int num7 = WorldGen.genRand.Next(1, 3);
                  if (num6 == 0)
                    chest.item[index2].SetDefaults(296);
                  if (num6 == 1)
                    chest.item[index2].SetDefaults(295);
                  if (num6 == 2)
                    chest.item[index2].SetDefaults(293);
                  if (num6 == 3)
                    chest.item[index2].SetDefaults(288);
                  if (num6 == 4)
                    chest.item[index2].SetDefaults(294);
                  if (num6 == 5)
                    chest.item[index2].SetDefaults(297);
                  if (num6 == 6)
                    chest.item[index2].SetDefaults(304);
                  if (num6 == 7)
                    chest.item[index2].SetDefaults(2323);
                  chest.item[index2].stack = num7;
                  ++index2;
                }
                if (WorldGen.genRand.Next(3) > 0)
                {
                  int num6 = WorldGen.genRand.Next(8);
                  int num7 = WorldGen.genRand.Next(1, 3);
                  if (num6 == 0)
                    chest.item[index2].SetDefaults(305);
                  if (num6 == 1)
                    chest.item[index2].SetDefaults(301);
                  if (num6 == 2)
                    chest.item[index2].SetDefaults(302);
                  if (num6 == 3)
                    chest.item[index2].SetDefaults(288);
                  if (num6 == 4)
                    chest.item[index2].SetDefaults(300);
                  if (num6 == 5)
                    chest.item[index2].SetDefaults(2351);
                  if (num6 == 6)
                    chest.item[index2].SetDefaults(2348);
                  if (num6 == 7)
                    chest.item[index2].SetDefaults(2345);
                  chest.item[index2].stack = num7;
                  ++index2;
                }
                if (WorldGen.genRand.Next(3) == 0)
                {
                  int num6 = WorldGen.genRand.Next(1, 3);
                  if (WorldGen.genRand.Next(2) == 0)
                    chest.item[index2].SetDefaults(2350);
                  else
                    chest.item[index2].SetDefaults(4870);
                  chest.item[index2].stack = num6;
                  ++index2;
                }
                if (WorldGen.genRand.Next(2) == 0)
                {
                  int num6 = WorldGen.genRand.Next(2);
                  int num7 = WorldGen.genRand.Next(15) + 15;
                  if (num6 == 0)
                    chest.item[index2].SetDefaults(8);
                  if (num6 == 1)
                    chest.item[index2].SetDefaults(282);
                  chest.item[index2].stack = num7;
                  ++index2;
                }
                if (WorldGen.genRand.Next(2) == 0)
                {
                  chest.item[index2].SetDefaults(73);
                  chest.item[index2].stack = WorldGen.genRand.Next(2, 5);
                  ++index2;
                }
              }
              if (index2 > 0 && chestTileType == (ushort) 21)
              {
                if (style == 10 && WorldGen.genRand.Next(4) == 0)
                {
                  chest.item[index2].SetDefaults(2204);
                  ++index2;
                }
                if (style == 11 && WorldGen.genRand.Next(7) == 0)
                {
                  chest.item[index2].SetDefaults(2198);
                  ++index2;
                }
                if (style == 13 && WorldGen.genRand.Next(3) == 0)
                {
                  chest.item[index2].SetDefaults(2197);
                  ++index2;
                }
                if (style == 16)
                {
                  chest.item[index2].SetDefaults(2195);
                  ++index2;
                }
                if (Main.wallDungeon[(int) Main.tile[i, index1].wall] && WorldGen.genRand.Next(8) == 0)
                {
                  chest.item[index2].SetDefaults(2192);
                  ++index2;
                }
                if (style == 16)
                {
                  if (WorldGen.genRand.Next(5) == 0)
                  {
                    chest.item[index2].SetDefaults(2767);
                    ++index2;
                  }
                  else
                  {
                    chest.item[index2].SetDefaults(2766);
                    chest.item[index2].stack = WorldGen.genRand.Next(3, 8);
                    ++index2;
                  }
                }
              }
            }
            return true;
          }
          if (trySlope)
          {
            if (num1 > -1)
              Main.tile[i - 1, index1].slope((byte) num1);
            if (num2 > -1)
              Main.tile[i, index1].slope((byte) num2);
          }
          return false;
        }
      }
      return false;
    }

    public static void UnlockDoor(int i, int j)
    {
      int index1 = i;
      int index2 = j;
      if (Main.tile[index1, index2] == null)
        return;
      while (Main.tile[index1, index2].frameY != (short) 594)
      {
        --index2;
        if (Main.tile[index1, index2].frameY < (short) 594 || index2 <= 0)
          return;
      }
      SoundEngine.PlaySound(22, index1 * 16, index2 * 16 + 16, 1, 1f, 0.0f);
      for (int index3 = index2; index3 <= index2 + 2; ++index3)
      {
        if (Main.tile[index1, index3] == null)
          Main.tile[index1, index3] = new Tile();
        Main.tile[index1, index3].frameY += (short) 54;
        for (int index4 = 0; index4 < 4; ++index4)
          Dust.NewDust(new Vector2((float) (index1 * 16), (float) (index3 * 16)), 16, 16, 11, 0.0f, 0.0f, 0, new Color(), 1f);
      }
      AchievementsHelper.NotifyProgressionEvent(22);
    }

    public static bool OpenDoor(int i, int j, int direction)
    {
      if (Main.tile[i, j - 1] == null)
        Main.tile[i, j - 1] = new Tile();
      if (Main.tile[i, j - 2] == null)
        Main.tile[i, j - 2] = new Tile();
      if (Main.tile[i, j + 1] == null)
        Main.tile[i, j + 1] = new Tile();
      if (Main.tile[i, j] == null)
        Main.tile[i, j] = new Tile();
      Tile t = Main.tile[i, j];
      if (t.type != (ushort) 10 || WorldGen.IsLockedDoor(t))
        return false;
      short num1 = 0;
      int frameY = (int) t.frameY;
      int num2 = 0;
      while (frameY >= 54)
      {
        frameY -= 54;
        ++num2;
      }
      if (t.frameX >= (short) 54)
      {
        int num3 = (int) t.frameX / 54;
        num2 += 36 * num3;
        num1 += (short) (72 * num3);
      }
      int y = j - frameY / 18;
      int index = i;
      byte color1 = Main.tile[index, y].color();
      if (Main.tile[index, y + 1] == null)
        Main.tile[index, y + 1] = new Tile();
      byte color2 = Main.tile[index, y + 1].color();
      if (Main.tile[index, y + 2] == null)
        Main.tile[index, y + 2] = new Tile();
      byte color3 = Main.tile[index, y + 2].color();
      int x;
      int i1;
      if (direction == -1)
      {
        x = i - 1;
        num1 += (short) 36;
        i1 = i - 1;
      }
      else
      {
        x = i;
        i1 = i + 1;
      }
      for (int j1 = y; j1 < y + 3; ++j1)
      {
        if (Main.tile[i1, j1] == null)
          Main.tile[i1, j1] = new Tile();
        if (Main.tile[i1, j1].active())
        {
          if (!Main.tileCut[(int) Main.tile[i1, j1].type] && Main.tile[i1, j1].type != (ushort) 3 && (Main.tile[i1, j1].type != (ushort) 24 && Main.tile[i1, j1].type != (ushort) 52) && (Main.tile[i1, j1].type != (ushort) 61 && Main.tile[i1, j1].type != (ushort) 62 && (Main.tile[i1, j1].type != (ushort) 69 && Main.tile[i1, j1].type != (ushort) 71)) && (Main.tile[i1, j1].type != (ushort) 73 && Main.tile[i1, j1].type != (ushort) 74 && (Main.tile[i1, j1].type != (ushort) 110 && Main.tile[i1, j1].type != (ushort) 113) && (Main.tile[i1, j1].type != (ushort) 115 && Main.tile[i1, j1].type != (ushort) 165)))
            return false;
          WorldGen.KillTile(i1, j1, false, false, false);
        }
      }
      if (Main.netMode != 1 && Wiring.running)
      {
        Wiring.SkipWire(x, y);
        Wiring.SkipWire(x, y + 1);
        Wiring.SkipWire(x, y + 2);
        Wiring.SkipWire(x + 1, y);
        Wiring.SkipWire(x + 1, y + 1);
        Wiring.SkipWire(x + 1, y + 2);
      }
      int num4 = num2 % 36 * 54;
      SoundEngine.PlaySound(8, i * 16, j * 16, 1, 1f, 0.0f);
      Main.tile[x, y].active(true);
      Main.tile[x, y].type = (ushort) 11;
      Main.tile[x, y].frameY = (short) num4;
      Main.tile[x, y].frameX = num1;
      Main.tile[x, y].color(color1);
      if (Main.tile[x + 1, y] == null)
        Main.tile[x + 1, y] = new Tile();
      Main.tile[x + 1, y].active(true);
      Main.tile[x + 1, y].type = (ushort) 11;
      Main.tile[x + 1, y].frameY = (short) num4;
      Main.tile[x + 1, y].frameX = (short) ((int) num1 + 18);
      Main.tile[x + 1, y].color(color1);
      if (Main.tile[x, y + 1] == null)
        Main.tile[x, y + 1] = new Tile();
      Main.tile[x, y + 1].active(true);
      Main.tile[x, y + 1].type = (ushort) 11;
      Main.tile[x, y + 1].frameY = (short) (num4 + 18);
      Main.tile[x, y + 1].frameX = num1;
      Main.tile[x, y + 1].color(color2);
      if (Main.tile[x + 1, y + 1] == null)
        Main.tile[x + 1, y + 1] = new Tile();
      Main.tile[x + 1, y + 1].active(true);
      Main.tile[x + 1, y + 1].type = (ushort) 11;
      Main.tile[x + 1, y + 1].frameY = (short) (num4 + 18);
      Main.tile[x + 1, y + 1].frameX = (short) ((int) num1 + 18);
      Main.tile[x + 1, y + 1].color(color2);
      if (Main.tile[x, y + 2] == null)
        Main.tile[x, y + 2] = new Tile();
      Main.tile[x, y + 2].active(true);
      Main.tile[x, y + 2].type = (ushort) 11;
      Main.tile[x, y + 2].frameY = (short) (num4 + 36);
      Main.tile[x, y + 2].frameX = num1;
      Main.tile[x, y + 2].color(color3);
      if (Main.tile[x + 1, y + 2] == null)
        Main.tile[x + 1, y + 2] = new Tile();
      Main.tile[x + 1, y + 2].active(true);
      Main.tile[x + 1, y + 2].type = (ushort) 11;
      Main.tile[x + 1, y + 2].frameY = (short) (num4 + 36);
      Main.tile[x + 1, y + 2].frameX = (short) ((int) num1 + 18);
      Main.tile[x + 1, y + 2].color(color3);
      for (int i2 = x - 1; i2 <= x + 2; ++i2)
      {
        for (int j1 = y - 1; j1 <= y + 2; ++j1)
          WorldGen.TileFrame(i2, j1, false, false);
      }
      return true;
    }

    public static void Check1xX(int x, int j, short type)
    {
      if (WorldGen.destroyObject)
        return;
      int frameX = (int) Main.tile[x, j].frameX;
      int num1 = 3;
      if (type == (short) 92)
        num1 = 6;
      int frameY = (int) Main.tile[x, j].frameY;
      int num2 = 0;
      while (frameY >= 18 * num1)
      {
        frameY -= 18 * num1;
        ++num2;
      }
      int num3 = (int) Main.tile[x, j].frameX / 18;
      int num4 = j - frameY / 18;
      bool flag = false;
      for (int index = 0; index < num1; ++index)
      {
        if (Main.tile[x, num4 + index] == null)
          Main.tile[x, num4 + index] = new Tile();
        if (!Main.tile[x, num4 + index].active())
          flag = true;
        else if ((int) Main.tile[x, num4 + index].type != (int) type)
          flag = true;
        else if ((int) Main.tile[x, num4 + index].frameY != index * 18 + num2 * num1 * 18)
          flag = true;
        else if ((int) Main.tile[x, num4 + index].frameX != frameX)
          flag = true;
      }
      if (Main.tile[x, num4 + num1] == null)
        Main.tile[x, num4 + num1] = new Tile();
      if (!WorldGen.SolidTileAllowBottomSlope(x, num4 + num1))
        flag = true;
      if (!flag)
        return;
      WorldGen.destroyObject = true;
      for (int index = 0; index < num1; ++index)
      {
        if ((int) Main.tile[x, num4 + index].type == (int) type)
          WorldGen.KillTile(x, num4 + index, false, false, false);
      }
      if (type == (short) 92)
        Item.NewItem(x * 16, j * 16, 32, 32, 341, 1, false, 0, false, false);
      if (type == (short) 453)
      {
        int Type = num3 >= 2 ? (num3 >= 4 ? 3743 : 3745) : 3744;
        Item.NewItem(x * 16, j * 16, 16, 32, Type, 1, false, 0, false, false);
      }
      if (type == (short) 93)
      {
        int Type = 0;
        if (num2 == 0)
          Type = 342;
        else if (num2 >= 1 && num2 <= 10)
          Type = 2082 + num2 - 1;
        else if (num2 >= 11 && num2 <= 16)
        {
          Type = 2129 + num2 - 11;
        }
        else
        {
          switch (num2)
          {
            case 17:
              Type = 2225;
              break;
            case 18:
              Type = 2533;
              break;
            case 19:
              Type = 2547;
              break;
            case 20:
              Type = 2563;
              break;
            case 21:
              Type = 2578;
              break;
            case 22:
              Type = 2643;
              break;
            case 23:
              Type = 2644;
              break;
            case 24:
              Type = 2645;
              break;
            case 25:
              Type = 2646;
              break;
            case 26:
              Type = 2647;
              break;
            case 27:
              Type = 2819;
              break;
            case 28:
              Type = 3135;
              break;
            case 29:
              Type = 3137;
              break;
            case 30:
              Type = 3136;
              break;
            case 31:
              Type = 3892;
              break;
            case 32:
              Type = 3942;
              break;
            case 33:
              Type = 3969;
              break;
            case 34:
              Type = 4156;
              break;
            case 35:
              Type = 4177;
              break;
            case 36:
              Type = 4198;
              break;
            case 37:
              Type = 4219;
              break;
            case 38:
              Type = 4308;
              break;
            case 39:
              Type = 4577;
              break;
          }
        }
        Item.NewItem(x * 16, j * 16, 32, 32, Type, 1, false, 0, false, false);
      }
      WorldGen.destroyObject = false;
    }

    public static void Check2xX(int i, int j, ushort type)
    {
      if (WorldGen.destroyObject)
        return;
      int index1 = i;
      int frameX1 = (int) Main.tile[i, j].frameX;
      while (frameX1 >= 36)
        frameX1 -= 36;
      if (frameX1 == 18)
        --index1;
      if (Main.tile[index1, j] == null)
        Main.tile[index1, j] = new Tile();
      int num1 = (int) Main.tile[index1, j].frameY / 18;
      int num2 = 3;
      if (type == (ushort) 104)
        num2 = 5;
      if (type == (ushort) 207)
        num2 = 4;
      int num3 = 0;
      while (num1 >= num2)
      {
        num1 -= num2;
        num3 += num2 * 18;
      }
      int y = j - num1;
      if (type == (ushort) 410 && num3 != 0)
        num3 += 2;
      if (Main.tile[index1, y] == null)
        Main.tile[index1, y] = new Tile();
      int frameX2 = (int) Main.tile[index1, j].frameX;
      int frameY = (int) Main.tile[index1, j].frameY;
      bool flag = false;
      for (int index2 = 0; index2 < num2; ++index2)
      {
        if (Main.tile[index1, y + index2] == null)
          Main.tile[index1, y + index2] = new Tile();
        if (!Main.tile[index1, y + index2].active())
          flag = true;
        else if ((int) Main.tile[index1, y + index2].type != (int) type)
          flag = true;
        else if ((int) Main.tile[index1, y + index2].frameY != index2 * 18 + num3)
          flag = true;
        else if ((int) Main.tile[index1, y + index2].frameX != frameX2)
          flag = true;
        if (Main.tile[index1 + 1, y + index2] == null)
          Main.tile[index1 + 1, y + index2] = new Tile();
        if (!Main.tile[index1 + 1, y + index2].active())
          flag = true;
        else if ((int) Main.tile[index1 + 1, y + index2].type != (int) type)
          flag = true;
        else if ((int) Main.tile[index1 + 1, y + index2].frameY != index2 * 18 + num3)
          flag = true;
        else if ((int) Main.tile[index1 + 1, y + index2].frameX != frameX2 + 18)
          flag = true;
      }
      if (type == (ushort) 465 || type == (ushort) 531 || (type == (ushort) 591 || type == (ushort) 592))
      {
        for (int index2 = 0; index2 < 2; ++index2)
        {
          if (!WorldGen.SolidTileAllowTopSlope(index1 + index2, y - 1))
          {
            flag = true;
            break;
          }
        }
      }
      else
      {
        if (!WorldGen.SolidTileAllowBottomSlope(index1, y + num2))
          flag = true;
        if (!WorldGen.SolidTileAllowBottomSlope(index1 + 1, y + num2))
          flag = true;
      }
      if (!flag)
        return;
      WorldGen.destroyObject = true;
      for (int index2 = 0; index2 < num2; ++index2)
      {
        if ((int) Main.tile[index1, y + index2].type == (int) type)
          WorldGen.KillTile(index1, y + index2, false, false, false);
        if ((int) Main.tile[index1 + 1, y + index2].type == (int) type)
          WorldGen.KillTile(index1 + 1, y + index2, false, false, false);
      }
      if (type == (ushort) 104)
      {
        int num4 = frameX2 / 36;
        int Type = num4 < 1 || num4 > 5 ? (num4 != 6 ? (num4 != 7 ? (num4 < 8 || num4 > 23 ? (num4 != 24 ? (num4 != 25 ? (num4 != 26 ? (num4 != 27 ? (num4 != 28 ? (num4 != 29 ? (num4 != 30 ? (num4 != 31 ? (num4 != 32 ? (num4 != 33 ? (num4 != 34 ? (num4 != 35 ? (num4 != 36 ? (num4 != 37 ? (num4 != 38 ? (num4 != 39 ? (num4 != 40 ? 359 : 4575) : 4306) : 4217) : 4196) : 4175) : 4154) : 3966) : 3940) : 3902) : 3901) : 3900) : 3899) : 3898) : 3127) : 3128) : 3126) : 2809) : 2591 + num4 - 8) : 2575) : 2560) : 2237 + num4 - 1;
        Item.NewItem(index1 * 16, j * 16, 32, 32, Type, 1, false, 0, false, false);
      }
      if (type == (ushort) 105)
      {
        int num4 = frameX2 / 36 + frameY / 54 % 3 * 55;
        int Type = num4 != 0 ? (num4 != 1 ? (num4 != 43 ? (num4 != 44 ? (num4 != 45 ? (num4 != 46 ? (num4 != 47 ? (num4 != 48 ? (num4 != 49 ? (num4 != 50 ? (num4 < 51 || num4 > 62 ? (num4 < 63 || num4 > 75 ? (num4 != 76 ? (num4 != 77 ? (num4 != 78 ? (num4 != 79 ? 438 + num4 - 2 : 4466) : 4342) : 4360) : 4397) : 3708 + num4 - 63) : 3651 + num4 - 51) : 2672) : 1462) : 1410) : 1409) : 1408) : 1154) : 1153) : 1152) : 52) : 360;
        Item.NewItem(index1 * 16, j * 16, 32, 32, Type, 1, false, 0, false, false);
      }
      if (type == (ushort) 356)
        Item.NewItem(index1 * 16, j * 16, 32, 32, 3064, 1, false, 0, false, false);
      if (type == (ushort) 456)
        Item.NewItem(index1 * 16, j * 16, 32, 32, 3748, 1, false, 0, false, false);
      if (type == (ushort) 337)
      {
        int num4 = frameX2 / 36;
        Item.NewItem(index1 * 16, j * 16, 32, 32, 2702 + num4, 1, false, 0, false, false);
      }
      if (type == (ushort) 207)
      {
        int Type = frameX2 / 36;
        switch (Type)
        {
          case 0:
            Type = 909;
            break;
          case 1:
            Type = 910;
            break;
          default:
            if (Type >= 2 && Type <= 7)
            {
              Type = 938 + Type;
              break;
            }
            switch (Type)
            {
              case 8:
                Type = 4922;
                break;
              case 9:
                Type = 4417;
                break;
            }
            break;
        }
        Item.NewItem(index1 * 16, j * 16, 32, 32, Type, 1, false, 0, false, false);
      }
      if (type == (ushort) 410)
      {
        int num4 = frameX2 / 36;
        Item.NewItem(index1 * 16, j * 16, 32, 32, num4 + 3536, 1, false, 0, false, false);
      }
      if (type == (ushort) 480)
        Item.NewItem(index1 * 16, j * 16, 32, 32, 4054, 1, false, 0, false, false);
      if (type == (ushort) 509)
        Item.NewItem(index1 * 16, j * 16, 32, 32, 4318, 1, false, 0, false, false);
      if (type == (ushort) 489)
        Item.NewItem(index1 * 16, j * 16, 32, 32, 4074, 1, false, 0, false, false);
      if (type == (ushort) 320)
        Item.NewItem(index1 * 16, j * 16, 32, 32, 2496, 1, false, 0, false, false);
      if (type == (ushort) 349)
        Item.NewItem(index1 * 16, j * 16, 32, 32, 470, 1, false, 0, false, false);
      if (type == (ushort) 506)
        Item.NewItem(index1 * 16, j * 16, 32, 32, 4276, 1, false, 0, false, false);
      if (type == (ushort) 545)
        Item.NewItem(index1 * 16, j * 16, 32, 32, 4420, 1, false, 0, false, false);
      if (type == (ushort) 465)
        Item.NewItem(index1 * 16, j * 16, 32, 32, 3815, 1, false, 0, false, false);
      if (type == (ushort) 531)
        Item.NewItem(index1 * 16, j * 16, 32, 32, 4355, 1, false, 0, false, false);
      if (type == (ushort) 378)
      {
        Item.NewItem(index1 * 16, j * 16, 32, 48, 3202, 1, false, 0, false, false);
        TETrainingDummy.Kill(index1, y);
      }
      if (type == (ushort) 560)
      {
        int num4 = frameX2 / 36;
        Item.NewItem(index1 * 16, j * 16, 32, 32, num4 + 4599, 1, false, 0, false, false);
      }
      if (type == (ushort) 591)
      {
        int num4 = frameX2 / 36;
        Item.NewItem(index1 * 16, j * 16, 32, 32, num4 + 4858, 1, false, 0, false, false);
      }
      if (type == (ushort) 592)
        Item.NewItem(index1 * 16, j * 16, 32, 32, 4867, 1, false, 0, false, false);
      WorldGen.destroyObject = false;
    }

    public static void PlaceTight(int x, int y, bool spiders = false)
    {
      if (Main.tile[x, y - 1] == null)
        Main.tile[x, y - 1] = new Tile();
      if (Main.tile[x, y] == null)
        Main.tile[x, y] = new Tile();
      if (Main.tile[x, y + 1] == null)
        Main.tile[x, y + 1] = new Tile();
      WorldGen.PlaceUncheckedStalactite(x, y, WorldGen.genRand.Next(2) == 0, WorldGen.genRand.Next(3), spiders);
      if (Main.tile[x, y].type != (ushort) 165)
        return;
      WorldGen.CheckTight(x, y);
    }

    public static void PlaceUncheckedStalactite(
      int x,
      int y,
      bool preferSmall,
      int variation,
      bool spiders)
    {
      ushort num1 = 165;
      variation = Utils.Clamp<int>(variation, 0, 2);
      if (WorldGen.SolidTile(x, y - 1, false) && !Main.tile[x, y].active() && !Main.tile[x, y + 1].active())
      {
        if (spiders)
        {
          int num2 = 108 + variation * 18;
          Main.tile[x, y].type = num1;
          Main.tile[x, y].active(true);
          Main.tile[x, y].frameX = (short) num2;
          Main.tile[x, y].frameY = (short) 0;
          Main.tile[x, y + 1].type = num1;
          Main.tile[x, y + 1].active(true);
          Main.tile[x, y + 1].frameX = (short) num2;
          Main.tile[x, y + 1].frameY = (short) 18;
        }
        else
        {
          if (Main.tile[x, y - 1].type == (ushort) 147 || Main.tile[x, y - 1].type == (ushort) 161 || (Main.tile[x, y - 1].type == (ushort) 163 || Main.tile[x, y - 1].type == (ushort) 164) || Main.tile[x, y - 1].type == (ushort) 200)
          {
            if (preferSmall)
            {
              int num2 = variation * 18;
              Main.tile[x, y].type = num1;
              Main.tile[x, y].active(true);
              Main.tile[x, y].frameX = (short) num2;
              Main.tile[x, y].frameY = (short) 72;
            }
            else
            {
              int num2 = variation * 18;
              Main.tile[x, y].type = num1;
              Main.tile[x, y].active(true);
              Main.tile[x, y].frameX = (short) num2;
              Main.tile[x, y].frameY = (short) 0;
              Main.tile[x, y + 1].type = num1;
              Main.tile[x, y + 1].active(true);
              Main.tile[x, y + 1].frameX = (short) num2;
              Main.tile[x, y + 1].frameY = (short) 18;
            }
          }
          if (Main.tile[x, y - 1].type == (ushort) 1 || Main.tileMoss[(int) Main.tile[x, y - 1].type] || (Main.tile[x, y - 1].type == (ushort) 117 || Main.tile[x, y - 1].type == (ushort) 25) || Main.tile[x, y - 1].type == (ushort) 203)
          {
            if (preferSmall)
            {
              int num2 = 54 + variation * 18;
              Main.tile[x, y].type = num1;
              Main.tile[x, y].active(true);
              Main.tile[x, y].frameX = (short) num2;
              Main.tile[x, y].frameY = (short) 72;
            }
            else
            {
              int num2 = 54 + variation * 18;
              Main.tile[x, y].type = num1;
              Main.tile[x, y].active(true);
              Main.tile[x, y].frameX = (short) num2;
              Main.tile[x, y].frameY = (short) 0;
              Main.tile[x, y + 1].type = num1;
              Main.tile[x, y + 1].active(true);
              Main.tile[x, y + 1].frameX = (short) num2;
              Main.tile[x, y + 1].frameY = (short) 18;
            }
          }
          if (Main.tile[x, y - 1].type == (ushort) 225)
          {
            int num2 = 162 + variation * 18;
            Main.tile[x, y].type = num1;
            Main.tile[x, y].active(true);
            Main.tile[x, y].frameX = (short) num2;
            Main.tile[x, y].frameY = (short) 72;
          }
          if (Main.tile[x, y - 1].type == (ushort) 396 || Main.tile[x, y - 1].type == (ushort) 397)
          {
            if (preferSmall)
            {
              int num2 = 378 + variation * 18;
              Main.tile[x, y].type = num1;
              Main.tile[x, y].active(true);
              Main.tile[x, y].frameX = (short) num2;
              Main.tile[x, y].frameY = (short) 72;
            }
            else
            {
              int num2 = 378 + variation * 18;
              Main.tile[x, y].type = num1;
              Main.tile[x, y].active(true);
              Main.tile[x, y].frameX = (short) num2;
              Main.tile[x, y].frameY = (short) 0;
              Main.tile[x, y + 1].type = num1;
              Main.tile[x, y + 1].active(true);
              Main.tile[x, y + 1].frameX = (short) num2;
              Main.tile[x, y + 1].frameY = (short) 18;
            }
          }
          if (Main.tile[x, y - 1].type == (ushort) 368)
          {
            if (preferSmall)
            {
              int num2 = 432 + variation * 18;
              Main.tile[x, y].type = num1;
              Main.tile[x, y].active(true);
              Main.tile[x, y].frameX = (short) num2;
              Main.tile[x, y].frameY = (short) 72;
            }
            else
            {
              int num2 = 432 + variation * 18;
              Main.tile[x, y].type = num1;
              Main.tile[x, y].active(true);
              Main.tile[x, y].frameX = (short) num2;
              Main.tile[x, y].frameY = (short) 0;
              Main.tile[x, y + 1].type = num1;
              Main.tile[x, y + 1].active(true);
              Main.tile[x, y + 1].frameX = (short) num2;
              Main.tile[x, y + 1].frameY = (short) 18;
            }
          }
          if (Main.tile[x, y - 1].type != (ushort) 367)
            return;
          if (preferSmall)
          {
            int num2 = 486 + variation * 18;
            Main.tile[x, y].type = num1;
            Main.tile[x, y].active(true);
            Main.tile[x, y].frameX = (short) num2;
            Main.tile[x, y].frameY = (short) 72;
          }
          else
          {
            int num2 = 486 + variation * 18;
            Main.tile[x, y].type = num1;
            Main.tile[x, y].active(true);
            Main.tile[x, y].frameX = (short) num2;
            Main.tile[x, y].frameY = (short) 0;
            Main.tile[x, y + 1].type = num1;
            Main.tile[x, y + 1].active(true);
            Main.tile[x, y + 1].frameX = (short) num2;
            Main.tile[x, y + 1].frameY = (short) 18;
          }
        }
      }
      else
      {
        if (spiders || !WorldGen.SolidTile(x, y + 1, false) || (Main.tile[x, y].active() || Main.tile[x, y - 1].active()))
          return;
        if (Main.tile[x, y + 1].type == (ushort) 1 || Main.tileMoss[(int) Main.tile[x, y + 1].type] || (Main.tile[x, y - 1].type == (ushort) 117 || Main.tile[x, y - 1].type == (ushort) 25) || Main.tile[x, y - 1].type == (ushort) 203)
        {
          if (preferSmall)
          {
            int num2 = 54 + variation * 18;
            Main.tile[x, y].type = num1;
            Main.tile[x, y].active(true);
            Main.tile[x, y].frameX = (short) num2;
            Main.tile[x, y].frameY = (short) 90;
          }
          else
          {
            int num2 = 54 + variation * 18;
            Main.tile[x, y - 1].type = num1;
            Main.tile[x, y - 1].active(true);
            Main.tile[x, y - 1].frameX = (short) num2;
            Main.tile[x, y - 1].frameY = (short) 36;
            Main.tile[x, y].type = num1;
            Main.tile[x, y].active(true);
            Main.tile[x, y].frameX = (short) num2;
            Main.tile[x, y].frameY = (short) 54;
          }
        }
        if (Main.tile[x, y + 1].type == (ushort) 225)
        {
          int num2 = 162 + variation * 18;
          Main.tile[x, y].type = num1;
          Main.tile[x, y].active(true);
          Main.tile[x, y].frameX = (short) num2;
          Main.tile[x, y].frameY = (short) 90;
        }
        if (Main.tile[x, y + 1].type == (ushort) 396 || Main.tile[x, y + 1].type == (ushort) 397)
        {
          if (preferSmall)
          {
            int num2 = 378 + variation * 18;
            Main.tile[x, y].type = num1;
            Main.tile[x, y].active(true);
            Main.tile[x, y].frameX = (short) num2;
            Main.tile[x, y].frameY = (short) 90;
          }
          else
          {
            int num2 = 378 + variation * 18;
            Main.tile[x, y - 1].type = num1;
            Main.tile[x, y - 1].active(true);
            Main.tile[x, y - 1].frameX = (short) num2;
            Main.tile[x, y - 1].frameY = (short) 36;
            Main.tile[x, y].type = num1;
            Main.tile[x, y].active(true);
            Main.tile[x, y].frameX = (short) num2;
            Main.tile[x, y].frameY = (short) 54;
          }
        }
        if (Main.tile[x, y + 1].type == (ushort) 368)
        {
          if (preferSmall)
          {
            int num2 = 432 + variation * 18;
            Main.tile[x, y].type = num1;
            Main.tile[x, y].active(true);
            Main.tile[x, y].frameX = (short) num2;
            Main.tile[x, y].frameY = (short) 90;
          }
          else
          {
            int num2 = 432 + variation * 18;
            Main.tile[x, y - 1].type = num1;
            Main.tile[x, y - 1].active(true);
            Main.tile[x, y - 1].frameX = (short) num2;
            Main.tile[x, y - 1].frameY = (short) 36;
            Main.tile[x, y].type = num1;
            Main.tile[x, y].active(true);
            Main.tile[x, y].frameX = (short) num2;
            Main.tile[x, y].frameY = (short) 54;
          }
        }
        if (Main.tile[x, y + 1].type != (ushort) 367)
          return;
        if (preferSmall)
        {
          int num2 = 486 + variation * 18;
          Main.tile[x, y].type = num1;
          Main.tile[x, y].active(true);
          Main.tile[x, y].frameX = (short) num2;
          Main.tile[x, y].frameY = (short) 90;
        }
        else
        {
          int num2 = 486 + variation * 18;
          Main.tile[x, y - 1].type = num1;
          Main.tile[x, y - 1].active(true);
          Main.tile[x, y - 1].frameX = (short) num2;
          Main.tile[x, y - 1].frameY = (short) 36;
          Main.tile[x, y].type = num1;
          Main.tile[x, y].active(true);
          Main.tile[x, y].frameX = (short) num2;
          Main.tile[x, y].frameY = (short) 54;
        }
      }
    }

    public static bool UpdateStalagtiteStyle(int x, int j)
    {
      if (Main.netMode == 1 || Main.tile[x, j] == null)
        return true;
      int style;
      bool fail1;
      WorldGen.GetStalagtiteStyle(x, j, out style, out fail1);
      if (fail1)
        return false;
      bool fail2;
      int desiredStyle;
      int height;
      int y;
      WorldGen.GetDesiredStalagtiteStyle(x, j, out fail2, out desiredStyle, out height, out y);
      if (fail2)
        return false;
      if (style != desiredStyle)
      {
        int num = WorldGen.genRand.Next(3) * 18;
        switch (desiredStyle)
        {
          case 0:
            num += 54;
            break;
          case 1:
            num += 216;
            break;
          case 2:
            num += 270;
            break;
          case 3:
            num += 324;
            break;
          case 4:
            num += 378;
            break;
          case 5:
            num += 432;
            break;
          case 6:
            num += 486;
            break;
          case 7:
            num = num;
            break;
          case 8:
            num += 540;
            break;
          case 9:
            num += 594;
            break;
          case 10:
            num += 648;
            break;
        }
        for (int index = y; index < y + height; ++index)
          Main.tile[x, index].frameX = (short) num;
        if (Main.netMode == 2)
          NetMessage.SendTileSquare(-1, x, y, 2, TileChangeType.None);
      }
      return true;
    }

    private static void GetDesiredStalagtiteStyle(
      int x,
      int j,
      out bool fail,
      out int desiredStyle,
      out int height,
      out int y)
    {
      fail = false;
      desiredStyle = 0;
      height = 1;
      y = j;
      if (Main.tile[x, y].frameY == (short) 72)
        desiredStyle = (int) Main.tile[x, y - 1].type;
      else if (Main.tile[x, y].frameY == (short) 90)
        desiredStyle = (int) Main.tile[x, y + 1].type;
      else if (Main.tile[x, y].frameY >= (short) 36)
      {
        if (Main.tile[x, y].frameY == (short) 54)
          --y;
        height = 2;
        desiredStyle = (int) Main.tile[x, y + 2].type;
      }
      else
      {
        if (Main.tile[x, y].frameY == (short) 18)
          --y;
        height = 2;
        desiredStyle = (int) Main.tile[x, y - 1].type;
      }
      if (desiredStyle == 1 || Main.tileMoss[desiredStyle])
        desiredStyle = 0;
      else if (desiredStyle == 200)
        desiredStyle = 10;
      else if (desiredStyle == 164)
        desiredStyle = 8;
      else if (desiredStyle == 163)
        desiredStyle = 9;
      else if (desiredStyle == 117 || desiredStyle == 402 || desiredStyle == 403)
        desiredStyle = 1;
      else if (desiredStyle == 25 || desiredStyle == 398 || desiredStyle == 400)
        desiredStyle = 2;
      else if (desiredStyle == 203 || desiredStyle == 399 || desiredStyle == 401)
        desiredStyle = 3;
      else if (desiredStyle == 396 || desiredStyle == 397)
        desiredStyle = 4;
      else if (desiredStyle == 367)
        desiredStyle = 6;
      else if (desiredStyle == 368)
        desiredStyle = 5;
      else if (desiredStyle == 161 || desiredStyle == 147)
        desiredStyle = 7;
      else
        fail = true;
    }

    private static void GetStalagtiteStyle(int x, int y, out int style, out bool fail)
    {
      style = 0;
      fail = false;
      switch ((int) Main.tile[x, y].frameX / 54)
      {
        case 0:
          style = 7;
          break;
        case 1:
          style = 0;
          break;
        case 4:
          style = 1;
          break;
        case 5:
          style = 2;
          break;
        case 6:
          style = 3;
          break;
        case 7:
          style = 4;
          break;
        case 8:
          style = 5;
          break;
        case 9:
          style = 6;
          break;
        case 10:
          style = 8;
          break;
        case 11:
          style = 9;
          break;
        case 12:
          style = 10;
          break;
        default:
          fail = true;
          break;
      }
    }

    public static void CheckTight(int x, int j)
    {
      if (Main.tile[x, j] == null)
        return;
      int j1 = j;
      if (Main.tile[x, j1].frameY == (short) 72)
      {
        if (Main.tile[x, j1 - 1] == null)
          Main.tile[x, j1 - 1] = new Tile();
        if (Main.tile[x, j1] == null)
          Main.tile[x, j1] = new Tile();
        if (Main.tile[x, j1 + 1] == null)
          Main.tile[x, j1 + 1] = new Tile();
        bool flag = false;
        if (!WorldGen.SolidTile(x, j1 - 1, false))
          flag = true;
        if (!flag && !WorldGen.UpdateStalagtiteStyle(x, j1))
          flag = true;
        if (!flag)
          return;
        WorldGen.destroyObject = true;
        if ((int) Main.tile[x, j1].type == (int) Main.tile[x, j].type)
          WorldGen.KillTile(x, j1, false, false, false);
        WorldGen.destroyObject = false;
      }
      else if (Main.tile[x, j1].frameY == (short) 90)
      {
        if (Main.tile[x, j1 - 1] == null)
          Main.tile[x, j1 - 1] = new Tile();
        if (Main.tile[x, j1] == null)
          Main.tile[x, j1] = new Tile();
        if (Main.tile[x, j1 + 1] == null)
          Main.tile[x, j1 + 1] = new Tile();
        bool flag = false;
        if (!WorldGen.SolidTile(x, j1 + 1, false))
          flag = true;
        if (!flag && !WorldGen.UpdateStalagtiteStyle(x, j1))
          flag = true;
        if (!flag)
          return;
        WorldGen.destroyObject = true;
        if ((int) Main.tile[x, j1].type == (int) Main.tile[x, j].type)
          WorldGen.KillTile(x, j1, false, false, false);
        WorldGen.destroyObject = false;
      }
      else if (Main.tile[x, j1].frameY >= (short) 36)
      {
        if (Main.tile[x, j1].frameY == (short) 54)
          --j1;
        if (Main.tile[x, j1] == null)
          Main.tile[x, j1] = new Tile();
        if (Main.tile[x, j1 + 1] == null)
          Main.tile[x, j1 + 1] = new Tile();
        if (Main.tile[x, j1 + 2] == null)
          Main.tile[x, j1 + 2] = new Tile();
        bool flag = false;
        if (!WorldGen.SolidTile(x, j1 + 2, false))
          flag = true;
        if ((int) Main.tile[x, j1 + 1].type != (int) Main.tile[x, j1].type)
          flag = true;
        if ((int) Main.tile[x, j1 + 1].frameX != (int) Main.tile[x, j1].frameX)
          flag = true;
        if (!flag && !WorldGen.UpdateStalagtiteStyle(x, j1))
          flag = true;
        if (!flag)
          return;
        WorldGen.destroyObject = true;
        if ((int) Main.tile[x, j1].type == (int) Main.tile[x, j].type)
          WorldGen.KillTile(x, j1, false, false, false);
        if ((int) Main.tile[x, j1 + 1].type == (int) Main.tile[x, j].type)
          WorldGen.KillTile(x, j1 + 1, false, false, false);
        WorldGen.destroyObject = false;
      }
      else
      {
        if (Main.tile[x, j1].frameY == (short) 18)
          --j1;
        if (Main.tile[x, j1 - 1] == null)
          Main.tile[x, j1 - 1] = new Tile();
        if (Main.tile[x, j1] == null)
          Main.tile[x, j1] = new Tile();
        if (Main.tile[x, j1 + 1] == null)
          Main.tile[x, j1 + 1] = new Tile();
        bool flag = false;
        if (!WorldGen.SolidTile(x, j1 - 1, false))
          flag = true;
        if ((int) Main.tile[x, j1 + 1].type != (int) Main.tile[x, j1].type)
          flag = true;
        if ((int) Main.tile[x, j1 + 1].frameX != (int) Main.tile[x, j1].frameX)
          flag = true;
        if (!flag && !WorldGen.UpdateStalagtiteStyle(x, j1))
          flag = true;
        if (!flag)
          return;
        WorldGen.destroyObject = true;
        if ((int) Main.tile[x, j1].type == (int) Main.tile[x, j].type)
          WorldGen.KillTile(x, j1, false, false, false);
        if ((int) Main.tile[x, j1 + 1].type == (int) Main.tile[x, j].type)
          WorldGen.KillTile(x, j1 + 1, false, false, false);
        WorldGen.destroyObject = false;
      }
    }

    public static void Place1xX(int x, int y, ushort type, int style = 0)
    {
      int num1 = style * 18;
      int num2 = 3;
      if (type == (ushort) 92)
        num2 = 6;
      bool flag = true;
      for (int index = y - num2 + 1; index < y + 1; ++index)
      {
        if (Main.tile[x, index] == null)
          Main.tile[x, index] = new Tile();
        if (Main.tile[x, index].active())
          flag = false;
        if (type == (ushort) 93 && Main.tile[x, index].liquid > (byte) 0)
          flag = false;
      }
      if (!flag || !WorldGen.SolidTile2(x, y + 1))
        return;
      for (int index = 0; index < num2; ++index)
      {
        Main.tile[x, y - num2 + 1 + index].active(true);
        Main.tile[x, y - num2 + 1 + index].frameY = (short) (index * 18 + num2 * num1);
        Main.tile[x, y - num2 + 1 + index].frameX = (short) 0;
        Main.tile[x, y - num2 + 1 + index].type = type;
      }
    }

    public static int checkXmasTreeDrop(int x, int y, int obj)
    {
      int index1 = x;
      int index2 = y;
      if (Main.tile[x, y].frameX < (short) 10)
      {
        index1 -= (int) Main.tile[x, y].frameX;
        index2 -= (int) Main.tile[x, y].frameY;
      }
      int num1 = 0;
      if (((int) Main.tile[index1, index2].frameY & 1) == 1)
        ++num1;
      if (((int) Main.tile[index1, index2].frameY & 2) == 2)
        num1 += 2;
      if (((int) Main.tile[index1, index2].frameY & 4) == 4)
        num1 += 4;
      int num2 = 0;
      if (((int) Main.tile[index1, index2].frameY & 8) == 8)
        ++num2;
      if (((int) Main.tile[index1, index2].frameY & 16) == 16)
        num2 += 2;
      if (((int) Main.tile[index1, index2].frameY & 32) == 32)
        num2 += 4;
      int num3 = 0;
      if (((int) Main.tile[index1, index2].frameY & 64) == 64)
        ++num3;
      if (((int) Main.tile[index1, index2].frameY & 128) == 128)
        num3 += 2;
      if (((int) Main.tile[index1, index2].frameY & 256) == 256)
        num3 += 4;
      if (((int) Main.tile[index1, index2].frameY & 512) == 512)
        num3 += 8;
      int num4 = 0;
      if (((int) Main.tile[index1, index2].frameY & 1024) == 1024)
        ++num4;
      if (((int) Main.tile[index1, index2].frameY & 2048) == 2048)
        num4 += 2;
      if (((int) Main.tile[index1, index2].frameY & 4096) == 4096)
        num4 += 4;
      if (((int) Main.tile[index1, index2].frameY & 8192) == 8192)
        num4 += 8;
      if (obj == 0 && num1 > 0)
        return num1;
      if (obj == 1 && num2 > 0)
        return num2;
      if (obj == 2 && num3 > 0)
        return num3;
      return obj == 3 && num4 > 0 ? num4 : -1;
    }

    public static void dropXmasTree(int x, int y, int obj)
    {
      int index1 = x;
      int index2 = y;
      if (Main.tile[x, y].frameX < (short) 10)
      {
        index1 -= (int) Main.tile[x, y].frameX;
        index2 -= (int) Main.tile[x, y].frameY;
      }
      int num1 = 0;
      if (((int) Main.tile[index1, index2].frameY & 1) == 1)
        ++num1;
      if (((int) Main.tile[index1, index2].frameY & 2) == 2)
        num1 += 2;
      if (((int) Main.tile[index1, index2].frameY & 4) == 4)
        num1 += 4;
      int num2 = 0;
      if (((int) Main.tile[index1, index2].frameY & 8) == 8)
        ++num2;
      if (((int) Main.tile[index1, index2].frameY & 16) == 16)
        num2 += 2;
      if (((int) Main.tile[index1, index2].frameY & 32) == 32)
        num2 += 4;
      int num3 = 0;
      if (((int) Main.tile[index1, index2].frameY & 64) == 64)
        ++num3;
      if (((int) Main.tile[index1, index2].frameY & 128) == 128)
        num3 += 2;
      if (((int) Main.tile[index1, index2].frameY & 256) == 256)
        num3 += 4;
      if (((int) Main.tile[index1, index2].frameY & 512) == 512)
        num3 += 8;
      int num4 = 0;
      if (((int) Main.tile[index1, index2].frameY & 1024) == 1024)
        ++num4;
      if (((int) Main.tile[index1, index2].frameY & 2048) == 2048)
        num4 += 2;
      if (((int) Main.tile[index1, index2].frameY & 4096) == 4096)
        num4 += 4;
      if (((int) Main.tile[index1, index2].frameY & 8192) == 8192)
        num4 += 8;
      if (obj == 0 && num1 > 0)
      {
        int number = Item.NewItem(x * 16, y * 16, 16, 16, 1874 + num1 - 1, 1, false, 0, false, false);
        if (Main.netMode != 1)
          return;
        NetMessage.SendData(21, -1, -1, (NetworkText) null, number, 1f, 0.0f, 0.0f, 0, 0, 0);
      }
      else if (obj == 1 && num2 > 0)
      {
        int number = Item.NewItem(x * 16, y * 16, 16, 16, 1878 + num2 - 1, 1, false, 0, false, false);
        if (Main.netMode != 1)
          return;
        NetMessage.SendData(21, -1, -1, (NetworkText) null, number, 1f, 0.0f, 0.0f, 0, 0, 0);
      }
      else if (obj == 2 && num3 > 0)
      {
        int number = Item.NewItem(x * 16, y * 16, 16, 16, 1884 + num3 - 1, 1, false, 0, false, false);
        if (Main.netMode != 1)
          return;
        NetMessage.SendData(21, -1, -1, (NetworkText) null, number, 1f, 0.0f, 0.0f, 0, 0, 0);
      }
      else
      {
        if (obj != 3 || num4 <= 0)
          return;
        int number = Item.NewItem(x * 16, y * 16, 16, 16, 1895 + num4 - 1, 1, false, 0, false, false);
        if (Main.netMode != 1)
          return;
        NetMessage.SendData(21, -1, -1, (NetworkText) null, number, 1f, 0.0f, 0.0f, 0, 0, 0);
      }
    }

    public static void setXmasTree(int x, int y, int obj, int style)
    {
      int index1 = x;
      int index2 = y;
      if (Main.tile[x, y].frameX < (short) 10)
      {
        index1 -= (int) Main.tile[x, y].frameX;
        index2 -= (int) Main.tile[x, y].frameY;
      }
      if (obj == 0)
      {
        if ((style & 1) == 1)
          Main.tile[index1, index2].frameY |= (short) 1;
        else
          Main.tile[index1, index2].frameY &= (short) -2;
        if ((style & 2) == 2)
          Main.tile[index1, index2].frameY |= (short) 2;
        else
          Main.tile[index1, index2].frameY &= (short) -3;
        if ((style & 4) == 4)
          Main.tile[index1, index2].frameY |= (short) 4;
        else
          Main.tile[index1, index2].frameY &= (short) -5;
      }
      if (obj == 1)
      {
        if ((style & 1) == 1)
          Main.tile[index1, index2].frameY |= (short) 8;
        else
          Main.tile[index1, index2].frameY &= (short) -9;
        if ((style & 2) == 2)
          Main.tile[index1, index2].frameY |= (short) 16;
        else
          Main.tile[index1, index2].frameY &= (short) -17;
        if ((style & 4) == 4)
          Main.tile[index1, index2].frameY |= (short) 32;
        else
          Main.tile[index1, index2].frameY &= (short) -33;
      }
      if (obj == 2)
      {
        if ((style & 1) == 1)
          Main.tile[index1, index2].frameY |= (short) 64;
        else
          Main.tile[index1, index2].frameY &= (short) -65;
        if ((style & 2) == 2)
          Main.tile[index1, index2].frameY |= (short) 128;
        else
          Main.tile[index1, index2].frameY &= (short) -129;
        if ((style & 4) == 4)
          Main.tile[index1, index2].frameY |= (short) 256;
        else
          Main.tile[index1, index2].frameY &= (short) -257;
        if ((style & 8) == 8)
          Main.tile[index1, index2].frameY |= (short) 512;
        else
          Main.tile[index1, index2].frameY &= (short) -513;
      }
      if (obj != 3)
        return;
      if ((style & 1) == 1)
        Main.tile[index1, index2].frameY |= (short) 1024;
      else
        Main.tile[index1, index2].frameY &= (short) -1025;
      if ((style & 2) == 2)
        Main.tile[index1, index2].frameY |= (short) 2048;
      else
        Main.tile[index1, index2].frameY &= (short) -2049;
      if ((style & 4) == 4)
        Main.tile[index1, index2].frameY |= (short) 4096;
      else
        Main.tile[index1, index2].frameY &= (short) -4097;
      if ((style & 8) == 8)
        Main.tile[index1, index2].frameY |= (short) 8192;
      else
        Main.tile[index1, index2].frameY &= (short) -8193;
    }

    public static int PlaceXmasTree_Direct(
      int x,
      int y,
      int type,
      int style,
      int dir,
      int alternate)
    {
      for (short index1 = 0; index1 < (short) 4; ++index1)
      {
        for (short index2 = 0; index2 < (short) 8; ++index2)
        {
          Tile tile = Main.tile[x + (int) index1, y + (int) index2];
          tile.active(true);
          tile.type = (ushort) type;
          if (index1 == (short) 0 && index2 == (short) 0)
          {
            tile.frameX = (short) 10;
            tile.frameY = (short) 0;
          }
          else
          {
            tile.frameX = index1;
            tile.frameY = index2;
          }
        }
      }
      return 0;
    }

    public static void PlaceXmasTree(int x, int y, ushort type = 171)
    {
      bool flag = true;
      int num1 = x - 1;
      int num2 = y - 7;
      for (int i = num1; i < num1 + 4; ++i)
      {
        for (int index = num2; index < num2 + 8; ++index)
        {
          if (Main.tile[i, index].active())
            flag = false;
        }
        if (i > num1 && i < num1 + 3 && !WorldGen.SolidTile(i, num2 + 8, false))
          flag = false;
      }
      if (!flag)
        return;
      int num3 = 0;
      for (int index1 = num1; index1 < num1 + 4; ++index1)
      {
        int num4 = 0;
        for (int index2 = num2; index2 < num2 + 8; ++index2)
        {
          Main.tile[index1, index2].active(true);
          if (num3 == 0 && num4 == 0)
          {
            Main.tile[index1, index2].frameX = (short) 10;
            Main.tile[index1, index2].frameY = (short) 0;
          }
          else
          {
            Main.tile[index1, index2].frameX = (short) num3;
            Main.tile[index1, index2].frameY = (short) num4;
          }
          Main.tile[index1, index2].type = type;
          Main.tile[index1, index2].active(true);
          ++num4;
        }
        ++num3;
      }
    }

    public static void CheckXmasTree(int x, int y)
    {
      if (WorldGen.destroyObject)
        return;
      int num1 = x;
      int num2 = y;
      if (Main.tile[x, y].frameX < (short) 10)
      {
        num1 -= (int) Main.tile[x, y].frameX;
        num2 -= (int) Main.tile[x, y].frameY;
      }
      bool flag = false;
      int num3 = 0;
      for (int i = num1; i < num1 + 4; ++i)
      {
        int num4 = 0;
        for (int index = num2; index < num2 + 8; ++index)
        {
          if (Main.tile[i, index].active() && Main.tile[i, index].type == (ushort) 171)
          {
            if (num3 != 0 && num4 != 0 && ((int) Main.tile[i, index].frameX != num3 && (int) Main.tile[i, index].frameY != num4))
              flag = true;
          }
          else
            flag = true;
          ++num4;
        }
        ++num3;
        if (i > num1 && i < num1 + 3 && !WorldGen.SolidTile2(i, num2 + 8))
          flag = true;
      }
      if (!flag)
        return;
      WorldGen.destroyObject = true;
      for (int i = num1; i < num1 + 4; ++i)
      {
        for (int j = num2; j < num2 + 8; ++j)
        {
          if (Main.tile[i, j].type == (ushort) 171)
            WorldGen.KillTile(i, j, false, false, false);
        }
      }
      Item.NewItem(x * 16, y * 16, 32, 32, 1873, 1, false, 0, false, false);
      WorldGen.destroyObject = false;
    }

    public static void Place2xX(int x, int y, ushort type, int style = 0)
    {
      int num1 = style * 36;
      int num2 = 0;
      int num3 = 3;
      if (type == (ushort) 105 && style == 34)
      {
        type = (ushort) 349;
        style = 0;
        num1 = 0;
      }
      if (type == (ushort) 105)
      {
        int num4 = style / 55;
        num1 -= 1980 * num4;
        num2 += 54 * num4;
      }
      if (type == (ushort) 104)
        num3 = 5;
      if (type == (ushort) 207)
        num3 = 4;
      bool flag = true;
      for (int index = y - num3 + 1; index < y + 1; ++index)
      {
        if (Main.tile[x, index] == null)
          Main.tile[x, index] = new Tile();
        if (Main.tile[x, index].active())
          flag = false;
        if (Main.tile[x + 1, index] == null)
          Main.tile[x + 1, index] = new Tile();
        if (Main.tile[x + 1, index].active())
          flag = false;
      }
      if (!flag || !WorldGen.SolidTile2(x, y + 1) || !WorldGen.SolidTile2(x + 1, y + 1))
        return;
      for (int index = 0; index < num3; ++index)
      {
        Main.tile[x, y - num3 + 1 + index].active(true);
        Main.tile[x, y - num3 + 1 + index].frameY = (short) (num2 + index * 18);
        Main.tile[x, y - num3 + 1 + index].frameX = (short) num1;
        Main.tile[x, y - num3 + 1 + index].type = type;
        Main.tile[x + 1, y - num3 + 1 + index].active(true);
        Main.tile[x + 1, y - num3 + 1 + index].frameY = (short) (num2 + index * 18);
        Main.tile[x + 1, y - num3 + 1 + index].frameX = (short) (num1 + 18);
        Main.tile[x + 1, y - num3 + 1 + index].type = type;
      }
    }

    public static int GetItemDrop_Benches(int style)
    {
      switch (style)
      {
        case 1:
          return 2397;
        case 2:
          return 2398;
        case 3:
          return 2399;
        case 4:
          return 2400;
        case 5:
          return 2401;
        case 6:
          return 2402;
        case 7:
          return 2403;
        case 8:
          return 2404;
        case 9:
          return 2405;
        case 10:
          return 2406;
        case 11:
          return 2407;
        case 12:
          return 2408;
        case 13:
          return 2409;
        case 14:
          return 2410;
        case 15:
          return 2411;
        case 16:
          return 2412;
        case 17:
          return 2413;
        case 18:
          return 2414;
        case 19:
          return 2415;
        case 20:
          return 2416;
        case 21:
          return 2521;
        case 22:
          return 2527;
        case 23:
          return 2539;
        case 24:
          return 858;
        case 25:
          return 2582;
        case 26:
          return 2634;
        case 27:
          return 2635;
        case 28:
          return 2636;
        case 29:
          return 2823;
        case 30:
          return 3150;
        case 31:
          return 3152;
        case 32:
          return 3151;
        case 33:
          return 3918;
        case 34:
          return 3919;
        case 35:
          return 3947;
        case 36:
          return 3973;
        case 37:
          return 4161;
        case 38:
          return 4182;
        case 39:
          return 4203;
        case 40:
          return 4224;
        case 41:
          return 4313;
        case 42:
          return 4582;
        case 43:
          return 4993;
        default:
          return 335;
      }
    }

    public static int GetItemDrop_PicnicTables(int style)
    {
      return style == 0 || style != 1 ? 4064 : 4065;
    }

    public static int GetItemDrop_Chair(int style)
    {
      switch (style)
      {
        case 1:
          return 358;
        case 2:
          return 628;
        case 3:
          return 629;
        case 4:
          return 630;
        case 5:
          return 806;
        case 6:
          return 807;
        case 7:
          return 808;
        case 8:
          return 809;
        case 9:
          return 810;
        case 10:
          return 826;
        case 11:
          return 915;
        case 12:
          return 1143;
        case 13:
          return 1396;
        case 14:
          return 1399;
        case 15:
          return 1402;
        case 16:
          return 1459;
        case 17:
          return 1509;
        case 18:
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
          return 1703 + style - 18;
        case 24:
          return 1792;
        case 25:
          return 1814;
        case 26:
          return 1925;
        case 27:
          return 2228;
        case 28:
          return 2288;
        case 29:
          return 2524;
        case 30:
          return 2557;
        case 31:
          return 2572;
        case 32:
          return 2812;
        case 33:
          return 3174;
        case 34:
          return 3176;
        case 35:
          return 3175;
        case 36:
          return 3889;
        case 37:
          return 3937;
        case 38:
          return 3963;
        case 39:
          return 4151;
        case 40:
          return 4172;
        case 41:
          return 4193;
        case 42:
          return 4214;
        case 43:
          return 4304;
        case 44:
          return 4572;
        default:
          return 34;
      }
    }

    public static int GetItemDrop_Toilet(int style)
    {
      int num = 4096 + style;
      switch (style)
      {
        case 32:
          num = 4141;
          break;
        case 33:
          num = 4165;
          break;
        case 34:
          num = 4186;
          break;
        case 35:
          num = 4207;
          break;
        case 36:
          num = 4228;
          break;
        case 37:
          num = 4316;
          break;
        case 38:
          num = 4586;
          break;
        case 39:
          num = 4731;
          break;
      }
      if (num > 4731)
        num = 4731;
      return num;
    }

    public static void Check1x2(int x, int j, ushort type)
    {
      if (WorldGen.destroyObject)
        return;
      int j1 = j;
      bool flag = true;
      if (Main.tile[x, j1] == null)
        Main.tile[x, j1] = new Tile();
      if (Main.tile[x, j1 + 1] == null)
        Main.tile[x, j1 + 1] = new Tile();
      int frameY = (int) Main.tile[x, j1].frameY;
      int style = 0;
      while (frameY >= 40)
      {
        frameY -= 40;
        ++style;
      }
      if (frameY == 18)
        --j1;
      int num1 = (int) Main.tile[x, j1].frameX / 18;
      if (Main.tile[x, j1].frameX == (short) -1)
        num1 = (int) Main.tile[x, j1 + 1].frameX / 18;
      if (Main.tile[x, j1] == null)
        Main.tile[x, j1] = new Tile();
      if ((int) Main.tile[x, j1].frameY == 40 * style && (int) Main.tile[x, j1 + 1].frameY == 40 * style + 18 && ((int) Main.tile[x, j1].type == (int) type && (int) Main.tile[x, j1 + 1].type == (int) type))
        flag = false;
      if (Main.tile[x, j1 + 2] == null)
        Main.tile[x, j1 + 2] = new Tile();
      if (!WorldGen.SolidTileAllowBottomSlope(x, j1 + 2) && !TileID.Sets.Platforms[(int) Main.tile[x, j1 + 2].type])
        flag = true;
      if (Main.tile[x, j1].type == (ushort) 20)
      {
        int num2 = (int) Main.tile[x, j1].frameX / 54;
        int type1 = (int) Main.tile[x, j1 + 2].type;
        int num3 = -1;
        switch (type1)
        {
          case 2:
          case 477:
            num3 = 0;
            break;
          case 23:
            num3 = 3;
            break;
          case 53:
            num3 = 6;
            break;
          case 60:
            num3 = 2;
            break;
          case 109:
          case 492:
            num3 = 5;
            break;
          case 112:
            num3 = 9;
            break;
          case 116:
            num3 = 7;
            break;
          case 147:
            num3 = 1;
            break;
          case 199:
            num3 = 4;
            break;
          case 234:
            num3 = 8;
            break;
          default:
            flag = true;
            break;
        }
        if (!flag && num2 != num3)
        {
          int num4 = 54 * num3 + WorldGen.genRand.Next(3) * 18;
          Main.tile[x, j1].frameX = (short) num4;
          Main.tile[x, j1 + 1].frameX = (short) num4;
        }
      }
      if (!flag)
        return;
      WorldGen.destroyObject = true;
      if ((int) Main.tile[x, j1].type == (int) type)
        WorldGen.KillTile(x, j1, false, false, false);
      if ((int) Main.tile[x, j1 + 1].type == (int) type)
        WorldGen.KillTile(x, j1 + 1, false, false, false);
      if (type == (ushort) 216)
        Item.NewItem(x * 16, j1 * 16, 32, 32, 970 + style, 1, false, 0, false, false);
      if (type == (ushort) 338)
        Item.NewItem(x * 16, j1 * 16, 32, 32, 2738, 1, false, 0, false, false);
      if (type == (ushort) 390)
        Item.NewItem(x * 16, j1 * 16, 16, 32, 3253, 1, false, 0, false, false);
      if (type == (ushort) 493)
      {
        int Type = 0;
        switch (num1)
        {
          case 0:
            Type = 4083;
            break;
          case 1:
            Type = 4084;
            break;
          case 2:
            Type = 4085;
            break;
          case 3:
            Type = 4086;
            break;
          case 4:
            Type = 4087;
            break;
          case 5:
            Type = 4088;
            break;
        }
        if (Type > 0)
          Item.NewItem(x * 16, j1 * 16, 32, 32, Type, 1, false, 0, false, false);
      }
      if (type == (ushort) 15)
      {
        int itemDropChair = WorldGen.GetItemDrop_Chair(style);
        Item.NewItem(x * 16, j1 * 16, 32, 32, itemDropChair, 1, false, 0, false, false);
      }
      if (type == (ushort) 497)
      {
        int itemDropToilet = WorldGen.GetItemDrop_Toilet(style);
        Item.NewItem(x * 16, j1 * 16, 32, 32, itemDropToilet, 1, false, 0, false, false);
      }
      else if (type == (ushort) 134)
      {
        if (style == 1)
          Item.NewItem(x * 16, j1 * 16, 32, 32, 1220, 1, false, 0, false, false);
        else
          Item.NewItem(x * 16, j1 * 16, 32, 32, 525, 1, false, 0, false, false);
      }
      WorldGen.destroyObject = false;
    }

    public static void CheckOnTable1x1(int x, int y, int type)
    {
      if (Main.tile[x, y + 1] == null)
        return;
      if (Main.tile[x, y + 1].topSlope())
      {
        if (TileID.Sets.Platforms[(int) Main.tile[x, y + 1].type])
        {
          if (Main.tile[x, y + 1].blockType() == 3 && Main.tile[x - 1, y + 1].active() && (Main.tile[x - 1, y + 1].blockType() == 0 && TileID.Sets.Platforms[(int) Main.tile[x - 1, y + 1].type]) || Main.tile[x, y + 1].blockType() == 2 && Main.tile[x + 1, y + 1].active() && (Main.tile[x + 1, y + 1].blockType() == 0 && TileID.Sets.Platforms[(int) Main.tile[x + 1, y + 1].type]))
            return;
          WorldGen.KillTile(x, y, false, false, false);
        }
        else
          WorldGen.KillTile(x, y, false, false, false);
      }
      else
      {
        if (Main.tile[x, y + 1].active() && Main.tileTable[(int) Main.tile[x, y + 1].type] && !Main.tile[x, y + 1].halfBrick())
          return;
        if (type == 78)
        {
          if (WorldGen.SolidTileAllowBottomSlope(x, y + 1))
            return;
          WorldGen.KillTile(x, y, false, false, false);
        }
        else
          WorldGen.KillTile(x, y, false, false, false);
      }
    }

    public static void CheckSign(int x, int y, ushort type)
    {
      if (WorldGen.destroyObject)
        return;
      int num1 = x - 2;
      int num2 = x + 3;
      int num3 = y - 2;
      int num4 = y + 3;
      if (num1 < 0 || num2 > Main.maxTilesX || (num3 < 0 || num4 > Main.maxTilesY))
        return;
      bool flag = false;
      for (int index1 = num1; index1 < num2; ++index1)
      {
        for (int index2 = num3; index2 < num4; ++index2)
        {
          if (Main.tile[index1, index2] == null)
            Main.tile[index1, index2] = new Tile();
        }
      }
      int num5 = (int) Main.tile[x, y].frameX / 18;
      int num6 = (int) Main.tile[x, y].frameY / 18;
      int num7 = num5 % 2;
      int num8 = num6 % 2;
      int index3 = x - num7;
      int index4 = y - num8;
      int num9 = (int) Main.tile[index3, index4].frameX / 18 / 2;
      int num10 = (int) Main.tile[index3, index4].frameY / 18 / 2;
      int num11 = (int) Main.tile[x, y].frameX / 18;
      int num12 = 0;
      while (num11 > 1)
      {
        num11 -= 2;
        ++num12;
      }
      int num13 = index3;
      int num14 = index3 + 2;
      int num15 = index4;
      int num16 = index4 + 2;
      int num17 = 0;
      for (int index1 = num13; index1 < num14; ++index1)
      {
        int num18 = 0;
        for (int index2 = num15; index2 < num16; ++index2)
        {
          if (!Main.tile[index1, index2].active() || (int) Main.tile[index1, index2].type != (int) type)
          {
            flag = true;
            break;
          }
          if ((int) Main.tile[index1, index2].frameX / 18 != num17 + num9 * 2 || (int) Main.tile[index1, index2].frameY / 18 != num18 + num10 * 2)
          {
            flag = true;
            break;
          }
          ++num18;
        }
        ++num17;
      }
      if (!flag)
      {
        if (type == (ushort) 85)
        {
          if (WorldGen.SolidTileAllowBottomSlope(index3, index4 + 2) && WorldGen.SolidTileAllowBottomSlope(index3 + 1, index4 + 2))
            num9 = num12;
          else
            flag = true;
        }
        else if (WorldGen.TopEdgeCanBeAttachedTo(index3, index4 + 2) && WorldGen.TopEdgeCanBeAttachedTo(index3 + 1, index4 + 2))
          num9 = 0;
        else if (WorldGen.BottomEdgeCanBeAttachedTo(index3, index4 - 1) && WorldGen.BottomEdgeCanBeAttachedTo(index3 + 1, index4 - 1))
          num9 = 1;
        else if (WorldGen.RightEdgeCanBeAttachedTo(index3 - 1, index4) && WorldGen.RightEdgeCanBeAttachedTo(index3 - 1, index4 + 1))
          num9 = 2;
        else if (WorldGen.LeftEdgeCanBeAttachedTo(index3 + 2, index4) && WorldGen.LeftEdgeCanBeAttachedTo(index3 + 2, index4 + 1))
          num9 = 3;
        else if (Main.tile[index3, index4].wall > (ushort) 0 && Main.tile[index3 + 1, index4].wall > (ushort) 0 && (Main.tile[index3, index4 + 1].wall > (ushort) 0 && Main.tile[index3 + 1, index4 + 1].wall > (ushort) 0))
          num9 = 4;
        else
          flag = true;
      }
      if (flag)
      {
        if (type == (ushort) 395)
        {
          int index1 = TEItemFrame.Find(index3, index4);
          if (index1 != -1 && ((TEItemFrame) TileEntity.ByID[index1]).item.stack > 0)
          {
            ((TEItemFrame) TileEntity.ByID[index1]).DropItem();
            if (Main.netMode != 2)
              Main.LocalPlayer.InterruptItemUsageIfOverTile(395);
          }
        }
        WorldGen.destroyObject = true;
        for (int i = num13; i < num14; ++i)
        {
          for (int j = num15; j < num16; ++j)
          {
            if ((int) Main.tile[i, j].type == (int) type)
              WorldGen.KillTile(i, j, false, false, false);
          }
        }
        if (type != (ushort) 395)
          Sign.KillSign(index3, index4);
        if (type == (ushort) 85)
        {
          int Type = 321;
          if (num12 >= 6 && num12 <= 10)
            Type = 3229 + num12 - 6;
          else if (num12 >= 1 && num12 <= 5)
            Type = 1173 + num12 - 1;
          Item.NewItem(x * 16, y * 16, 32, 32, Type, 1, false, 0, false, false);
          if (Main.netMode != 1 && WorldGen.genRand.Next(2) == 0 && NPC.CountNPCS(316) < 2)
          {
            int closest = (int) Player.FindClosest(new Vector2((float) (x * 16), (float) (y * 16)), 16, 16);
            if (Main.player[closest].ZoneGraveyard || !Main.dayTime || (double) y > Main.worldSurface)
              NPC.SpawnOnPlayer(closest, 316);
          }
        }
        else if (type == (ushort) 395)
        {
          Item.NewItem(index3 * 16, index4 * 16, 32, 32, 3270, 1, false, 0, false, false);
          TEItemFrame.Kill(index3, index4);
        }
        else if (type == (ushort) 425)
          Item.NewItem(index3 * 16, index4 * 16, 32, 32, 3617, 1, false, 0, false, false);
        else if (type == (ushort) 573)
          Item.NewItem(index3 * 16, index4 * 16, 32, 32, 4710, 1, false, 0, false, false);
        else if (type == (ushort) 511)
          Item.NewItem(index3 * 16, index4 * 16, 32, 32, 4320, 1, false, 0, false, false);
        else if (type == (ushort) 510)
          Item.NewItem(index3 * 16, index4 * 16, 32, 32, 4319, 1, false, 0, false, false);
        else
          Item.NewItem(x * 16, y * 16, 32, 32, 171, 1, false, 0, false, false);
        WorldGen.destroyObject = false;
      }
      else
      {
        int num18 = 36 * num9;
        for (int index1 = 0; index1 < 2; ++index1)
        {
          for (int index2 = 0; index2 < 2; ++index2)
          {
            Main.tile[index3 + index1, index4 + index2].active(true);
            Main.tile[index3 + index1, index4 + index2].type = type;
            Main.tile[index3 + index1, index4 + index2].frameX = (short) (num18 + 18 * index1);
            Main.tile[index3 + index1, index4 + index2].frameY = (short) (18 * index2 + num10 * 36);
          }
        }
      }
    }

    public static bool PlaceSign(int x, int y, ushort type, int Style = 0)
    {
      int num1 = x - 2;
      int num2 = x + 3;
      int num3 = y - 2;
      int num4 = y + 3;
      if (num1 < 0 || num2 > Main.maxTilesX || (num3 < 0 || num4 > Main.maxTilesY))
        return false;
      for (int index1 = num1; index1 < num2; ++index1)
      {
        for (int index2 = num3; index2 < num4; ++index2)
        {
          if (Main.tile[index1, index2] == null)
            Main.tile[index1, index2] = new Tile();
        }
      }
      int index3 = x;
      int index4 = y;
      int num5 = 0;
      if (type == (ushort) 55 || type == (ushort) 425 || (type == (ushort) 510 || type == (ushort) 511))
      {
        if (WorldGen.SolidTile2(x, y + 1) && WorldGen.SolidTile2(x + 1, y + 1))
        {
          --index4;
          num5 = 0;
        }
        else if (Main.tile[x, y - 1].nactive() && Main.tileSolid[(int) Main.tile[x, y - 1].type] && (!Main.tileSolidTop[(int) Main.tile[x, y - 1].type] && Main.tile[x + 1, y - 1].nactive()) && (Main.tileSolid[(int) Main.tile[x + 1, y - 1].type] && !Main.tileSolidTop[(int) Main.tile[x + 1, y - 1].type]))
          num5 = 1;
        else if (Main.tile[x - 1, y].nactive() && Main.tileSolid[(int) Main.tile[x - 1, y].type] && (!Main.tileSolidTop[(int) Main.tile[x - 1, y].type] && !Main.tileNoAttach[(int) Main.tile[x - 1, y].type]) && (Main.tile[x - 1, y + 1].nactive() && Main.tileSolid[(int) Main.tile[x - 1, y + 1].type] && (!Main.tileSolidTop[(int) Main.tile[x - 1, y + 1].type] && !Main.tileNoAttach[(int) Main.tile[x - 1, y + 1].type])))
          num5 = 2;
        else if (Main.tile[x + 1, y].nactive() && Main.tileSolid[(int) Main.tile[x + 1, y].type] && (!Main.tileSolidTop[(int) Main.tile[x + 1, y].type] && !Main.tileNoAttach[(int) Main.tile[x + 1, y].type]) && (Main.tile[x + 1, y + 1].nactive() && Main.tileSolid[(int) Main.tile[x + 1, y + 1].type] && (!Main.tileSolidTop[(int) Main.tile[x + 1, y + 1].type] && !Main.tileNoAttach[(int) Main.tile[x + 1, y + 1].type])))
        {
          --index3;
          num5 = 3;
        }
        else
        {
          if (Main.tile[index3, index4].wall <= (ushort) 0 || Main.tile[index3 + 1, index4].wall <= (ushort) 0 || (Main.tile[index3, index4 + 1].wall <= (ushort) 0 || Main.tile[index3 + 1, index4 + 1].wall <= (ushort) 0))
            return false;
          num5 = 4;
        }
      }
      if (Main.tile[index3, index4].active() || Main.tile[index3 + 1, index4].active() || (Main.tile[index3, index4 + 1].active() || Main.tile[index3 + 1, index4 + 1].active()))
        return false;
      int num6 = 36 * num5;
      for (int index1 = 0; index1 < 2; ++index1)
      {
        for (int index2 = 0; index2 < 2; ++index2)
        {
          Main.tile[index3 + index1, index4 + index2].active(true);
          Main.tile[index3 + index1, index4 + index2].type = type;
          Main.tile[index3 + index1, index4 + index2].frameX = (short) (num6 + 18 * index1);
          Main.tile[index3 + index1, index4 + index2].frameY = (short) (18 * index2);
        }
      }
      return true;
    }

    public static bool Place2x2Horizontal(int x, int y, ushort type, int Style = 0)
    {
      int num1 = x - 2;
      int num2 = x + 3;
      int num3 = y - 2;
      int num4 = y + 3;
      if (num1 < 0 || num2 > Main.maxTilesX || (num3 < 0 || num4 > Main.maxTilesY))
        return false;
      for (int index1 = num1; index1 < num2; ++index1)
      {
        for (int index2 = num3; index2 < num4; ++index2)
        {
          if (Main.tile[index1, index2] == null)
            Main.tile[index1, index2] = new Tile();
        }
      }
      int index3 = x;
      int num5 = y;
      if (!WorldGen.SolidTile2(x, y + 1) || !WorldGen.SolidTile2(x + 1, y + 1))
        return false;
      int index4 = num5 - 1;
      int num6 = Style;
      if (Main.tile[index3, index4].active() || Main.tile[index3 + 1, index4].active() || (Main.tile[index3, index4 + 1].active() || Main.tile[index3 + 1, index4 + 1].active()))
        return false;
      int num7 = 36 * num6;
      for (int index1 = 0; index1 < 2; ++index1)
      {
        for (int index2 = 0; index2 < 2; ++index2)
        {
          Main.tile[index3 + index1, index4 + index2].active(true);
          Main.tile[index3 + index1, index4 + index2].type = type;
          Main.tile[index3 + index1, index4 + index2].frameX = (short) (num7 + 18 * index1);
          Main.tile[index3 + index1, index4 + index2].frameY = (short) (18 * index2);
        }
      }
      return true;
    }

    public static Color paintColor(int color)
    {
      Color white = Color.White;
      int num = color;
      if (num == 1 || num == 13)
      {
        white.R = byte.MaxValue;
        white.G = (byte) 0;
        white.B = (byte) 0;
      }
      if (num == 2 || num == 14)
      {
        white.R = byte.MaxValue;
        white.G = (byte) 127;
        white.B = (byte) 0;
      }
      if (num == 3 || num == 15)
      {
        white.R = byte.MaxValue;
        white.G = byte.MaxValue;
        white.B = (byte) 0;
      }
      if (num == 4 || num == 16)
      {
        white.R = (byte) 127;
        white.G = byte.MaxValue;
        white.B = (byte) 0;
      }
      if (num == 5 || num == 17)
      {
        white.R = (byte) 0;
        white.G = byte.MaxValue;
        white.B = (byte) 0;
      }
      if (num == 6 || num == 18)
      {
        white.R = (byte) 0;
        white.G = byte.MaxValue;
        white.B = (byte) 127;
      }
      if (num == 7 || num == 19)
      {
        white.R = (byte) 0;
        white.G = byte.MaxValue;
        white.B = byte.MaxValue;
      }
      if (num == 8 || num == 20)
      {
        white.R = (byte) 0;
        white.G = (byte) 127;
        white.B = byte.MaxValue;
      }
      if (num == 9 || num == 21)
      {
        white.R = (byte) 0;
        white.G = (byte) 0;
        white.B = byte.MaxValue;
      }
      if (num == 10 || num == 22)
      {
        white.R = (byte) 127;
        white.G = (byte) 0;
        white.B = byte.MaxValue;
      }
      if (num == 11 || num == 23)
      {
        white.R = byte.MaxValue;
        white.G = (byte) 0;
        white.B = byte.MaxValue;
      }
      if (num == 12 || num == 24)
      {
        white.R = byte.MaxValue;
        white.G = (byte) 0;
        white.B = (byte) 127;
      }
      if (num == 25)
      {
        white.R = (byte) 75;
        white.G = (byte) 75;
        white.B = (byte) 75;
      }
      if (num == 26)
      {
        white.R = byte.MaxValue;
        white.G = byte.MaxValue;
        white.B = byte.MaxValue;
      }
      if (num == 27)
      {
        white.R = (byte) 175;
        white.G = (byte) 175;
        white.B = (byte) 175;
      }
      if (num == 28)
      {
        white.R = byte.MaxValue;
        white.G = (byte) 178;
        white.B = (byte) 125;
      }
      if (num == 29)
      {
        white.R = (byte) 25;
        white.G = (byte) 25;
        white.B = (byte) 25;
      }
      if (num == 30)
      {
        white.R = (byte) 200;
        white.G = (byte) 200;
        white.B = (byte) 200;
        white.A = (byte) 150;
      }
      return white;
    }

    public static void paintEffect(int x, int y, byte color, byte oldColor)
    {
      int color1 = (int) color;
      if (color == (byte) 0)
        color1 = (int) oldColor;
      Color newColor = WorldGen.paintColor(color1);
      for (int index1 = 0; index1 < 10; ++index1)
      {
        int index2 = Dust.NewDust(new Vector2((float) (x * 16), (float) (y * 16)), 16, 16, 143, 0.0f, 0.0f, 50, newColor, 1f);
        if (WorldGen.genRand.Next(2) == 0)
        {
          Main.dust[index2].noGravity = true;
          Main.dust[index2].scale *= 1.2f;
        }
        else
          Main.dust[index2].scale *= 0.5f;
      }
    }

    public static bool paintTile(int x, int y, byte color, bool broadCast = false)
    {
      if (Main.tile[x, y] == null || !Main.tile[x, y].active())
        return false;
      byte oldColor = Main.tile[x, y].color();
      Main.tile[x, y].color(color);
      if (broadCast)
        NetMessage.SendData(63, -1, -1, (NetworkText) null, x, (float) y, (float) color, 0.0f, 0, 0, 0);
      WorldGen.paintEffect(x, y, color, oldColor);
      return true;
    }

    public static bool paintWall(int x, int y, byte color, bool broadCast = false)
    {
      if (Main.tile[x, y] == null || Main.tile[x, y].wall == (ushort) 0)
        return false;
      byte oldColor = Main.tile[x, y].wallColor();
      Main.tile[x, y].wallColor(color);
      if (broadCast)
        NetMessage.SendData(64, -1, -1, (NetworkText) null, x, (float) y, (float) color, 0.0f, 0, 0, 0);
      WorldGen.paintEffect(x, y, color, oldColor);
      return true;
    }

    public static void Place3x3Wall(int x, int y, ushort type, int style)
    {
      int num1 = x - 1;
      int num2 = y - 1;
      bool flag = true;
      for (int index1 = num1; index1 < num1 + 3; ++index1)
      {
        for (int index2 = num2; index2 < num2 + 3; ++index2)
        {
          if (Main.tile[index1, index2].active() || Main.tile[index1, index2].wall == (ushort) 0)
          {
            flag = false;
            break;
          }
        }
      }
      if (!flag)
        return;
      int num3 = 0;
      for (; style > 35; style -= 36)
        ++num3;
      int num4 = style * 54;
      int num5 = num3 * 54;
      for (int index1 = num1; index1 < num1 + 3; ++index1)
      {
        for (int index2 = num2; index2 < num2 + 3; ++index2)
        {
          Main.tile[index1, index2].active(true);
          Main.tile[index1, index2].type = type;
          Main.tile[index1, index2].frameX = (short) (num4 + 18 * (index1 - num1));
          Main.tile[index1, index2].frameY = (short) (num5 + 18 * (index2 - num2));
        }
      }
    }

    public static void Check3x3Wall(int x, int y)
    {
      if (WorldGen.destroyObject)
        return;
      bool flag = false;
      int type = (int) Main.tile[x, y].type;
      int num1 = 0;
      int num2 = 0;
      int num3 = (int) Main.tile[x, y].frameX / 18;
      while (num3 >= 3)
      {
        num3 -= 3;
        ++num1;
      }
      int num4 = x - num3;
      int num5 = (int) Main.tile[x, y].frameY / 18;
      while (num5 >= 3)
      {
        num5 -= 3;
        ++num2;
      }
      int num6 = y - num5;
      int num7 = num2 * 54;
      int num8 = num1 * 54;
      for (int index1 = num4; index1 < num4 + 3; ++index1)
      {
        for (int index2 = num6; index2 < num6 + 3; ++index2)
        {
          if ((int) Main.tile[index1, index2].type != type || !Main.tile[index1, index2].active() || (Main.tile[index1, index2].wall <= (ushort) 0 || (int) Main.tile[index1, index2].frameX != num8 + (index1 - num4) * 18) || (int) Main.tile[index1, index2].frameY != num7 + (index2 - num6) * 18)
          {
            flag = true;
            break;
          }
        }
      }
      if (!flag)
        return;
      WorldGen.destroyObject = true;
      for (int i = num4; i < num4 + 3; ++i)
      {
        for (int j = num6; j < num6 + 3; ++j)
        {
          if ((int) Main.tile[i, j].type == type && Main.tile[i, j].active())
            WorldGen.KillTile(i, j, false, false, false);
        }
      }
      switch (type)
      {
        case 240:
          int num9 = num1 + num2 * 36;
          switch (num9)
          {
            case 18:
              Item.NewItem(x * 16, y * 16, 32, 32, 1419, 1, false, 0, false, false);
              break;
            case 19:
              Item.NewItem(x * 16, y * 16, 32, 32, 1420, 1, false, 0, false, false);
              break;
            case 20:
              Item.NewItem(x * 16, y * 16, 32, 32, 1427, 1, false, 0, false, false);
              break;
            case 21:
              Item.NewItem(x * 16, y * 16, 32, 32, 1428, 1, false, 0, false, false);
              break;
            case 33:
              Item.NewItem(x * 16, y * 16, 32, 32, 1574, 1, false, 0, false, false);
              break;
            case 34:
              Item.NewItem(x * 16, y * 16, 32, 32, 1575, 1, false, 0, false, false);
              break;
            case 35:
              Item.NewItem(x * 16, y * 16, 32, 32, 1576, 1, false, 0, false, false);
              break;
            case 36:
              Item.NewItem(x * 16, y * 16, 32, 32, 1855, 1, false, 0, false, false);
              break;
            case 37:
              Item.NewItem(x * 16, y * 16, 32, 32, 1856, 1, false, 0, false, false);
              break;
            case 38:
              Item.NewItem(x * 16, y * 16, 32, 32, 1960, 1, false, 0, false, false);
              break;
            case 39:
              Item.NewItem(x * 16, y * 16, 32, 32, 1961, 1, false, 0, false, false);
              break;
            case 40:
              Item.NewItem(x * 16, y * 16, 32, 32, 1962, 1, false, 0, false, false);
              break;
            case 54:
              Item.NewItem(x * 16, y * 16, 32, 32, 2489, 1, false, 0, false, false);
              break;
            case 55:
              Item.NewItem(x * 16, y * 16, 32, 32, 2589, 1, false, 0, false, false);
              break;
            case 56:
              Item.NewItem(x * 16, y * 16, 32, 32, 3357, 1, false, 0, false, false);
              break;
            case 57:
              Item.NewItem(x * 16, y * 16, 32, 32, 3358, 1, false, 0, false, false);
              break;
            case 58:
              Item.NewItem(x * 16, y * 16, 32, 32, 3359, 1, false, 0, false, false);
              break;
            case 59:
              Item.NewItem(x * 16, y * 16, 32, 32, 3595, 1, false, 0, false, false);
              break;
            case 60:
              Item.NewItem(x * 16, y * 16, 32, 32, 3867, 1, false, 0, false, false);
              break;
            case 61:
              Item.NewItem(x * 16, y * 16, 32, 32, 3866, 1, false, 0, false, false);
              break;
            case 62:
              Item.NewItem(x * 16, y * 16, 32, 32, 3868, 1, false, 0, false, false);
              break;
            case 69:
              Item.NewItem(x * 16, y * 16, 32, 32, 4660, 1, false, 0, false, false);
              break;
            case 70:
              Item.NewItem(x * 16, y * 16, 32, 32, 4723, 1, false, 0, false, false);
              break;
            case 71:
              Item.NewItem(x * 16, y * 16, 32, 32, 4724, 1, false, 0, false, false);
              break;
            case 72:
              Item.NewItem(x * 16, y * 16, 32, 32, 4783, 1, false, 0, false, false);
              break;
            case 73:
              Item.NewItem(x * 16, y * 16, 32, 32, 4958, 1, false, 0, false, false);
              break;
            default:
              if (num9 >= 63 && num9 <= 68)
              {
                Item.NewItem(x * 16, y * 16, 32, 32, 4626 + num9 - 63, 1, false, 0, false, false);
                break;
              }
              if (num9 >= 41 && num9 <= 45)
              {
                Item.NewItem(x * 16, y * 16, 32, 32, 2114 + num9 - 41, 1, false, 0, false, false);
                break;
              }
              if (num9 >= 46 && num9 <= 53)
              {
                Item.NewItem(x * 16, y * 16, 32, 32, 2442 + num9 - 46, 1, false, 0, false, false);
                break;
              }
              if (num9 >= 22 && num9 <= 25)
              {
                Item.NewItem(x * 16, y * 16, 32, 32, 1440 + num9 - 22, 1, false, 0, false, false);
                break;
              }
              if (num9 >= 26 && num9 <= 29)
              {
                Item.NewItem(x * 16, y * 16, 32, 32, 1496 + num9 - 26, 1, false, 0, false, false);
                break;
              }
              if (num9 >= 30 && num9 <= 32)
              {
                Item.NewItem(x * 16, y * 16, 32, 32, 1538 + num9 - 30, 1, false, 0, false, false);
                break;
              }
              Item.NewItem(x * 16, y * 16, 32, 32, 1360 + num9, 1, false, 0, false, false);
              break;
          }
          break;
        case 440:
          int Type1 = -1;
          int Type2 = -1;
          switch (num1)
          {
            case 0:
              Type1 = 3644;
              Type2 = 1526;
              break;
            case 1:
              Type1 = 3645;
              Type2 = 1524;
              break;
            case 2:
              Type1 = 3646;
              Type2 = 1525;
              break;
            case 3:
              Type1 = 3647;
              Type2 = 1523;
              break;
            case 4:
              Type1 = 3648;
              Type2 = 1522;
              break;
            case 5:
              Type1 = 3649;
              Type2 = 1527;
              break;
            case 6:
              Type1 = 3650;
              Type2 = 3643;
              break;
          }
          if (Type1 != -1)
            Item.NewItem(x * 16, y * 16, 32, 32, Type1, 1, false, 0, false, false);
          if (Type2 != -1 && num2 == 1)
          {
            Item.NewItem(x * 16, y * 16, 32, 32, Type2, 1, false, 0, false, false);
            break;
          }
          break;
      }
      WorldGen.destroyObject = false;
    }

    public static void Place2x3Wall(int x, int y, ushort type, int style)
    {
      int num1 = x;
      int num2 = y - 1;
      bool flag = true;
      for (int index1 = num1; index1 < num1 + 2; ++index1)
      {
        for (int index2 = num2; index2 < num2 + 3; ++index2)
        {
          if (Main.tile[index1, index2].active() || Main.tile[index1, index2].wall == (ushort) 0)
          {
            flag = false;
            break;
          }
        }
      }
      if (!flag)
        return;
      int num3 = style * 36;
      int num4 = 0;
      for (int index1 = num1; index1 < num1 + 2; ++index1)
      {
        for (int index2 = num2; index2 < num2 + 3; ++index2)
        {
          Main.tile[index1, index2].active(true);
          Main.tile[index1, index2].type = type;
          Main.tile[index1, index2].frameX = (short) (num3 + 18 * (index1 - num1));
          Main.tile[index1, index2].frameY = (short) (num4 + 18 * (index2 - num2));
        }
      }
    }

    public static void Check2x3Wall(int x, int y)
    {
      if (WorldGen.destroyObject)
        return;
      bool flag = false;
      int type = (int) Main.tile[x, y].type;
      int num1 = 0;
      int num2 = (int) Main.tile[x, y].frameX / 18;
      while (num2 >= 2)
      {
        num2 -= 2;
        ++num1;
      }
      int num3 = x - num2;
      int num4 = y - (int) Main.tile[x, y].frameY / 18;
      int num5 = num1 * 36;
      for (int index1 = num3; index1 < num3 + 2; ++index1)
      {
        for (int index2 = num4; index2 < num4 + 3; ++index2)
        {
          if ((int) Main.tile[index1, index2].type != type || !Main.tile[index1, index2].active() || (Main.tile[index1, index2].wall <= (ushort) 0 || (int) Main.tile[index1, index2].frameX != num5 + (index1 - num3) * 18) || (int) Main.tile[index1, index2].frameY != (index2 - num4) * 18)
          {
            flag = true;
            break;
          }
        }
      }
      if (!flag)
        return;
      WorldGen.destroyObject = true;
      for (int i = num3; i < num3 + 2; ++i)
      {
        for (int j = num4; j < num4 + 3; ++j)
        {
          if ((int) Main.tile[i, j].type == type && Main.tile[i, j].active())
            WorldGen.KillTile(i, j, false, false, false);
        }
      }
      if (type == 245)
      {
        switch (num1)
        {
          case 5:
            Item.NewItem(x * 16, y * 16, 32, 32, 1495, 1, false, 0, false, false);
            break;
          case 6:
            Item.NewItem(x * 16, y * 16, 32, 32, 1577, 1, false, 0, false, false);
            break;
          case 7:
            Item.NewItem(x * 16, y * 16, 32, 32, 4638, 1, false, 0, false, false);
            break;
          case 8:
            Item.NewItem(x * 16, y * 16, 32, 32, 4639, 1, false, 0, false, false);
            break;
          case 9:
            Item.NewItem(x * 16, y * 16, 32, 32, 4659, 1, false, 0, false, false);
            break;
          case 10:
            Item.NewItem(x * 16, y * 16, 32, 32, 4726, 1, false, 0, false, false);
            break;
          case 11:
            Item.NewItem(x * 16, y * 16, 32, 32, 4727, 1, false, 0, false, false);
            break;
          case 12:
            Item.NewItem(x * 16, y * 16, 32, 32, 4728, 1, false, 0, false, false);
            break;
          default:
            Item.NewItem(x * 16, y * 16, 32, 32, 1474 + num1, 1, false, 0, false, false);
            break;
        }
      }
      WorldGen.destroyObject = false;
    }

    public static void Place3x2Wall(int x, int y, ushort type, int style)
    {
      int num1 = x - 1;
      int num2 = y;
      bool flag = true;
      for (int index1 = num1; index1 < num1 + 3; ++index1)
      {
        for (int index2 = num2; index2 < num2 + 2; ++index2)
        {
          if (Main.tile[index1, index2].active() || Main.tile[index1, index2].wall == (ushort) 0)
          {
            flag = false;
            break;
          }
        }
      }
      if (!flag)
        return;
      int num3 = 0;
      int num4 = style * 36;
      for (int index1 = num1; index1 < num1 + 3; ++index1)
      {
        for (int index2 = num2; index2 < num2 + 2; ++index2)
        {
          Main.tile[index1, index2].active(true);
          Main.tile[index1, index2].type = type;
          Main.tile[index1, index2].frameX = (short) (num3 + 18 * (index1 - num1));
          Main.tile[index1, index2].frameY = (short) (num4 + 18 * (index2 - num2));
        }
      }
    }

    public static void Check3x2Wall(int x, int y)
    {
      if (WorldGen.destroyObject)
        return;
      bool flag = false;
      int type = (int) Main.tile[x, y].type;
      int num1 = 0;
      int num2 = (int) Main.tile[x, y].frameY / 18;
      while (num2 >= 2)
      {
        num2 -= 2;
        ++num1;
      }
      int num3 = y - num2;
      int num4 = x - (int) Main.tile[x, y].frameX / 18;
      int num5 = num1 * 36;
      for (int index1 = num4; index1 < num4 + 3; ++index1)
      {
        for (int index2 = num3; index2 < num3 + 2; ++index2)
        {
          if ((int) Main.tile[index1, index2].type != type || !Main.tile[index1, index2].active() || (Main.tile[index1, index2].wall <= (ushort) 0 || (int) Main.tile[index1, index2].frameY != num5 + (index2 - num3) * 18) || (int) Main.tile[index1, index2].frameX != (index1 - num4) * 18)
          {
            flag = true;
            break;
          }
        }
      }
      if (!flag)
        return;
      WorldGen.destroyObject = true;
      for (int i = num4; i < num4 + 3; ++i)
      {
        for (int j = num3; j < num3 + 2; ++j)
        {
          if ((int) Main.tile[i, j].type == type && Main.tile[i, j].active())
            WorldGen.KillTile(i, j, false, false, false);
        }
      }
      if (type == 246)
      {
        switch (num1)
        {
          case 16:
            Item.NewItem(x * 16, y * 16, 32, 32, 1541, 1, false, 0, false, false);
            break;
          case 17:
            Item.NewItem(x * 16, y * 16, 32, 32, 1542, 1, false, 0, false, false);
            break;
          case 18:
            Item.NewItem(x * 16, y * 16, 32, 32, 1908, 1, false, 0, false, false);
            break;
          case 19:
            Item.NewItem(x * 16, y * 16, 32, 32, 4661, 1, false, 0, false, false);
            break;
          case 20:
            Item.NewItem(x * 16, y * 16, 32, 32, 4729, 1, false, 0, false, false);
            break;
          default:
            Item.NewItem(x * 16, y * 16, 32, 32, 1479 + num1, 1, false, 0, false, false);
            break;
        }
      }
      WorldGen.destroyObject = false;
    }

    public static void Place4x3Wall(int x, int y, ushort type, int style)
    {
      int num1 = x - 1;
      int num2 = y - 1;
      bool flag = true;
      for (int index1 = num1; index1 < num1 + 4; ++index1)
      {
        for (int index2 = num2; index2 < num2 + 3; ++index2)
        {
          if (Main.tile[index1, index2].active() || Main.tile[index1, index2].wall == (ushort) 0)
          {
            flag = false;
            break;
          }
        }
      }
      if (!flag)
        return;
      int num3 = 0;
      int num4 = style * 54;
      for (int index1 = num1; index1 < num1 + 4; ++index1)
      {
        for (int index2 = num2; index2 < num2 + 3; ++index2)
        {
          Main.tile[index1, index2].active(true);
          Main.tile[index1, index2].type = type;
          Main.tile[index1, index2].frameX = (short) (num3 + 18 * (index1 - num1));
          Main.tile[index1, index2].frameY = (short) (num4 + 18 * (index2 - num2));
        }
      }
    }

    public static void Check4x3Wall(int x, int y)
    {
      if (WorldGen.destroyObject)
        return;
      bool flag = false;
      int type = (int) Main.tile[x, y].type;
      int num1 = 0;
      int num2 = (int) Main.tile[x, y].frameY / 18;
      while (num2 >= 3)
      {
        num2 -= 3;
        ++num1;
      }
      int num3 = y - num2;
      int num4 = x - (int) Main.tile[x, y].frameX / 18;
      int num5 = num1 * 54;
      for (int index1 = num4; index1 < num4 + 4; ++index1)
      {
        for (int index2 = num3; index2 < num3 + 3; ++index2)
        {
          if ((int) Main.tile[index1, index2].type != type || !Main.tile[index1, index2].active() || (Main.tile[index1, index2].wall <= (ushort) 0 || (int) Main.tile[index1, index2].frameY != num5 + (index2 - num3) * 18) || (int) Main.tile[index1, index2].frameX != (index1 - num4) * 18)
          {
            flag = true;
            break;
          }
        }
      }
      if (!flag)
        return;
      WorldGen.destroyObject = true;
      for (int i = num4; i < num4 + 4; ++i)
      {
        for (int j = num3; j < num3 + 3; ++j)
        {
          if ((int) Main.tile[i, j].type == type && Main.tile[i, j].active())
            WorldGen.KillTile(i, j, false, false, false);
        }
      }
      if (type == 241)
        Item.NewItem(x * 16, y * 16, 32, 32, 1417, 1, false, 0, false, false);
      WorldGen.destroyObject = false;
    }

    public static void Place6x4Wall(int x, int y, ushort type, int style)
    {
      int num1 = x - 2;
      int num2 = y - 2;
      bool flag = true;
      for (int index1 = num1; index1 < num1 + 6; ++index1)
      {
        for (int index2 = num2; index2 < num2 + 4; ++index2)
        {
          if (Main.tile[index1, index2].active() || Main.tile[index1, index2].wall == (ushort) 0)
          {
            flag = false;
            break;
          }
        }
      }
      if (!flag)
        return;
      int num3 = 27;
      int num4 = style / num3 * 108;
      int num5 = style % num3 * 72;
      for (int index1 = num1; index1 < num1 + 6; ++index1)
      {
        for (int index2 = num2; index2 < num2 + 4; ++index2)
        {
          Main.tile[index1, index2].active(true);
          Main.tile[index1, index2].type = type;
          Main.tile[index1, index2].frameX = (short) (num4 + 18 * (index1 - num1));
          Main.tile[index1, index2].frameY = (short) (num5 + 18 * (index2 - num2));
        }
      }
    }

    public static void Check6x4Wall(int x, int y)
    {
      if (WorldGen.destroyObject)
        return;
      bool flag = false;
      int type = (int) Main.tile[x, y].type;
      int num1 = (int) Main.tile[x, y].frameY / 18;
      int num2 = (int) Main.tile[x, y].frameX / 18;
      int num3 = 27 * (num2 / 6) + (num1 >> 2);
      int num4 = num1 % 4;
      int num5 = num2 % 6;
      int num6 = y - num4;
      int num7 = x - (int) Main.tile[x, y].frameX / 18 % 6;
      int num8 = num3 % 27 * 72;
      int num9 = num3 / 27 * 108;
      for (int index1 = num7; index1 < num7 + 6; ++index1)
      {
        for (int index2 = num6; index2 < num6 + 4; ++index2)
        {
          if ((int) Main.tile[index1, index2].type != type || !Main.tile[index1, index2].active() || (Main.tile[index1, index2].wall <= (ushort) 0 || (int) Main.tile[index1, index2].frameY != num8 + (index2 - num6) * 18) || (int) Main.tile[index1, index2].frameX != num9 + (index1 - num7) * 18)
          {
            flag = true;
            break;
          }
        }
      }
      if (!flag)
        return;
      WorldGen.destroyObject = true;
      for (int i = num7; i < num7 + 6; ++i)
      {
        for (int j = num6; j < num6 + 4; ++j)
        {
          if ((int) Main.tile[i, j].type == type && Main.tile[i, j].active())
            WorldGen.KillTile(i, j, false, false, false);
        }
      }
      if (type == 242)
      {
        switch (num3)
        {
          case 30:
            Item.NewItem(x * 16, y * 16, 32, 32, 2995, 1, false, 0, false, false);
            break;
          case 43:
            Item.NewItem(x * 16, y * 16, 32, 32, 4658, 1, false, 0, false, false);
            break;
          case 44:
            Item.NewItem(x * 16, y * 16, 32, 32, 4725, 1, false, 0, false, false);
            break;
          default:
            if (num3 >= 37 && num3 <= 42)
            {
              Item.NewItem(x * 16, y * 16, 32, 32, 4632 + num3 - 37, 1, false, 0, false, false);
              break;
            }
            if (num3 >= 31 && num3 <= 35)
            {
              Item.NewItem(x * 16, y * 16, 32, 32, 3055 + num3 - 31, 1, false, 0, false, false);
              break;
            }
            if (num3 >= 27 && num3 <= 29)
            {
              Item.NewItem(x * 16, y * 16, 32, 32, 2865 + num3 - 27, 1, false, 0, false, false);
              break;
            }
            if (num3 == 36)
            {
              Item.NewItem(x * 16, y * 16, 32, 32, 3596, 1, false, 0, false, false);
              break;
            }
            if (num3 == 26)
            {
              Item.NewItem(x * 16, y * 16, 32, 32, 2497, 1, false, 0, false, false);
              break;
            }
            if (num3 == 25)
            {
              Item.NewItem(x * 16, y * 16, 32, 32, 2495, 1, false, 0, false, false);
              break;
            }
            if (num3 >= 22)
            {
              Item.NewItem(x * 16, y * 16, 32, 32, 2281 + num3 - 22, 1, false, 0, false, false);
              break;
            }
            if (num3 >= 17)
            {
              Item.NewItem(x * 16, y * 16, 32, 32, 1846 + num3 - 17, 1, false, 0, false, false);
              break;
            }
            if (num3 == 16)
            {
              Item.NewItem(x * 16, y * 16, 32, 32, 1573, 1, false, 0, false, false);
              break;
            }
            if (num3 >= 13)
            {
              Item.NewItem(x * 16, y * 16, 32, 32, 1500 + num3 - 13, 1, false, 0, false, false);
              break;
            }
            if (num3 >= 6)
            {
              Item.NewItem(x * 16, y * 16, 32, 32, 1433 + num3 - 6, 1, false, 0, false, false);
              break;
            }
            Item.NewItem(x * 16, y * 16, 32, 32, 1421 + num3, 1, false, 0, false, false);
            break;
        }
      }
      WorldGen.destroyObject = false;
    }

    private static int RollRandomSeaShellStyle()
    {
      int num = WorldGen.genRand.Next(2);
      if (WorldGen.genRand.Next(10) == 0)
        num = 2;
      if (WorldGen.genRand.Next(10) == 0)
        num = 3;
      if (WorldGen.genRand.Next(50) == 0)
        num = 4;
      return num;
    }

    public static void Place1x1(int x, int y, int type, int style = 0)
    {
      Tile tile = Main.tile[x, y];
      if (Main.tile[x, y] == null)
      {
        tile = new Tile();
        Main.tile[x, y] = tile;
      }
      if (Main.tile[x, y + 1] == null)
        Main.tile[x, y + 1] = new Tile();
      if (type == 324)
      {
        if (!WorldGen.SolidTile2(x, y + 1) && (!Main.tile[x, y + 1].nactive() || !Main.tileTable[(int) Main.tile[x, y + 1].type]))
          return;
        tile.active(true);
        tile.type = (ushort) type;
        tile.frameX = (short) (22 * WorldGen.genRand.Next(3));
        tile.frameY = (short) (22 * style);
      }
      else
      {
        if (!WorldGen.SolidTile2(x, y + 1) || tile.active())
          return;
        tile.active(true);
        tile.type = (ushort) type;
        switch (type)
        {
          case 36:
          case 144:
          case 239:
            tile.frameX = (short) (style * 18);
            tile.frameY = (short) 0;
            break;
          case 324:
            tile.frameX = (short) (22 * WorldGen.RollRandomSeaShellStyle());
            tile.frameY = (short) (22 * style);
            break;
          default:
            tile.frameY = (short) (style * 18);
            break;
        }
      }
    }

    public static void Check1x1(int x, int y, int type)
    {
      if (Main.tile[x, y + 1] == null || WorldGen.SolidTileAllowBottomSlope(x, y + 1))
        return;
      WorldGen.KillTile(x, y, false, false, false);
    }

    public static void CheckGolf1x1(int x, int y, int type)
    {
      Tile tile = Main.tile[x, y];
      bool flag = false;
      if ((int) tile.frameX % 18 != 0)
        flag = true;
      if ((int) tile.frameY % 18 != 0)
        flag = true;
      if (!WorldGen.SolidTileAllowBottomSlope(x, y + 1))
        flag = true;
      if (!flag)
        return;
      WorldGen.KillTile(x, y, false, false, false);
    }

    public static void CheckLogicTiles(int x, int y, int type)
    {
      if (type == 419)
      {
        Tile tile = Main.tile[x, y + 1];
        if (tile != null && (!tile.active() || tile.type != (ushort) 420 && tile.type != (ushort) 419))
        {
          WorldGen.KillTile(x, y, false, false, false);
          return;
        }
      }
      Tile tile1 = Main.tile[x, y];
      bool flag = false;
      if ((int) tile1.frameX % 18 != 0)
        flag = true;
      if ((int) tile1.frameY % 18 != 0)
        flag = true;
      if (!flag)
        return;
      WorldGen.KillTile(x, y, false, false, false);
    }

    public static void PlaceLogicTiles(int x, int y, int type, int style = 0)
    {
      Tile tile = Main.tile[x, y];
      if (Main.tile[x, y] == null)
      {
        tile = new Tile();
        Main.tile[x, y] = tile;
      }
      if (Main.tile[x, y + 1] == null)
        Main.tile[x, y + 1] = new Tile();
      if (type == 419)
      {
        if (!Main.tile[x, y + 1].active() || Main.tile[x, y + 1].type != (ushort) 419 && Main.tile[x, y + 1].type != (ushort) 420)
          return;
        tile.active(true);
        tile.type = (ushort) type;
        tile.frameX = (short) (style * 18);
        tile.frameY = (short) 0;
      }
      else
      {
        if (tile.active())
          return;
        tile.active(true);
        tile.type = (ushort) type;
        tile.frameX = (short) 0;
        tile.frameY = (short) (18 * style);
      }
    }

    public static void PlaceOnTable1x1(int x, int y, int type, int style = 0)
    {
      bool flag = false;
      if (Main.tile[x, y] == null)
        Main.tile[x, y] = new Tile();
      if (Main.tile[x, y + 1] == null)
        Main.tile[x, y + 1] = new Tile();
      if (!Main.tile[x, y].active() && Main.tile[x, y + 1].nactive() && Main.tileTable[(int) Main.tile[x, y + 1].type])
        flag = true;
      if (type == 78 && !Main.tile[x, y].active() && (Main.tile[x, y + 1].nactive() && Main.tileSolid[(int) Main.tile[x, y + 1].type]) && (!Main.tile[x, y + 1].halfBrick() && Main.tile[x, y + 1].slope() == (byte) 0))
        flag = true;
      if (!flag)
        return;
      Main.tile[x, y].active(true);
      Main.tile[x, y].type = (ushort) type;
      if (type == 33)
      {
        Main.tile[x, y].frameX = (short) 0;
        Main.tile[x, y].frameY = (short) (style * 22);
      }
      else
      {
        Main.tile[x, y].frameX = (short) (style * 18);
        Main.tile[x, y].frameY = (short) 0;
      }
      if (type != 50)
        return;
      Main.tile[x, y].frameX = (short) (18 * WorldGen.genRand.Next(5));
    }

    public static bool PlaceAlch(int x, int y, int style)
    {
      if (Main.tile[x, y] == null)
        Main.tile[x, y] = new Tile();
      if (Main.tile[x, y + 1] == null)
        Main.tile[x, y + 1] = new Tile();
      if (!Main.tile[x, y].active() && Main.tile[x, y + 1].nactive() && (!Main.tile[x, y + 1].halfBrick() && Main.tile[x, y + 1].slope() == (byte) 0))
      {
        bool flag = false;
        switch (style)
        {
          case 0:
            if (Main.tile[x, y + 1].type != (ushort) 2 && Main.tile[x, y + 1].type != (ushort) 477 && (Main.tile[x, y + 1].type != (ushort) 492 && Main.tile[x, y + 1].type != (ushort) 78) && (Main.tile[x, y + 1].type != (ushort) 380 && Main.tile[x, y + 1].type != (ushort) 109))
              flag = true;
            if (Main.tile[x, y].liquid > (byte) 0)
            {
              flag = true;
              break;
            }
            break;
          case 1:
            if (Main.tile[x, y + 1].type != (ushort) 60 && Main.tile[x, y + 1].type != (ushort) 78 && Main.tile[x, y + 1].type != (ushort) 380)
              flag = true;
            if (Main.tile[x, y].liquid > (byte) 0)
            {
              flag = true;
              break;
            }
            break;
          case 2:
            if (Main.tile[x, y + 1].type != (ushort) 0 && Main.tile[x, y + 1].type != (ushort) 59 && (Main.tile[x, y + 1].type != (ushort) 78 && Main.tile[x, y + 1].type != (ushort) 380))
              flag = true;
            if (Main.tile[x, y].liquid > (byte) 0)
            {
              flag = true;
              break;
            }
            break;
          case 3:
            if (Main.tile[x, y + 1].type != (ushort) 203 && Main.tile[x, y + 1].type != (ushort) 199 && (Main.tile[x, y + 1].type != (ushort) 23 && Main.tile[x, y + 1].type != (ushort) 25) && (Main.tile[x, y + 1].type != (ushort) 78 && Main.tile[x, y + 1].type != (ushort) 380))
              flag = true;
            if (Main.tile[x, y].liquid > (byte) 0)
            {
              flag = true;
              break;
            }
            break;
          case 4:
            if (Main.tile[x, y + 1].type != (ushort) 53 && Main.tile[x, y + 1].type != (ushort) 78 && (Main.tile[x, y + 1].type != (ushort) 380 && Main.tile[x, y + 1].type != (ushort) 116))
              flag = true;
            if (Main.tile[x, y].liquid > (byte) 0 && Main.tile[x, y].lava())
            {
              flag = true;
              break;
            }
            break;
          case 5:
            if (Main.tile[x, y + 1].type != (ushort) 57 && Main.tile[x, y + 1].type != (ushort) 78 && Main.tile[x, y + 1].type != (ushort) 380)
              flag = true;
            if (Main.tile[x, y].liquid > (byte) 0 && !Main.tile[x, y].lava())
            {
              flag = true;
              break;
            }
            break;
          case 6:
            if (Main.tile[x, y + 1].type != (ushort) 78 && Main.tile[x, y + 1].type != (ushort) 380 && (Main.tile[x, y + 1].type != (ushort) 147 && Main.tile[x, y + 1].type != (ushort) 161) && (Main.tile[x, y + 1].type != (ushort) 163 && Main.tile[x, y + 1].type != (ushort) 164 && Main.tile[x, y + 1].type != (ushort) 200))
              flag = true;
            if (Main.tile[x, y].liquid > (byte) 0 && Main.tile[x, y].lava())
            {
              flag = true;
              break;
            }
            break;
        }
        if (!flag)
        {
          Main.tile[x, y].active(true);
          Main.tile[x, y].type = (ushort) 82;
          Main.tile[x, y].frameX = (short) (18 * style);
          Main.tile[x, y].frameY = (short) 0;
          return true;
        }
      }
      return false;
    }

    public static void GrowSpike(int i, int j, ushort spikeType, ushort landType)
    {
      int index1 = i;
      int index2 = j;
      int num1 = 0;
      if (Main.tile[index1 + 1, index2].active() && (int) Main.tile[index1 + 1, index2].type == (int) spikeType)
        ++num1;
      if (Main.tile[index1 - 1, index2].active() && (int) Main.tile[index1 - 1, index2].type == (int) spikeType)
        ++num1;
      if (Main.tile[index1, index2 + 1].active() && (int) Main.tile[index1, index2 + 1].type == (int) spikeType)
        ++num1;
      if (Main.tile[index1, index2 - 1].active() && (int) Main.tile[index1, index2 - 1].type == (int) spikeType)
        ++num1;
      if (num1 >= 3 && (int) Main.tile[i, j].type != (int) landType)
        return;
      switch (WorldGen.genRand.Next(4))
      {
        case 0:
          --index2;
          break;
        case 1:
          ++index2;
          break;
        case 2:
          --index1;
          break;
        case 3:
          ++index1;
          break;
      }
      if (Main.tile[index1, index2].active())
        return;
      int num2 = 0;
      if (Main.tile[index1 + 1, index2].active() && (int) Main.tile[index1 + 1, index2].type == (int) spikeType)
        ++num2;
      if (Main.tile[index1 - 1, index2].active() && (int) Main.tile[index1 - 1, index2].type == (int) spikeType)
        ++num2;
      if (Main.tile[index1, index2 + 1].active() && (int) Main.tile[index1, index2 + 1].type == (int) spikeType)
        ++num2;
      if (Main.tile[index1, index2 - 1].active() && (int) Main.tile[index1, index2 - 1].type == (int) spikeType)
        ++num2;
      if (num2 >= 2)
        return;
      int num3 = 7;
      int num4 = index1 - num3;
      int num5 = index1 + num3;
      int num6 = index2 - num3;
      int num7 = index2 + num3;
      bool flag = false;
      for (int index3 = num4; index3 < num5; ++index3)
      {
        for (int index4 = num6; index4 < num7; ++index4)
        {
          if (Math.Abs(index3 - index1) * 2 + Math.Abs(index4 - index2) < 9 && Main.tile[index3, index4].active() && ((int) Main.tile[index3, index4].type == (int) landType && Main.tile[index3, index4 - 1].active()) && ((int) Main.tile[index3, index4 - 1].type == (int) spikeType && Main.tile[index3, index4 - 1].liquid == (byte) 0))
          {
            flag = true;
            break;
          }
        }
      }
      if (!flag)
        return;
      Main.tile[index1, index2].type = spikeType;
      Main.tile[index1, index2].active(true);
      WorldGen.SquareTileFrame(index1, index2, true);
      if (Main.netMode != 2)
        return;
      NetMessage.SendTileSquare(-1, index1, index2, 3, TileChangeType.None);
    }

    private static bool GrowMoreVines(int x, int y)
    {
      if (!WorldGen.InWorld(x, y, 30))
        return false;
      int num1 = 4;
      int num2 = 6;
      int num3 = 10;
      int num4 = 60;
      int num5 = 0;
      int num6 = y;
      if (Main.tile[x, y].type == (ushort) 528)
        num4 /= 5;
      for (int index1 = x - num1; index1 <= x + num1; ++index1)
      {
        for (int index2 = num6 - num2; index2 <= num6 + num3; ++index2)
        {
          if (TileID.Sets.IsVine[(int) Main.tile[index1, index2].type])
          {
            ++num5;
            if (index2 > y && Collision.CanHitLine(new Vector2((float) (x * 16), (float) (y * 16)), 1, 1, new Vector2((float) (index1 * 16), (float) (index2 * 16)), 1, 1))
            {
              if (Main.tile[index1, index2].type == (ushort) 528)
                num5 += (index2 - y) * 20;
              else
                num5 += (index2 - y) * 2;
            }
            if (num5 > num4)
              return false;
          }
        }
      }
      return true;
    }

    private static void MatureTheHerbPlants()
    {
      for (int i = 10; i < Main.maxTilesX - 10; ++i)
      {
        for (int index = 10; index < Main.maxTilesY - 10; ++index)
        {
          if ((double) index > Main.rockLayer && (Main.tile[i, index + 1].type == (ushort) 59 || Main.tile[i, index + 1].type == (ushort) 0) && (WorldGen.SolidTile(i, index + 1, false) && !Main.tile[i, index].active() && (Main.tile[i, index].liquid == (byte) 0 && WorldGen.genRand.Next(25) == 0)))
          {
            Main.tile[i, index].active(true);
            Main.tile[i, index].type = (ushort) 82;
            Main.tile[i, index].frameX = (short) 36;
            Main.tile[i, index].frameY = (short) 0;
          }
          if (Main.tile[i, index].type == (ushort) 82 && WorldGen.genRand.Next(3) == 0)
          {
            Main.tile[i, index].type = (ushort) 83;
            if (Main.tile[i, index].frameX == (short) 36 && WorldGen.genRand.Next(2) == 0)
              Main.tile[i, index].type = (ushort) 84;
            if (Main.tile[i, index].frameX == (short) 108 && WorldGen.genRand.Next(3) == 0)
              Main.tile[i, index].type = (ushort) 84;
          }
        }
      }
    }

    public static void GrowAlch(int x, int y)
    {
      if (!Main.tile[x, y].active())
        return;
      if (Main.tile[x, y].liquid > (byte) 0)
      {
        int num = (int) Main.tile[x, y].frameX / 18;
        if ((!Main.tile[x, y].lava() || num != 5) && (Main.tile[x, y].liquidType() != (byte) 0 || num != 1 && num != 4))
        {
          WorldGen.KillTile(x, y, false, false, false);
          if (Main.netMode == 2)
            NetMessage.SendTileSquare(-1, x, y, 1, TileChangeType.None);
          WorldGen.SquareTileFrame(x, y, true);
        }
      }
      if (Main.tile[x, y].type == (ushort) 82)
      {
        if (WorldGen.genRand.Next(50) == 0)
        {
          bool flag = false;
          if (Main.tile[x, y].frameX == (short) 108)
          {
            if (WorldGen.genRand.Next(2) == 0)
              flag = true;
          }
          else
            flag = true;
          if (!flag)
            return;
          Main.tile[x, y].type = (ushort) 83;
          if (Main.netMode == 2)
            NetMessage.SendTileSquare(-1, x, y, 1, TileChangeType.None);
          WorldGen.SquareTileFrame(x, y, true);
        }
        else if (Main.dayTime && Main.tile[x, y].type == (ushort) 82 && (Main.tile[x, y].frameX == (short) 0 && WorldGen.genRand.Next(50) == 0))
        {
          Main.tile[x, y].type = (ushort) 83;
          if (Main.netMode == 2)
            NetMessage.SendTileSquare(-1, x, y, 1, TileChangeType.None);
          WorldGen.SquareTileFrame(x, y, true);
        }
        else if (!Main.dayTime && Main.tile[x, y].type == (ushort) 82 && (Main.tile[x, y].frameX == (short) 18 && WorldGen.genRand.Next(50) == 0))
        {
          Main.tile[x, y].type = (ushort) 83;
          if (Main.netMode == 2)
            NetMessage.SendTileSquare(-1, x, y, 1, TileChangeType.None);
          WorldGen.SquareTileFrame(x, y, true);
        }
        else if (Main.raining && Main.tile[x, y].type == (ushort) 82 && (Main.tile[x, y].frameX == (short) 72 && WorldGen.genRand.Next(50) == 0))
        {
          Main.tile[x, y].type = (ushort) 83;
          if (Main.netMode == 2)
            NetMessage.SendTileSquare(-1, x, y, 1, TileChangeType.None);
          WorldGen.SquareTileFrame(x, y, true);
        }
        else if ((double) y > Main.worldSurface && Main.tile[x, y].type == (ushort) 82 && (Main.tile[x, y].frameX == (short) 36 && WorldGen.genRand.Next(50) == 0))
        {
          Main.tile[x, y].type = (ushort) 83;
          if (Main.netMode == 2)
            NetMessage.SendTileSquare(-1, x, y, 1, TileChangeType.None);
          WorldGen.SquareTileFrame(x, y, true);
        }
        else
        {
          if (y <= Main.maxTilesY - 200 || Main.tile[x, y].type != (ushort) 82 || (Main.tile[x, y].frameX != (short) 90 || WorldGen.genRand.Next(50) != 0))
            return;
          Main.tile[x, y].type = (ushort) 83;
          if (Main.netMode == 2)
            NetMessage.SendTileSquare(-1, x, y, 1, TileChangeType.None);
          WorldGen.SquareTileFrame(x, y, true);
        }
      }
      else if (Main.tile[x, y].frameX == (short) 36 && WorldGen.genRand.Next(3) != 0)
      {
        if (Main.tile[x, y].type == (ushort) 83)
        {
          if (WorldGen.genRand.Next(2) != 0)
            return;
          Main.tile[x, y].type = (ushort) 84;
          if (Main.netMode != 2)
            return;
          NetMessage.SendTileSquare(-1, x, y, 1, TileChangeType.None);
        }
        else
        {
          if (Main.tile[x, y].type != (ushort) 84 || WorldGen.genRand.Next(5) != 0)
            return;
          Main.tile[x, y].type = (ushort) 83;
          if (Main.netMode != 2)
            return;
          NetMessage.SendTileSquare(-1, x, y, 1, TileChangeType.None);
        }
      }
      else
      {
        if (Main.tile[x, y].frameX != (short) 108 || Main.tile[x, y].type != (ushort) 83 || WorldGen.genRand.Next(30) != 0)
          return;
        Main.tile[x, y].type = (ushort) 84;
        if (Main.netMode == 2)
          NetMessage.SendTileSquare(-1, x, y, 1, TileChangeType.None);
        WorldGen.SquareTileFrame(x, y, true);
      }
    }

    public static void PlantAlch()
    {
      int index1 = WorldGen.genRand.Next(20, Main.maxTilesX - 20);
      int index2 = WorldGen.genRand.Next(40) != 0 ? (WorldGen.genRand.Next(10) != 0 ? WorldGen.genRand.Next((int) Main.worldSurface, Main.maxTilesY - 20) : WorldGen.genRand.Next(20, Main.maxTilesY - 20)) : WorldGen.genRand.Next((int) (Main.rockLayer + (double) Main.maxTilesY) / 2, Main.maxTilesY - 20);
      while (index2 < Main.maxTilesY - 20 && !Main.tile[index1, index2].active())
        ++index2;
      if (!Main.tile[index1, index2].nactive() || Main.tile[index1, index2 - 1].active() || Main.tile[index1, index2 - 1].liquid != (byte) 0)
        return;
      int num1 = 15;
      int num2 = 5;
      int num3 = 0;
      int num4 = (int) ((double) num1 * ((double) Main.maxTilesX / 4200.0));
      int num5 = Utils.Clamp<int>(index1 - num4, 4, Main.maxTilesX - 4);
      int num6 = Utils.Clamp<int>(index1 + num4, 4, Main.maxTilesX - 4);
      int num7 = Utils.Clamp<int>(index2 - num4, 4, Main.maxTilesY - 4);
      int num8 = Utils.Clamp<int>(index2 + num4, 4, Main.maxTilesY - 4);
      for (int index3 = num5; index3 <= num6; ++index3)
      {
        for (int index4 = num7; index4 <= num8; ++index4)
        {
          if (Main.tileAlch[(int) Main.tile[index3, index4].type])
            ++num3;
        }
      }
      if (num3 >= num2)
        return;
      if (Main.tile[index1, index2].type == (ushort) 2 || Main.tile[index1, index2].type == (ushort) 109)
        WorldGen.PlaceAlch(index1, index2 - 1, 0);
      if (Main.tile[index1, index2].type == (ushort) 60)
        WorldGen.PlaceAlch(index1, index2 - 1, 1);
      if (Main.tile[index1, index2].type == (ushort) 0 || Main.tile[index1, index2].type == (ushort) 59)
        WorldGen.PlaceAlch(index1, index2 - 1, 2);
      if (Main.tile[index1, index2].type == (ushort) 23 || Main.tile[index1, index2].type == (ushort) 25 || (Main.tile[index1, index2].type == (ushort) 203 || Main.tile[index1, index2].type == (ushort) 199))
        WorldGen.PlaceAlch(index1, index2 - 1, 3);
      if ((Main.tile[index1, index2].type == (ushort) 53 || Main.tile[index1, index2].type == (ushort) 116) && (index1 >= WorldGen.beachDistance && index1 <= Main.maxTilesX - WorldGen.beachDistance))
        WorldGen.PlaceAlch(index1, index2 - 1, 4);
      if (Main.tile[index1, index2].type == (ushort) 57)
        WorldGen.PlaceAlch(index1, index2 - 1, 5);
      if (Main.tile[index1, index2].type == (ushort) 147 || Main.tile[index1, index2].type == (ushort) 163 || (Main.tile[index1, index2].type == (ushort) 164 || Main.tile[index1, index2].type == (ushort) 161) || Main.tile[index1, index2].type == (ushort) 200)
        WorldGen.PlaceAlch(index1, index2 - 1, 6);
      if (!Main.tile[index1, index2 - 1].active() || Main.netMode != 2)
        return;
      NetMessage.SendTileSquare(-1, index1, index2 - 1, 1, TileChangeType.None);
    }

    public static void CheckAlch(int x, int y)
    {
      if (Main.tile[x, y] == null)
        Main.tile[x, y] = new Tile();
      if (Main.tile[x, y + 1] == null)
        Main.tile[x, y + 1] = new Tile();
      bool flag = false;
      if (!Main.tile[x, y + 1].nactive())
        flag = true;
      if (Main.tile[x, y + 1].halfBrick())
        flag = true;
      int num = (int) Main.tile[x, y].frameX / 18;
      Main.tile[x, y].frameY = (short) 0;
      if (!flag)
      {
        switch (num)
        {
          case 0:
            if (Main.tile[x, y + 1].type != (ushort) 109 && Main.tile[x, y + 1].type != (ushort) 2 && (Main.tile[x, y + 1].type != (ushort) 477 && Main.tile[x, y + 1].type != (ushort) 492) && (Main.tile[x, y + 1].type != (ushort) 78 && Main.tile[x, y + 1].type != (ushort) 380))
              flag = true;
            if (Main.tile[x, y].liquid > (byte) 0 && Main.tile[x, y].lava())
            {
              flag = true;
              break;
            }
            break;
          case 1:
            if (Main.tile[x, y + 1].type != (ushort) 60 && Main.tile[x, y + 1].type != (ushort) 78 && Main.tile[x, y + 1].type != (ushort) 380)
              flag = true;
            if (Main.tile[x, y].liquid > (byte) 0 && Main.tile[x, y].lava())
            {
              flag = true;
              break;
            }
            break;
          case 2:
            if (Main.tile[x, y + 1].type != (ushort) 0 && Main.tile[x, y + 1].type != (ushort) 59 && (Main.tile[x, y + 1].type != (ushort) 78 && Main.tile[x, y + 1].type != (ushort) 380))
              flag = true;
            if (Main.tile[x, y].liquid > (byte) 0 && Main.tile[x, y].lava())
            {
              flag = true;
              break;
            }
            break;
          case 3:
            if (Main.tile[x, y + 1].type != (ushort) 199 && Main.tile[x, y + 1].type != (ushort) 203 && (Main.tile[x, y + 1].type != (ushort) 23 && Main.tile[x, y + 1].type != (ushort) 25) && (Main.tile[x, y + 1].type != (ushort) 78 && Main.tile[x, y + 1].type != (ushort) 380))
              flag = true;
            if (Main.tile[x, y].liquid > (byte) 0 && Main.tile[x, y].lava())
            {
              flag = true;
              break;
            }
            break;
          case 4:
            if (Main.tile[x, y + 1].type != (ushort) 53 && Main.tile[x, y + 1].type != (ushort) 78 && (Main.tile[x, y + 1].type != (ushort) 380 && Main.tile[x, y + 1].type != (ushort) 116))
              flag = true;
            if (Main.tile[x, y].liquid > (byte) 0 && Main.tile[x, y].lava())
            {
              flag = true;
              break;
            }
            break;
          case 5:
            if (Main.tile[x, y + 1].type != (ushort) 57 && Main.tile[x, y + 1].type != (ushort) 78 && Main.tile[x, y + 1].type != (ushort) 380)
              flag = true;
            if (Main.tile[x, y].type != (ushort) 82 && Main.tile[x, y].lava() && Main.netMode != 1)
            {
              if (Main.tile[x, y].liquid > (byte) 16)
              {
                if (Main.tile[x, y].type == (ushort) 83)
                {
                  Main.tile[x, y].type = (ushort) 84;
                  if (Main.netMode == 2)
                  {
                    NetMessage.SendTileSquare(-1, x, y, 1, TileChangeType.None);
                    break;
                  }
                  break;
                }
                break;
              }
              if (Main.tile[x, y].type == (ushort) 84)
              {
                Main.tile[x, y].type = (ushort) 83;
                if (Main.netMode == 2)
                {
                  NetMessage.SendTileSquare(-1, x, y, 1, TileChangeType.None);
                  break;
                }
                break;
              }
              break;
            }
            break;
          case 6:
            if (Main.tile[x, y + 1].type != (ushort) 78 && Main.tile[x, y + 1].type != (ushort) 380 && (Main.tile[x, y + 1].type != (ushort) 147 && Main.tile[x, y + 1].type != (ushort) 161) && (Main.tile[x, y + 1].type != (ushort) 163 && Main.tile[x, y + 1].type != (ushort) 164 && Main.tile[x, y + 1].type != (ushort) 200))
              flag = true;
            if (Main.tile[x, y].liquid > (byte) 0 && Main.tile[x, y].lava())
            {
              flag = true;
              break;
            }
            break;
        }
      }
      if (!flag)
        return;
      WorldGen.KillTile(x, y, false, false, false);
    }

    public static void CheckBanner(int x, int j, byte type)
    {
      if (WorldGen.destroyObject)
        return;
      int num1 = (int) Main.tile[x, j].frameY / 18;
      int num2 = 0;
      while (num1 >= 3)
      {
        num1 -= 3;
        ++num2;
      }
      int num3 = j - num1;
      int frameX = (int) Main.tile[x, j].frameX;
      bool flag = false;
      for (int index = 0; index < 3; ++index)
      {
        if (Main.tile[x, num3 + index] == null)
          Main.tile[x, num3 + index] = new Tile();
        if (!Main.tile[x, num3 + index].active())
          flag = true;
        else if ((int) Main.tile[x, num3 + index].type != (int) type)
          flag = true;
        else if ((int) Main.tile[x, num3 + index].frameY != index * 18 + num2 * 18 * 3)
          flag = true;
        else if ((int) Main.tile[x, num3 + index].frameX != frameX)
          flag = true;
      }
      if (Main.tile[x, num3 - 1] == null)
        Main.tile[x, num3 - 1] = new Tile();
      if (!Main.tile[x, num3 - 1].nactive())
        flag = true;
      if (!Main.tile[x, num3 - 1].topSlope() && !Main.tile[x, num3 - 1].halfBrick() && !Main.tileSolid[(int) Main.tile[x, num3 - 1].type] || Main.tileSolidTop[(int) Main.tile[x, num3 - 1].type] && (!TileID.Sets.Platforms[(int) Main.tile[x, num3 - 1].type] || !Main.tile[x, num3 - 1].halfBrick() && !Main.tile[x, num3 - 1].topSlope()) || (TileID.Sets.NotReallySolid[(int) Main.tile[x, num3 - 1].type] || Main.tile[x, num3 - 1].bottomSlope()))
        flag = true;
      if (!flag)
        return;
      WorldGen.destroyObject = true;
      for (int index = 0; index < 3; ++index)
      {
        if ((int) Main.tile[x, num3 + index].type == (int) type)
          WorldGen.KillTile(x, num3 + index, false, false, false);
      }
      if (type == (byte) 91)
      {
        int num4 = frameX / 18 + num2 * 111;
        if (num4 >= 297)
          Item.NewItem(x * 16, (num3 + 1) * 16, 32, 32, 4668 + num4, 1, false, 0, false, false);
        else if (num4 >= 295)
          Item.NewItem(x * 16, (num3 + 1) * 16, 32, 32, 4392 + num4, 1, false, 0, false, false);
        else if (num4 >= 294)
          Item.NewItem(x * 16, (num3 + 1) * 16, 32, 32, 4602, 1, false, 0, false, false);
        else if (num4 >= 288)
          Item.NewItem(x * 16, (num3 + 1) * 16, 32, 32, 4253 + num4, 1, false, 0, false, false);
        else if (num4 >= 278)
          Item.NewItem(x * 16, (num3 + 1) * 16, 32, 32, 3559 + num4, 1, false, 0, false, false);
        else if (num4 >= 273)
          Item.NewItem(x * 16, (num3 + 1) * 16, 32, 32, 3516 + num4, 1, false, 0, false, false);
        else if (num4 >= 272)
          Item.NewItem(x * 16, (num3 + 1) * 16, 32, 32, 3780, 1, false, 0, false, false);
        else if (num4 >= 270)
          Item.NewItem(x * 16, (num3 + 1) * 16, 32, 32, 3323 + num4, 1, false, 0, false, false);
        else if (num4 >= 207)
          Item.NewItem(x * 16, (num3 + 1) * 16, 32, 32, 3183 + num4, 1, false, 0, false, false);
        else if (num4 >= 109)
          Item.NewItem(x * 16, (num3 + 1) * 16, 32, 32, 2788 + num4, 1, false, 0, false, false);
        else if (num4 >= 22)
          Item.NewItem(x * 16, (num3 + 1) * 16, 32, 32, 1593 + num4, 1, false, 0, false, false);
        else if (num4 >= 10 && num4 <= 15)
          Item.NewItem(x * 16, (num3 + 1) * 16, 32, 32, 1441 + num4, 1, false, 0, false, false);
        else if (num4 >= 16 && num4 <= 21)
          Item.NewItem(x * 16, (num3 + 1) * 16, 32, 32, 1448 + num4, 1, false, 0, false, false);
        else if (num4 >= 7 && num4 <= 9)
          Item.NewItem(x * 16, (num3 + 1) * 16, 32, 32, 838 + num4, 1, false, 0, false, false);
        else if (num4 >= 4 && num4 <= 6)
          Item.NewItem(x * 16, (num3 + 1) * 16, 32, 32, 785 + num4, 1, false, 0, false, false);
        else
          Item.NewItem(x * 16, (num3 + 1) * 16, 32, 32, 337 + num4, 1, false, 0, false, false);
      }
      WorldGen.destroyObject = false;
    }

    public static void PlaceBanner(int x, int y, ushort type, int style = 0)
    {
      int num1 = style * 18;
      int num2 = 0;
      if (style >= 90)
      {
        num1 -= 1620;
        num2 += 54;
      }
      if (Main.tile[x, y - 1] == null)
        Main.tile[x, y - 1] = new Tile();
      if (Main.tile[x, y] == null)
        Main.tile[x, y] = new Tile();
      if (Main.tile[x, y + 1] == null)
        Main.tile[x, y + 1] = new Tile();
      if (Main.tile[x, y + 2] == null)
        Main.tile[x, y + 2] = new Tile();
      if (!Main.tile[x, y - 1].nactive() || !Main.tileSolid[(int) Main.tile[x, y - 1].type] || (Main.tileSolidTop[(int) Main.tile[x, y - 1].type] || Main.tile[x, y].active()) || (Main.tile[x, y + 1].active() || Main.tile[x, y + 2].active()))
        return;
      Main.tile[x, y].active(true);
      Main.tile[x, y].frameY = (short) num2;
      Main.tile[x, y].frameX = (short) num1;
      Main.tile[x, y].type = type;
      Main.tile[x, y + 1].active(true);
      Main.tile[x, y + 1].frameY = (short) (num2 + 18);
      Main.tile[x, y + 1].frameX = (short) num1;
      Main.tile[x, y + 1].type = type;
      Main.tile[x, y + 2].active(true);
      Main.tile[x, y + 2].frameY = (short) (num2 + 36);
      Main.tile[x, y + 2].frameX = (short) num1;
      Main.tile[x, y + 2].type = type;
    }

    public static void PlaceMan(int i, int j, int dir)
    {
      for (int index1 = i; index1 <= i + 1; ++index1)
      {
        for (int index2 = j - 2; index2 <= j; ++index2)
        {
          if (Main.tile[index1, index2].active())
            return;
        }
      }
      if (!WorldGen.SolidTile2(i, j + 1) || !WorldGen.SolidTile2(i + 1, j + 1))
        return;
      byte num = 0;
      if (dir == 1)
        num = (byte) 36;
      Main.tile[i, j - 2].active(true);
      Main.tile[i, j - 2].frameY = (short) 0;
      Main.tile[i, j - 2].frameX = (short) num;
      Main.tile[i, j - 2].type = (ushort) 128;
      Main.tile[i, j - 1].active(true);
      Main.tile[i, j - 1].frameY = (short) 18;
      Main.tile[i, j - 1].frameX = (short) num;
      Main.tile[i, j - 1].type = (ushort) 128;
      Main.tile[i, j].active(true);
      Main.tile[i, j].frameY = (short) 36;
      Main.tile[i, j].frameX = (short) num;
      Main.tile[i, j].type = (ushort) 128;
      Main.tile[i + 1, j - 2].active(true);
      Main.tile[i + 1, j - 2].frameY = (short) 0;
      Main.tile[i + 1, j - 2].frameX = (short) (byte) (18U + (uint) num);
      Main.tile[i + 1, j - 2].type = (ushort) 128;
      Main.tile[i + 1, j - 1].active(true);
      Main.tile[i + 1, j - 1].frameY = (short) 18;
      Main.tile[i + 1, j - 1].frameX = (short) (byte) (18U + (uint) num);
      Main.tile[i + 1, j - 1].type = (ushort) 128;
      Main.tile[i + 1, j].active(true);
      Main.tile[i + 1, j].frameY = (short) 36;
      Main.tile[i + 1, j].frameX = (short) (byte) (18U + (uint) num);
      Main.tile[i + 1, j].type = (ushort) 128;
    }

    public static void PlaceWoman(int i, int j, int dir)
    {
      for (int index1 = i; index1 <= i + 1; ++index1)
      {
        for (int index2 = j - 2; index2 <= j; ++index2)
        {
          if (Main.tile[index1, index2].active())
            return;
        }
      }
      if (!WorldGen.SolidTile2(i, j + 1) || !WorldGen.SolidTile2(i + 1, j + 1))
        return;
      byte num = 0;
      if (dir == 1)
        num = (byte) 36;
      Main.tile[i, j - 2].active(true);
      Main.tile[i, j - 2].frameY = (short) 0;
      Main.tile[i, j - 2].frameX = (short) num;
      Main.tile[i, j - 2].type = (ushort) 269;
      Main.tile[i, j - 1].active(true);
      Main.tile[i, j - 1].frameY = (short) 18;
      Main.tile[i, j - 1].frameX = (short) num;
      Main.tile[i, j - 1].type = (ushort) 269;
      Main.tile[i, j].active(true);
      Main.tile[i, j].frameY = (short) 36;
      Main.tile[i, j].frameX = (short) num;
      Main.tile[i, j].type = (ushort) 269;
      Main.tile[i + 1, j - 2].active(true);
      Main.tile[i + 1, j - 2].frameY = (short) 0;
      Main.tile[i + 1, j - 2].frameX = (short) (byte) (18U + (uint) num);
      Main.tile[i + 1, j - 2].type = (ushort) 269;
      Main.tile[i + 1, j - 1].active(true);
      Main.tile[i + 1, j - 1].frameY = (short) 18;
      Main.tile[i + 1, j - 1].frameX = (short) (byte) (18U + (uint) num);
      Main.tile[i + 1, j - 1].type = (ushort) 269;
      Main.tile[i + 1, j].active(true);
      Main.tile[i + 1, j].frameY = (short) 36;
      Main.tile[i + 1, j].frameX = (short) (byte) (18U + (uint) num);
      Main.tile[i + 1, j].type = (ushort) 269;
    }

    public static void CheckWeaponsRack(int i, int j)
    {
      if (WorldGen.destroyObject)
        return;
      int num1 = i;
      int num2 = j - (int) Main.tile[i, j].frameY / 18;
      int num3 = (int) Main.tile[i, j].frameX;
      int num4 = 0;
      while (num3 >= 5000)
      {
        num3 -= 5000;
        ++num4;
      }
      if (num4 != 0)
        num3 = (num4 - 1) * 18;
      int num5 = num3 % 54;
      int num6 = num1 - num5 / 18;
      bool flag = false;
      for (int index1 = 0; index1 < 3; ++index1)
      {
        for (int index2 = 0; index2 < 3; ++index2)
        {
          int index3 = num6 + index1;
          int index4 = num2 + index2;
          int num7 = (int) Main.tile[index3, index4].frameX;
          int num8 = 0;
          while (num7 >= 5000)
          {
            num7 -= 5000;
            ++num8;
          }
          if (num8 != 0)
            num7 = (num8 - 1) * 18;
          int num9 = num7 % 54;
          if (!Main.tile[index3, index4].active() || Main.tile[index3, index4].type != (ushort) 334 || (Main.tile[index3, index4].wall <= (ushort) 0 || (int) Main.tile[index3, index4].frameY != index2 * 18) || num9 != index1 * 18)
            flag = true;
        }
      }
      if (!flag)
        return;
      WorldGen.destroyObject = true;
      Item.NewItem(i * 16, j * 16, 48, 48, 2699, 1, false, 0, false, false);
      for (int index1 = 0; index1 < 3; ++index1)
      {
        for (int index2 = 0; index2 < 3; ++index2)
        {
          int i1 = num6 + index1;
          int j1 = num2 + index2;
          if (Main.tile[i1, j1].active() && Main.tile[i1, j1].type == (ushort) 334)
            WorldGen.KillTile(i1, j1, false, false, false);
        }
      }
      WorldGen.destroyObject = false;
    }

    public static void ToggleGemLock(int i, int j, bool on)
    {
      Tile tileSafely = Framing.GetTileSafely(i, j);
      if (!tileSafely.active() || tileSafely.type != (ushort) 440 || tileSafely.frameY < (short) 54 && !on)
        return;
      bool flag = false;
      int Type = -1;
      if (tileSafely.frameY >= (short) 54)
        flag = true;
      int num1 = (int) Main.tile[i, j].frameX / 54;
      int num2 = (int) Main.tile[i, j].frameX % 54 / 18;
      int num3 = (int) Main.tile[i, j].frameY % 54 / 18;
      switch (num1)
      {
        case 0:
          Type = 1526;
          break;
        case 1:
          Type = 1524;
          break;
        case 2:
          Type = 1525;
          break;
        case 3:
          Type = 1523;
          break;
        case 4:
          Type = 1522;
          break;
        case 5:
          Type = 1527;
          break;
        case 6:
          Type = 3643;
          break;
      }
      for (int index1 = i - num2; index1 < i - num2 + 3; ++index1)
      {
        for (int index2 = j - num3; index2 < j - num3 + 3; ++index2)
          Main.tile[index1, index2].frameY = (short) ((on ? 54 : 0) + (index2 - j + num3) * 18);
      }
      if (Type != -1 & flag)
        Item.NewItem(i * 16, j * 16, 32, 32, Type, 1, false, 0, false, false);
      WorldGen.SquareTileFrame(i, j, true);
      NetMessage.SendTileSquare(-1, i - num2 + 1, j - num3 + 1, 3, TileChangeType.None);
      Wiring.HitSwitch(i - num2, j - num3);
      NetMessage.SendData(59, -1, -1, (NetworkText) null, i - num2, (float) (j - num3), 0.0f, 0.0f, 0, 0, 0);
    }

    public static void CheckMan(int i, int j)
    {
      if (WorldGen.destroyObject)
        return;
      int num1 = i;
      int num2 = j - (int) Main.tile[i, j].frameY / 18;
      int frameX1 = (int) Main.tile[i, j].frameX;
      while (frameX1 >= 100)
        frameX1 -= 100;
      while (frameX1 >= 36)
        frameX1 -= 36;
      int i1 = num1 - frameX1 / 18;
      bool flag = false;
      for (int index1 = 0; index1 <= 1; ++index1)
      {
        for (int index2 = 0; index2 <= 2; ++index2)
        {
          int index3 = i1 + index1;
          int index4 = num2 + index2;
          int frameX2 = (int) Main.tile[index3, index4].frameX;
          while (frameX2 >= 100)
            frameX2 -= 100;
          if (frameX2 >= 36)
            frameX2 -= 36;
          if (!Main.tile[index3, index4].active() || Main.tile[index3, index4].type != (ushort) 128 || ((int) Main.tile[index3, index4].frameY != index2 * 18 || frameX2 != index1 * 18))
            flag = true;
        }
      }
      if (!WorldGen.SolidTileAllowBottomSlope(i1, num2 + 3) || !WorldGen.SolidTileAllowBottomSlope(i1 + 1, num2 + 3))
        flag = true;
      if (!flag)
        return;
      WorldGen.destroyObject = true;
      Item.NewItem(i * 16, j * 16, 32, 32, 498, 1, false, 0, false, false);
      for (int index1 = 0; index1 <= 1; ++index1)
      {
        for (int index2 = 0; index2 <= 2; ++index2)
        {
          int i2 = i1 + index1;
          int j1 = num2 + index2;
          if (Main.tile[i2, j1].active() && Main.tile[i2, j1].type == (ushort) 128)
            WorldGen.KillTile(i2, j1, false, false, false);
        }
      }
      WorldGen.destroyObject = false;
    }

    public static void CheckWoman(int i, int j)
    {
      if (WorldGen.destroyObject)
        return;
      int num1 = i;
      int num2 = j - (int) Main.tile[i, j].frameY / 18;
      int frameX1 = (int) Main.tile[i, j].frameX;
      while (frameX1 >= 100)
        frameX1 -= 100;
      while (frameX1 >= 36)
        frameX1 -= 36;
      int i1 = num1 - frameX1 / 18;
      bool flag = false;
      for (int index1 = 0; index1 <= 1; ++index1)
      {
        for (int index2 = 0; index2 <= 2; ++index2)
        {
          int index3 = i1 + index1;
          int index4 = num2 + index2;
          int frameX2 = (int) Main.tile[index3, index4].frameX;
          while (frameX2 >= 100)
            frameX2 -= 100;
          if (frameX2 >= 36)
            frameX2 -= 36;
          if (!Main.tile[index3, index4].active() || Main.tile[index3, index4].type != (ushort) 269 || ((int) Main.tile[index3, index4].frameY != index2 * 18 || frameX2 != index1 * 18))
            flag = true;
        }
      }
      if (!WorldGen.SolidTileAllowBottomSlope(i1, num2 + 3) || !WorldGen.SolidTileAllowBottomSlope(i1 + 1, num2 + 3))
        flag = true;
      if (!flag)
        return;
      WorldGen.destroyObject = true;
      Item.NewItem(i * 16, j * 16, 32, 32, 1989, 1, false, 0, false, false);
      for (int index1 = 0; index1 <= 1; ++index1)
      {
        for (int index2 = 0; index2 <= 2; ++index2)
        {
          int i2 = i1 + index1;
          int j1 = num2 + index2;
          if (Main.tile[i2, j1].active() && Main.tile[i2, j1].type == (ushort) 269)
            WorldGen.KillTile(i2, j1, false, false, false);
        }
      }
      WorldGen.destroyObject = false;
    }

    public static void Place1x2(int x, int y, ushort type, int style)
    {
      short num1 = 0;
      if (type == (ushort) 20)
        num1 = (short) (WorldGen.genRand.Next(3) * 18);
      if (Main.tile[x, y - 1] == null)
        Main.tile[x, y - 1] = new Tile();
      if (Main.tile[x, y + 1] == null)
        Main.tile[x, y + 1] = new Tile();
      if (!(WorldGen.SolidTile2(x, y + 1) & !Main.tile[x, y - 1].active()))
        return;
      short num2 = (short) (style * 40);
      Main.tile[x, y - 1].active(true);
      Main.tile[x, y - 1].frameY = num2;
      Main.tile[x, y - 1].frameX = num1;
      Main.tile[x, y - 1].type = type;
      Main.tile[x, y].active(true);
      Main.tile[x, y].frameY = (short) ((int) num2 + 18);
      Main.tile[x, y].frameX = num1;
      Main.tile[x, y].type = type;
    }

    public static void Place1x2Top(int x, int y, ushort type, int style)
    {
      short num1 = 0;
      if (Main.tile[x, y - 1] == null)
        Main.tile[x, y - 1] = new Tile();
      if (Main.tile[x, y + 1] == null)
        Main.tile[x, y + 1] = new Tile();
      if (!Main.tile[x, y - 1].nactive() || !Main.tileSolid[(int) Main.tile[x, y - 1].type] || (Main.tileSolidTop[(int) Main.tile[x, y - 1].type] || Main.tile[x, y + 1].active()))
        return;
      short num2 = (short) (style * 36);
      Main.tile[x, y].active(true);
      Main.tile[x, y].frameY = num2;
      Main.tile[x, y].frameX = num1;
      Main.tile[x, y].type = type;
      Main.tile[x, y + 1].active(true);
      Main.tile[x, y + 1].frameY = (short) ((int) num2 + 18);
      Main.tile[x, y + 1].frameX = num1;
      Main.tile[x, y + 1].type = type;
    }

    public static void Check1x2Top(int x, int j, ushort type)
    {
      if (WorldGen.destroyObject)
        return;
      int index = j;
      bool flag = true;
      int num1 = (int) Main.tile[x, index].frameY / 18;
      int num2 = 0;
      while (num1 >= 2)
      {
        num1 -= 2;
        ++num2;
      }
      int j1 = index - num1;
      int num3 = num2 * 36;
      if (Main.tile[x, j1] == null)
        Main.tile[x, j1] = new Tile();
      if (Main.tile[x, j1 + 1] == null)
        Main.tile[x, j1 + 1] = new Tile();
      if (Main.tile[x, j1] == null)
        Main.tile[x, j1] = new Tile();
      if ((int) Main.tile[x, j1].frameY == num3 && (int) Main.tile[x, j1 + 1].frameY == num3 + 18 && ((int) Main.tile[x, j1].type == (int) type && (int) Main.tile[x, j1 + 1].type == (int) type))
        flag = false;
      if (Main.tile[x, j1 - 1] == null)
        Main.tile[x, j1 - 1] = new Tile();
      if (!Main.tile[x, j1 - 1].nactive() || !Main.tileSolid[(int) Main.tile[x, j1 - 1].type] || Main.tileSolidTop[(int) Main.tile[x, j1 - 1].type])
        flag = true;
      if (!flag)
        return;
      WorldGen.destroyObject = true;
      if ((int) Main.tile[x, j1].type == (int) type)
        WorldGen.KillTile(x, j1, false, false, false);
      if ((int) Main.tile[x, j1 + 1].type == (int) type)
        WorldGen.KillTile(x, j1 + 1, false, false, false);
      switch (type)
      {
        case 42:
          int Type = 0;
          switch (num2)
          {
            case 0:
              Type = 136;
              break;
            case 7:
              Type = 1431;
              break;
            case 8:
              Type = 1808;
              break;
            case 9:
              Type = 1859;
              break;
            default:
              if (num2 < 10)
              {
                Type = 1389 + num2;
                break;
              }
              switch (num2)
              {
                case 10:
                  Type = 2032;
                  break;
                case 11:
                  Type = 2033;
                  break;
                case 12:
                  Type = 2034;
                  break;
                case 13:
                  Type = 2035;
                  break;
                case 14:
                  Type = 2036;
                  break;
                case 15:
                  Type = 2037;
                  break;
                case 16:
                  Type = 2038;
                  break;
                case 17:
                  Type = 2039;
                  break;
                case 18:
                  Type = 2040;
                  break;
                case 19:
                  Type = 2041;
                  break;
                case 20:
                  Type = 2042;
                  break;
                case 21:
                  Type = 2043;
                  break;
                default:
                  if (num2 >= 22 && num2 <= 25)
                  {
                    Type = 2145 + num2 - 22;
                    break;
                  }
                  switch (num2)
                  {
                    case 26:
                      Type = 2226;
                      break;
                    case 27:
                      Type = 2530;
                      break;
                    case 28:
                      Type = 2546;
                      break;
                    case 29:
                      Type = 2564;
                      break;
                    case 30:
                      Type = 2579;
                      break;
                    case 31:
                      Type = 2641;
                      break;
                    case 32:
                      Type = 2642;
                      break;
                    case 33:
                      Type = 2820;
                      break;
                    case 34:
                      Type = 3138;
                      break;
                    case 35:
                      Type = 3140;
                      break;
                    case 36:
                      Type = 3139;
                      break;
                    case 37:
                      Type = 3891;
                      break;
                    case 38:
                      Type = 3943;
                      break;
                    case 39:
                      Type = 3970;
                      break;
                    case 40:
                      Type = 4157;
                      break;
                    case 41:
                      Type = 4178;
                      break;
                    case 42:
                      Type = 4199;
                      break;
                    case 43:
                      Type = 4220;
                      break;
                    case 44:
                      Type = 4309;
                      break;
                    case 45:
                      Type = 4578;
                      break;
                  }
                  break;
              }
              break;
          }
          Item.NewItem(x * 16, j1 * 16, 32, 32, Type, 1, false, 0, false, false);
          break;
        case 270:
          Item.NewItem(x * 16, j1 * 16, 32, 32, 1993, 1, false, 0, false, false);
          break;
        case 271:
          Item.NewItem(x * 16, j1 * 16, 32, 32, 2005, 1, false, 0, false, false);
          break;
        case 572:
          Item.NewItem(x * 16, j1 * 16, 32, 32, 4695 + num2, 1, false, 0, false, false);
          break;
        case 581:
          Item.NewItem(x * 16, j1 * 16, 32, 32, 4848, 1, false, 0, false, false);
          break;
      }
      WorldGen.destroyObject = false;
    }

    public static bool PlaceSmallPile(int i, int j, int X, int Y, ushort type = 185)
    {
      int i1 = i;
      int index = j;
      short num1 = (short) (Y * 18);
      short num2 = (short) (X * 18);
      if (Main.tile[i1, index] == null)
        Main.tile[i1, index] = new Tile();
      if (Main.tile[i1 + 1, index] == null)
        Main.tile[i1 + 1, index] = new Tile();
      if (Main.tile[i1, index + 1] == null)
        Main.tile[i1, index + 1] = new Tile();
      if (Main.tile[i1 + 1, index + 1] == null)
        Main.tile[i1 + 1, index + 1] = new Tile();
      if (Main.tile[i1, index].lava())
        return false;
      if (Y == 1)
      {
        short num3 = (short) (X * 36);
        bool flag = false;
        if (WorldGen.SolidTile2(i1, index + 1) && WorldGen.SolidTile2(i1 + 1, index + 1) && (!Main.tile[i1, index].active() && !Main.tile[i1 + 1, index].active()))
          flag = true;
        if (flag)
        {
          Main.tile[i1, index].active(true);
          Main.tile[i1, index].frameY = num1;
          Main.tile[i1, index].frameX = num3;
          Main.tile[i1, index].type = type;
          Main.tile[i1 + 1, index].active(true);
          Main.tile[i1 + 1, index].frameY = num1;
          Main.tile[i1 + 1, index].frameX = (short) ((int) num3 + 18);
          Main.tile[i1 + 1, index].type = type;
          return true;
        }
      }
      else if (WorldGen.SolidTile2(i1, index + 1) && !Main.tile[i1, index].active())
      {
        Main.tile[i1, index].active(true);
        Main.tile[i1, index].frameY = num1;
        Main.tile[i1, index].frameX = num2;
        Main.tile[i1, index].type = type;
        return true;
      }
      return false;
    }

    public static void CheckPile(int i, int y)
    {
      int i1 = i;
      if (Main.tile[i1, y] == null)
        Main.tile[i1, y] = new Tile();
      if (Main.tile[i1 + 1, y] == null)
        Main.tile[i1 + 1, y] = new Tile();
      if (Main.tile[i1, y + 1] == null)
        Main.tile[i1, y + 1] = new Tile();
      if (Main.tile[i1 + 1, y + 1] == null)
        Main.tile[i1 + 1, y + 1] = new Tile();
      if (Main.tile[i1, y].frameY == (short) 18)
      {
        WorldGen.Check2x1(i1, y, Main.tile[i1, y].type);
      }
      else
      {
        if (WorldGen.SolidTile(i1, y + 1, false))
          return;
        WorldGen.KillTile(i1, y, false, false, false);
      }
    }

    public static void Check2x1(int i, int y, ushort type)
    {
      if (WorldGen.destroyObject)
        return;
      int index = i;
      bool flag = true;
      if (Main.tile[index, y] == null)
        Main.tile[index, y] = new Tile();
      int num1 = (int) Main.tile[index, y].frameX / 18;
      int num2 = num1 >> 1;
      int num3 = num1 % 2;
      int i1 = index - num3;
      if (Main.tile[i1, y] == null)
        Main.tile[i1, y] = new Tile();
      if (Main.tile[i1 + 1, y] == null)
        Main.tile[i1 + 1, y] = new Tile();
      if (Main.tile[i1, y + 1] == null)
        Main.tile[i1, y + 1] = new Tile();
      if (Main.tile[i1 + 1, y + 1] == null)
        Main.tile[i1 + 1, y + 1] = new Tile();
      if ((int) Main.tile[i1 + 1, y].frameX == (int) Main.tile[i1, y].frameX + 18 && (int) Main.tile[i1, y].type == (int) type && (int) Main.tile[i1 + 1, y].type == (int) type)
        flag = false;
      if (type == (ushort) 29 || type == (ushort) 103 || type == (ushort) 462)
      {
        if (!Main.tile[i1, y + 1].active() || !Main.tileTable[(int) Main.tile[i1, y + 1].type] || (Main.tile[i1, y + 1].halfBrick() || Main.tile[i1, y + 1].topSlope()))
          flag = true;
        if (!Main.tile[i1 + 1, y + 1].active() || !Main.tileTable[(int) Main.tile[i1 + 1, y + 1].type] || (Main.tile[i1 + 1, y + 1].halfBrick() || Main.tile[i1 + 1, y + 1].topSlope()))
          flag = true;
      }
      else
      {
        if (!WorldGen.SolidTileAllowBottomSlope(i1, y + 1))
          flag = true;
        if (!WorldGen.SolidTileAllowBottomSlope(i1 + 1, y + 1))
          flag = true;
      }
      if (type == (ushort) 185 && Main.tile[i1, y].frameX >= (short) 1368 && (Main.tile[i1, y].frameX <= (short) 1458 && Main.tile[i1, y + 1].type != (ushort) 2) && (Main.tile[i1 + 1, y + 1].type != (ushort) 2 && Main.tile[i1, y + 1].type != (ushort) 477 && (Main.tile[i1 + 1, y + 1].type != (ushort) 477 && Main.tile[i1, y + 1].type != (ushort) 492)) && Main.tile[i1 + 1, y + 1].type != (ushort) 492)
      {
        Main.tile[i1, y].frameX -= (short) 1368;
        Main.tile[i1 + 1, y].frameX -= (short) 1368;
      }
      if (!flag)
        return;
      int frameX = (int) Main.tile[i1, y].frameX;
      if (!Main.tile[i1, y].active())
        frameX = (int) Main.tile[i1 + 1, y].frameX;
      WorldGen.destroyObject = true;
      if ((int) Main.tile[i1, y].type == (int) type)
        WorldGen.KillTile(i1, y, false, false, false);
      if ((int) Main.tile[i1 + 1, y].type == (int) type)
        WorldGen.KillTile(i1 + 1, y, false, false, false);
      if (type == (ushort) 16)
      {
        if (num2 == 1)
          Item.NewItem(i1 * 16, y * 16, 32, 32, 716, 1, false, 0, false, false);
        else
          Item.NewItem(i1 * 16, y * 16, 32, 32, 35, 1, false, 0, false, false);
      }
      if (type == (ushort) 18)
      {
        int Type = 36;
        if (num2 >= 1 && num2 <= 3)
          Type = 634 + num2;
        else if (num2 >= 4 && num2 <= 8)
        {
          Type = 807 + num2;
        }
        else
        {
          switch (num2)
          {
            case 9:
              Type = 916;
              break;
            case 10:
              Type = 1145;
              break;
            case 11:
              Type = 1398;
              break;
            case 12:
              Type = 1401;
              break;
            case 13:
              Type = 1404;
              break;
            case 14:
              Type = 1461;
              break;
            case 15:
              Type = 1511;
              break;
            case 16:
              Type = 1795;
              break;
            case 17:
              Type = 1817;
              break;
            case 18:
              Type = 2229;
              break;
            case 19:
              Type = 2251;
              break;
            case 20:
              Type = 2252;
              break;
            case 21:
              Type = 2253;
              break;
            case 22:
              Type = 2534;
              break;
            case 23:
              Type = 673;
              break;
            case 24:
              Type = 2631;
              break;
            case 25:
              Type = 2632;
              break;
            case 26:
              Type = 2633;
              break;
            case 27:
              Type = 2826;
              break;
            case 28:
              Type = 3156;
              break;
            case 29:
              Type = 3158;
              break;
            case 30:
              Type = 3157;
              break;
            case 31:
              Type = 3909;
              break;
            case 32:
              Type = 3910;
              break;
            case 33:
              Type = 3949;
              break;
            case 34:
              Type = 3975;
              break;
            case 35:
              Type = 4163;
              break;
            case 36:
              Type = 4184;
              break;
            case 37:
              Type = 4205;
              break;
            case 38:
              Type = 4226;
              break;
            case 39:
              Type = 4315;
              break;
            case 40:
              Type = 4584;
              break;
          }
        }
        Item.NewItem(i1 * 16, y * 16, 32, 32, Type, 1, false, 0, false, false);
      }
      if (type == (ushort) 185)
      {
        if (frameX >= 576 && frameX <= 610)
        {
          Item.NewItem(i1 * 16, y * 16, 32, 32, 71, WorldGen.genRand.Next(10, 100), false, 0, false, false);
          Item.NewItem(i1 * 16, y * 16, 32, 32, 71, WorldGen.genRand.Next(20, 100), false, 0, false, false);
          if (WorldGen.genRand.Next(3) != 0)
            Item.NewItem(i1 * 16, y * 16, 32, 32, 71, WorldGen.genRand.Next(10, 100), false, 0, false, false);
          if (WorldGen.genRand.Next(3) != 0)
            Item.NewItem(i1 * 16, y * 16, 32, 32, 71, WorldGen.genRand.Next(20, 100), false, 0, false, false);
          if (WorldGen.genRand.Next(2) == 0)
            Item.NewItem(i1 * 16, y * 16, 32, 32, 71, WorldGen.genRand.Next(10, 100), false, 0, false, false);
          if (WorldGen.genRand.Next(2) == 0)
            Item.NewItem(i1 * 16, y * 16, 32, 32, 71, WorldGen.genRand.Next(20, 100), false, 0, false, false);
          if (WorldGen.genRand.Next(3) == 0)
            Item.NewItem(i1 * 16, y * 16, 32, 32, 71, WorldGen.genRand.Next(10, 100), false, 0, false, false);
          if (WorldGen.genRand.Next(3) == 0)
            Item.NewItem(i1 * 16, y * 16, 32, 32, 71, WorldGen.genRand.Next(20, 100), false, 0, false, false);
          if (WorldGen.genRand.Next(4) == 0)
            Item.NewItem(i1 * 16, y * 16, 32, 32, 71, WorldGen.genRand.Next(10, 100), false, 0, false, false);
          if (WorldGen.genRand.Next(4) == 0)
            Item.NewItem(i1 * 16, y * 16, 32, 32, 71, WorldGen.genRand.Next(20, 100), false, 0, false, false);
          if (WorldGen.genRand.Next(5) == 0)
            Item.NewItem(i1 * 16, y * 16, 32, 32, 71, WorldGen.genRand.Next(10, 100), false, 0, false, false);
          if (WorldGen.genRand.Next(5) == 0)
            Item.NewItem(i1 * 16, y * 16, 32, 32, 71, WorldGen.genRand.Next(20, 100), false, 0, false, false);
        }
        if (frameX >= 612 && frameX <= 646)
        {
          Item.NewItem(i1 * 16, y * 16, 32, 32, 72, WorldGen.genRand.Next(10, 100), false, 0, false, false);
          if (WorldGen.genRand.Next(2) == 0)
            Item.NewItem(i1 * 16, y * 16, 32, 32, 72, WorldGen.genRand.Next(20, 100), false, 0, false, false);
          if (WorldGen.genRand.Next(3) == 0)
            Item.NewItem(i1 * 16, y * 16, 32, 32, 72, WorldGen.genRand.Next(30, 100), false, 0, false, false);
        }
        if (frameX >= 648 && frameX <= 682)
        {
          Item.NewItem(i1 * 16, y * 16, 32, 32, 73, WorldGen.genRand.Next(1, 6), false, 0, false, false);
          if (WorldGen.genRand.Next(2) == 0)
            Item.NewItem(i1 * 16, y * 16, 32, 32, 73, WorldGen.genRand.Next(2, 6), false, 0, false, false);
          if (WorldGen.genRand.Next(3) == 0)
            Item.NewItem(i1 * 16, y * 16, 32, 32, 73, WorldGen.genRand.Next(3, 6), false, 0, false, false);
        }
        if (frameX >= 684 && frameX <= 718)
          Item.NewItem(i1 * 16, y * 16, 32, 32, 181, WorldGen.genRand.Next(1, 4), false, 0, false, false);
        if (frameX >= 720 && frameX <= 754)
          Item.NewItem(i1 * 16, y * 16, 32, 32, 180, WorldGen.genRand.Next(1, 4), false, 0, false, false);
        if (frameX >= 756 && frameX <= 790)
          Item.NewItem(i1 * 16, y * 16, 32, 32, 177, WorldGen.genRand.Next(1, 4), false, 0, false, false);
        if (frameX >= 792 && frameX <= 826)
          Item.NewItem(i1 * 16, y * 16, 32, 32, 179, WorldGen.genRand.Next(1, 4), false, 0, false, false);
        if (frameX >= 828 && frameX <= 862)
          Item.NewItem(i1 * 16, y * 16, 32, 32, 178, WorldGen.genRand.Next(1, 4), false, 0, false, false);
        if (frameX >= 864 && frameX <= 898)
          Item.NewItem(i1 * 16, y * 16, 32, 32, 182, WorldGen.genRand.Next(1, 4), false, 0, false, false);
      }
      if (type == (ushort) 462)
        Item.NewItem(i1 * 16, y * 16, 32, 32, 3795, 1, false, 0, false, false);
      if (type == (ushort) 29)
      {
        Item.NewItem(i1 * 16, y * 16, 32, 32, 87, 1, false, 0, false, false);
        SoundEngine.PlaySound(13, i * 16, y * 16, 1, 1f, 0.0f);
      }
      if (type == (ushort) 103)
      {
        int Type = 356;
        if (num2 == 1)
          Type = 2235;
        if (num2 == 2)
          Type = 2242;
        if (num2 == 3)
          Type = 2243;
        Item.NewItem(i1 * 16, y * 16, 32, 32, Type, 1, false, 0, false, false);
        SoundEngine.PlaySound(13, i * 16, y * 16, 1, 1f, 0.0f);
      }
      else if (type == (ushort) 134)
      {
        if (num2 == 1)
          Item.NewItem(i1 * 16, y * 16, 32, 32, 1220, 1, false, 0, false, false);
        else
          Item.NewItem(i1 * 16, y * 16, 32, 32, 525, 1, false, 0, false, false);
      }
      WorldGen.destroyObject = false;
      WorldGen.SquareTileFrame(i1, y, true);
      WorldGen.SquareTileFrame(i1 + 1, y, true);
    }

    public static void Place2x1(int x, int y, ushort type, int style = 0)
    {
      if (Main.tile[x, y] == null)
        Main.tile[x, y] = new Tile();
      if (Main.tile[x + 1, y] == null)
        Main.tile[x + 1, y] = new Tile();
      if (Main.tile[x, y + 1] == null)
        Main.tile[x, y + 1] = new Tile();
      if (Main.tile[x + 1, y + 1] == null)
        Main.tile[x + 1, y + 1] = new Tile();
      bool flag = false;
      if (type != (ushort) 29 && type != (ushort) 103 && (WorldGen.SolidTile2(x, y + 1) && WorldGen.SolidTile2(x + 1, y + 1)) && (!Main.tile[x, y].active() && !Main.tile[x + 1, y].active()))
        flag = true;
      else if ((type == (ushort) 29 || type == (ushort) 103) && (Main.tile[x, y + 1].active() && Main.tile[x + 1, y + 1].active()) && (Main.tileTable[(int) Main.tile[x, y + 1].type] && Main.tileTable[(int) Main.tile[x + 1, y + 1].type] && (!Main.tile[x, y].active() && !Main.tile[x + 1, y].active())))
        flag = true;
      if (!flag)
        return;
      Main.tile[x, y].active(true);
      Main.tile[x, y].frameY = (short) 0;
      Main.tile[x, y].frameX = (short) (36 * style);
      Main.tile[x, y].type = type;
      Main.tile[x + 1, y].active(true);
      Main.tile[x + 1, y].frameY = (short) 0;
      Main.tile[x + 1, y].frameX = (short) (36 * style + 18);
      Main.tile[x + 1, y].type = type;
    }

    public static void Check4x2(int i, int j, int type)
    {
      if (WorldGen.destroyObject)
        return;
      bool flag = false;
      int num1 = i;
      int num2 = type != 487 ? num1 + (int) Main.tile[i, j].frameX / 18 * -1 : num1 + (int) Main.tile[i, j].frameX / 18 % 4 * -1;
      if ((type == 79 || type == 90) && Main.tile[i, j].frameX >= (short) 72)
        num2 += 4;
      int num3 = (int) Main.tile[i, j].frameY / 18;
      int style = 0;
      while (num3 > 1)
      {
        num3 -= 2;
        ++style;
      }
      int num4 = j - num3;
      if (type == 487)
        style = (int) Main.tile[i, j].frameX / 72;
      for (int i1 = num2; i1 < num2 + 4; ++i1)
      {
        for (int index = num4; index < num4 + 2; ++index)
        {
          int num5 = (i1 - num2) * 18;
          int num6 = (index - num4) * 18;
          if ((type == 79 || type == 90) && Main.tile[i, j].frameX >= (short) 72)
            num5 = (i1 - num2 + 4) * 18;
          if (type == 487)
            num5 += style * 72;
          else
            num6 += style * 36;
          if (Main.tile[i1, index] == null)
            Main.tile[i1, index] = new Tile();
          if (!Main.tile[i1, index].active() || (int) Main.tile[i1, index].type != type || ((int) Main.tile[i1, index].frameX != num5 || (int) Main.tile[i1, index].frameY != num6))
            flag = true;
        }
        if (Main.tile[i1, num4 + 2] == null)
          Main.tile[i1, num4 + 2] = new Tile();
        if (!WorldGen.SolidTileAllowBottomSlope(i1, num4 + 2) && (!Main.tile[i1, num4 + 2].active() || !TileID.Sets.Platforms[(int) Main.tile[i1, num4 + 2].type]))
          flag = true;
      }
      if (!flag)
        return;
      WorldGen.destroyObject = true;
      for (int i1 = num2; i1 < num2 + 4; ++i1)
      {
        for (int j1 = num4; j1 < num4 + 3; ++j1)
        {
          if ((int) Main.tile[i1, j1].type == type && Main.tile[i1, j1].active())
            WorldGen.KillTile(i1, j1, false, false, false);
        }
      }
      if (type == 79)
      {
        int Type = style != 0 ? (style != 4 ? (style < 9 || style > 12 ? (style < 5 || style > 8 ? (style < 13 || style > 18 ? (style != 19 ? (style != 20 ? (style != 21 ? (style != 22 ? (style != 23 ? (style != 24 ? (style != 25 ? (style != 26 ? (style != 27 ? (style != 28 ? (style != 29 ? (style != 30 ? (style != 31 ? (style != 32 ? (style != 33 ? (style != 34 ? (style != 35 ? (style != 36 ? (style != 37 ? (style != 38 ? (style != 39 ? style + 643 : 4567) : 4299) : 4209) : 4188) : 4167) : 4146) : 3959) : 3932) : 3897) : 3163) : 3164) : 3162) : 2811) : 2669) : 2568) : 2553) : 2538) : 2520) : 2231) : 2140) : 2139) : 2066 + style - 13) : 1465 + style) : 1710 + style) : 920) : 224;
        Item.NewItem(i * 16, j * 16, 32, 32, Type, 1, false, 0, false, false);
      }
      if (type == 487)
        Item.NewItem(i * 16, j * 16, 32, 32, WorldGen.GetItemDrop_PicnicTables(style), 1, false, 0, false, false);
      if (type == 90)
      {
        int Type = 0;
        if (style == 0)
          Type = 336;
        else if (style >= 1 && style <= 10)
          Type = 2072 + style - 1;
        else if (style >= 11 && style <= 15)
        {
          Type = 2124 + style - 11;
        }
        else
        {
          switch (style)
          {
            case 16:
              Type = 2232;
              break;
            case 17:
              Type = 2519;
              break;
            case 18:
              Type = 2537;
              break;
            case 19:
              Type = 2552;
              break;
            case 20:
              Type = 2567;
              break;
            case 21:
              Type = 2658;
              break;
            case 22:
              Type = 2659;
              break;
            case 23:
              Type = 2660;
              break;
            case 24:
              Type = 2661;
              break;
            case 25:
              Type = 2662;
              break;
            case 26:
              Type = 2663;
              break;
            case 27:
              Type = 2810;
              break;
            case 28:
              Type = 3159;
              break;
            case 29:
              Type = 3161;
              break;
            case 30:
              Type = 3160;
              break;
            case 31:
              Type = 3895;
              break;
            case 32:
              Type = 3931;
              break;
            case 33:
              Type = 3958;
              break;
            case 34:
              Type = 4145;
              break;
            case 35:
              Type = 4166;
              break;
            case 36:
              Type = 4187;
              break;
            case 37:
              Type = 4208;
              break;
            case 38:
              Type = 4298;
              break;
            case 39:
              Type = 4566;
              break;
          }
        }
        Item.NewItem(i * 16, j * 16, 32, 32, Type, 1, false, 0, false, false);
      }
      WorldGen.destroyObject = false;
      for (int i1 = num2 - 1; i1 < num2 + 4; ++i1)
      {
        for (int j1 = num4 - 1; j1 < num4 + 4; ++j1)
          WorldGen.TileFrame(i1, j1, false, false);
      }
    }

    private static bool OasisPlantWaterCheck(int x, int y, bool boost = false)
    {
      int num1 = 45;
      int num2 = 20;
      if (boost)
      {
        num1 += 4;
        num2 += 3;
      }
      int num3 = 20;
      int num4 = 0;
      for (int index1 = x - num1; index1 <= x + num1; ++index1)
      {
        if (x > WorldGen.beachDistance && x < Main.maxTilesX - WorldGen.beachDistance)
        {
          for (int index2 = y - num2; index2 <= y + num2; ++index2)
          {
            if (WorldGen.InWorld(index1, index2, 0) && !WorldGen.SolidTile(index1, index2, false))
              num4 += (int) Main.tile[index1, index2].liquid;
          }
        }
      }
      return num4 / (int) byte.MaxValue >= num3;
    }

    public static void PlaceOasisPlant(int X, int Y, ushort type = 530)
    {
      int num1 = WorldGen.genRand.Next(9);
      int num2 = 0;
      int x = X;
      int y = Y;
      if (x < WorldGen.beachDistance || x > Main.maxTilesX - WorldGen.beachDistance || (y < 5 || y > Main.maxTilesY - 5))
        return;
      bool flag = true;
      for (int i = x - 1; i < x + 2; ++i)
      {
        for (int index = y - 1; index < y + 1; ++index)
        {
          if (Main.tile[i, index] == null)
            Main.tile[i, index] = new Tile();
          if (Main.tile[i, index].active() && Main.tile[i, index].type != (ushort) 529)
            flag = false;
          if (Main.tile[i, index].liquid > (byte) 0)
            flag = false;
        }
        if (Main.tile[i, y + 1] == null)
          Main.tile[i, y + 1] = new Tile();
        if (!WorldGen.SolidTile(i, y + 1, false) || !TileID.Sets.Conversion.Sand[(int) Main.tile[i, y + 1].type])
          flag = false;
      }
      if (!flag || !WorldGen.OasisPlantWaterCheck(x, y, false))
        return;
      short num3 = (short) (54 * num1);
      short num4 = (short) (36 * num2);
      Main.tile[x - 1, y - 1].active(true);
      Main.tile[x - 1, y - 1].frameY = num4;
      Main.tile[x - 1, y - 1].frameX = num3;
      Main.tile[x - 1, y - 1].type = type;
      Main.tile[x, y - 1].active(true);
      Main.tile[x, y - 1].frameY = num4;
      Main.tile[x, y - 1].frameX = (short) ((int) num3 + 18);
      Main.tile[x, y - 1].type = type;
      Main.tile[x + 1, y - 1].active(true);
      Main.tile[x + 1, y - 1].frameY = num4;
      Main.tile[x + 1, y - 1].frameX = (short) ((int) num3 + 36);
      Main.tile[x + 1, y - 1].type = type;
      Main.tile[x - 1, y].active(true);
      Main.tile[x - 1, y].frameY = (short) ((int) num4 + 18);
      Main.tile[x - 1, y].frameX = num3;
      Main.tile[x - 1, y].type = type;
      Main.tile[x, y].active(true);
      Main.tile[x, y].frameY = (short) ((int) num4 + 18);
      Main.tile[x, y].frameX = (short) ((int) num3 + 18);
      Main.tile[x, y].type = type;
      Main.tile[x + 1, y].active(true);
      Main.tile[x + 1, y].frameY = (short) ((int) num4 + 18);
      Main.tile[x + 1, y].frameX = (short) ((int) num3 + 36);
      Main.tile[x + 1, y].type = type;
    }

    public static void CheckOasisPlant(int i, int j, int type = 530)
    {
      if (WorldGen.destroyObject)
        return;
      bool flag = false;
      int num1 = j;
      Tile tileSafely = Framing.GetTileSafely(i, j);
      int num2 = (int) tileSafely.frameY % 36;
      int j1 = num1 + num2 / 18 * -1;
      int i1 = (int) tileSafely.frameX / 18;
      int num3 = 0;
      int num4 = (int) Framing.GetTileSafely(i1, j1).frameY / 36;
      while (i1 > 2)
      {
        i1 -= 3;
        ++num3;
      }
      int num5 = i - i1;
      int num6 = num3 * 54;
      for (int i2 = num5; i2 < num5 + 3; ++i2)
      {
        for (int index = j1; index < j1 + 2; ++index)
        {
          if (Main.tile[i2, index] == null)
            Main.tile[i2, index] = new Tile();
          if (!Main.tile[i2, index].active() || (int) Main.tile[i2, index].type != type || ((int) Main.tile[i2, index].frameX != (i2 - num5) * 18 + num6 || (int) Main.tile[i2, index].frameY != (index - j1) * 18))
            flag = true;
        }
        if (Main.tile[i2, j1 + 2] == null)
          Main.tile[i2, j1 + 2] = new Tile();
        if (!WorldGen.SolidTile(i2, j1 + 2, false) || !TileID.Sets.Conversion.Sand[(int) Main.tile[i2, j1 + 2].type])
          flag = true;
      }
      if (!flag)
        return;
      int frameX = (int) Main.tile[i, j].frameX;
      WorldGen.destroyObject = true;
      for (int i2 = num5; i2 < num5 + 3; ++i2)
      {
        for (int j2 = j1; j2 < j1 + 2; ++j2)
        {
          if (Main.tile[i2, j2] == null)
            Main.tile[i2, j2] = new Tile();
          if ((int) Main.tile[i2, j2].type == type && Main.tile[i2, j2].active())
            WorldGen.KillTile(i2, j2, false, false, false);
        }
      }
      WorldGen.destroyObject = false;
      for (int i2 = num5 - 1; i2 < num5 + 4; ++i2)
      {
        for (int j2 = j1 - 1; j2 < j1 + 3; ++j2)
          WorldGen.TileFrame(i2, j2, false, false);
      }
    }

    public static void GetBiomeInfluence(
      int startX,
      int endX,
      int startY,
      int endY,
      out int corruptCount,
      out int crimsonCount,
      out int hallowedCount)
    {
      corruptCount = 0;
      crimsonCount = 0;
      hallowedCount = 0;
      for (int index1 = startX; index1 <= endX; ++index1)
      {
        for (int index2 = startY; index2 <= endY; ++index2)
        {
          Tile tile = Main.tile[index1, index2];
          if (tile != null)
          {
            if (TileID.Sets.Corrupt[(int) tile.type])
              ++corruptCount;
            if (TileID.Sets.Crimson[(int) tile.type])
              ++crimsonCount;
            if (TileID.Sets.Hallow[(int) tile.type])
              ++hallowedCount;
          }
        }
      }
    }

    public static void PlaceJunglePlant(int X2, int Y2, ushort type, int styleX, int styleY)
    {
      if (styleY > 0 || type == (ushort) 236 || type == (ushort) 238)
      {
        int index1 = Y2;
        int index2 = X2;
        if (type == (ushort) 95 || type == (ushort) 126)
          ++index1;
        if (X2 < 5 || X2 > Main.maxTilesX - 5 || (index1 < 5 || index1 > Main.maxTilesY - 5))
          return;
        bool flag = true;
        for (int i = index2 - 1; i < index2 + 1; ++i)
        {
          for (int index3 = index1 - 1; index3 < index1 + 1; ++index3)
          {
            if (Main.tile[i, index3] == null)
              Main.tile[i, index3] = new Tile();
            if (Main.tile[i, index3].active() && Main.tile[i, index3].type != (ushort) 61 && (Main.tile[i, index3].type != (ushort) 62 && Main.tile[i, index3].type != (ushort) 69) && (Main.tile[i, index3].type != (ushort) 74 && (type != (ushort) 236 || Main.tile[i, index3].type != (ushort) 233)) && ((type != (ushort) 238 || Main.tile[i, index3].type != (ushort) 233) && (Main.tile[i, index3].type != (ushort) 185 || Main.tile[i, index3].frameY != (short) 0)))
              flag = false;
            if (type == (ushort) 98 && Main.tile[i, index3].liquid > (byte) 0)
              flag = false;
          }
          if (Main.tile[i, index1 + 1] == null)
            Main.tile[i, index1 + 1] = new Tile();
          if (!WorldGen.SolidTile(i, index1 + 1, false) || Main.tile[i, index1 + 1].type != (ushort) 60)
            flag = false;
        }
        if (!flag)
          return;
        short num1 = 36;
        if (type == (ushort) 236 || type == (ushort) 238)
          num1 = (short) 0;
        short num2 = (short) (36 * styleX);
        Main.tile[index2 - 1, index1 - 1].active(true);
        Main.tile[index2 - 1, index1 - 1].frameY = num1;
        Main.tile[index2 - 1, index1 - 1].frameX = num2;
        Main.tile[index2 - 1, index1 - 1].type = type;
        Main.tile[index2, index1 - 1].active(true);
        Main.tile[index2, index1 - 1].frameY = num1;
        Main.tile[index2, index1 - 1].frameX = (short) (18 + (int) num2);
        Main.tile[index2, index1 - 1].type = type;
        Main.tile[index2 - 1, index1].active(true);
        Main.tile[index2 - 1, index1].frameY = (short) ((int) num1 + 18);
        Main.tile[index2 - 1, index1].frameX = num2;
        Main.tile[index2 - 1, index1].type = type;
        Main.tile[index2, index1].active(true);
        Main.tile[index2, index1].frameY = (short) ((int) num1 + 18);
        Main.tile[index2, index1].frameX = (short) (18 + (int) num2);
        Main.tile[index2, index1].type = type;
      }
      else
      {
        int num1 = styleX;
        int index1 = X2;
        int index2 = Y2;
        if (index1 < 5 || index1 > Main.maxTilesX - 5 || (index2 < 5 || index2 > Main.maxTilesY - 5))
          return;
        bool flag = true;
        for (int i = index1 - 1; i < index1 + 2; ++i)
        {
          for (int index3 = index2 - 1; index3 < index2 + 1; ++index3)
          {
            if (Main.tile[i, index3] == null)
              Main.tile[i, index3] = new Tile();
            if (Main.tile[i, index3].active() && Main.tile[i, index3].type != (ushort) 61 && (Main.tile[i, index3].type != (ushort) 62 && Main.tile[i, index3].type != (ushort) 69) && (Main.tile[i, index3].type != (ushort) 74 && (Main.tile[i, index3].type != (ushort) 185 || Main.tile[i, index3].frameY != (short) 0)))
              flag = false;
          }
          if (Main.tile[i, index2 + 1] == null)
            Main.tile[i, index2 + 1] = new Tile();
          if (!WorldGen.SolidTile(i, index2 + 1, false) || Main.tile[i, index2 + 1].type != (ushort) 60)
            flag = false;
        }
        if (!flag)
          return;
        short num2 = (short) (54 * num1);
        Main.tile[index1 - 1, index2 - 1].active(true);
        Main.tile[index1 - 1, index2 - 1].frameY = (short) 0;
        Main.tile[index1 - 1, index2 - 1].frameX = num2;
        Main.tile[index1 - 1, index2 - 1].type = type;
        Main.tile[index1, index2 - 1].active(true);
        Main.tile[index1, index2 - 1].frameY = (short) 0;
        Main.tile[index1, index2 - 1].frameX = (short) ((int) num2 + 18);
        Main.tile[index1, index2 - 1].type = type;
        Main.tile[index1 + 1, index2 - 1].active(true);
        Main.tile[index1 + 1, index2 - 1].frameY = (short) 0;
        Main.tile[index1 + 1, index2 - 1].frameX = (short) ((int) num2 + 36);
        Main.tile[index1 + 1, index2 - 1].type = type;
        Main.tile[index1 - 1, index2].active(true);
        Main.tile[index1 - 1, index2].frameY = (short) 18;
        Main.tile[index1 - 1, index2].frameX = num2;
        Main.tile[index1 - 1, index2].type = type;
        Main.tile[index1, index2].active(true);
        Main.tile[index1, index2].frameY = (short) 18;
        Main.tile[index1, index2].frameX = (short) ((int) num2 + 18);
        Main.tile[index1, index2].type = type;
        Main.tile[index1 + 1, index2].active(true);
        Main.tile[index1 + 1, index2].frameY = (short) 18;
        Main.tile[index1 + 1, index2].frameX = (short) ((int) num2 + 36);
        Main.tile[index1 + 1, index2].type = type;
      }
    }

    public static void CheckJunglePlant(int i, int j, int type)
    {
      if (WorldGen.destroyObject)
        return;
      if (Main.tile[i, j].frameY >= (short) 36 || Main.tile[i, j].type == (ushort) 236 || Main.tile[i, j].type == (ushort) 238)
      {
        bool flag = false;
        int num1 = (int) Main.tile[i, j].frameX / 18;
        int num2 = 0;
        while (num1 > 1)
        {
          num1 -= 2;
          ++num2;
        }
        int num3 = i - num1;
        int num4 = 36;
        if (type == 236 || type == 238)
          num4 = 0;
        int num5 = (int) Main.tile[i, j].frameY / 18;
        while (num5 > 1)
          num5 -= 2;
        int num6 = j - num5;
        int num7 = num2 * 36;
        for (int i1 = num3; i1 < num3 + 2; ++i1)
        {
          for (int index = num6; index < num6 + 2; ++index)
          {
            if (Main.tile[i1, index] == null)
              Main.tile[i1, index] = new Tile();
            if (!Main.tile[i1, index].active() || (int) Main.tile[i1, index].type != type || ((int) Main.tile[i1, index].frameX != (i1 - num3) * 18 + num7 || (int) Main.tile[i1, index].frameY != (index - num6) * 18 + num4))
              flag = true;
          }
          if (Main.tile[i1, num6 + 2] == null)
            Main.tile[i1, num6 + 2] = new Tile();
          if (!WorldGen.SolidTile(i1, num6 + 2, false) || Main.tile[i1, num6 + 2].type != (ushort) 60)
            flag = true;
        }
        if (!flag)
          return;
        if (type == 238)
        {
          float num8 = (float) (i * 16);
          float num9 = (float) (j * 16);
          float num10 = -1f;
          int plr = 0;
          for (int index = 0; index < (int) byte.MaxValue; ++index)
          {
            float num11 = Math.Abs(Main.player[index].position.X - num8) + Math.Abs(Main.player[index].position.Y - num9);
            if ((double) num11 < (double) num10 || (double) num10 == -1.0)
            {
              plr = index;
              num10 = num11;
            }
          }
          if ((double) num10 / 16.0 < 50.0)
            NPC.SpawnOnPlayer(plr, 262);
        }
        if (type == 236)
          Item.NewItem(i * 16, j * 16, 32, 32, 1291, 1, false, 0, false, false);
        int frameX = (int) Main.tile[i, j].frameX;
        WorldGen.destroyObject = true;
        for (int i1 = num3; i1 < num3 + 2; ++i1)
        {
          for (int j1 = num6; j1 < num6 + 2; ++j1)
          {
            if (Main.tile[i1, j1] == null)
              Main.tile[i1, j1] = new Tile();
            if ((int) Main.tile[i1, j1].type == type && Main.tile[i1, j1].active())
              WorldGen.KillTile(i1, j1, false, false, false);
          }
        }
        WorldGen.destroyObject = false;
      }
      else
      {
        bool flag = false;
        int num1 = j + (int) Main.tile[i, j].frameY / 18 * -1;
        int num2 = (int) Main.tile[i, j].frameX / 18;
        int num3 = 0;
        while (num2 > 2)
        {
          num2 -= 3;
          ++num3;
        }
        int num4 = i - num2;
        int num5 = num3 * 54;
        for (int i1 = num4; i1 < num4 + 3; ++i1)
        {
          for (int index = num1; index < num1 + 2; ++index)
          {
            if (Main.tile[i1, index] == null)
              Main.tile[i1, index] = new Tile();
            if (!Main.tile[i1, index].active() || (int) Main.tile[i1, index].type != type || ((int) Main.tile[i1, index].frameX != (i1 - num4) * 18 + num5 || (int) Main.tile[i1, index].frameY != (index - num1) * 18))
              flag = true;
          }
          if (Main.tile[i1, num1 + 2] == null)
            Main.tile[i1, num1 + 2] = new Tile();
          if (!WorldGen.SolidTile(i1, num1 + 2, false) || Main.tile[i1, num1 + 2].type != (ushort) 60)
            flag = true;
        }
        if (!flag)
          return;
        int frameX = (int) Main.tile[i, j].frameX;
        WorldGen.destroyObject = true;
        for (int i1 = num4; i1 < num4 + 3; ++i1)
        {
          for (int j1 = num1; j1 < num1 + 3; ++j1)
          {
            if (Main.tile[i1, j1] == null)
              Main.tile[i1, j1] = new Tile();
            if ((int) Main.tile[i1, j1].type == type && Main.tile[i1, j1].active())
              WorldGen.KillTile(i1, j1, false, false, false);
          }
        }
        WorldGen.destroyObject = false;
      }
    }

    public static void CheckSuper(int x, int y, int type)
    {
      if (WorldGen.destroyObject)
        return;
      Tile tile = Main.tile[x, y];
      int style = 0;
      if (type == 376)
        style = (int) tile.frameX / 36;
      if (type == 443)
        style = (int) tile.frameX / 36;
      if (type == 485)
        style = (int) tile.frameX / 36;
      bool flag1 = type == 376;
      bool flag2 = type == 443;
      bool flag3 = type == 444;
      bool flag4 = type == 485;
      TileObjectData tileData = TileObjectData.GetTileData(type, style, 0);
      int num1 = tileData.StyleHorizontal ? 1 : 0;
      int width = tileData.Width;
      int height = tileData.Height;
      int num2 = x;
      int num3 = y;
      int num4 = num2 - (int) tile.frameX / 18 % width;
      int j = num3 - (int) tile.frameY / 18 % height;
      int num5 = 0;
      int num6 = 0;
      if (num1 != 0)
        num5 = (int) tile.frameX / tileData.CoordinateFullWidth;
      else
        num6 = (int) tile.frameY / tileData.CoordinateFullHeight;
      bool flag5 = false;
      bool flag6 = false;
      for (int index1 = 0; index1 < width; ++index1)
      {
        for (int index2 = 0; index2 < height; ++index2)
        {
          Tile tileSafely = Framing.GetTileSafely(num4 + index1, j + index2);
          if (!tileSafely.active() || (int) tileSafely.type != type || ((int) tileSafely.frameX != num5 * tileData.CoordinateFullWidth + index1 * (tileData.CoordinateWidth + 2) || (int) tileSafely.frameY != num6 * tileData.CoordinateFullHeight + index2 * (tileData.CoordinateHeights[0] + 2)))
            flag5 = true;
        }
      }
      if (flag1)
      {
        for (int index = 0; index < width; ++index)
        {
          Tile tileSafely = Framing.GetTileSafely(num4 + index, j + height);
          if (!tileSafely.active() || !Main.tileSolid[(int) tileSafely.type] && !Main.tileTable[(int) tileSafely.type])
            flag5 = true;
          if (tileSafely.halfBrick())
            flag5 = true;
        }
      }
      if (flag2)
      {
        bool flag7 = true;
        bool flag8 = true;
        for (int index = 0; index < width; ++index)
        {
          if (!WorldGen.AnchorValid(Framing.GetTileSafely(num4 + index, j + height), AnchorType.SolidTile | AnchorType.SolidWithTop | AnchorType.SolidSide))
            flag8 = false;
          if (!WorldGen.AnchorValid(Framing.GetTileSafely(num4 + index, j - 1), AnchorType.SolidBottom))
            flag7 = false;
        }
        if (!flag7 && !flag8)
          flag5 = true;
        if (!flag5)
        {
          int num7 = 0;
          if (flag8)
          {
            for (int index = 0; index < width; ++index)
              Framing.GetTileSafely(num4 + index, j).frameX = (short) (index * 18 + style / 2 * 36 + num7 * 36);
          }
          else
          {
            for (int index = 0; index < width; ++index)
              Framing.GetTileSafely(num4 + index, j).frameX = (short) (index * 18 + (style - 2) / 2 * 36 + 72 + num7 * 36);
          }
        }
      }
      if (flag3)
      {
        bool flag7 = true;
        for (int index = 0; index < width; ++index)
        {
          if (!WorldGen.AnchorValid(Framing.GetTileSafely(num4 + index, j - 1), AnchorType.SolidTile))
            flag7 = false;
        }
        if (!flag7)
          flag5 = true;
        for (int index1 = 0; index1 < width; ++index1)
        {
          for (int index2 = 0; index2 < height; ++index2)
          {
            if (Framing.GetTileSafely(num4 + index1, j + index2).liquid > (byte) 0)
            {
              flag5 = true;
              flag6 = true;
            }
          }
        }
      }
      if (flag4)
      {
        bool flag7 = true;
        for (int index = 0; index < width; ++index)
        {
          if (!WorldGen.AnchorValid(Framing.GetTileSafely(num4 + index, j + height), AnchorType.SolidTile))
            flag7 = false;
        }
        if (!flag7)
          flag5 = true;
      }
      if (!flag5)
        return;
      WorldGen.destroyObject = true;
      for (int index1 = 0; index1 < width; ++index1)
      {
        for (int index2 = 0; index2 < height; ++index2)
        {
          if ((int) Main.tile[num4 + index1, j + index2].type == type && Main.tile[num4 + index1, j + index2].active())
            WorldGen.KillTile(num4 + index1, j + index2, false, false, false);
        }
      }
      int Type = 0;
      if (type == 376)
      {
        switch (style)
        {
          case 0:
            Type = 2334;
            break;
          case 1:
            Type = 2335;
            break;
          case 2:
            Type = 2336;
            break;
          case 3:
            Type = 3203;
            break;
          case 4:
            Type = 3204;
            break;
          case 5:
            Type = 3205;
            break;
          case 6:
            Type = 3206;
            break;
          case 7:
            Type = 3207;
            break;
          case 8:
            Type = 3208;
            break;
          case 9:
            Type = 3979;
            break;
          case 10:
            Type = 3980;
            break;
          case 11:
            Type = 3981;
            break;
          case 12:
            Type = 3982;
            break;
          case 13:
            Type = 3983;
            break;
          case 14:
            Type = 3984;
            break;
          case 15:
            Type = 3985;
            break;
          case 16:
            Type = 3986;
            break;
          case 17:
            Type = 3987;
            break;
          case 18:
            Type = 4405;
            break;
          case 19:
            Type = 4406;
            break;
          case 20:
            Type = 4407;
            break;
          case 21:
            Type = 4408;
            break;
          case 22:
            Type = 4877;
            break;
          case 23:
            Type = 4878;
            break;
          case 24:
            Type = 5002;
            break;
          case 25:
            Type = 5003;
            break;
        }
      }
      if (type == 443)
        Type = 3722;
      if (type == 485 && !WorldGen.gen && Main.netMode != 1)
      {
        int num7 = 1;
        for (int index = 0; index < num7; ++index)
        {
          int number = NPC.NewNPC(num4 * 16, j * 16 + 32, 582, 0, 0.0f, 0.0f, 0.0f, 0.0f, (int) byte.MaxValue);
          Main.npc[number].TargetClosest(true);
          Main.npc[number].velocity = new Vector2((float) Main.npc[number].direction * 1.5f, -5f);
          NetMessage.SendData(23, -1, -1, (NetworkText) null, number, 0.0f, 0.0f, 0.0f, 0, 0, 0);
          int time = 20;
          int fromWho = -1;
          Main.npc[number].GetImmuneTime(fromWho, time);
          NetMessage.SendData(131, -1, -1, (NetworkText) null, number, 1f, (float) fromWho, (float) time, 0, 0, 0);
        }
      }
      if (type == 444 && Main.netMode != 1 && !flag6)
        Projectile.NewProjectile((float) (num4 * 16 + 16), (float) (j * 16 + 16), 0.0f, 0.0f, 655, 0, 0.0f, Main.myPlayer, 0.0f, 0.0f);
      if (Type != 0)
        Item.NewItem(num4 * 16, j * 16, tileData.CoordinateFullWidth, tileData.CoordinateFullHeight, Type, 1, false, 0, false, false);
      WorldGen.destroyObject = false;
      for (int index1 = -1; index1 < width + 1; ++index1)
      {
        for (int index2 = -1; index2 < height + 1; ++index2)
          WorldGen.TileFrame(num4 + index1, j + index2, false, false);
      }
    }

    public static void Check2x2(int i, int j, int type)
    {
      if (WorldGen.destroyObject)
        return;
      bool flag1 = false;
      int num1 = 0;
      int num2 = (int) Main.tile[i, j].frameX / 18 * -1;
      if (num2 < -1)
      {
        num2 += 2;
        num1 = 36;
      }
      int i1 = num2 + i;
      int num3 = type == 172 ? 38 : 36;
      int frameY = (int) Main.tile[i, j].frameY;
      int num4 = 0;
      while (frameY >= num3)
      {
        frameY -= num3;
        ++num4;
      }
      int index1 = j - frameY / 18;
      for (int i2 = i1; i2 < i1 + 2; ++i2)
      {
        for (int j1 = index1; j1 < index1 + 2; ++j1)
        {
          Tile tileSafely = Framing.GetTileSafely(i2, j1);
          if (!tileSafely.active() || (int) tileSafely.type != type || ((int) tileSafely.frameX != (i2 - i1) * 18 + num1 || (int) tileSafely.frameY != (j1 - index1) * 18 + num4 * num3))
            flag1 = true;
        }
        switch (type)
        {
          case 95:
          case 126:
            Framing.GetTileSafely(i2, index1 - 1);
            if (!Main.tile[i2, index1 - 1].active() || !Main.tileSolid[(int) Main.tile[i2, index1 - 1].type] || Main.tileSolidTop[(int) Main.tile[i2, index1 - 1].type])
            {
              flag1 = true;
              continue;
            }
            continue;
          case 132:
          case 138:
          case 484:
            continue;
          default:
            Tile tileSafely1 = Framing.GetTileSafely(i2, index1 + 2);
            if (!tileSafely1.active() || !Main.tileSolid[(int) tileSafely1.type] && !Main.tileTable[(int) tileSafely1.type])
              flag1 = true;
            if (tileSafely1.halfBrick())
            {
              flag1 = true;
              continue;
            }
            continue;
        }
      }
      switch (type)
      {
        case 132:
          flag1 = false;
          index1 = (int) Main.tile[i, j].frameY / 18 * -1 + j;
          int num5 = 0;
          int num6 = (int) Main.tile[i, j].frameX / 18 * -1;
          while (num6 < -1)
          {
            num6 += 2;
            num5 += 36;
          }
          i1 = num6 + i;
          for (int index2 = i1; index2 < i1 + 2; ++index2)
          {
            for (int index3 = index1; index3 < index1 + 2; ++index3)
            {
              if (Main.tile[index2, index3] == null)
                Main.tile[index2, index3] = new Tile();
              if (!Main.tile[index2, index3].active() || (int) Main.tile[index2, index3].type != type || ((int) Main.tile[index2, index3].frameX != (index2 - i1) * 18 + num5 || (int) Main.tile[index2, index3].frameY != (index3 - index1) * 18))
                flag1 = true;
            }
          }
          if (Main.tile[i1, index1 + 2] == null)
            Main.tile[i1, index1 + 2] = new Tile();
          if (Main.tile[i1 + 1, index1 + 2] == null)
            Main.tile[i1 + 1, index1 + 2] = new Tile();
          bool flag2 = false;
          ushort type1 = Main.tile[i1, index1 + 2].type;
          ushort type2 = Main.tile[i1 + 1, index1 + 2].type;
          if (!Main.tile[i1, index1 + 2].active() || !Main.tileSolid[(int) type1] && !Main.tileSolidTop[(int) type1] || (Main.tile[i1, index1 + 2].halfBrick() || Main.tile[i1, index1 + 2].slope() != (byte) 0 && !Main.tile[i1, index1 + 2].bottomSlope()))
            flag2 = true;
          if (!Main.tile[i1 + 1, index1 + 2].active() || !Main.tileSolid[(int) type2] && !Main.tileSolidTop[(int) type2] || (Main.tile[i1 + 1, index1 + 2].halfBrick() || Main.tile[i1 + 1, index1 + 2].slope() != (byte) 0 && !Main.tile[i1 + 1, index1 + 2].bottomSlope()))
            flag2 = true;
          if (flag2)
          {
            if (Main.tile[i1, index1].wall < (ushort) 1 || Main.tile[i1 + 1, index1].wall < (ushort) 1 || (Main.tile[i1, index1 + 1].wall < (ushort) 1 || Main.tile[i1 + 1, index1 + 1].wall < (ushort) 1))
            {
              flag1 = true;
              break;
            }
            if (num5 < 72)
            {
              for (int index2 = i1; index2 < i1 + 2; ++index2)
              {
                for (int index3 = index1; index3 < index1 + 2; ++index3)
                  Main.tile[index2, index3].frameX += (short) 72;
              }
              break;
            }
            break;
          }
          if (num5 >= 72)
          {
            for (int index2 = i1; index2 < i1 + 2; ++index2)
            {
              for (int index3 = index1; index3 < index1 + 2; ++index3)
                Main.tile[index2, index3].frameX -= (short) 72;
            }
            break;
          }
          break;
        case 138:
        case 484:
          ushort type3 = Main.tile[i1, index1 - 1].type;
          ushort type4 = Main.tile[i1 + 1, index1 - 1].type;
          if ((TileID.Sets.BasicChest[(int) type3] || TileID.Sets.BasicChest[(int) type4] || (type3 == (ushort) 88 || type4 == (ushort) 88) || (TileID.Sets.BasicChestFake[(int) type3] || TileID.Sets.BasicChestFake[(int) type4] || (type3 == (ushort) 470 || type4 == (ushort) 470)) || type3 == (ushort) 475 ? 1 : (type4 == (ushort) 475 ? 1 : 0)) == 0 && !WorldGen.SolidTileAllowBottomSlope(i1, index1 + 2) && !WorldGen.SolidTileAllowBottomSlope(i1 + 1, index1 + 2))
          {
            flag1 = true;
            break;
          }
          break;
      }
      if (!flag1)
        return;
      WorldGen.destroyObject = true;
      for (int i2 = i1; i2 < i1 + 2; ++i2)
      {
        for (int j1 = index1; j1 < index1 + 2; ++j1)
        {
          if ((int) Main.tile[i2, j1].type == type && Main.tile[i2, j1].active())
            WorldGen.KillTile(i2, j1, false, false, false);
        }
      }
      int Type = 0;
      if (type <= 565)
      {
        switch (type - 521)
        {
          case 0:
            Type = 4327;
            break;
          case 1:
            Type = 4328;
            break;
          case 2:
            Type = 4329;
            break;
          case 3:
            Type = 4330;
            break;
          case 4:
            Type = 4331;
            break;
          case 5:
            Type = 4332;
            break;
          case 6:
            Type = 4333;
            break;
          default:
            if (type != 564)
            {
              if (type == 565)
              {
                Type = 4552;
                break;
              }
              break;
            }
            Type = 4553;
            break;
        }
      }
      else if (type != 594)
      {
        if (type != 621)
        {
          if (type == 622)
            Type = 5008;
        }
        else
          Type = 3750;
      }
      else
        Type = 4869;
      if (type == 598)
        Type = 4880;
      if (type == 360)
        Type = 3072;
      if (type == 580)
        Type = 4846;
      if (type == 620)
        Type = 4964;
      if (type == 505)
        Type = 4275;
      if (type == 543)
        Type = 4398;
      if (type == 568)
        Type = 4655;
      if (type == 569)
        Type = 4656;
      if (type == 570)
        Type = 4657;
      if (type >= 288 && type <= 295)
        Type = 2178 + type - 288;
      if (type >= 316 && type <= 318)
        Type = 2439 + type - 316;
      if (type == 85)
        Type = 321;
      if (type == 94)
        Type = 352;
      if (type == 95)
        Type = 344;
      if (type == 96)
        Type = 345;
      if (type == 97)
        Type = 346;
      if (type == 98)
        Type = 347;
      if (type == 99)
        Type = 348;
      if (type == 335)
        Type = 2700;
      if (type == 411)
        Type = 3545;
      if (type == 100)
      {
        if (num4 == 0)
          Type = 349;
        else if (num4 >= 1 && num4 <= 12)
          Type = 2092 + num4 - 1;
        else if (num4 >= 13 && num4 <= 16)
        {
          Type = 2149 + num4 - 13;
        }
        else
        {
          switch (num4)
          {
            case 17:
              Type = 2227;
              break;
            case 18:
              Type = 2522;
              break;
            case 19:
              Type = 2541;
              break;
            case 20:
              Type = 2555;
              break;
            case 21:
              Type = 2570;
              break;
            case 22:
              Type = 2664;
              break;
            case 23:
              Type = 2665;
              break;
            case 24:
              Type = 2666;
              break;
            case 25:
              Type = 2667;
              break;
            case 26:
              Type = 2668;
              break;
            case 27:
              Type = 2825;
              break;
            case 28:
              Type = 3168;
              break;
            case 29:
              Type = 3170;
              break;
            case 30:
              Type = 3169;
              break;
            case 31:
              Type = 3893;
              break;
            case 32:
              Type = 3935;
              break;
            case 33:
              Type = 3961;
              break;
            case 34:
              Type = 4149;
              break;
            case 35:
              Type = 4170;
              break;
            case 36:
              Type = 4191;
              break;
            case 37:
              Type = 4212;
              break;
            case 38:
              Type = 4302;
              break;
            case 39:
              Type = 4570;
              break;
          }
        }
      }
      if (type == 173)
        Type = 714;
      if (type == 125)
        Type = 487;
      if (type == 287)
        Type = 2177;
      if (type == 126)
        Type = 488;
      if (type == 132)
        Type = 513;
      if (type == 142)
        Type = 581;
      if (type == 143)
        Type = 582;
      if (type == 282)
        Type = 250;
      if (type == 319)
        Type = 2490;
      if (type == 490)
        Type = 4075;
      if (type == 172)
      {
        Type = 2827 + num4;
        switch (num4)
        {
          case 29:
            Type = 3147;
            break;
          case 30:
            Type = 3149;
            break;
          case 31:
            Type = 3148;
            break;
          case 32:
            Type = 3896;
            break;
          case 33:
            Type = 3946;
            break;
          case 34:
            Type = 3972;
            break;
          case 35:
            Type = 4160;
            break;
          case 36:
            Type = 4181;
            break;
          case 37:
            Type = 4202;
            break;
          case 38:
            Type = 4223;
            break;
          case 39:
            Type = 4312;
            break;
          case 40:
            Type = 4581;
            break;
        }
      }
      if (Type != 0)
        Item.NewItem(i * 16, j * 16, 32, 32, Type, 1, false, 0, false, false);
      if (type == 138 && !WorldGen.gen && Main.netMode != 1)
        Projectile.NewProjectile((float) (i1 * 16) + 15.5f, (float) (index1 * 16 + 16), 0.0f, 0.0f, 99, 70, 10f, Main.myPlayer, 0.0f, 0.0f);
      if (type == 484 && !WorldGen.gen && Main.netMode != 1)
        Projectile.NewProjectile((float) (i1 * 16) + 15.5f, (float) (index1 * 16 + 16), 0.0f, 0.0f, 727, 70, 10f, Main.myPlayer, 0.0f, 0.0f);
      WorldGen.destroyObject = false;
      for (int i2 = i1 - 1; i2 < i1 + 3; ++i2)
      {
        for (int j1 = index1 - 1; j1 < index1 + 3; ++j1)
          WorldGen.TileFrame(i2, j1, false, false);
      }
    }

    public static bool CheckBoulderChest(int i, int j)
    {
      int num1 = (int) Main.tile[i, j].frameX / 18 * -1;
      if (num1 < -1)
        num1 += 2;
      int index = num1 + i;
      int frameY = (int) Main.tile[i, j].frameY;
      while (frameY >= 36)
        frameY -= 36;
      int num2 = j - frameY / 18;
      return WorldGen.IsAContainer(Main.tile[index, num2 - 1]) || WorldGen.IsAContainer(Main.tile[index + 1, num2 - 1]);
    }

    public static bool IsAContainer(Tile t)
    {
      return t.type == (ushort) 88 || t.type == (ushort) 470 || (t.type == (ushort) 475 || TileID.Sets.BasicChest[(int) t.type]) || TileID.Sets.BasicChestFake[(int) t.type];
    }

    public static void OreRunner(int i, int j, double strength, int steps, ushort type)
    {
      double num1 = strength;
      float num2 = (float) steps;
      Vector2 vector2_1;
      vector2_1.X = (float) i;
      vector2_1.Y = (float) j;
      Vector2 vector2_2;
      vector2_2.X = (float) WorldGen.genRand.Next(-10, 11) * 0.1f;
      vector2_2.Y = (float) WorldGen.genRand.Next(-10, 11) * 0.1f;
      while (num1 > 0.0 && (double) num2 > 0.0)
      {
        if ((double) vector2_1.Y < 0.0 && (double) num2 > 0.0 && type == (ushort) 59)
          num2 = 0.0f;
        num1 = strength * ((double) num2 / (double) steps);
        --num2;
        int num3 = (int) ((double) vector2_1.X - num1 * 0.5);
        int num4 = (int) ((double) vector2_1.X + num1 * 0.5);
        int num5 = (int) ((double) vector2_1.Y - num1 * 0.5);
        int num6 = (int) ((double) vector2_1.Y + num1 * 0.5);
        if (num3 < 0)
          num3 = 0;
        if (num4 > Main.maxTilesX)
          num4 = Main.maxTilesX;
        if (num5 < 0)
          num5 = 0;
        if (num6 > Main.maxTilesY)
          num6 = Main.maxTilesY;
        for (int index1 = num3; index1 < num4; ++index1)
        {
          for (int index2 = num5; index2 < num6; ++index2)
          {
            if ((double) Math.Abs((float) index1 - vector2_1.X) + (double) Math.Abs((float) index2 - vector2_1.Y) < strength * 0.5 * (1.0 + (double) WorldGen.genRand.Next(-10, 11) * 0.015) && Main.tile[index1, index2].active() && (Main.tile[index1, index2].type == (ushort) 0 || Main.tile[index1, index2].type == (ushort) 1 || (Main.tile[index1, index2].type == (ushort) 23 || Main.tile[index1, index2].type == (ushort) 25) || (Main.tile[index1, index2].type == (ushort) 40 || Main.tile[index1, index2].type == (ushort) 53 || (Main.tile[index1, index2].type == (ushort) 57 || Main.tile[index1, index2].type == (ushort) 59)) || (Main.tile[index1, index2].type == (ushort) 60 || Main.tile[index1, index2].type == (ushort) 70 || (Main.tile[index1, index2].type == (ushort) 109 || Main.tile[index1, index2].type == (ushort) 112) || (Main.tile[index1, index2].type == (ushort) 116 || Main.tile[index1, index2].type == (ushort) 117 || (Main.tile[index1, index2].type == (ushort) 147 || Main.tile[index1, index2].type == (ushort) 161))) || (Main.tile[index1, index2].type == (ushort) 163 || Main.tile[index1, index2].type == (ushort) 164 || (Main.tileMoss[(int) Main.tile[index1, index2].type] || Main.tile[index1, index2].type == (ushort) 199) || (Main.tile[index1, index2].type == (ushort) 200 || Main.tile[index1, index2].type == (ushort) 203 || Main.tile[index1, index2].type == (ushort) 234) || Main.tile[index1, index2].type == (ushort) 225 && Main.tile[index1, index2].wall != (ushort) 108)))
            {
              Main.tile[index1, index2].type = type;
              WorldGen.SquareTileFrame(index1, index2, true);
              if (Main.netMode == 2)
                NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
            }
          }
        }
        vector2_1 += vector2_2;
        vector2_2.X += (float) WorldGen.genRand.Next(-10, 11) * 0.05f;
        if ((double) vector2_2.X > 1.0)
          vector2_2.X = 1f;
        if ((double) vector2_2.X < -1.0)
          vector2_2.X = -1f;
      }
    }

    public static void SmashAltar(int i, int j)
    {
      if (Main.netMode == 1 || !Main.hardMode || (WorldGen.noTileActions || WorldGen.gen))
        return;
      int num1 = WorldGen.altarCount % 3;
      int num2 = WorldGen.altarCount / 3 + 1;
      float num3 = (float) (Main.maxTilesX / 4200);
      int num4 = 1 - num1;
      float num5 = (num3 * 310f - (float) (85 * num1)) * 0.85f / (float) num2;
      bool flag = false;
      if (Main.drunkWorld)
      {
        switch (WorldGen.SavedOreTiers.Adamantite)
        {
          case 111:
            WorldGen.SavedOreTiers.Adamantite = 223;
            break;
          case 223:
            WorldGen.SavedOreTiers.Adamantite = 111;
            break;
        }
      }
      int num6;
      switch (num1)
      {
        case 0:
          if (WorldGen.SavedOreTiers.Cobalt == -1)
          {
            flag = true;
            WorldGen.SavedOreTiers.Cobalt = 107;
            if (WorldGen.genRand.Next(2) == 0)
              WorldGen.SavedOreTiers.Cobalt = 221;
          }
          int index1 = 12;
          if (WorldGen.SavedOreTiers.Cobalt == 221)
          {
            index1 += 9;
            num5 *= 0.9f;
          }
          switch (Main.netMode)
          {
            case 0:
              Main.NewText(Lang.misc[index1].Value, (byte) 50, byte.MaxValue, (byte) 130);
              break;
            case 2:
              ChatHelper.BroadcastChatMessage(NetworkText.FromKey(Lang.misc[index1].Key), new Color(50, (int) byte.MaxValue, 130), -1);
              break;
          }
          num6 = WorldGen.SavedOreTiers.Cobalt;
          num5 *= 1.05f;
          break;
        case 1:
          if (Main.drunkWorld)
          {
            if (WorldGen.SavedOreTiers.Mythril == 108)
              WorldGen.SavedOreTiers.Mythril = 222;
            else if (WorldGen.SavedOreTiers.Mythril == 222)
              WorldGen.SavedOreTiers.Mythril = 108;
          }
          if (WorldGen.SavedOreTiers.Mythril == -1)
          {
            flag = true;
            WorldGen.SavedOreTiers.Mythril = 108;
            if (WorldGen.genRand.Next(2) == 0)
              WorldGen.SavedOreTiers.Mythril = 222;
          }
          int index2 = 13;
          if (WorldGen.SavedOreTiers.Mythril == 222)
          {
            index2 += 9;
            num5 *= 0.9f;
          }
          switch (Main.netMode)
          {
            case 0:
              Main.NewText(Lang.misc[index2].Value, (byte) 50, byte.MaxValue, (byte) 130);
              break;
            case 2:
              ChatHelper.BroadcastChatMessage(NetworkText.FromKey(Lang.misc[index2].Key), new Color(50, (int) byte.MaxValue, 130), -1);
              break;
          }
          num6 = WorldGen.SavedOreTiers.Mythril;
          break;
        default:
          if (Main.drunkWorld)
          {
            switch (WorldGen.SavedOreTiers.Cobalt)
            {
              case 107:
                WorldGen.SavedOreTiers.Cobalt = 221;
                break;
              case 221:
                WorldGen.SavedOreTiers.Cobalt = 107;
                break;
            }
          }
          if (WorldGen.SavedOreTiers.Adamantite == -1)
          {
            flag = true;
            WorldGen.SavedOreTiers.Adamantite = 111;
            if (WorldGen.genRand.Next(2) == 0)
              WorldGen.SavedOreTiers.Adamantite = 223;
          }
          int index3 = 14;
          if (WorldGen.SavedOreTiers.Adamantite == 223)
          {
            index3 += 9;
            num5 *= 0.9f;
          }
          switch (Main.netMode)
          {
            case 0:
              Main.NewText(Lang.misc[index3].Value, (byte) 50, byte.MaxValue, (byte) 130);
              break;
            case 2:
              ChatHelper.BroadcastChatMessage(NetworkText.FromKey(Lang.misc[index3].Key), new Color(50, (int) byte.MaxValue, 130), -1);
              break;
          }
          num6 = WorldGen.SavedOreTiers.Adamantite;
          break;
      }
      if (flag)
        NetMessage.SendData(7, -1, -1, (NetworkText) null, 0, 0.0f, 0.0f, 0.0f, 0, 0, 0);
      for (int index4 = 0; (double) index4 < (double) num5; ++index4)
      {
        int i1 = WorldGen.genRand.Next(100, Main.maxTilesX - 100);
        double num7 = Main.worldSurface;
        if (num6 == 108 || num6 == 222)
          num7 = Main.rockLayer;
        if (num6 == 111 || num6 == 223)
          num7 = (Main.rockLayer + Main.rockLayer + (double) Main.maxTilesY) / 3.0;
        int j1 = WorldGen.genRand.Next((int) num7, Main.maxTilesY - 150);
        double strength = (double) WorldGen.genRand.Next(5, 9 + num4);
        int steps = WorldGen.genRand.Next(5, 9 + num4);
        int num8 = (int) (ushort) num6;
        WorldGen.OreRunner(i1, j1, strength, steps, (ushort) num8);
      }
      int num9 = WorldGen.genRand.Next(3);
      int num10 = 0;
      while (num9 != 2 && num10++ < 1000)
      {
        int tileX = WorldGen.genRand.Next(100, Main.maxTilesX - 100);
        int tileY = WorldGen.genRand.Next((int) Main.rockLayer + 50, Main.maxTilesY - 300);
        if (Main.tile[tileX, tileY].active() && Main.tile[tileX, tileY].type == (ushort) 1)
        {
          Main.tile[tileX, tileY].type = num9 != 0 ? (ushort) 117 : (!WorldGen.crimson ? (ushort) 25 : (ushort) 203);
          if (Main.netMode == 2)
          {
            NetMessage.SendTileSquare(-1, tileX, tileY, 1, TileChangeType.None);
            break;
          }
          break;
        }
      }
      if (Main.netMode != 1)
      {
        int num7 = Main.rand.Next(2) + 1;
        for (int index4 = 0; index4 < num7; ++index4)
          NPC.SpawnOnPlayer((int) Player.FindClosest(new Vector2((float) (i * 16), (float) (j * 16)), 16, 16), 82);
      }
      ++WorldGen.altarCount;
      AchievementsHelper.NotifyProgressionEvent(6);
    }

    public static void Check3x1(int i, int j, int type)
    {
      if (WorldGen.destroyObject)
        return;
      bool flag = false;
      int num1 = (int) Main.tile[i, j].frameX / 18;
      int num2 = 0;
      while (num1 > 2)
      {
        num1 -= 3;
        ++num2;
      }
      int num3 = i - num1;
      int num4 = num2 * 54;
      for (int i1 = num3; i1 < num3 + 3; ++i1)
      {
        int index = j;
        if (Main.tile[i1, index] == null)
          Main.tile[i1, index] = new Tile();
        if (!Main.tile[i1, index].active() || (int) Main.tile[i1, index].type != type || ((int) Main.tile[i1, index].frameX != (i1 - num3) * 18 + num4 || Main.tile[i1, index].frameY != (short) 0))
          flag = true;
        if (Main.tile[i1, index - 1].active() && (TileID.Sets.BasicChest[(int) Main.tile[i1, index - 1].type] || TileID.Sets.BasicChestFake[(int) Main.tile[i1, index - 1].type] || (Main.tile[i1, index - 1].type == (ushort) 88 || Main.tile[i1, index - 1].type == (ushort) 470) || (Main.tile[i1, index - 1].type == (ushort) 475 || Main.tile[i1, index - 1].type == (ushort) 597)))
          return;
        if (!WorldGen.SolidTileAllowBottomSlope(i1, index + 1))
          flag = true;
      }
      if (!flag)
        return;
      int frameX = (int) Main.tile[i, j].frameX;
      WorldGen.destroyObject = true;
      if (type == 235)
        Item.NewItem(i * 16, j * 16, 32, 32, 1263, 1, false, 0, false, false);
      for (int i1 = num3; i1 < num3 + 3; ++i1)
      {
        int j1 = j;
        if (Main.tile[i1, j1] == null)
          Main.tile[i1, j1] = new Tile();
        if ((int) Main.tile[i1, j1].type == type && Main.tile[i1, j1].active())
          WorldGen.KillTile(i1, j1, false, false, false);
      }
      WorldGen.destroyObject = false;
      for (int i1 = num3 - 1; i1 < num3 + 4; ++i1)
      {
        int j1 = j;
        WorldGen.TileFrame(i1, j1, false, false);
      }
    }

    public static void Check3x2(int i, int j, int type)
    {
      if (WorldGen.destroyObject)
        return;
      bool flag1 = false;
      bool flag2 = false;
      int num1 = j;
      if (Main.tile[i, j] == null)
        Main.tile[i, j] = new Tile();
      int num2 = 36;
      int num3 = (int) Main.tile[i, j].frameY / num2;
      int num4 = (int) Main.tile[i, j].frameY % num2;
      int index1 = num1 - num4 / 18;
      int num5 = (int) Main.tile[i, j].frameX / 18;
      int style = 0;
      while (num5 > 2)
      {
        num5 -= 3;
        ++style;
      }
      int index2 = i - num5;
      int num6 = style * 54;
      if (type == 14 && style == 25)
        flag2 = true;
      int j1 = index1 + 2;
      if (flag2)
        --j1;
      for (int i1 = index2; i1 < index2 + 3; ++i1)
      {
        for (int index3 = index1; index3 < j1; ++index3)
        {
          if (Main.tile[i1, index3] == null)
            Main.tile[i1, index3] = new Tile();
          if (!Main.tile[i1, index3].active() || (int) Main.tile[i1, index3].type != type || ((int) Main.tile[i1, index3].frameX != (i1 - index2) * 18 + num6 || (int) Main.tile[i1, index3].frameY != (index3 - index1) * 18 + num3 * 36))
            flag1 = true;
        }
        if (type == 285 || type == 286 || (type == 298 || type == 299) || (type == 310 || type == 339 || type == 538) || (type >= 361 && type <= 364 || (type == 532 || type == 544) || (type == 533 || type == 555 || (type == 556 || type == 582))) || type == 619)
        {
          if (!WorldGen.SolidTileAllowBottomSlope(i1, j1) && (Main.tile[i1, j1] == null || !Main.tile[i1, j1].nactive() || (!Main.tileSolidTop[(int) Main.tile[i1, j1].type] || Main.tile[i1, j1].frameY != (short) 0)) && (Main.tile[i1, j1] == null || !Main.tile[i1, j1].active() || !TileID.Sets.Platforms[(int) Main.tile[i1, j1].type]))
            flag1 = true;
        }
        else if (type == 488)
        {
          int num7 = 0;
          if (Main.tile[i1, j1] != null && Main.tile[i1, j1].active())
            num7 = (int) Main.tile[i1, j1].type;
          if ((num7 == 2 || num7 == 477 || num7 == 109 ? 1 : (num7 == 492 ? 1 : 0)) == 0)
            flag1 = true;
        }
        else if (!WorldGen.SolidTileAllowBottomSlope(i1, j1))
          flag1 = true;
      }
      if (type == 187 && Main.tile[index2, index1] != null && (Main.tile[index2, index1].frameX >= (short) 756 && Main.tile[index2, index1].frameX <= (short) 900) && (Main.tile[index2, index1 + 2].type != (ushort) 2 && Main.tile[index2 + 1, index1 + 2].type != (ushort) 2 && (Main.tile[index2 + 2, index1 + 2].type != (ushort) 2 && Main.tile[index2, index1 + 2].type != (ushort) 477)) && (Main.tile[index2 + 1, index1 + 2].type != (ushort) 477 && Main.tile[index2 + 2, index1 + 2].type != (ushort) 477 && (Main.tile[index2, index1 + 2].type != (ushort) 492 && Main.tile[index2 + 1, index1 + 2].type != (ushort) 492) && Main.tile[index2 + 2, index1 + 2].type != (ushort) 492))
      {
        Main.tile[index2, index1].frameX -= (short) 378;
        Main.tile[index2 + 1, index1].frameX -= (short) 378;
        Main.tile[index2 + 2, index1].frameX -= (short) 378;
        Main.tile[index2, index1 + 1].frameX -= (short) 378;
        Main.tile[index2 + 1, index1 + 1].frameX -= (short) 378;
        Main.tile[index2 + 2, index1 + 1].frameX -= (short) 378;
        Main.tile[index2, index1].type = (ushort) 186;
        Main.tile[index2 + 1, index1].type = (ushort) 186;
        Main.tile[index2 + 2, index1].type = (ushort) 186;
        Main.tile[index2, index1 + 1].type = (ushort) 186;
        Main.tile[index2 + 1, index1 + 1].type = (ushort) 186;
        Main.tile[index2 + 2, index1 + 1].type = (ushort) 186;
      }
      if (flag1 && type == 488 && WorldGen.gen)
      {
        for (int index3 = index2; index3 < index2 + 3; ++index3)
        {
          for (int index4 = index1; index4 < index1 + 2; ++index4)
          {
            Main.tile[index3, index4].active(true);
            Main.tile[index3, index4].type = (ushort) 488;
            Main.tile[index3, index4].frameX = (short) ((index3 - index2) * 18);
            Main.tile[index3, index4].frameY = (short) ((index4 - index1) * 18);
          }
          Main.tile[index3, index1 + 2].active(true);
          Main.tile[index3, index1 + 2].type = (ushort) 2;
          Main.tile[index3, index1 + 2].slope((byte) 0);
          Main.tile[index3, index1 + 2].halfBrick(false);
        }
        flag1 = false;
      }
      if (!flag1)
        return;
      int frameX = (int) Main.tile[i, j].frameX;
      WorldGen.destroyObject = true;
      int num8 = index1 + 3;
      if (flag2)
      {
        int num9 = num8 - 1;
      }
      for (int i1 = index2; i1 < index2 + 3; ++i1)
      {
        for (int j2 = index1; j2 < index1 + 3; ++j2)
        {
          if (Main.tile[i1, j2] == null)
            Main.tile[i1, j2] = new Tile();
          if ((int) Main.tile[i1, j2].type == type && Main.tile[i1, j2].active())
            WorldGen.KillTile(i1, j2, false, false, false);
        }
      }
      if (type == 14)
      {
        int Type = style < 1 || style > 3 ? (style < 15 || style > 20 ? (style < 4 || style > 7 ? (style != 8 ? (style != 9 ? (style != 10 ? (style != 11 ? (style != 12 ? (style != 13 ? (style != 14 ? (style != 23 ? (style != 21 ? (style != 22 ? (style != 24 ? (style != 25 ? (style != 26 ? (style != 27 ? (style != 28 ? (style != 29 ? (style != 30 ? (style != 31 ? (style != 32 ? (style != 33 ? (style != 34 ? 32 : 3154) : 3155) : 3153) : 2824) : 2743) : 2583) : 677) : 2550) : 2532) : 2259) : 2248) : 1816) : 1794) : 1926) : 1510) : 1460) : 1403) : 1400) : 1397) : 1144) : 917) : 823 + style) : 1698 + style) : 637 + style;
        Item.NewItem(i * 16, j * 16, 32, 32, Type, 1, false, 0, false, false);
      }
      if (type == 469)
      {
        int Type = 3920;
        if (style == 1)
          Type = 3948;
        if (style == 2)
          Type = 3974;
        if (style == 3)
          Type = 4162;
        if (style == 4)
          Type = 4183;
        if (style == 5)
          Type = 4204;
        if (style == 6)
          Type = 4225;
        if (style == 7)
          Type = 4314;
        if (style == 8)
          Type = 4583;
        Item.NewItem(i * 16, j * 16, 32, 32, Type, 1, false, 0, false, false);
      }
      else if (type == 114)
        Item.NewItem(i * 16, j * 16, 32, 32, 398, 1, false, 0, false, false);
      else if (type == 26)
      {
        if (!WorldGen.noTileActions && !WorldGen.IsGeneratingHardMode)
          WorldGen.SmashAltar(i, j);
      }
      else if (type == 298)
        Item.NewItem(i * 16, j * 16, 32, 32, 2190, 1, false, 0, false, false);
      else if (type == 299)
        Item.NewItem(i * 16, j * 16, 32, 32, 2191, 1, false, 0, false, false);
      else if (type >= 361 && type <= 364)
        Item.NewItem(i * 16, j * 16, 32, 32, 3073 + type - 361, 1, false, 0, false, false);
      else if (type >= 391 && type <= 394)
      {
        Item.NewItem(i * 16, j * 16, 48, 32, 3254 + type - 391, 1, false, 0, false, false);
      }
      else
      {
        switch (type)
        {
          case 17:
            Item.NewItem(i * 16, j * 16, 32, 32, 33, 1, false, 0, false, false);
            break;
          case 77:
            Item.NewItem(i * 16, j * 16, 32, 32, 221, 1, false, 0, false, false);
            break;
          case 86:
            Item.NewItem(i * 16, j * 16, 32, 32, 332, 1, false, 0, false, false);
            break;
          case 87:
            int Type1 = style < 1 || style > 3 ? (style != 4 ? (style < 5 || style > 7 ? (style < 8 || style > 10 ? (style < 11 || style > 20 ? (style != 21 ? (style != 22 ? (style != 23 ? (style != 24 ? (style != 25 ? (style != 26 ? (style != 27 ? (style != 28 ? (style != 29 ? (style != 30 ? (style != 31 ? (style != 32 ? (style != 33 ? (style != 34 ? (style != 35 ? (style != 36 ? (style != 37 ? (style != 38 ? (style != 39 ? 333 : 4579) : 4310) : 4221) : 4200) : 4179) : 4158) : 3971) : 3944) : 3916) : 3915) : 3142) : 3143) : 3141) : 2821) : 2671) : 2580) : 2565) : 2548) : 2531) : 2376 + style - 11) : 2254 + style - 8) : 2245 + style - 5) : 919) : 640 + style;
            Item.NewItem(i * 16, j * 16, 32, 32, Type1, 1, false, 0, false, false);
            break;
          case 88:
            int dresserItemDrop = WorldGen.GetDresserItemDrop(style);
            Item.NewItem(i * 16, j * 16, 32, 32, dresserItemDrop, 1, false, 0, false, false);
            break;
          case 89:
            Item.NewItem(i * 16, j * 16, 32, 32, WorldGen.GetItemDrop_Benches(style), 1, false, 0, false, false);
            break;
          case 133:
            if (frameX >= 54)
            {
              Item.NewItem(i * 16, j * 16, 32, 32, 1221, 1, false, 0, false, false);
              break;
            }
            Item.NewItem(i * 16, j * 16, 32, 32, 524, 1, false, 0, false, false);
            break;
          case 186:
            if (frameX >= 864)
            {
              if (frameX <= 954)
              {
                Item.NewItem(i * 16, j * 16, 32, 32, 71, WorldGen.genRand.Next(20, 100), false, 0, false, false);
                Item.NewItem(i * 16, j * 16, 32, 32, 71, WorldGen.genRand.Next(30, 100), false, 0, false, false);
                Item.NewItem(i * 16, j * 16, 32, 32, 71, WorldGen.genRand.Next(40, 100), false, 0, false, false);
                if (WorldGen.genRand.Next(3) != 0)
                  Item.NewItem(i * 16, j * 16, 32, 32, 71, WorldGen.genRand.Next(20, 100), false, 0, false, false);
                if (WorldGen.genRand.Next(3) != 0)
                  Item.NewItem(i * 16, j * 16, 32, 32, 71, WorldGen.genRand.Next(30, 100), false, 0, false, false);
                if (WorldGen.genRand.Next(3) != 0)
                  Item.NewItem(i * 16, j * 16, 32, 32, 71, WorldGen.genRand.Next(40, 100), false, 0, false, false);
                if (WorldGen.genRand.Next(2) == 0)
                  Item.NewItem(i * 16, j * 16, 32, 32, 71, WorldGen.genRand.Next(20, 100), false, 0, false, false);
                if (WorldGen.genRand.Next(2) == 0)
                  Item.NewItem(i * 16, j * 16, 32, 32, 71, WorldGen.genRand.Next(30, 100), false, 0, false, false);
                if (WorldGen.genRand.Next(2) == 0)
                  Item.NewItem(i * 16, j * 16, 32, 32, 71, WorldGen.genRand.Next(40, 100), false, 0, false, false);
                if (WorldGen.genRand.Next(3) == 0)
                  Item.NewItem(i * 16, j * 16, 32, 32, 71, WorldGen.genRand.Next(20, 100), false, 0, false, false);
                if (WorldGen.genRand.Next(3) == 0)
                  Item.NewItem(i * 16, j * 16, 32, 32, 71, WorldGen.genRand.Next(30, 100), false, 0, false, false);
                if (WorldGen.genRand.Next(3) == 0)
                  Item.NewItem(i * 16, j * 16, 32, 32, 71, WorldGen.genRand.Next(40, 100), false, 0, false, false);
                if (WorldGen.genRand.Next(4) == 0)
                  Item.NewItem(i * 16, j * 16, 32, 32, 71, WorldGen.genRand.Next(20, 100), false, 0, false, false);
                if (WorldGen.genRand.Next(4) == 0)
                  Item.NewItem(i * 16, j * 16, 32, 32, 71, WorldGen.genRand.Next(30, 100), false, 0, false, false);
                if (WorldGen.genRand.Next(4) == 0)
                  Item.NewItem(i * 16, j * 16, 32, 32, 71, WorldGen.genRand.Next(40, 100), false, 0, false, false);
                if (WorldGen.genRand.Next(5) == 0)
                  Item.NewItem(i * 16, j * 16, 32, 32, 71, WorldGen.genRand.Next(20, 100), false, 0, false, false);
                if (WorldGen.genRand.Next(5) == 0)
                  Item.NewItem(i * 16, j * 16, 32, 32, 71, WorldGen.genRand.Next(30, 100), false, 0, false, false);
                if (WorldGen.genRand.Next(5) == 0)
                {
                  Item.NewItem(i * 16, j * 16, 32, 32, 71, WorldGen.genRand.Next(40, 100), false, 0, false, false);
                  break;
                }
                break;
              }
              if (frameX <= 1062)
              {
                Item.NewItem(i * 16, j * 16, 32, 32, 72, WorldGen.genRand.Next(10, 100), false, 0, false, false);
                if (WorldGen.genRand.Next(2) == 0)
                  Item.NewItem(i * 16, j * 16, 32, 32, 72, WorldGen.genRand.Next(20, 100), false, 0, false, false);
                if (WorldGen.genRand.Next(3) == 0)
                  Item.NewItem(i * 16, j * 16, 32, 32, 72, WorldGen.genRand.Next(30, 100), false, 0, false, false);
                if (WorldGen.genRand.Next(4) == 0)
                  Item.NewItem(i * 16, j * 16, 32, 32, 72, WorldGen.genRand.Next(40, 100), false, 0, false, false);
                if (WorldGen.genRand.Next(5) == 0)
                {
                  Item.NewItem(i * 16, j * 16, 32, 32, 72, WorldGen.genRand.Next(50, 100), false, 0, false, false);
                  break;
                }
                break;
              }
              if (frameX <= 1170)
              {
                Item.NewItem(i * 16, j * 16, 32, 32, 73, WorldGen.genRand.Next(1, 7), false, 0, false, false);
                if (WorldGen.genRand.Next(2) == 0)
                  Item.NewItem(i * 16, j * 16, 32, 32, 73, WorldGen.genRand.Next(2, 7), false, 0, false, false);
                if (WorldGen.genRand.Next(3) == 0)
                  Item.NewItem(i * 16, j * 16, 32, 32, 73, WorldGen.genRand.Next(3, 7), false, 0, false, false);
                if (WorldGen.genRand.Next(4) == 0)
                  Item.NewItem(i * 16, j * 16, 32, 32, 73, WorldGen.genRand.Next(4, 7), false, 0, false, false);
                if (WorldGen.genRand.Next(5) == 0)
                {
                  Item.NewItem(i * 16, j * 16, 32, 32, 73, WorldGen.genRand.Next(5, 7), false, 0, false, false);
                  break;
                }
                break;
              }
              break;
            }
            break;
          case 215:
            switch (style)
            {
              case 0:
                Item.NewItem(i * 16, j * 16, 32, 32, 966, 1, false, 0, false, false);
                break;
              case 6:
                Item.NewItem(i * 16, j * 16, 32, 32, 3723, 1, false, 0, false, false);
                break;
              case 7:
                Item.NewItem(i * 16, j * 16, 32, 32, 3724, 1, false, 0, false, false);
                break;
              case 8:
              case 9:
              case 10:
              case 11:
              case 12:
              case 13:
                Item.NewItem(i * 16, j * 16, 32, 32, 4689 + style - 8, 1, false, 0, false, false);
                break;
              default:
                Item.NewItem(i * 16, j * 16, 32, 32, 3046 + style - 1, 1, false, 0, false, false);
                break;
            }
            break;
          case 217:
            Item.NewItem(i * 16, j * 16, 32, 32, 995, 1, false, 0, false, false);
            break;
          case 218:
            Item.NewItem(i * 16, j * 16, 32, 32, 996, 1, false, 0, false, false);
            break;
          case 219:
            Item.NewItem(i * 16, j * 16, 32, 32, 997, 1, false, 0, false, false);
            break;
          case 220:
            Item.NewItem(i * 16, j * 16, 32, 32, 998, 1, false, 0, false, false);
            break;
          case 228:
            Item.NewItem(i * 16, j * 16, 32, 32, 1120, 1, false, 0, false, false);
            break;
          case 237:
            Item.NewItem(i * 16, j * 16, 32, 32, 1292, 1, false, 0, false, false);
            break;
          case 244:
            Item.NewItem(i * 16, j * 16, 32, 32, 1449, 1, false, 0, false, false);
            break;
          case 285:
            Item.NewItem(i * 16, j * 16, 32, 32, 2174, 1, false, 0, false, false);
            break;
          case 286:
            Item.NewItem(i * 16, j * 16, 32, 32, 2175, 1, false, 0, false, false);
            break;
          case 310:
            Item.NewItem(i * 16, j * 16, 32, 32, 2207, 1, false, 0, false, false);
            break;
          case 339:
            Item.NewItem(i * 16, j * 16, 32, 32, 2741, 1, false, 0, false, false);
            break;
          case 377:
            Item.NewItem(i * 16, j * 16, 32, 32, 3198, 1, false, 0, false, false);
            break;
          case 405:
            Item.NewItem(i * 16, j * 16, 32, 32, 3364, 1, false, 0, false, false);
            break;
          case 486:
            Item.NewItem(i * 16, j * 16, 32, 32, 4063, 1, false, 0, false, false);
            break;
          case 488:
            Item.NewItem(i * 16, j * 16, 32, 32, 9, WorldGen.genRand.Next(10, 21), false, 0, false, false);
            break;
          case 532:
            Item.NewItem(i * 16, j * 16, 32, 32, 4364, 1, false, 0, false, false);
            break;
          case 533:
            Item.NewItem(i * 16, j * 16, 32, 32, 4376, 1, false, 0, false, false);
            break;
          case 538:
            Item.NewItem(i * 16, j * 16, 32, 32, 4380, 1, false, 0, false, false);
            break;
          case 544:
            Item.NewItem(i * 16, j * 16, 32, 32, 4399, 1, false, 0, false, false);
            break;
          case 555:
            Item.NewItem(i * 16, j * 16, 32, 32, 4475, 1, false, 0, false, false);
            break;
          case 556:
            Item.NewItem(i * 16, j * 16, 32, 32, 4476, 1, false, 0, false, false);
            break;
          case 582:
            Item.NewItem(i * 16, j * 16, 32, 32, 4850, 1, false, 0, false, false);
            break;
          case 619:
            Item.NewItem(i * 16, j * 16, 32, 32, 4963, 1, false, 0, false, false);
            break;
          default:
            if (type == 187 && frameX >= 918 && frameX <= 970)
            {
              if (Main.rand.Next(50) == 0)
              {
                Item.NewItem(i * 16, j * 16, 32, 32, 4144, 1, false, 0, false, false);
                break;
              }
              Item.NewItem(i * 16, j * 16, 32, 32, 989, 1, false, 0, false, false);
              break;
            }
            break;
        }
      }
      WorldGen.destroyObject = false;
      for (int i1 = index2 - 1; i1 < index2 + 4; ++i1)
      {
        for (int j2 = index1 - 1; j2 < index1 + 4; ++j2)
          WorldGen.TileFrame(i1, j2, false, false);
      }
      if (type != 488)
        return;
      WorldGen.mysticLogsEvent.FallenLogDestroyed();
    }

    private static int GetDresserItemDrop(int style)
    {
      return style < 1 || style > 3 ? (style != 4 ? (style < 5 || style > 15 ? (style != 16 ? (style != 17 ? (style != 18 ? (style != 19 ? (style != 20 ? (style != 21 ? (style != 22 ? (style != 23 ? (style != 24 ? (style != 25 ? (style != 26 ? (style != 27 ? (style != 28 ? (style != 29 ? (style != 30 ? (style != 31 ? (style != 32 ? (style != 33 ? (style != 34 ? (style != 35 ? (style != 36 ? (style != 37 ? (style != 38 ? (style != 39 ? 334 : 4569) : 4301) : 4211) : 4190) : 4169) : 4148) : 3968) : 3934) : 3914) : 3913) : 3912) : 3911) : 3133) : 3134) : 3132) : 2816) : 2640) : 2639) : 2638) : 2637) : 2577) : 2562) : 2545) : 2529) : 2386 + style - 5) : 918) : 646 + style;
    }

    public static void Check3x4(int i, int j, int type)
    {
      if (WorldGen.destroyObject)
        return;
      bool flag = false;
      int num1 = i;
      int num2 = j;
      int num3 = 0;
      int num4 = 0;
      int num5 = (int) Main.tile[i, j].frameX / 18;
      int num6 = (int) Main.tile[i, j].frameY / 18;
      for (; num5 >= 3; num5 -= 3)
        ++num3;
      for (; num6 >= 4; num6 -= 4)
        ++num4;
      int num7 = num1 - num5;
      int num8 = num2 - num6;
      for (int i1 = num7; i1 < num7 + 3; ++i1)
      {
        for (int index = num8; index < num8 + 4; ++index)
        {
          if (Main.tile[i1, index] == null)
            Main.tile[i1, index] = new Tile();
          if (!Main.tile[i1, index].active() || (int) Main.tile[i1, index].type != type || ((int) Main.tile[i1, index].frameX != num3 * 54 + (i1 - num7) * 18 || (int) Main.tile[i1, index].frameY != num4 * 72 + (index - num8) * 18))
            flag = true;
        }
        if (Main.tile[i1, num8 + 4] == null)
          Main.tile[i1, num8 + 4] = new Tile();
        if (!WorldGen.SolidTileAllowBottomSlope(i1, num8 + 4))
          flag = true;
      }
      if (!flag)
        return;
      WorldGen.destroyObject = true;
      for (int i1 = num7; i1 < num7 + 3; ++i1)
      {
        for (int j1 = num8; j1 < num8 + 4; ++j1)
        {
          if ((int) Main.tile[i1, j1].type == type && Main.tile[i1, j1].active())
            WorldGen.KillTile(i1, j1, false, false, false);
        }
      }
      switch (type)
      {
        case 101:
          int Type1 = num3 != 1 ? (num3 != 2 ? (num3 != 3 ? (num3 != 4 ? (num3 != 5 ? (num3 != 6 ? (num3 != 7 ? (num3 != 8 ? (num3 != 9 ? (num3 != 10 ? (num3 != 11 ? (num3 != 12 ? (num3 != 13 ? (num3 != 14 ? (num3 != 15 ? (num3 != 16 ? (num3 != 17 ? (num3 < 18 || num3 > 21 ? (num3 != 22 ? (num3 != 23 ? (num3 != 24 ? (num3 != 25 ? (num3 != 26 ? (num3 != 27 ? (num3 != 28 ? (num3 != 29 ? (num3 != 30 ? (num3 != 31 ? (num3 != 32 ? (num3 != 33 ? (num3 != 34 ? (num3 != 35 ? (num3 != 36 ? (num3 != 37 ? (num3 != 38 ? (num3 != 39 ? (num3 != 40 ? 354 : 4568) : 4300) : 4210) : 4189) : 4168) : 4147) : 3960) : 3933) : 3917) : 3166) : 3167) : 3165) : 2817) : 2670) : 2569) : 2554) : 2540) : 2536) : 2233) : 2135 + num3 - 18) : 2031) : 2030) : 2029) : 2028) : 2027) : 2026) : 2025) : 2024) : 2023) : 2022) : 2021) : 2020) : 1512) : 1463) : 1416) : 1415) : 1414;
          Item.NewItem(i * 16, j * 16, 32, 32, Type1, 1, false, 0, false, false);
          break;
        case 102:
          Item.NewItem(i * 16, j * 16, 32, 32, 355, 1, false, 0, false, false);
          break;
        case 463:
          Item.NewItem(i * 16, j * 16, 32, 32, 3813, 1, false, 0, false, false);
          break;
        case 617:
          int Type2 = 4924 + num3;
          Item.NewItem(i * 16, j * 16, 32, 32, Type2, 1, false, 0, false, false);
          break;
      }
      WorldGen.destroyObject = false;
      for (int i1 = num7 - 1; i1 < num7 + 4; ++i1)
      {
        for (int j1 = num8 - 1; j1 < num8 + 4; ++j1)
          WorldGen.TileFrame(i1, j1, false, false);
      }
    }

    public static void Check5x4(int i, int j, int type)
    {
      if (WorldGen.destroyObject)
        return;
      bool flag = false;
      int num1 = i;
      int num2 = j;
      int num3 = 0;
      int num4;
      for (num4 = (int) Main.tile[i, j].frameX / 18; num4 >= 5; num4 -= 5)
        ++num3;
      int num5 = num1 - num4;
      int num6 = num2 + (int) Main.tile[i, j].frameY / 18 * -1;
      for (int i1 = num5; i1 < num5 + 5; ++i1)
      {
        for (int index = num6; index < num6 + 4; ++index)
        {
          if (Main.tile[i1, index] == null)
            Main.tile[i1, index] = new Tile();
          if (!Main.tile[i1, index].active() || (int) Main.tile[i1, index].type != type || ((int) Main.tile[i1, index].frameX != num3 * 90 + (i1 - num5) * 18 || (int) Main.tile[i1, index].frameY != (index - num6) * 18))
            flag = true;
        }
        if (Main.tile[i1, num6 + 4] == null)
          Main.tile[i1, num6 + 4] = new Tile();
        if (!WorldGen.SolidTileAllowBottomSlope(i1, num6 + 4))
          flag = true;
      }
      if (!flag)
        return;
      WorldGen.destroyObject = true;
      for (int i1 = num5; i1 < num5 + 5; ++i1)
      {
        for (int j1 = num6; j1 < num6 + 4; ++j1)
        {
          if ((int) Main.tile[i1, j1].type == type && Main.tile[i1, j1].active())
            WorldGen.KillTile(i1, j1, false, false, false);
        }
      }
      if (type == 464)
        Item.NewItem(i * 16, j * 16, 32, 32, 3814, 1, false, 0, false, false);
      if (type == 466)
        Item.NewItem(i * 16, j * 16, 32, 32, 3816, 1, false, 0, false, false);
      WorldGen.destroyObject = false;
      for (int i1 = num5 - 1; i1 < num5 + 6; ++i1)
      {
        for (int j1 = num6 - 1; j1 < num6 + 5; ++j1)
          WorldGen.TileFrame(i1, j1, false, false);
      }
    }

    public static void Check6x3(int i, int j, int type)
    {
      if (WorldGen.destroyObject)
        return;
      bool flag = false;
      int num1 = i;
      int num2 = j;
      int num3 = num1 + (int) Main.tile[i, j].frameX / 18 * -1;
      int num4 = num2 + (int) Main.tile[i, j].frameY / 18 * -1;
      for (int i1 = num3; i1 < num3 + 6; ++i1)
      {
        for (int index = num4; index < num4 + 3; ++index)
        {
          int num5 = (i1 - num3) * 18;
          if (Main.tile[i1, index] == null)
            Main.tile[i1, index] = new Tile();
          if (!Main.tile[i1, index].active() || (int) Main.tile[i1, index].type != type || ((int) Main.tile[i1, index].frameX != num5 || (int) Main.tile[i1, index].frameY != (index - num4) * 18))
            flag = true;
        }
        if (Main.tile[i1, num4 + 3] == null)
          Main.tile[i1, num4 + 3] = new Tile();
        if (!WorldGen.SolidTileAllowBottomSlope(i1, num4 + 3) && (!Main.tile[i1, num4 + 3].nactive() || !Main.tileSolidTop[(int) Main.tile[i1, num4 + 3].type] || Main.tile[i1, num4 + 3].frameY != (short) 0))
          flag = true;
      }
      if (!flag)
        return;
      WorldGen.destroyObject = true;
      for (int i1 = num3; i1 < num3 + 6; ++i1)
      {
        for (int j1 = num4; j1 < num4 + 3; ++j1)
        {
          if ((int) Main.tile[i1, j1].type == type && Main.tile[i1, j1].active())
            WorldGen.KillTile(i1, j1, false, false, false);
        }
      }
      if (type == 275)
        Item.NewItem(i * 16, j * 16, 32, 32, 2162, 1, false, 0, false, false);
      if (type == 413)
        Item.NewItem(i * 16, j * 16, 32, 32, 3565, 1, false, 0, false, false);
      if (type == 414)
        Item.NewItem(i * 16, j * 16, 32, 32, 3566, 1, false, 0, false, false);
      if (type == 276)
        Item.NewItem(i * 16, j * 16, 32, 32, 2163, 1, false, 0, false, false);
      if (type == 277)
        Item.NewItem(i * 16, j * 16, 32, 32, 2164, 1, false, 0, false, false);
      if (type == 278)
        Item.NewItem(i * 16, j * 16, 32, 32, 2165, 1, false, 0, false, false);
      if (type == 279)
        Item.NewItem(i * 16, j * 16, 32, 32, 2166, 1, false, 0, false, false);
      if (type == 280)
        Item.NewItem(i * 16, j * 16, 32, 32, 2167, 1, false, 0, false, false);
      if (type == 281)
        Item.NewItem(i * 16, j * 16, 32, 32, 2168, 1, false, 0, false, false);
      if (type == 296)
        Item.NewItem(i * 16, j * 16, 32, 32, 2186, 1, false, 0, false, false);
      if (type == 297)
        Item.NewItem(i * 16, j * 16, 32, 32, 2187, 1, false, 0, false, false);
      if (type == 309)
        Item.NewItem(i * 16, j * 16, 32, 32, 2206, 1, false, 0, false, false);
      if (type == 358)
        Item.NewItem(i * 16, j * 16, 32, 32, 3070, 1, false, 0, false, false);
      if (type == 359)
        Item.NewItem(i * 16, j * 16, 32, 32, 3071, 1, false, 0, false, false);
      if (type == 542)
        Item.NewItem(i * 16, j * 16, 32, 32, 4396, 1, false, 0, false, false);
      if (type == 550)
        Item.NewItem(i * 16, j * 16, 32, 32, 4461, 1, false, 0, false, false);
      if (type == 551)
        Item.NewItem(i * 16, j * 16, 32, 32, 4462, 1, false, 0, false, false);
      if (type == 553)
        Item.NewItem(i * 16, j * 16, 32, 32, 4473, 1, false, 0, false, false);
      if (type == 554)
        Item.NewItem(i * 16, j * 16, 32, 32, 4474, 1, false, 0, false, false);
      if (type == 558)
        Item.NewItem(i * 16, j * 16, 32, 32, 4481, 1, false, 0, false, false);
      if (type == 559)
        Item.NewItem(i * 16, j * 16, 32, 32, 4483, 1, false, 0, false, false);
      if (type == 599)
        Item.NewItem(i * 16, j * 16, 32, 32, 4882, 1, false, 0, false, false);
      if (type == 600)
        Item.NewItem(i * 16, j * 16, 32, 32, 4883, 1, false, 0, false, false);
      if (type == 601)
        Item.NewItem(i * 16, j * 16, 32, 32, 4884, 1, false, 0, false, false);
      if (type == 602)
        Item.NewItem(i * 16, j * 16, 32, 32, 4885, 1, false, 0, false, false);
      if (type == 603)
        Item.NewItem(i * 16, j * 16, 32, 32, 4886, 1, false, 0, false, false);
      if (type == 604)
        Item.NewItem(i * 16, j * 16, 32, 32, 4887, 1, false, 0, false, false);
      if (type == 605)
        Item.NewItem(i * 16, j * 16, 32, 32, 4888, 1, false, 0, false, false);
      if (type == 606)
        Item.NewItem(i * 16, j * 16, 32, 32, 4889, 1, false, 0, false, false);
      if (type == 607)
        Item.NewItem(i * 16, j * 16, 32, 32, 4890, 1, false, 0, false, false);
      if (type == 608)
        Item.NewItem(i * 16, j * 16, 32, 32, 4891, 1, false, 0, false, false);
      if (type == 609)
        Item.NewItem(i * 16, j * 16, 32, 32, 4892, 1, false, 0, false, false);
      if (type == 610)
        Item.NewItem(i * 16, j * 16, 32, 32, 4893, 1, false, 0, false, false);
      if (type == 611)
        Item.NewItem(i * 16, j * 16, 32, 32, 4894, 1, false, 0, false, false);
      if (type == 612)
        Item.NewItem(i * 16, j * 16, 32, 32, 4895, 1, false, 0, false, false);
      WorldGen.destroyObject = false;
      for (int i1 = num3 - 1; i1 < num3 + 7; ++i1)
      {
        for (int j1 = num4 - 1; j1 < num4 + 4; ++j1)
          WorldGen.TileFrame(i1, j1, false, false);
      }
    }

    public static void Place6x3(int x, int y, ushort type, int direction = -1, int style = 0)
    {
      if (x < 5 || x > Main.maxTilesX - 5 || (y < 5 || y > Main.maxTilesY - 5))
        return;
      bool flag = true;
      for (int i = x - 3; i < x + 3; ++i)
      {
        for (int index = y - 2; index <= y; ++index)
        {
          if (Main.tile[i, index] == null)
            Main.tile[i, index] = new Tile();
          if (Main.tile[i, index].active())
            flag = false;
        }
        if (Main.tile[i, y + 1] == null)
          Main.tile[i, y + 1] = new Tile();
        if (!WorldGen.SolidTile2(i, y + 1) && (!Main.tile[i, y + 1].nactive() || !Main.tileSolidTop[(int) Main.tile[i, y + 1].type] || Main.tile[i, y + 1].frameY != (short) 0))
          flag = false;
      }
      if (!flag)
        return;
      int num1 = 0;
      for (int index1 = x - 3; index1 < x + 3; ++index1)
      {
        int num2 = 0;
        for (int index2 = y - 2; index2 <= y; ++index2)
        {
          Main.tile[index1, index2].active(true);
          Main.tile[index1, index2].frameY = (short) num2;
          Main.tile[index1, index2].frameX = (short) num1;
          Main.tile[index1, index2].type = type;
          num2 += 18;
        }
        num1 += 18;
      }
    }

    public static void Place4x2(int x, int y, ushort type, int direction = -1, int style = 0)
    {
      if (x < 5 || x > Main.maxTilesX - 5 || (y < 5 || y > Main.maxTilesY - 5))
        return;
      bool flag = true;
      for (int i = x - 1; i < x + 3; ++i)
      {
        for (int index = y - 1; index < y + 1; ++index)
        {
          if (Main.tile[i, index] == null)
            Main.tile[i, index] = new Tile();
          if (Main.tile[i, index].active())
            flag = false;
        }
        if (Main.tile[i, y + 1] == null)
          Main.tile[i, y + 1] = new Tile();
        if (!WorldGen.SolidTile2(i, y + 1))
          flag = false;
      }
      short num1 = 0;
      if (direction == 1)
        num1 = (short) 72;
      int num2 = 36 * style;
      if (!flag)
        return;
      Main.tile[x - 1, y - 1].active(true);
      Main.tile[x - 1, y - 1].frameY = (short) num2;
      Main.tile[x - 1, y - 1].frameX = num1;
      Main.tile[x - 1, y - 1].type = type;
      Main.tile[x, y - 1].active(true);
      Main.tile[x, y - 1].frameY = (short) num2;
      Main.tile[x, y - 1].frameX = (short) (18 + (int) num1);
      Main.tile[x, y - 1].type = type;
      Main.tile[x + 1, y - 1].active(true);
      Main.tile[x + 1, y - 1].frameY = (short) num2;
      Main.tile[x + 1, y - 1].frameX = (short) (36 + (int) num1);
      Main.tile[x + 1, y - 1].type = type;
      Main.tile[x + 2, y - 1].active(true);
      Main.tile[x + 2, y - 1].frameY = (short) num2;
      Main.tile[x + 2, y - 1].frameX = (short) (54 + (int) num1);
      Main.tile[x + 2, y - 1].type = type;
      Main.tile[x - 1, y].active(true);
      Main.tile[x - 1, y].frameY = (short) (num2 + 18);
      Main.tile[x - 1, y].frameX = num1;
      Main.tile[x - 1, y].type = type;
      Main.tile[x, y].active(true);
      Main.tile[x, y].frameY = (short) (num2 + 18);
      Main.tile[x, y].frameX = (short) (18 + (int) num1);
      Main.tile[x, y].type = type;
      Main.tile[x + 1, y].active(true);
      Main.tile[x + 1, y].frameY = (short) (num2 + 18);
      Main.tile[x + 1, y].frameX = (short) (36 + (int) num1);
      Main.tile[x + 1, y].type = type;
      Main.tile[x + 2, y].active(true);
      Main.tile[x + 2, y].frameY = (short) (num2 + 18);
      Main.tile[x + 2, y].frameX = (short) (54 + (int) num1);
      Main.tile[x + 2, y].type = type;
    }

    public static void ShootFromCannon(
      int x,
      int y,
      int angle,
      int ammo,
      int Damage,
      float KnockBack,
      int owner)
    {
      float num1 = 14f;
      float num2 = 0.0f;
      float num3 = 0.0f;
      int Type = 162;
      if (ammo == 2)
        Type = 281;
      if (ammo == 3)
        Type = 178;
      if (ammo == 4)
      {
        Type = 601;
        num1 = 3f;
      }
      if (ammo == 5)
      {
        Type = 601;
        num1 = 3f;
      }
      int num4 = 0;
      int num5 = 0;
      if (ammo == 5)
        num4 = 1;
      if (ammo == 2)
        num5 = owner + 1;
      if (angle == 0)
      {
        num2 = 10f;
        num3 = 0.0f;
      }
      if (angle == 1)
      {
        num2 = 7.5f;
        num3 = -2.5f;
      }
      if (angle == 2)
      {
        num2 = 5f;
        num3 = -5f;
      }
      if (angle == 3)
      {
        num2 = 2.75f;
        num3 = -6f;
      }
      if (angle == 4)
      {
        num2 = 0.0f;
        num3 = -10f;
      }
      if (angle == 5)
      {
        num2 = -2.75f;
        num3 = -6f;
      }
      if (angle == 6)
      {
        num2 = -5f;
        num3 = -5f;
      }
      if (angle == 7)
      {
        num2 = -7.5f;
        num3 = -2.5f;
      }
      if (angle == 8)
      {
        num2 = -10f;
        num3 = 0.0f;
      }
      Vector2 vector2 = new Vector2((float) ((x + 2) * 16), (float) ((y + 2) * 16));
      float num6 = num2;
      float num7 = num3;
      float num8 = (float) Math.Sqrt((double) num6 * (double) num6 + (double) num7 * (double) num7);
      if (ammo == 4 || ammo == 5)
      {
        if (angle == 4)
          vector2.X += 5f;
        vector2.Y += 5f;
      }
      float num9 = num1 / num8;
      float SpeedX = num6 * num9;
      float SpeedY = num7 * num9;
      if (Main.myPlayer != owner && Main.netMode == 2 && (ammo == 4 || ammo == 5))
      {
        NetMessage.SendData(108, owner, -1, (NetworkText) null, Damage, KnockBack, (float) x, (float) y, angle, ammo, owner);
      }
      else
      {
        if (Main.netMode == 2)
          owner = Main.myPlayer;
        int index = Projectile.NewProjectile(vector2.X, vector2.Y, SpeedX, SpeedY, Type, Damage, KnockBack, owner, (float) num4, (float) num5);
        Main.projectile[index].originatedFromActivableTile = true;
      }
    }

    public static void SwitchCannon(int i, int j)
    {
      int num1 = (int) Main.tile[i, j].frameX / 18;
      while (num1 >= 4)
        num1 -= 4;
      int num2 = (int) Main.tile[i, j].frameY / 18;
      while (num2 >= 3)
        num2 -= 3;
      int num3 = 1;
      if (num1 < 2)
        num3 = -1;
      int index1 = i - num1;
      int index2 = j - num2;
      if (num3 == 1 && Main.tile[index1, index2].frameY <= (short) 52 || num3 == -1 && Main.tile[index1, index2].frameY >= (short) 432)
        return;
      int num4 = num3 * -54;
      for (int index3 = index1; index3 < index1 + 4; ++index3)
      {
        for (int index4 = index2; index4 < index2 + 3; ++index4)
        {
          if (Main.tile[index3, index4] == null)
            Main.tile[index3, index4] = new Tile();
          if (Main.tile[index3, index4].active() && Main.tile[index3, index4].type == (ushort) 209)
            Main.tile[index3, index4].frameY += (short) num4;
        }
      }
      NetMessage.SendTileSquare(-1, index1 + 1, index2 + 1, 4, TileChangeType.None);
    }

    public static void CheckCannon(int i, int j, int type)
    {
      if (WorldGen.destroyObject)
        return;
      bool flag = false;
      int num1 = (int) Main.tile[i, j].frameX / 18;
      int num2 = 0;
      for (; num1 >= 4; num1 -= 4)
        ++num2;
      int num3 = i - num1;
      int num4 = (int) Main.tile[i, j].frameY / 18;
      int num5 = 0;
      for (; num4 >= 3; num4 -= 3)
        num5 += 54;
      int num6 = j - num4;
      int num7 = 72 * num2;
      for (int i1 = num3; i1 < num3 + 4; ++i1)
      {
        int num8 = num5;
        for (int index = num6; index < num6 + 3; ++index)
        {
          if (Main.tile[i1, index] == null)
            Main.tile[i1, index] = new Tile();
          if (!Main.tile[i1, index].active() || (int) Main.tile[i1, index].type != type || ((int) Main.tile[i1, index].frameX != num7 || (int) Main.tile[i1, index].frameY != num8))
            flag = true;
          num8 += 18;
        }
        if (Main.tile[i1, num6 + 3] == null)
          Main.tile[i1, num6 + 3] = new Tile();
        if (!WorldGen.SolidTileAllowBottomSlope(i1, num6 + 3) && i1 != num3 && i1 != num3 + 3)
          flag = true;
        num7 += 18;
      }
      if (!flag)
        return;
      WorldGen.destroyObject = true;
      for (int i1 = num3; i1 < num3 + 4; ++i1)
      {
        for (int j1 = num6; j1 < num6 + 3; ++j1)
        {
          if ((int) Main.tile[i1, j1].type == type && Main.tile[i1, j1].active())
            WorldGen.KillTile(i1, j1, false, false, false);
        }
      }
      int Type = 928;
      switch (num2)
      {
        case 1:
          Type = 1337;
          break;
        case 2:
          Type = 3369;
          break;
        case 3:
        case 4:
          Type = 3664;
          break;
      }
      Item.NewItem(i * 16, j * 16, 32, 32, Type, 1, false, 0, false, false);
      WorldGen.destroyObject = false;
      for (int i1 = num3; i1 < num3 + 4; ++i1)
      {
        for (int j1 = num6; j1 < num6 + 3; ++j1)
          WorldGen.TileFrame(i1, j1, false, false);
      }
    }

    public static void PlaceCannon(int x, int y, ushort type, int style = 0)
    {
      if (x < 5 || x > Main.maxTilesX - 5 || (y < 5 || y > Main.maxTilesY - 5))
        return;
      bool flag = true;
      for (int i = x - 1; i < x + 3; ++i)
      {
        for (int index = y - 2; index < y + 1; ++index)
        {
          if (Main.tile[i, index] == null)
            Main.tile[i, index] = new Tile();
          if (Main.tile[i, index].active())
            flag = false;
        }
        if (Main.tile[i, y + 1] == null)
          Main.tile[i, y + 1] = new Tile();
        if (!WorldGen.SolidTile2(i, y + 1) && i != x - 1 && i != x + 2)
          flag = false;
      }
      int num1 = 72 * style;
      int num2 = 0;
      if (!flag)
        return;
      Main.tile[x - 1, y - 2].active(true);
      Main.tile[x - 1, y - 2].frameY = (short) num2;
      Main.tile[x - 1, y - 2].frameX = (short) num1;
      Main.tile[x - 1, y - 2].type = type;
      Main.tile[x, y - 2].active(true);
      Main.tile[x, y - 2].frameY = (short) num2;
      Main.tile[x, y - 2].frameX = (short) (18 + num1);
      Main.tile[x, y - 2].type = type;
      Main.tile[x + 1, y - 2].active(true);
      Main.tile[x + 1, y - 2].frameY = (short) num2;
      Main.tile[x + 1, y - 2].frameX = (short) (36 + num1);
      Main.tile[x + 1, y - 2].type = type;
      Main.tile[x + 2, y - 2].active(true);
      Main.tile[x + 2, y - 2].frameY = (short) num2;
      Main.tile[x + 2, y - 2].frameX = (short) (54 + num1);
      Main.tile[x + 2, y - 2].type = type;
      Main.tile[x - 1, y - 1].active(true);
      Main.tile[x - 1, y - 1].frameY = (short) (num2 + 18);
      Main.tile[x - 1, y - 1].frameX = (short) num1;
      Main.tile[x - 1, y - 1].type = type;
      Main.tile[x, y - 1].active(true);
      Main.tile[x, y - 1].frameY = (short) (num2 + 18);
      Main.tile[x, y - 1].frameX = (short) (18 + num1);
      Main.tile[x, y - 1].type = type;
      Main.tile[x + 1, y - 1].active(true);
      Main.tile[x + 1, y - 1].frameY = (short) (num2 + 18);
      Main.tile[x + 1, y - 1].frameX = (short) (36 + num1);
      Main.tile[x + 1, y - 1].type = type;
      Main.tile[x + 2, y - 1].active(true);
      Main.tile[x + 2, y - 1].frameY = (short) (num2 + 18);
      Main.tile[x + 2, y - 1].frameX = (short) (54 + num1);
      Main.tile[x + 2, y - 1].type = type;
      Main.tile[x - 1, y].active(true);
      Main.tile[x - 1, y].frameY = (short) (num2 + 36);
      Main.tile[x - 1, y].frameX = (short) num1;
      Main.tile[x - 1, y].type = type;
      Main.tile[x, y].active(true);
      Main.tile[x, y].frameY = (short) (num2 + 36);
      Main.tile[x, y].frameX = (short) (18 + num1);
      Main.tile[x, y].type = type;
      Main.tile[x + 1, y].active(true);
      Main.tile[x + 1, y].frameY = (short) (num2 + 36);
      Main.tile[x + 1, y].frameX = (short) (36 + num1);
      Main.tile[x + 1, y].type = type;
      Main.tile[x + 2, y].active(true);
      Main.tile[x + 2, y].frameY = (short) (num2 + 36);
      Main.tile[x + 2, y].frameX = (short) (54 + num1);
      Main.tile[x + 2, y].type = type;
    }

    public static void SwitchMB(int i, int j)
    {
      int num1 = (int) Main.tile[i, j].frameY / 18;
      while (num1 >= 2)
        num1 -= 2;
      int num2 = (int) Main.tile[i, j].frameX / 18;
      if (num2 >= 2)
        num2 -= 2;
      int num3 = i - num2;
      int num4 = j - num1;
      for (int index1 = num3; index1 < num3 + 2; ++index1)
      {
        for (int index2 = num4; index2 < num4 + 2; ++index2)
        {
          if (Main.tile[index1, index2] == null)
            Main.tile[index1, index2] = new Tile();
          if (Main.tile[index1, index2].active() && (Main.tile[index1, index2].type == (ushort) 139 || Main.tile[index1, index2].type == (ushort) 35))
          {
            if (Main.tile[index1, index2].frameX < (short) 36)
              Main.tile[index1, index2].frameX += (short) 36;
            else
              Main.tile[index1, index2].frameX -= (short) 36;
          }
        }
      }
      if (Wiring.running)
      {
        Wiring.SkipWire(num3, num4);
        Wiring.SkipWire(num3 + 1, num4);
        Wiring.SkipWire(num3, num4 + 1);
        Wiring.SkipWire(num3 + 1, num4 + 1);
      }
      NetMessage.SendTileSquare(-1, num3, num4, 3, TileChangeType.None);
    }

    public static void SwitchMonolith(int i, int j)
    {
      int num1 = (int) Main.tile[i, j].frameX / 18;
      while (num1 >= 2)
        num1 -= 2;
      int num2 = (int) Main.tile[i, j].frameY / 18;
      if (num2 >= 3)
        num2 -= 3;
      int num3 = i - num1;
      int y = j - num2;
      for (int index1 = num3; index1 < num3 + 2; ++index1)
      {
        for (int index2 = y; index2 < y + 3; ++index2)
        {
          if (Main.tile[index1, index2] == null)
            Main.tile[index1, index2] = new Tile();
          if (Main.tile[index1, index2].active())
          {
            if (Main.tile[index1, index2].type == (ushort) 410)
            {
              if (Main.tile[index1, index2].frameY < (short) 56)
                Main.tile[index1, index2].frameY += (short) 56;
              else
                Main.tile[index1, index2].frameY -= (short) 56;
            }
            else if (Main.tile[index1, index2].type == (ushort) 480)
            {
              if (Main.tile[index1, index2].frameY < (short) 54)
                Main.tile[index1, index2].frameY += (short) 54;
              else
                Main.tile[index1, index2].frameY -= (short) 54;
            }
            else if (Main.tile[index1, index2].type == (ushort) 509)
            {
              if (Main.tile[index1, index2].frameY < (short) 54)
                Main.tile[index1, index2].frameY += (short) 54;
              else
                Main.tile[index1, index2].frameY -= (short) 54;
            }
          }
        }
      }
      if (Wiring.running)
      {
        Wiring.SkipWire(num3, y);
        Wiring.SkipWire(num3, y + 1);
        Wiring.SkipWire(num3, y + 2);
        Wiring.SkipWire(num3 + 1, y);
        Wiring.SkipWire(num3 + 1, y + 1);
        Wiring.SkipWire(num3 + 1, y + 2);
      }
      NetMessage.SendTileSquare(-1, num3, y + 1, 3, TileChangeType.None);
    }

    public static void SwitchFountain(int i, int j)
    {
      int num1 = (int) Main.tile[i, j].frameX / 18;
      while (num1 >= 2)
        num1 -= 2;
      int num2 = (int) Main.tile[i, j].frameY / 18;
      if (num2 >= 4)
        num2 -= 4;
      int num3 = i - num1;
      int y = j - num2;
      for (int index1 = num3; index1 < num3 + 2; ++index1)
      {
        for (int index2 = y; index2 < y + 4; ++index2)
        {
          if (Main.tile[index1, index2] == null)
            Main.tile[index1, index2] = new Tile();
          if (Main.tile[index1, index2].active() && Main.tile[index1, index2].type == (ushort) 207)
          {
            if (Main.tile[index1, index2].frameY < (short) 72)
              Main.tile[index1, index2].frameY += (short) 72;
            else
              Main.tile[index1, index2].frameY -= (short) 72;
          }
        }
      }
      if (Wiring.running)
      {
        Wiring.SkipWire(num3, y);
        Wiring.SkipWire(num3, y + 1);
        Wiring.SkipWire(num3, y + 2);
        Wiring.SkipWire(num3, y + 3);
        Wiring.SkipWire(num3 + 1, y);
        Wiring.SkipWire(num3 + 1, y + 1);
        Wiring.SkipWire(num3 + 1, y + 2);
        Wiring.SkipWire(num3 + 1, y + 3);
      }
      NetMessage.SendTileSquare(-1, num3, y + 1, 4, TileChangeType.None);
    }

    public static void CheckMB(int i, int j, int type)
    {
      if (WorldGen.destroyObject)
        return;
      bool flag = false;
      int num1 = 0;
      int num2;
      for (num2 = (int) Main.tile[i, j].frameY / 18; num2 >= 2; num2 -= 2)
        ++num1;
      int num3 = (int) Main.tile[i, j].frameX / 18;
      int num4 = 0;
      if (num3 >= 2)
      {
        num3 -= 2;
        ++num4;
      }
      int num5 = i - num3;
      int num6 = j - num2;
      for (int index1 = num5; index1 < num5 + 2; ++index1)
      {
        for (int index2 = num6; index2 < num6 + 2; ++index2)
        {
          if (Main.tile[index1, index2] == null)
            Main.tile[index1, index2] = new Tile();
          if (!Main.tile[index1, index2].active() || (int) Main.tile[index1, index2].type != type || ((int) Main.tile[index1, index2].frameX != (index1 - num5) * 18 + num4 * 36 || (int) Main.tile[index1, index2].frameY != (index2 - num6) * 18 + num1 * 36))
            flag = true;
        }
        if (!Main.tile[index1, num6 + 2].nactive())
          flag = true;
        else if (!Main.tileSolid[(int) Main.tile[index1, num6 + 2].type] && !Main.tileTable[(int) Main.tile[index1, num6 + 2].type])
          flag = true;
      }
      if (!flag)
        return;
      WorldGen.destroyObject = true;
      for (int i1 = num5; i1 < num5 + 2; ++i1)
      {
        for (int j1 = num6; j1 < num6 + 3; ++j1)
        {
          if ((int) Main.tile[i1, j1].type == type && Main.tile[i1, j1].active())
            WorldGen.KillTile(i1, j1, false, false, false);
        }
      }
      if (type == 35)
        Item.NewItem(i * 16, j * 16, 32, 32, 1813, 1, false, 0, false, false);
      else if (num1 == 28)
        Item.NewItem(i * 16, j * 16, 32, 32, 1963, 1, false, 0, false, false);
      else if (num1 == 29)
        Item.NewItem(i * 16, j * 16, 32, 32, 1964, 1, false, 0, false, false);
      else if (num1 == 30)
        Item.NewItem(i * 16, j * 16, 32, 32, 1965, 1, false, 0, false, false);
      else if (num1 == 31)
        Item.NewItem(i * 16, j * 16, 32, 32, 2742, 1, false, 0, false, false);
      else if (num1 == 32)
        Item.NewItem(i * 16, j * 16, 32, 32, 3044, 1, false, 0, false, false);
      else if (num1 == 33)
        Item.NewItem(i * 16, j * 16, 32, 32, 3235, 1, false, 0, false, false);
      else if (num1 == 34)
        Item.NewItem(i * 16, j * 16, 32, 32, 3236, 1, false, 0, false, false);
      else if (num1 == 35)
        Item.NewItem(i * 16, j * 16, 32, 32, 3237, 1, false, 0, false, false);
      else if (num1 == 36)
        Item.NewItem(i * 16, j * 16, 32, 32, 3370, 1, false, 0, false, false);
      else if (num1 == 37)
        Item.NewItem(i * 16, j * 16, 32, 32, 3371, 1, false, 0, false, false);
      else if (num1 == 38)
        Item.NewItem(i * 16, j * 16, 32, 32, 3796, 1, false, 0, false, false);
      else if (num1 == 39)
        Item.NewItem(i * 16, j * 16, 32, 32, 3869, 1, false, 0, false, false);
      else if (num1 == 43)
        Item.NewItem(i * 16, j * 16, 32, 32, 4077, 1, false, 0, false, false);
      else if (num1 == 41)
        Item.NewItem(i * 16, j * 16, 32, 32, 4078, 1, false, 0, false, false);
      else if (num1 == 42)
        Item.NewItem(i * 16, j * 16, 32, 32, 4079, 1, false, 0, false, false);
      else if (num1 == 44)
        Item.NewItem(i * 16, j * 16, 32, 32, 4080, 1, false, 0, false, false);
      else if (num1 == 45)
        Item.NewItem(i * 16, j * 16, 32, 32, 4081, 1, false, 0, false, false);
      else if (num1 == 40)
        Item.NewItem(i * 16, j * 16, 32, 32, 4082, 1, false, 0, false, false);
      else if (num1 == 46)
        Item.NewItem(i * 16, j * 16, 32, 32, 4237, 1, false, 0, false, false);
      else if (num1 == 47)
        Item.NewItem(i * 16, j * 16, 32, 32, 4356, 1, false, 0, false, false);
      else if (num1 == 48)
        Item.NewItem(i * 16, j * 16, 32, 32, 4357, 1, false, 0, false, false);
      else if (num1 == 49)
        Item.NewItem(i * 16, j * 16, 32, 32, 4358, 1, false, 0, false, false);
      else if (num1 == 50)
        Item.NewItem(i * 16, j * 16, 32, 32, 4421, 1, false, 0, false, false);
      else if (num1 == 51)
        Item.NewItem(i * 16, j * 16, 32, 32, 4606, 1, false, 0, false, false);
      else if (num1 == 52)
        Item.NewItem(i * 16, j * 16, 32, 32, 4979, 1, false, 0, false, false);
      else if (num1 == 53)
        Item.NewItem(i * 16, j * 16, 32, 32, 4985, 1, false, 0, false, false);
      else if (num1 == 54)
        Item.NewItem(i * 16, j * 16, 32, 32, 4990, 1, false, 0, false, false);
      else if (num1 == 55)
        Item.NewItem(i * 16, j * 16, 32, 32, 4991, 1, false, 0, false, false);
      else if (num1 == 56)
        Item.NewItem(i * 16, j * 16, 32, 32, 4992, 1, false, 0, false, false);
      else if (num1 == 57)
        Item.NewItem(i * 16, j * 16, 32, 32, 5006, 1, false, 0, false, false);
      else if (num1 == 58)
        Item.NewItem(i * 16, j * 16, 32, 32, 5014, 1, false, 0, false, false);
      else if (num1 == 59)
        Item.NewItem(i * 16, j * 16, 32, 32, 5015, 1, false, 0, false, false);
      else if (num1 == 60)
        Item.NewItem(i * 16, j * 16, 32, 32, 5016, 1, false, 0, false, false);
      else if (num1 == 61)
        Item.NewItem(i * 16, j * 16, 32, 32, 5017, 1, false, 0, false, false);
      else if (num1 == 62)
        Item.NewItem(i * 16, j * 16, 32, 32, 5018, 1, false, 0, false, false);
      else if (num1 == 63)
        Item.NewItem(i * 16, j * 16, 32, 32, 5019, 1, false, 0, false, false);
      else if (num1 == 64)
        Item.NewItem(i * 16, j * 16, 32, 32, 5020, 1, false, 0, false, false);
      else if (num1 == 65)
        Item.NewItem(i * 16, j * 16, 32, 32, 5021, 1, false, 0, false, false);
      else if (num1 == 66)
        Item.NewItem(i * 16, j * 16, 32, 32, 5022, 1, false, 0, false, false);
      else if (num1 == 67)
        Item.NewItem(i * 16, j * 16, 32, 32, 5023, 1, false, 0, false, false);
      else if (num1 == 68)
        Item.NewItem(i * 16, j * 16, 32, 32, 5024, 1, false, 0, false, false);
      else if (num1 == 69)
        Item.NewItem(i * 16, j * 16, 32, 32, 5025, 1, false, 0, false, false);
      else if (num1 == 70)
        Item.NewItem(i * 16, j * 16, 32, 32, 5026, 1, false, 0, false, false);
      else if (num1 == 71)
        Item.NewItem(i * 16, j * 16, 32, 32, 5027, 1, false, 0, false, false);
      else if (num1 == 72)
        Item.NewItem(i * 16, j * 16, 32, 32, 5028, 1, false, 0, false, false);
      else if (num1 == 73)
        Item.NewItem(i * 16, j * 16, 32, 32, 5029, 1, false, 0, false, false);
      else if (num1 == 74)
        Item.NewItem(i * 16, j * 16, 32, 32, 5030, 1, false, 0, false, false);
      else if (num1 == 75)
        Item.NewItem(i * 16, j * 16, 32, 32, 5031, 1, false, 0, false, false);
      else if (num1 == 76)
        Item.NewItem(i * 16, j * 16, 32, 32, 5032, 1, false, 0, false, false);
      else if (num1 == 77)
        Item.NewItem(i * 16, j * 16, 32, 32, 5033, 1, false, 0, false, false);
      else if (num1 == 78)
        Item.NewItem(i * 16, j * 16, 32, 32, 5034, 1, false, 0, false, false);
      else if (num1 == 79)
        Item.NewItem(i * 16, j * 16, 32, 32, 5035, 1, false, 0, false, false);
      else if (num1 == 80)
        Item.NewItem(i * 16, j * 16, 32, 32, 5036, 1, false, 0, false, false);
      else if (num1 == 81)
        Item.NewItem(i * 16, j * 16, 32, 32, 5037, 1, false, 0, false, false);
      else if (num1 == 82)
        Item.NewItem(i * 16, j * 16, 32, 32, 5038, 1, false, 0, false, false);
      else if (num1 == 83)
        Item.NewItem(i * 16, j * 16, 32, 32, 5039, 1, false, 0, false, false);
      else if (num1 == 84)
        Item.NewItem(i * 16, j * 16, 32, 32, 5040, 1, false, 0, false, false);
      else if (num1 == 85)
        Item.NewItem(i * 16, j * 16, 32, 32, 5044, 1, false, 0, false, false);
      else if (num1 >= 13)
        Item.NewItem(i * 16, j * 16, 32, 32, 1596 + num1 - 13, 1, false, 0, false, false);
      else
        Item.NewItem(i * 16, j * 16, 32, 32, 562 + num1, 1, false, 0, false, false);
      for (int i1 = num5 - 1; i1 < num5 + 3; ++i1)
      {
        for (int j1 = num6 - 1; j1 < num6 + 3; ++j1)
          WorldGen.TileFrame(i1, j1, false, false);
      }
      WorldGen.destroyObject = false;
    }

    public static void PlaceMB(int X, int y, ushort type, int style)
    {
      int index1 = X + 1;
      if (index1 < 5 || index1 > Main.maxTilesX - 5 || (y < 5 || y > Main.maxTilesY - 5))
        return;
      bool flag = true;
      for (int index2 = index1 - 1; index2 < index1 + 1; ++index2)
      {
        for (int index3 = y - 1; index3 < y + 1; ++index3)
        {
          if (Main.tile[index2, index3] == null)
            Main.tile[index2, index3] = new Tile();
          if (Main.tile[index2, index3].active())
            flag = false;
        }
        if (Main.tile[index2, y + 1] == null)
          Main.tile[index2, y + 1] = new Tile();
        if (!Main.tile[index2, y + 1].active() || Main.tile[index2, y + 1].halfBrick() || !Main.tileSolid[(int) Main.tile[index2, y + 1].type] && !Main.tileTable[(int) Main.tile[index2, y + 1].type])
          flag = false;
      }
      if (!flag)
        return;
      Main.tile[index1 - 1, y - 1].active(true);
      Main.tile[index1 - 1, y - 1].frameY = (short) (style * 36);
      Main.tile[index1 - 1, y - 1].frameX = (short) 0;
      Main.tile[index1 - 1, y - 1].type = type;
      Main.tile[index1, y - 1].active(true);
      Main.tile[index1, y - 1].frameY = (short) (style * 36);
      Main.tile[index1, y - 1].frameX = (short) 18;
      Main.tile[index1, y - 1].type = type;
      Main.tile[index1 - 1, y].active(true);
      Main.tile[index1 - 1, y].frameY = (short) (style * 36 + 18);
      Main.tile[index1 - 1, y].frameX = (short) 0;
      Main.tile[index1 - 1, y].type = type;
      Main.tile[index1, y].active(true);
      Main.tile[index1, y].frameY = (short) (style * 36 + 18);
      Main.tile[index1, y].frameX = (short) 18;
      Main.tile[index1, y].type = type;
    }

    public static void Place2x2(int x, int y, ushort type, int style)
    {
      if (type == (ushort) 95 || type == (ushort) 126)
        ++y;
      if (x < 5 || x > Main.maxTilesX - 5 || (y < 5 || y > Main.maxTilesY - 5))
        return;
      if (type == (ushort) 172)
      {
        if (!WorldGen.CanPlaceSink(x, y, type, style))
          return;
      }
      else
      {
        for (int i = x - 1; i < x + 1; ++i)
        {
          for (int j = y - 1; j < y + 1; ++j)
          {
            Tile tileSafely = Framing.GetTileSafely(i, j);
            if (tileSafely.active() || type == (ushort) 98 && tileSafely.liquid > (byte) 0)
              return;
          }
          switch (type)
          {
            case 95:
            case 126:
              Tile tileSafely1 = Framing.GetTileSafely(i, y - 2);
              if (!tileSafely1.nactive() || !Main.tileSolid[(int) tileSafely1.type] || Main.tileSolidTop[(int) tileSafely1.type])
                return;
              continue;
            case 132:
              continue;
            default:
              Tile tileSafely2 = Framing.GetTileSafely(i, y + 1);
              if (!tileSafely2.nactive() || !WorldGen.SolidTile2(tileSafely2) && !Main.tileTable[(int) tileSafely2.type])
                return;
              continue;
          }
        }
      }
      if (type == (ushort) 132)
      {
        bool flag = true;
        if (Main.tile[x - 1, y + 1] == null)
          Main.tile[x - 1, y + 1] = new Tile();
        if (Main.tile[x, y + 1] == null)
          Main.tile[x, y + 1] = new Tile();
        if (!Main.tile[x - 1, y + 1].nactive() || !WorldGen.SolidTile2(x - 1, y + 1) && !Main.tileTable[(int) Main.tile[x - 1, y + 1].type])
          flag = false;
        if (!Main.tile[x, y + 1].nactive() || !WorldGen.SolidTile2(x, y + 1) && !Main.tileTable[(int) Main.tile[x, y + 1].type])
          flag = false;
        if (!flag && (Main.tile[x - 1, y - 1].wall < (ushort) 1 || Main.tile[x, y - 1].wall < (ushort) 1 || (Main.tile[x - 1, y].wall < (ushort) 1 || Main.tile[x - 1, y].wall < (ushort) 1)))
          return;
      }
      --x;
      --y;
      int num = type == (ushort) 172 ? 38 : 36;
      for (int index1 = 0; index1 < 2; ++index1)
      {
        for (int index2 = 0; index2 < 2; ++index2)
        {
          Tile tile = Main.tile[x + index1, y + index2];
          tile.active(true);
          tile.frameX = (short) (index1 * 18);
          tile.frameY = (short) (style * num + index2 * 18);
          tile.type = type;
        }
      }
    }

    public static bool PlaceObject(
      int x,
      int y,
      int type,
      bool mute = false,
      int style = 0,
      int alternate = 0,
      int random = -1,
      int direction = -1)
    {
      TileObject objectData;
      if (type >= 623 || !TileObject.CanPlace(x, y, type, style, direction, out objectData, false))
        return false;
      objectData.random = random;
      if (TileObject.Place(objectData) && !mute)
      {
        WorldGen.SquareTileFrame(x, y, true);
        SoundEngine.PlaySound(0, x * 16, y * 16, 1, 1f, 0.0f);
      }
      return true;
    }

    public static bool ShiftTrapdoor(int x, int y, bool playerAbove, int onlyCloseOrOpen = -1)
    {
      Tile tileSafely1 = Framing.GetTileSafely(x, y);
      if (tileSafely1.type == (ushort) 386 && onlyCloseOrOpen != 1)
      {
        Point topLeftAndStyles = WorldGen.GetTopLeftAndStyles(ref x, ref y, 2, 2, 18, 18);
        if (topLeftAndStyles.X == 0)
        {
          if (Main.netMode != 1 && Wiring.running)
          {
            Wiring.SkipWire(x, y);
            Wiring.SkipWire(x, y + 1);
            Wiring.SkipWire(x + 1, y);
            Wiring.SkipWire(x + 1, y + 1);
          }
          if (!Collision.EmptyTile(x, y + 1, true) || !Collision.EmptyTile(x + 1, y + 1, true))
            return false;
          SoundEngine.PlaySound(8, x * 16 + 16, y * 16 + 16, 1, 1f, 0.0f);
          for (int index = 0; index < 2; ++index)
            Framing.GetTileSafely(x + index, y).ClearTile();
          for (int index = 0; index < 2; ++index)
          {
            Tile tileSafely2 = Framing.GetTileSafely(x + index, y + 1);
            tileSafely2.type = (ushort) 387;
            tileSafely2.frameX = (short) (index * 18);
            tileSafely2.frameY = (short) (topLeftAndStyles.Y * 18);
          }
          for (int index1 = -1; index1 < 3; ++index1)
          {
            for (int index2 = 0; index2 < 3; ++index2)
              WorldGen.TileFrame(x + index1, y + index2, false, false);
          }
          return true;
        }
        if (topLeftAndStyles.X == 1)
        {
          if (Main.netMode != 1 && Wiring.running)
          {
            Wiring.SkipWire(x, y - 1);
            Wiring.SkipWire(x, y);
            Wiring.SkipWire(x + 1, y - 1);
            Wiring.SkipWire(x + 1, y);
          }
          if (!Collision.EmptyTile(x, y, true) || !Collision.EmptyTile(x + 1, y, true))
            return false;
          SoundEngine.PlaySound(8, x * 16 + 16, y * 16, 1, 1f, 0.0f);
          for (int index = 0; index < 2; ++index)
            Framing.GetTileSafely(x + index, y + 1).ClearTile();
          for (int index = 0; index < 2; ++index)
          {
            Tile tileSafely2 = Framing.GetTileSafely(x + index, y);
            tileSafely2.type = (ushort) 387;
            tileSafely2.frameX = (short) (index * 18);
            tileSafely2.frameY = (short) (topLeftAndStyles.Y * 18);
          }
          for (int index1 = -1; index1 < 3; ++index1)
          {
            for (int index2 = -1; index2 < 2; ++index2)
              WorldGen.TileFrame(x + index1, y + index2, false, false);
          }
          return true;
        }
      }
      if (tileSafely1.type == (ushort) 387 && onlyCloseOrOpen != 0)
      {
        WorldGen.GetTopLeftAndStyles(ref x, ref y, 2, 1, 18, 18);
        int directionInt = playerAbove.ToDirectionInt();
        for (int index = 0; index < 2; ++index)
        {
          Tile tileSafely2 = Framing.GetTileSafely(x + index, y + directionInt);
          if (tileSafely2.active() && !Main.tileCut[(int) tileSafely2.type])
            return false;
        }
        if (Main.netMode != 1 && Wiring.running)
        {
          Wiring.SkipWire(x, y);
          Wiring.SkipWire(x, y + directionInt);
          Wiring.SkipWire(x + 1, y);
          Wiring.SkipWire(x + 1, y + directionInt);
        }
        SoundEngine.PlaySound(8, x * 16 + 16, y * 16, 1, 1f, 0.0f);
        for (int index = 0; index < 2; ++index)
        {
          Tile tileSafely2 = Framing.GetTileSafely(x + index, y + directionInt);
          if (tileSafely2.active() && Main.tileCut[(int) tileSafely2.type])
            WorldGen.KillTile(x + index, y + directionInt, false, false, false);
        }
        for (int index1 = 0; index1 < 2; ++index1)
        {
          byte color = Framing.GetTileSafely(x + index1, y).color();
          for (int index2 = 0; index2 < 2; ++index2)
          {
            Tile tileSafely2 = Framing.GetTileSafely(x + index1, y + index2 - (!playerAbove).ToInt());
            tileSafely2.type = (ushort) 386;
            tileSafely2.frameX = (short) (index1 * 18 + playerAbove.ToInt() * 36);
            tileSafely2.frameY = (short) (index2 * 18);
            tileSafely2.color(color);
            tileSafely2.active(true);
          }
        }
        for (int index1 = -1; index1 < 3; ++index1)
        {
          for (int index2 = -1; index2 < 3; ++index2)
            WorldGen.TileFrame(x + index1, y + index2 - (!playerAbove).ToInt() * 2, false, false);
        }
        return true;
      }
      SoundEngine.PlaySound(9, x * 16, y * 16, 1, 1f, 0.0f);
      return false;
    }

    public static void CheckTrapDoor(int x, int y, int type)
    {
      if (WorldGen.destroyObject)
        return;
      bool flag = false;
      int w = 0;
      int h = 0;
      Point point = new Point();
      if (type == 387)
      {
        w = 2;
        h = 1;
        point = WorldGen.GetTopLeftAndStyles(ref x, ref y, w, h, 18, 18);
        flag = flag || !WorldGen.CheckTileFrames(type, x, y, w, h, point.X, 18, point.Y, 18) || !WorldGen.CheckTileAnchors(x, y, w, h, 1, AnchorType.SolidTile);
      }
      if (type == 386)
      {
        w = 2;
        h = 2;
        point = WorldGen.GetTopLeftAndStyles(ref x, ref y, w, h, 18, 18);
        flag = flag || !WorldGen.CheckTileFrames(type, x, y, w, h, point.X, 18, point.Y, 18);
        if (point.X == 0)
          flag = flag || !WorldGen.CheckTileAnchors(x, y + 1, w, 1, 1, AnchorType.SolidTile);
        else if (point.X == 1)
          flag = flag || !WorldGen.CheckTileAnchors(x, y, w, 1, 1, AnchorType.SolidTile);
      }
      if (!flag)
        return;
      WorldGen.destroyObject = true;
      for (int i = x; i < x + w; ++i)
      {
        for (int j = y; j < y + h; ++j)
          WorldGen.KillTile(i, j, false, false, false);
      }
      int Type = 3239;
      if (point.Y == 0)
        Type = 3239;
      Item.NewItem(x * 16, y * 16, w * 16, h * 16, Type, 1, false, 0, false, false);
      for (int i = x - 1; i < x + w + 1; ++i)
      {
        for (int j = y - 1; j < y + h + 1; ++j)
          WorldGen.TileFrame(i, j, false, false);
      }
      WorldGen.destroyObject = false;
    }

    public static void CheckTallGate(int x, int y, int type)
    {
      if (WorldGen.destroyObject)
        return;
      bool flag = false;
      Tile tileSafely1 = Framing.GetTileSafely(x, y);
      Point point = new Point((int) tileSafely1.frameX / 18, 0);
      TileObjectData tileData = TileObjectData.GetTileData(type, point.X, 0);
      point.Y = (int) tileSafely1.frameY / tileData.CoordinateFullHeight;
      int width = tileData.Width;
      int height = tileData.Height;
      int index1 = 0;
      for (int index2 = (int) tileSafely1.frameY % tileData.CoordinateFullHeight; index1 < height && index2 - tileData.CoordinateHeights[index1] >= 0; ++index1)
        index2 -= tileData.CoordinateHeights[index1];
      int coordinateFullHeight = tileData.CoordinateFullHeight;
      y -= index1;
      int num = point.Y * tileData.CoordinateFullHeight;
      for (int index2 = 0; index2 < height; ++index2)
      {
        Tile tileSafely2 = Framing.GetTileSafely(x, y + index2);
        if ((int) tileSafely2.frameX != point.X * tileData.CoordinateFullWidth || (int) tileSafely2.frameY != num)
        {
          flag = true;
          break;
        }
        num += tileData.CoordinateHeights[index2] + tileData.CoordinatePadding;
      }
      if (!flag && WorldGen.CheckTileAnchors(x, y, width, height, 2, AnchorType.SolidTile))
        return;
      WorldGen.destroyObject = true;
      for (int i = x; i < x + width; ++i)
      {
        for (int j = y; j < y + height; ++j)
          WorldGen.KillTile(i, j, false, false, false);
      }
      int Type = 3240;
      if (point.Y == 0)
        Type = 3240;
      Item.NewItem(x * 16, y * 16, width * 16, height * 16, Type, 1, false, 0, false, false);
      for (int i = x - 1; i < x + width + 1; ++i)
      {
        for (int j = y - 1; j < y + height + 1; ++j)
          WorldGen.TileFrame(i, j, false, false);
      }
      WorldGen.destroyObject = false;
    }

    public static bool ShiftTallGate(int x, int y, bool closing, bool forced = false)
    {
      ushort num1 = closing ? (ushort) 388 : (ushort) 389;
      ushort num2 = closing ? (ushort) 389 : (ushort) 388;
      Tile tileSafely = Framing.GetTileSafely(x, y);
      if ((int) tileSafely.type != (int) num2)
        return false;
      Point point = new Point((int) tileSafely.frameX / 18, 0);
      TileObjectData tileData = TileObjectData.GetTileData(388, point.X, 0);
      point.Y = (int) tileSafely.frameY / tileData.CoordinateFullHeight;
      int width = tileData.Width;
      int height = tileData.Height;
      int index1 = 0;
      for (int index2 = (int) tileSafely.frameY % tileData.CoordinateFullHeight; index1 < height && index2 - tileData.CoordinateHeights[index1] >= 0; ++index1)
        index2 -= tileData.CoordinateHeights[index1];
      int coordinateFullHeight = tileData.CoordinateFullHeight;
      y -= index1;
      if (Main.netMode != 1 && Wiring.running)
      {
        for (int index2 = 0; index2 < height; ++index2)
          Wiring.SkipWire(x, y + index2);
      }
      for (int index2 = 0; index2 < height; ++index2)
      {
        if (!forced && !Collision.EmptyTile(x, y + index2, true))
          return false;
      }
      SoundEngine.PlaySound(8, x * 16 + 16, y * 16 + 16, 1, 1f, 0.0f);
      for (int index2 = 0; index2 < height; ++index2)
        Framing.GetTileSafely(x, y + index2).type = num1;
      for (int index2 = -1; index2 < 2; ++index2)
      {
        for (int index3 = -1; index3 < height + 1; ++index3)
          WorldGen.TileFrame(x + index2, y + index3, false, false);
      }
      return true;
    }

    public static Point GetTopLeftAndStyles(
      ref int x,
      ref int y,
      int w,
      int h,
      int frameXinc,
      int frameYinc)
    {
      Tile tileSafely = Framing.GetTileSafely(x, y);
      Point point = new Point((int) tileSafely.frameX / (w * frameXinc), (int) tileSafely.frameY / (h * frameYinc));
      if (frameXinc != 0)
        x -= (int) tileSafely.frameX / frameXinc % w;
      if (frameYinc == 0)
        return point;
      y -= (int) tileSafely.frameY / frameYinc % h;
      return point;
    }

    public static bool CheckTileFrames(
      int type,
      int sx,
      int sy,
      int w,
      int h,
      int styleX,
      int frameXinc,
      int styleY,
      int frameYinc)
    {
      for (int index1 = 0; index1 < w; ++index1)
      {
        for (int index2 = 0; index2 < h; ++index2)
        {
          Tile tileSafely = Framing.GetTileSafely(sx + index1, sy + index2);
          if (!tileSafely.active() || (int) tileSafely.type != type || ((int) tileSafely.frameX != styleX * w * frameXinc + index1 * frameXinc || (int) tileSafely.frameY != styleY * h * frameYinc + index2 * frameYinc))
            return false;
        }
      }
      return true;
    }

    public static bool CheckTileAnchors(
      int sx,
      int sy,
      int w,
      int h,
      int mode,
      AnchorType anchor)
    {
      if ((mode & 1) == 1)
      {
        for (int j = sy; j < sy + h; ++j)
        {
          if (!WorldGen.AnchorValid(Framing.GetTileSafely(sx - 1, j), anchor) || !WorldGen.AnchorValid(Framing.GetTileSafely(sx + w, j), anchor))
            return false;
        }
      }
      if ((mode & 2) == 2)
      {
        for (int i = sx; i < sx + w; ++i)
        {
          if (!WorldGen.AnchorValid(Framing.GetTileSafely(i, sy - 1), anchor) || !WorldGen.AnchorValid(Framing.GetTileSafely(i, sy + h), anchor))
            return false;
        }
      }
      return true;
    }

    public static bool AnchorValid(Tile tileCache, AnchorType anchor)
    {
      bool flag = false;
      if (tileCache.nactive())
      {
        if ((anchor & AnchorType.SolidTile) == AnchorType.SolidTile && Main.tileSolid[(int) tileCache.type] && (!Main.tileSolidTop[(int) tileCache.type] && !Main.tileNoAttach[(int) tileCache.type]) && tileCache.blockType() == 0)
          flag = true;
        if ((anchor & AnchorType.SolidBottom) == AnchorType.SolidBottom && (Main.tileSolid[(int) tileCache.type] && (!Main.tileSolidTop[(int) tileCache.type] || TileID.Sets.Platforms[(int) tileCache.type] && (tileCache.halfBrick() || tileCache.topSlope())) || (tileCache.topSlope() || tileCache.halfBrick())) && (!TileID.Sets.NotReallySolid[(int) tileCache.type] && !tileCache.bottomSlope()))
          flag = true;
        if (!flag && ((anchor & AnchorType.SolidWithTop) == AnchorType.SolidWithTop || (anchor & AnchorType.Table) == AnchorType.Table))
        {
          if (TileID.Sets.Platforms[(int) tileCache.type])
          {
            int num = (int) tileCache.frameX / TileObjectData.PlatformFrameWidth();
            if (!tileCache.halfBrick() && num >= 0 && num <= 7 || (num >= 12 && num <= 16 || num >= 25 && num <= 26))
              flag = true;
          }
          else if (Main.tileSolid[(int) tileCache.type] && Main.tileSolidTop[(int) tileCache.type])
            flag = true;
        }
        if (!flag && (anchor & AnchorType.Table) == AnchorType.Table && (!TileID.Sets.Platforms[(int) tileCache.type] && Main.tileTable[(int) tileCache.type]) && tileCache.blockType() == 0)
          flag = true;
        if (!flag && (anchor & AnchorType.SolidSide) == AnchorType.SolidSide && (Main.tileSolid[(int) tileCache.type] && !Main.tileSolidTop[(int) tileCache.type]))
        {
          switch (tileCache.blockType())
          {
            case 4:
            case 5:
              flag = true;
              break;
          }
        }
      }
      else if (!flag && (anchor & AnchorType.EmptyTile) == AnchorType.EmptyTile)
        flag = true;
      return flag;
    }

    public static bool CanPlaceSink(int x, int y, ushort type, int style)
    {
      if (x < 5 || x > Main.maxTilesX - 5 || (y < 5 || y > Main.maxTilesY - 5))
        return false;
      bool flag = true;
      --x;
      --y;
      for (int index1 = 0; index1 < 2; ++index1)
      {
        for (int index2 = 0; index2 < 2; ++index2)
        {
          if (Framing.GetTileSafely(x + index1, y + index2).active())
            flag = false;
        }
        Tile tileSafely = Framing.GetTileSafely(x + index1, y + 2);
        if (!tileSafely.nactive() || !WorldGen.SolidTile(tileSafely))
          flag = false;
      }
      return flag;
    }

    public static void Place3x4(int x, int y, ushort type, int style)
    {
      if (x < 5 || x > Main.maxTilesX - 5 || (y < 5 || y > Main.maxTilesY - 5))
        return;
      bool flag = true;
      for (int i = x - 1; i < x + 2; ++i)
      {
        for (int index = y - 3; index < y + 1; ++index)
        {
          if (Main.tile[i, index] == null)
            Main.tile[i, index] = new Tile();
          if (Main.tile[i, index].active())
            flag = false;
        }
        if (Main.tile[i, y + 1] == null)
          Main.tile[i, y + 1] = new Tile();
        if (!WorldGen.SolidTile2(i, y + 1))
          flag = false;
      }
      if (!flag)
        return;
      int num1 = style * 54;
      for (int index = -3; index <= 0; ++index)
      {
        short num2 = (short) ((3 + index) * 18);
        Main.tile[x - 1, y + index].active(true);
        Main.tile[x - 1, y + index].frameY = num2;
        Main.tile[x - 1, y + index].frameX = (short) num1;
        Main.tile[x - 1, y + index].type = type;
        Main.tile[x, y + index].active(true);
        Main.tile[x, y + index].frameY = num2;
        Main.tile[x, y + index].frameX = (short) (num1 + 18);
        Main.tile[x, y + index].type = type;
        Main.tile[x + 1, y + index].active(true);
        Main.tile[x + 1, y + index].frameY = num2;
        Main.tile[x + 1, y + index].frameX = (short) (num1 + 36);
        Main.tile[x + 1, y + index].type = type;
      }
    }

    public static void Place5x4(int x, int y, ushort type, int style)
    {
      if (x < 5 || x > Main.maxTilesX - 5 || (y < 5 || y > Main.maxTilesY - 5))
        return;
      bool flag = true;
      for (int i = x - 2; i < x + 3; ++i)
      {
        for (int index = y - 3; index < y + 1; ++index)
        {
          if (Main.tile[i, index] == null)
            Main.tile[i, index] = new Tile();
          if (Main.tile[i, index].active())
            flag = false;
        }
        if (Main.tile[i, y + 1] == null)
          Main.tile[i, y + 1] = new Tile();
        if (!WorldGen.SolidTile2(i, y + 1))
          flag = false;
      }
      if (!flag)
        return;
      int num1 = style * 54;
      for (int index = -3; index <= 0; ++index)
      {
        short num2 = (short) ((3 + index) * 18);
        Main.tile[x - 2, y + index].active(true);
        Main.tile[x - 2, y + index].frameY = num2;
        Main.tile[x - 2, y + index].frameX = (short) (num1 - 36);
        Main.tile[x - 2, y + index].type = type;
        Main.tile[x - 1, y + index].active(true);
        Main.tile[x - 1, y + index].frameY = num2;
        Main.tile[x - 1, y + index].frameX = (short) (num1 - 18);
        Main.tile[x - 1, y + index].type = type;
        Main.tile[x, y + index].active(true);
        Main.tile[x, y + index].frameY = num2;
        Main.tile[x, y + index].frameX = (short) num1;
        Main.tile[x, y + index].type = type;
        Main.tile[x + 1, y + index].active(true);
        Main.tile[x + 1, y + index].frameY = num2;
        Main.tile[x + 1, y + index].frameX = (short) (num1 + 18);
        Main.tile[x + 1, y + index].type = type;
        Main.tile[x + 1, y + index].active(true);
        Main.tile[x + 1, y + index].frameY = num2;
        Main.tile[x + 1, y + index].frameX = (short) (num1 + 36);
        Main.tile[x + 1, y + index].type = type;
      }
    }

    public static void Place3x1(int x, int y, ushort type, int style = 0)
    {
      if (x < 5 || x > Main.maxTilesX - 5 || (y < 5 || y > Main.maxTilesY - 5))
        return;
      bool flag = true;
      for (int i = x - 1; i < x + 2; ++i)
      {
        int index = y;
        if (Main.tile[i, index] == null)
          Main.tile[i, index] = new Tile();
        if (Main.tile[i, index].active())
          flag = false;
        if (Main.tile[i, y + 1] == null)
          Main.tile[i, y + 1] = new Tile();
        if (!WorldGen.SolidTile2(i, y + 1))
          flag = false;
      }
      if (!flag)
        return;
      short num = (short) (54 * style);
      Main.tile[x - 1, y].active(true);
      Main.tile[x - 1, y].frameY = (short) 0;
      Main.tile[x - 1, y].frameX = num;
      Main.tile[x - 1, y].type = type;
      Main.tile[x, y].active(true);
      Main.tile[x, y].frameY = (short) 0;
      Main.tile[x, y].frameX = (short) ((int) num + 18);
      Main.tile[x, y].type = type;
      Main.tile[x + 1, y].active(true);
      Main.tile[x + 1, y].frameY = (short) 0;
      Main.tile[x + 1, y].frameX = (short) ((int) num + 36);
      Main.tile[x + 1, y].type = type;
    }

    public static void Place3x2(int x, int y, ushort type, int style = 0)
    {
      if (x < 5 || x > Main.maxTilesX - 5 || (y < 5 || y > Main.maxTilesY - 5))
        return;
      bool flag1 = false;
      bool flag2 = true;
      if (type == (ushort) 14 && style == 25)
        flag1 = true;
      int num1 = y - 1;
      if (flag1)
        num1 = y;
      for (int i = x - 1; i < x + 2; ++i)
      {
        for (int index = num1; index < y + 1; ++index)
        {
          if (Main.tile[i, index] == null)
            Main.tile[i, index] = new Tile();
          if (Main.tile[i, index].active())
            flag2 = false;
          if (type == (ushort) 215 && Main.tile[i, index].liquid > (byte) 0)
            flag2 = false;
        }
        if (Main.tile[i, y + 1] == null)
          Main.tile[i, y + 1] = new Tile();
        if (type == (ushort) 285 || type == (ushort) 286 || (type == (ushort) 298 || type == (ushort) 299) || (type == (ushort) 310 || type >= (ushort) 361 && type <= (ushort) 364) || (type == (ushort) 582 || type == (ushort) 619))
        {
          if (!WorldGen.SolidTile2(i, y + 1) && (!Main.tile[i, y + 1].nactive() || !Main.tileSolidTop[(int) Main.tile[i, y + 1].type] || Main.tile[i, y + 1].frameY != (short) 0))
            flag2 = false;
        }
        else
        {
          if (type == (ushort) 26 && Main.tile[i, y + 1].type == (ushort) 484)
            flag2 = false;
          if (!WorldGen.SolidTile2(i, y + 1))
            flag2 = false;
        }
      }
      if (type == (ushort) 88)
      {
        if (Chest.CreateChest(x - 1, y - 1, -1) == -1)
          flag2 = false;
        else if (Main.netMode == 1)
          NetMessage.SendData(34, -1, -1, (NetworkText) null, 2, (float) x, (float) y, (float) style, 0, 0, 0);
      }
      if (!flag2)
        return;
      short num2 = (short) (54 * style);
      if (flag1)
      {
        Main.tile[x - 1, y].active(true);
        Main.tile[x - 1, y].frameY = (short) 0;
        Main.tile[x - 1, y].frameX = num2;
        Main.tile[x - 1, y].type = type;
        Main.tile[x, y].active(true);
        Main.tile[x, y].frameY = (short) 0;
        Main.tile[x, y].frameX = (short) ((int) num2 + 18);
        Main.tile[x, y].type = type;
        Main.tile[x + 1, y].active(true);
        Main.tile[x + 1, y].frameY = (short) 0;
        Main.tile[x + 1, y].frameX = (short) ((int) num2 + 36);
        Main.tile[x + 1, y].type = type;
      }
      else
      {
        Main.tile[x - 1, y - 1].active(true);
        Main.tile[x - 1, y - 1].frameY = (short) 0;
        Main.tile[x - 1, y - 1].frameX = num2;
        Main.tile[x - 1, y - 1].type = type;
        Main.tile[x, y - 1].active(true);
        Main.tile[x, y - 1].frameY = (short) 0;
        Main.tile[x, y - 1].frameX = (short) ((int) num2 + 18);
        Main.tile[x, y - 1].type = type;
        Main.tile[x + 1, y - 1].active(true);
        Main.tile[x + 1, y - 1].frameY = (short) 0;
        Main.tile[x + 1, y - 1].frameX = (short) ((int) num2 + 36);
        Main.tile[x + 1, y - 1].type = type;
        Main.tile[x - 1, y].active(true);
        Main.tile[x - 1, y].frameY = (short) 18;
        Main.tile[x - 1, y].frameX = num2;
        Main.tile[x - 1, y].type = type;
        Main.tile[x, y].active(true);
        Main.tile[x, y].frameY = (short) 18;
        Main.tile[x, y].frameX = (short) ((int) num2 + 18);
        Main.tile[x, y].type = type;
        Main.tile[x + 1, y].active(true);
        Main.tile[x + 1, y].frameY = (short) 18;
        Main.tile[x + 1, y].frameX = (short) ((int) num2 + 36);
        Main.tile[x + 1, y].type = type;
      }
    }

    public static void Place2x2Style(int x, int y, ushort type, int style = 0)
    {
      if (x < 5 || x > Main.maxTilesX - 5 || (y < 5 || y > Main.maxTilesY - 5))
        return;
      short num1 = 0;
      if (type == (ushort) 254)
        num1 = (short) ((int) (short) (x % 12 / 2) * 36);
      bool flag = true;
      for (int i = x - 1; i < x + 1; ++i)
      {
        for (int index = y - 1; index < y + 1; ++index)
        {
          if (Main.tile[i, index] == null)
            Main.tile[i, index] = new Tile();
          if (Main.tile[i, index].active())
            flag = false;
        }
        if (Main.tile[i, y + 1] == null)
          Main.tile[i, y + 1] = new Tile();
        if (!WorldGen.SolidTile(i, y + 1, false))
          flag = false;
        if (type == (ushort) 254 && Main.tile[i, y + 1].type != (ushort) 2 && (Main.tile[i, y + 1].type != (ushort) 477 && Main.tile[i, y + 1].type != (ushort) 492) && Main.tile[i, y + 1].type != (ushort) 109)
          flag = false;
      }
      if (!flag)
        return;
      short num2 = (short) (36 * style);
      Main.tile[x - 1, y - 1].active(true);
      Main.tile[x - 1, y - 1].frameY = num1;
      Main.tile[x - 1, y - 1].frameX = num2;
      Main.tile[x - 1, y - 1].type = type;
      Main.tile[x, y - 1].active(true);
      Main.tile[x, y - 1].frameY = num1;
      Main.tile[x, y - 1].frameX = (short) ((int) num2 + 18);
      Main.tile[x, y - 1].type = type;
      Main.tile[x - 1, y].active(true);
      Main.tile[x - 1, y].frameY = (short) ((int) num1 + 18);
      Main.tile[x - 1, y].frameX = num2;
      Main.tile[x - 1, y].type = type;
      Main.tile[x, y].active(true);
      Main.tile[x, y].frameY = (short) ((int) num1 + 18);
      Main.tile[x, y].frameX = (short) ((int) num2 + 18);
      Main.tile[x, y].type = type;
    }

    public static bool NearFriendlyWall(int x, int y)
    {
      try
      {
        if (x < 2 || x >= Main.maxTilesX - 2 || (y < 2 || y >= Main.maxTilesY - 2) || (Main.tile[x, y].wall == (ushort) 0 || Main.wallHouse[(int) Main.tile[x, y].wall]) || (Main.tile[x - 1, y].wall == (ushort) 0 || Main.wallHouse[(int) Main.tile[x - 1, y].wall] || (Main.tile[x + 1, y].wall == (ushort) 0 || Main.wallHouse[(int) Main.tile[x + 1, y].wall])) || (Main.tile[x, y - 1].wall == (ushort) 0 || Main.wallHouse[(int) Main.tile[x, y - 1].wall] || Main.tile[x, y + 1].wall == (ushort) 0))
          return true;
        if (Main.wallHouse[(int) Main.tile[x, y + 1].wall])
          return true;
      }
      catch
      {
      }
      return false;
    }

    public static void Check2x2Style(int i, int j, int type)
    {
      if (WorldGen.destroyObject)
        return;
      bool flag = false;
      int num1 = j;
      int num2 = (int) Main.tile[i, j].frameY / 18;
      while (num2 > 1)
        num2 -= 2;
      int num3 = num1 - num2;
      int num4 = (int) Main.tile[i, j].frameX / 18;
      int num5 = 0;
      while (num4 > 1)
      {
        num4 -= 2;
        ++num5;
      }
      int num6 = i - num4;
      int num7 = num5 * 36;
      for (int i1 = num6; i1 < num6 + 2; ++i1)
      {
        for (int index = num3; index < num3 + 2; ++index)
        {
          if (Main.tile[i1, index] == null)
            Main.tile[i1, index] = new Tile();
          if (!Main.tile[i1, index].active() || (int) Main.tile[i1, index].type != type || (int) Main.tile[i1, index].frameX != (i1 - num6) * 18 + num7)
            flag = true;
        }
        if (!WorldGen.SolidTileAllowBottomSlope(i1, num3 + 2))
          flag = true;
      }
      if (!flag)
        return;
      int frameX = (int) Main.tile[i, j].frameX;
      WorldGen.destroyObject = true;
      for (int i1 = num6; i1 < num6 + 2; ++i1)
      {
        for (int j1 = num3; j1 < num3 + 2; ++j1)
        {
          if (Main.tile[i1, j1] == null)
            Main.tile[i1, j1] = new Tile();
          if ((int) Main.tile[i1, j1].type == type && Main.tile[i1, j1].active())
            WorldGen.KillTile(i1, j1, false, false, false);
        }
      }
      switch (type)
      {
        case 96:
          if (num5 == 0)
            Item.NewItem(i * 16, j * 16, 32, 32, 345, 1, false, 0, false, false);
          if (num5 == 1)
          {
            Item.NewItem(i * 16, j * 16, 32, 32, 1791, 1, false, 0, false, false);
            break;
          }
          break;
        case 254:
          if (frameX >= 72)
          {
            if (frameX < 108)
            {
              if (WorldGen.genRand.Next(2) == 0)
              {
                Item.NewItem(i * 16, j * 16, 32, 32, 1725, WorldGen.genRand.Next(1, 3), false, 0, false, false);
                break;
              }
              break;
            }
            if (frameX < 144)
            {
              Item.NewItem(i * 16, j * 16, 32, 32, 1725, WorldGen.genRand.Next(2, 6), false, 0, false, false);
              break;
            }
            Item.NewItem(i * 16, j * 16, 32, 32, 1725, WorldGen.genRand.Next(5, 11), false, 0, false, false);
            if (Main.halloween && WorldGen.genRand.Next(200) == 0)
            {
              Item.NewItem(i * 16, j * 16, 32, 32, 1799, 1, false, 0, false, false);
              break;
            }
            break;
          }
          break;
        case 441:
          int Type1 = -1;
          switch (num5)
          {
            case 0:
              Type1 = 3665;
              break;
            case 1:
              Type1 = 3666;
              break;
            case 3:
              Type1 = 3667;
              break;
            case 7:
              Type1 = 3668;
              break;
            case 8:
              Type1 = 3669;
              break;
            case 9:
              Type1 = 3670;
              break;
            case 10:
              Type1 = 3671;
              break;
            case 11:
              Type1 = 3672;
              break;
            case 12:
              Type1 = 3673;
              break;
            case 13:
              Type1 = 3674;
              break;
            case 14:
              Type1 = 3675;
              break;
            case 15:
              Type1 = 3676;
              break;
            case 16:
              Type1 = 3677;
              break;
            case 17:
              Type1 = 3678;
              break;
            case 18:
              Type1 = 3679;
              break;
            case 19:
              Type1 = 3680;
              break;
            case 20:
              Type1 = 3681;
              break;
            case 21:
              Type1 = 3682;
              break;
            case 22:
              Type1 = 3683;
              break;
            case 28:
              Type1 = 3684;
              break;
            case 29:
              Type1 = 3685;
              break;
            case 30:
              Type1 = 3686;
              break;
            case 31:
              Type1 = 3687;
              break;
            case 32:
              Type1 = 3688;
              break;
            case 33:
              Type1 = 3689;
              break;
            case 34:
              Type1 = 3690;
              break;
            case 35:
              Type1 = 3691;
              break;
            case 37:
              Type1 = 3692;
              break;
            case 39:
              Type1 = 3693;
              break;
            case 41:
              Type1 = 3694;
              break;
            case 42:
              Type1 = 3695;
              break;
            case 43:
              Type1 = 3696;
              break;
            case 44:
              Type1 = 3697;
              break;
            case 45:
              Type1 = 3698;
              break;
            case 46:
              Type1 = 3699;
              break;
            case 47:
              Type1 = 3700;
              break;
            case 48:
              Type1 = 3701;
              break;
            case 49:
              Type1 = 3702;
              break;
            case 50:
              Type1 = 3703;
              break;
            case 51:
              Type1 = 3704;
              break;
          }
          if (Type1 != -1)
          {
            Item.NewItem(i * 16, j * 16, 32, 32, Type1, 1, false, 0, false, false);
            break;
          }
          break;
        case 457:
          Item.NewItem(i * 16, j * 16, 32, 32, 3749, 1, false, 0, false, false);
          break;
        case 468:
          int Type2 = -1;
          switch (num5)
          {
            case 0:
              Type2 = 3886;
              break;
            case 1:
              Type2 = 3887;
              break;
            case 2:
              Type2 = 3950;
              break;
            case 3:
              Type2 = 3976;
              break;
            case 4:
              Type2 = -1;
              break;
            case 5:
              Type2 = 4164;
              break;
            case 6:
              Type2 = 4185;
              break;
            case 7:
              Type2 = 4206;
              break;
            case 8:
              Type2 = 4227;
              break;
            case 9:
              Type2 = 4266;
              break;
            case 10:
              Type2 = 4268;
              break;
            case 11:
              Type2 = 4585;
              break;
            case 12:
              Type2 = 4713;
              break;
          }
          if (Type2 != -1)
          {
            Item.NewItem(i * 16, j * 16, 32, 32, Type2, 1, false, 0, false, false);
            break;
          }
          break;
      }
      WorldGen.destroyObject = false;
      for (int i1 = num6 - 1; i1 < num6 + 3; ++i1)
      {
        for (int j1 = num3 - 1; j1 < num3 + 3; ++j1)
          WorldGen.TileFrame(i1, j1, false, false);
      }
    }

    public static void PlacePumpkin(int x, int superY)
    {
      ushort num1 = 254;
      int index1 = superY;
      int num2 = WorldGen.genRand.Next(6) * 36;
      if (x < 5 || x > Main.maxTilesX - 5 || (index1 < 5 || index1 > Main.maxTilesY - 5))
        return;
      bool flag = true;
      for (int i = x - 1; i < x + 1; ++i)
      {
        for (int index2 = index1 - 1; index2 < index1 + 1; ++index2)
        {
          if (Main.tile[i, index2] == null)
            Main.tile[i, index2] = new Tile();
          if (Main.tile[i, index2].active() && Main.tile[i, index2].type != (ushort) 3 && (Main.tile[i, index2].type != (ushort) 73 && Main.tile[i, index2].type != (ushort) 113) && (Main.tile[i, index2].type != (ushort) 110 && (Main.tile[i, index2].type != (ushort) 185 || Main.tile[i, index2].frameY != (short) 0)))
            flag = false;
          if (Main.tile[i, index2].liquid > (byte) 0)
            flag = false;
        }
        if (!WorldGen.SolidTile(i, index1 + 1, false) || Main.tile[i, index1 + 1].type != (ushort) 2 && Main.tile[i, index1 + 1].type != (ushort) 109)
          flag = false;
      }
      if (!flag)
        return;
      Main.tile[x - 1, index1 - 1].active(true);
      Main.tile[x - 1, index1 - 1].frameY = (short) num2;
      Main.tile[x - 1, index1 - 1].frameX = (short) 0;
      Main.tile[x - 1, index1 - 1].type = num1;
      Main.tile[x, index1 - 1].active(true);
      Main.tile[x, index1 - 1].frameY = (short) num2;
      Main.tile[x, index1 - 1].frameX = (short) 18;
      Main.tile[x, index1 - 1].type = num1;
      Main.tile[x - 1, index1].active(true);
      Main.tile[x - 1, index1].frameY = (short) (num2 + 18);
      Main.tile[x - 1, index1].frameX = (short) 0;
      Main.tile[x - 1, index1].type = num1;
      Main.tile[x, index1].active(true);
      Main.tile[x, index1].frameY = (short) (num2 + 18);
      Main.tile[x, index1].frameX = (short) 18;
      Main.tile[x, index1].type = num1;
    }

    public static void GrowPumpkin(int i, int j, int type)
    {
      if (WorldGen.destroyObject)
        return;
      bool flag = false;
      int num1 = j;
      int num2 = (int) Main.tile[i, j].frameY / 18;
      while (num2 > 1)
        num2 -= 2;
      int tileY = num1 - num2;
      int num3 = (int) Main.tile[i, j].frameX / 18;
      int num4 = 0;
      while (num3 > 1)
      {
        num3 -= 2;
        ++num4;
      }
      int tileX = i - num3;
      int num5 = num4 * 36;
      if (num4 >= 4)
        return;
      for (int i1 = tileX; i1 < tileX + 2; ++i1)
      {
        for (int index = tileY; index < tileY + 2; ++index)
        {
          if (Main.tile[i1, index] == null)
            Main.tile[i1, index] = new Tile();
          if (!Main.tile[i1, index].active() || (int) Main.tile[i1, index].type != type || (int) Main.tile[i1, index].frameX != (i1 - tileX) * 18 + num5)
            flag = true;
        }
        if (!WorldGen.SolidTile(i1, tileY + 2, false) || Main.tile[i1, tileY + 2].type != (ushort) 2 && Main.tile[i1, tileY + 2].type != (ushort) 477 && (Main.tile[i1, tileY + 2].type != (ushort) 492 && Main.tile[i1, tileY + 2].type != (ushort) 109))
          flag = true;
      }
      if (!flag)
      {
        for (int index1 = tileX; index1 < tileX + 2; ++index1)
        {
          for (int index2 = tileY; index2 < tileY + 2; ++index2)
          {
            if (Main.tile[index1, index2] == null)
              Main.tile[index1, index2] = new Tile();
            if ((int) Main.tile[index1, index2].type == type && Main.tile[index1, index2].active())
              Main.tile[index1, index2].frameX += (short) 36;
          }
        }
      }
      if (Main.netMode != 2)
        return;
      NetMessage.SendTileSquare(-1, tileX, tileY, 4, TileChangeType.None);
    }

    public static void FixHearts()
    {
      for (int i = 0; i < Main.maxTilesX; ++i)
      {
        for (int j = 0; j < Main.maxTilesY; ++j)
        {
          Tile tile = Main.tile[i, j];
          if (tile.active() && tile.type == (ushort) 12 && (tile.frameX == (short) 0 && tile.frameY == (short) 0))
            WorldGen.FixHeart(i, j);
        }
      }
    }

    public static void DestroyHeart(int i, int j)
    {
      WorldGen.destroyObject = true;
      for (int i1 = i; i1 < i + 2; ++i1)
      {
        for (int j1 = j; j1 < j + 2; ++j1)
        {
          if (i1 < Main.maxTilesX && j1 < Main.maxTilesY)
          {
            Tile tile = Main.tile[i1, j1];
            if (tile.active() && tile.type == (ushort) 12)
              WorldGen.KillTile(i1, j1, false, false, false);
          }
        }
      }
      WorldGen.destroyObject = false;
    }

    public static void FixHeart(int i, int j)
    {
      if (i < 40 || i >= Main.maxTilesX - 40 || (j < 40 || j >= Main.maxTilesY - 40))
      {
        WorldGen.DestroyHeart(i, j);
      }
      else
      {
        Tile tile1 = Main.tile[i, j + 2];
        Tile tile2 = Main.tile[i + 1, j + 2];
        if (tile1.active() && !Main.tileSolid[(int) tile1.type] && Main.tileCut[(int) tile1.type])
          WorldGen.KillTile(i, j + 2, false, false, false);
        if (tile2.active() && !Main.tileSolid[(int) tile2.type] && Main.tileCut[(int) tile2.type])
          WorldGen.KillTile(i + 1, j + 2, false, false, false);
        if (!tile1.active())
        {
          if (!tile2.active())
          {
            WorldGen.DestroyHeart(i, j);
            return;
          }
          if (Main.tileSolid[(int) tile2.type])
          {
            tile1.type = tile2.type;
            tile1.active(true);
          }
        }
        if (!tile2.active() && Main.tileSolid[(int) tile1.type])
        {
          tile2.type = tile1.type;
          tile2.active(true);
        }
        if (!tile1.nactive() || !Main.tileSolid[(int) tile1.type] || (!tile2.nactive() || !Main.tileSolid[(int) tile2.type]))
        {
          WorldGen.DestroyHeart(i, j);
        }
        else
        {
          if (tile1.blockType() != 0)
          {
            tile1.slope((byte) 0);
            tile1.halfBrick(false);
          }
          if (tile2.blockType() == 0)
            return;
          tile2.slope((byte) 0);
          tile2.halfBrick(false);
        }
      }
    }

    public static void FixChands()
    {
      for (int i = 5; i < Main.maxTilesX - 5; ++i)
      {
        for (int j = 5; j < Main.maxTilesY - 5; ++j)
        {
          if (Main.tile[i, j].active())
          {
            int type = (int) Main.tile[i, j].type;
            if (Main.tile[i, j].active() && (type == 35 || type == 36 || (type == 170 || type == 171) || type == 172))
              WorldGen.FixChand(i, j);
          }
        }
      }
    }

    public static void FixChand(int i, int j)
    {
      int num1 = 0;
      int type = (int) Main.tile[i, j].type;
      if (Main.tile[i, j].active())
      {
        if (type == 35)
          num1 = 1;
        if (type == 36)
          num1 = 2;
        if (type == 170)
          num1 = 3;
        if (type == 171)
          num1 = 4;
        if (type == 172)
          num1 = 5;
      }
      if (num1 <= 0)
        return;
      int num2 = j;
      int num3 = (int) Main.tile[i, j].frameX / 18;
      while (num3 >= 3)
        num3 -= 3;
      if (num3 >= 3)
        num3 -= 3;
      int num4 = i - num3;
      int num5 = num2 + (int) Main.tile[i, j].frameY / 18 * -1;
      for (int index1 = num4; index1 < num4 + 3; ++index1)
      {
        for (int index2 = num5; index2 < num5 + 3; ++index2)
        {
          if (Main.tile[index1, index2] == null)
            Main.tile[index1, index2] = new Tile();
          if (Main.tile[index1, index2].active() && (int) Main.tile[index1, index2].type == type)
          {
            Main.tile[index1, index2].type = (ushort) 34;
            Main.tile[index1, index2].frameY += (short) (num1 * 54);
          }
        }
      }
    }

    public static void PlaceChand(int x, int y, ushort type, int style = 0)
    {
      bool flag = true;
      int num1 = 0;
      for (int index1 = x - 1; index1 < x + 2; ++index1)
      {
        for (int index2 = y; index2 < y + 3; ++index2)
        {
          if (Main.tile[index1, index2] == null)
            Main.tile[index1, index2] = new Tile();
          if (Main.tile[index1, index2].active())
            flag = false;
        }
      }
      if (Main.tile[x, y - 1] == null)
        Main.tile[x, y - 1] = new Tile();
      if (!Main.tile[x, y - 1].nactive() || !Main.tileSolid[(int) Main.tile[x, y - 1].type] || Main.tileSolidTop[(int) Main.tile[x, y - 1].type])
        flag = false;
      if (!flag)
        return;
      int num2 = style / 36 * 18 * 6;
      int num3 = style * 18 * 3;
      Main.tile[x - 1, y + num1].active(true);
      Main.tile[x - 1, y + num1].frameY = (short) num3;
      Main.tile[x - 1, y + num1].frameX = (short) num2;
      Main.tile[x - 1, y + num1].type = type;
      Main.tile[x, y + num1].active(true);
      Main.tile[x, y + num1].frameY = (short) num3;
      Main.tile[x, y + num1].frameX = (short) (num2 + 18);
      Main.tile[x, y + num1].type = type;
      Main.tile[x + 1, y + num1].active(true);
      Main.tile[x + 1, y + num1].frameY = (short) num3;
      Main.tile[x + 1, y + num1].frameX = (short) (num2 + 36);
      Main.tile[x + 1, y + num1].type = type;
      Main.tile[x - 1, y + 1 + num1].active(true);
      Main.tile[x - 1, y + 1 + num1].frameY = (short) (num3 + 18);
      Main.tile[x - 1, y + 1 + num1].frameX = (short) num2;
      Main.tile[x - 1, y + 1 + num1].type = type;
      Main.tile[x, y + 1 + num1].active(true);
      Main.tile[x, y + 1 + num1].frameY = (short) (num3 + 18);
      Main.tile[x, y + 1 + num1].frameX = (short) (num2 + 18);
      Main.tile[x, y + 1 + num1].type = type;
      Main.tile[x + 1, y + 1 + num1].active(true);
      Main.tile[x + 1, y + 1 + num1].frameY = (short) (num3 + 18);
      Main.tile[x + 1, y + 1 + num1].frameX = (short) (num2 + 36);
      Main.tile[x + 1, y + 1 + num1].type = type;
      Main.tile[x - 1, y + 2 + num1].active(true);
      Main.tile[x - 1, y + 2 + num1].frameY = (short) (num3 + 36);
      Main.tile[x - 1, y + 2 + num1].frameX = (short) num2;
      Main.tile[x - 1, y + 2 + num1].type = type;
      Main.tile[x, y + 2 + num1].active(true);
      Main.tile[x, y + 2 + num1].frameY = (short) (num3 + 36);
      Main.tile[x, y + 2 + num1].frameX = (short) (num2 + 18);
      Main.tile[x, y + 2 + num1].type = type;
      Main.tile[x + 1, y + 2 + num1].active(true);
      Main.tile[x + 1, y + 2 + num1].frameY = (short) (num3 + 36);
      Main.tile[x + 1, y + 2 + num1].frameX = (short) (num2 + 36);
      Main.tile[x + 1, y + 2 + num1].type = type;
    }

    public static void CheckChand(int i, int j, int type)
    {
      if (WorldGen.destroyObject)
        return;
      bool flag = false;
      int num1 = 3;
      if (type == 454)
        num1 = 4;
      int num2 = (int) Main.tile[i, j].frameX / 18;
      int num3 = 0;
      for (; num2 >= num1; num2 -= num1)
        ++num3;
      int num4 = i - num2;
      int num5 = 18 * num1 * num3;
      if (num2 >= num1)
        num2 -= num1;
      int num6 = i - num2;
      int num7 = (int) Main.tile[i, j].frameY / 18;
      int num8 = 0;
      for (; num7 >= 3; num7 -= 3)
        ++num8;
      if (num5 >= 108)
        num8 += 37 * (num5 / 108);
      int num9 = 54 * num8;
      if (num5 >= 108)
        num9 -= 54 * (num5 / 108) * 37;
      if (num7 >= 3)
        num7 -= 3;
      int num10 = j - num7;
      for (int index1 = num6; index1 < num6 + num1; ++index1)
      {
        for (int index2 = num10; index2 < num10 + 3; ++index2)
        {
          if (Main.tile[index1, index2] == null)
            Main.tile[index1, index2] = new Tile();
          if (!Main.tile[index1, index2].active() || (int) Main.tile[index1, index2].type != type || ((int) Main.tile[index1, index2].frameX != (index1 - num4) * 18 + num5 || (int) Main.tile[index1, index2].frameY != (index2 - num10) * 18 + num9))
            flag = true;
        }
      }
      if (Main.tile[num6 + 1, num10 - 1] == null)
        Main.tile[num6 + 1, num10 - 1] = new Tile();
      if (!Main.tile[num6 + 1, num10 - 1].nactive() || !Main.tileSolid[(int) Main.tile[num6 + 1, num10 - 1].type] || Main.tileSolidTop[(int) Main.tile[num6 + 1, num10 - 1].type])
        flag = true;
      if (!flag)
        return;
      WorldGen.destroyObject = true;
      for (int i1 = num6; i1 < num6 + num1; ++i1)
      {
        for (int j1 = num10; j1 < num10 + 3; ++j1)
        {
          if ((int) Main.tile[i1, j1].type == type && Main.tile[i1, j1].active())
            WorldGen.KillTile(i1, j1, false, false, false);
        }
      }
      if (type == 454)
      {
        switch (Main.rand.Next(9))
        {
          case 2:
          case 3:
          case 4:
            int num11 = Main.rand.Next(10, 31);
            while (num11 > 0)
            {
              int Stack = Main.rand.Next(2, 11);
              if (Stack > num11)
                Stack = num11;
              num11 -= Stack;
              Item.NewItem(i * 16, j * 16, 32, 32, 72, Stack, false, 0, false, false);
            }
            break;
          case 5:
          case 6:
            int num12 = Main.rand.Next(60, 80);
            while (num12 > 0)
            {
              int Stack = Main.rand.Next(3, 16);
              if (Stack > num12)
                Stack = num12;
              num12 -= Stack;
              Item.NewItem(i * 16 - 10, j * 16 - 10, 52, 52, 72, Stack, false, 0, false, false);
            }
            Item.NewItem(i * 16, j * 16, 32, 32, 1358, 1, false, 0, false, false);
            break;
          case 7:
            int num13 = Main.rand.Next(10, 31);
            while (num13 > 0)
            {
              int Stack = Main.rand.Next(2, 9);
              if (Stack > num13)
                Stack = num13;
              num13 -= Stack;
              Item.NewItem(i * 16 - 10, j * 16 - 10, 52, 52, 72, Stack, false, 0, false, false);
            }
            if (Main.rand.Next(8) == 0)
              Item.NewItem(i * 16, j * 16, 32, 32, 3532, 1, false, 0, false, false);
            if (Main.rand.Next(8) == 0)
              Item.NewItem(i * 16, j * 16, 32, 32, 3532, 1, false, 0, false, false);
            Item.NewItem(i * 16, j * 16, 32, 32, 73, 1, false, 0, false, false);
            break;
          case 8:
            int num14 = 100;
            while (num14 > 0)
            {
              int Stack = Main.rand.Next(3, 16);
              if (Stack > num14)
                Stack = num14;
              num14 -= Stack;
              Item.NewItem(i * 16 - 10, j * 16 - 10, 52, 52, 72, Stack, false, 0, false, false);
            }
            int num15 = Main.rand.Next(30, 91);
            while (num15 > 0)
            {
              int Stack = Main.rand.Next(7, 14);
              if (Stack > num15)
                Stack = num15;
              num15 -= Stack;
              Item.NewItem(i * 16 - 10, j * 16 - 10, 52, 52, 1349, Stack, false, 0, false, false);
            }
            Item.NewItem(i * 16, j * 16, 32, 32, 1358, 1, false, 0, false, false);
            Item.NewItem(i * 16, j * 16, 32, 32, 73, 1, false, 0, false, false);
            break;
        }
      }
      if (type == 34)
      {
        int Type = num8 != 1 ? (num8 != 2 ? (num8 != 3 ? (num8 != 4 ? (num8 != 5 ? (num8 != 6 ? (num8 < 7 || num8 > 17 ? (num8 < 18 || num8 > 21 ? (num8 != 22 ? (num8 != 23 ? (num8 != 24 ? (num8 != 25 ? (num8 != 26 ? (num8 != 27 ? (num8 != 28 ? (num8 != 29 ? (num8 != 30 ? (num8 != 31 ? (num8 != 32 ? (num8 != 33 ? (num8 != 34 ? (num8 != 35 ? (num8 != 36 ? (num8 != 37 ? (num8 != 38 ? (num8 != 39 ? (num8 != 40 ? (num8 != 41 ? (num8 != 42 ? (num8 != 43 ? (num8 != 44 ? (num8 != 45 ? 106 : 4573) : 4305) : 4215) : 4194) : 4173) : 4152) : 3964) : 3938) : 3894) : 3178) : 3179) : 3177) : 2813) : 2657) : 2656) : 2655) : 2654) : 2653) : 2652) : 2573) : 2558) : 2543) : 2525) : 2224) : 2141 + num8 - 18) : 2055 + num8 - 7) : 1812) : 712) : 711) : 710) : 108) : 107;
        Item.NewItem(i * 16, j * 16, 32, 32, Type, 1, false, 0, false, false);
      }
      WorldGen.destroyObject = false;
      for (int i1 = num6 - 1; i1 < num6 + num1 + 1; ++i1)
      {
        for (int j1 = num10 - 1; j1 < num10 + 4; ++j1)
          WorldGen.TileFrame(i1, j1, false, false);
      }
    }

    public static void Check3x3(int i, int j, int type)
    {
      if (WorldGen.destroyObject)
        return;
      bool flag = false;
      int num1 = j;
      int num2 = (int) Main.tile[i, j].frameX / 18;
      int num3 = 0;
      for (; num2 >= 3; num2 -= 3)
        ++num3;
      int num4 = i - num2;
      int num5 = 54 * num3;
      int num6 = (int) Main.tile[i, j].frameY / 54;
      int num7 = (int) Main.tile[i, j].frameY % 54 / 18;
      if (num2 >= 3)
        num2 -= 3;
      int num8 = i - num2;
      int num9 = num1 - num7;
      for (int index1 = num8; index1 < num8 + 3; ++index1)
      {
        for (int index2 = num9; index2 < num9 + 3; ++index2)
        {
          if (Main.tile[index1, index2] == null)
            Main.tile[index1, index2] = new Tile();
          if (!Main.tile[index1, index2].active() || (int) Main.tile[index1, index2].type != type || ((int) Main.tile[index1, index2].frameX != (index1 - num4) * 18 + num5 || (int) Main.tile[index1, index2].frameY != (index2 - num9) * 18 + num6 * 54))
            flag = true;
        }
      }
      if (type == 106 || type == 212 || (type == 219 || type == 220) || (type == 228 || type == 231 || (type == 243 || type == 247)) || (type == 283 || type >= 300 && type <= 308 || (type == 354 || type == 355 || (type == 499 || type == 406))) || (type == 412 || type == 452 || (type == 455 || type == 491)))
      {
        for (int i1 = num8; i1 < num8 + 3; ++i1)
        {
          if (Main.tile[i1, num9 + 3] == null)
            Main.tile[i1, num9 + 3] = new Tile();
          if (!WorldGen.SolidTileAllowBottomSlope(i1, num9 + 3))
          {
            flag = true;
            break;
          }
        }
      }
      else
      {
        if (Main.tile[num8 + 1, num9 - 1] == null)
          Main.tile[num8 + 1, num9 - 1] = new Tile();
        if (!Main.tile[num8 + 1, num9 - 1].nactive() || !Main.tileSolid[(int) Main.tile[num8 + 1, num9 - 1].type] || Main.tileSolidTop[(int) Main.tile[num8 + 1, num9 - 1].type])
          flag = true;
      }
      if (!flag)
        return;
      WorldGen.destroyObject = true;
      for (int i1 = num8; i1 < num8 + 3; ++i1)
      {
        for (int j1 = num9; j1 < num9 + 3; ++j1)
        {
          if ((int) Main.tile[i1, j1].type == type && Main.tile[i1, j1].active())
            WorldGen.KillTile(i1, j1, false, false, false);
        }
      }
      switch (type)
      {
        case 106:
          Item.NewItem(i * 16, j * 16, 32, 32, 363, 1, false, 0, false, false);
          break;
        case 212:
          Item.NewItem(i * 16, j * 16, 32, 32, 951, 1, false, 0, false, false);
          break;
        case 219:
          Item.NewItem(i * 16, j * 16, 32, 32, 997, 1, false, 0, false, false);
          break;
        case 220:
          Item.NewItem(i * 16, j * 16, 32, 32, 998, 1, false, 0, false, false);
          break;
        case 228:
          Item.NewItem(i * 16, j * 16, 32, 32, 1120, 1, false, 0, false, false);
          break;
        case 243:
          Item.NewItem(i * 16, j * 16, 32, 32, 1430, 1, false, 0, false, false);
          break;
        case 247:
          Item.NewItem(i * 16, j * 16, 32, 32, 1551, 1, false, 0, false, false);
          break;
        case 283:
          Item.NewItem(i * 16, j * 16, 32, 32, 2172, 1, false, 0, false, false);
          break;
        default:
          if (type >= 300 && type <= 306)
          {
            Item.NewItem(i * 16, j * 16, 32, 32, 2192 + type - 300, 1, false, 0, false, false);
            break;
          }
          switch (type)
          {
            case 231:
              int num10 = (i + 1) * 16 + 8;
              int num11 = j * 16;
              Gore.NewGore(new Vector2((float) num10, (float) num11), new Vector2(), 300, 1f);
              Gore.NewGore(new Vector2((float) num10, (float) (num11 + 8)), new Vector2(), 301, 1f);
              Gore.NewGore(new Vector2((float) num10, (float) (num11 + 16)), new Vector2(), 302, 1f);
              float num12 = (float) (i * 16);
              float num13 = (float) (j * 16);
              float num14 = -1f;
              int plr = 0;
              for (int index = 0; index < (int) byte.MaxValue; ++index)
              {
                if (Main.player[index].active && !Main.player[index].dead)
                {
                  float num15 = Math.Abs(Main.player[index].position.X - num12) + Math.Abs(Main.player[index].position.Y - num13);
                  if ((double) num15 < (double) num14 || (double) num14 == -1.0)
                  {
                    plr = index;
                    num14 = num15;
                  }
                }
              }
              if ((double) num14 < 4800.0)
              {
                NPC.SpawnOnPlayer(plr, 222);
                break;
              }
              break;
            case 307:
              Item.NewItem(i * 16, j * 16, 32, 32, 2203, 1, false, 0, false, false);
              break;
            case 308:
              Item.NewItem(i * 16, j * 16, 32, 32, 2204, 1, false, 0, false, false);
              break;
            case 354:
              Item.NewItem(i * 16, j * 16, 32, 32, 2999, 1, false, 0, false, false);
              break;
            case 355:
              Item.NewItem(i * 16, j * 16, 32, 32, 3000, 1, false, 0, false, false);
              break;
            case 406:
              Item.NewItem(i * 16, j * 16, 32, 32, 3365, 1, false, 0, false, false);
              break;
            case 412:
              Item.NewItem(i * 16, j * 16, 32, 32, 3549, 1, false, 0, false, false);
              break;
            case 452:
              Item.NewItem(i * 16, j * 16, 32, 32, 3742, 1, false, 0, false, false);
              break;
            case 455:
              Item.NewItem(i * 16, j * 16, 32, 32, 3747, 1, false, 0, false, false);
              break;
            case 491:
              Item.NewItem(i * 16, j * 16, 32, 32, 4076, 1, false, 0, false, false);
              break;
            case 499:
              Item.NewItem(i * 16, j * 16, 32, 32, 4142, 1, false, 0, false, false);
              break;
          }
          break;
      }
      WorldGen.destroyObject = false;
      for (int i1 = num8 - 1; i1 < num8 + 4; ++i1)
      {
        for (int j1 = num9 - 1; j1 < num9 + 4; ++j1)
          WorldGen.TileFrame(i1, j1, false, false);
      }
    }

    public static void Check2x5(int i, int j, int type)
    {
      if (WorldGen.destroyObject)
        return;
      bool flag = false;
      int num1 = j;
      int num2 = (int) Main.tile[i, j].frameX / 18;
      int num3 = 0;
      for (; num2 >= 2; num2 -= 2)
        ++num3;
      int num4 = i - num2;
      int num5 = 36 * num3;
      int num6 = (int) Main.tile[i, j].frameY % 80 / 18;
      if (num2 >= 3)
        num2 -= 2;
      int num7 = i - num2;
      int num8 = num1 - num6;
      for (int index1 = num7; index1 < num7 + 2; ++index1)
      {
        for (int index2 = num8; index2 < num8 + 5; ++index2)
        {
          if (Main.tile[index1, index2] == null)
            Main.tile[index1, index2] = new Tile();
          if (!Main.tile[index1, index2].active() || (int) Main.tile[index1, index2].type != type || ((int) Main.tile[index1, index2].frameX != (index1 - num4) * 18 + num5 || (int) Main.tile[index1, index2].frameY != (index2 - num8) * 18))
            flag = true;
        }
      }
      for (int i1 = num7; i1 < num7 + 2; ++i1)
      {
        if (Main.tile[i1, num8 + 5] == null)
          Main.tile[i1, num8 + 5] = new Tile();
        if (!WorldGen.SolidTileAllowBottomSlope(i1, num8 + 5))
        {
          flag = true;
          break;
        }
      }
      if (!flag)
        return;
      WorldGen.destroyObject = true;
      for (int i1 = num7; i1 < num7 + 2; ++i1)
      {
        for (int j1 = num8; j1 < num8 + 5; ++j1)
        {
          if ((int) Main.tile[i1, j1].type == type && Main.tile[i1, j1].active())
            WorldGen.KillTile(i1, j1, false, false, false);
        }
      }
      if (type == 547)
        Item.NewItem(i * 16, j * 16, 32, 32, 4430 + num3, 1, false, 0, false, false);
      WorldGen.destroyObject = false;
      for (int i1 = num7 - 1; i1 < num7 + 3; ++i1)
      {
        for (int j1 = num8 - 1; j1 < num8 + 6; ++j1)
          WorldGen.TileFrame(i1, j1, false, false);
      }
    }

    public static void Check3x5(int i, int j, int type)
    {
      if (WorldGen.destroyObject)
        return;
      bool flag = false;
      int num1 = j;
      int num2 = (int) Main.tile[i, j].frameX / 18;
      int num3 = 0;
      for (; num2 >= 3; num2 -= 3)
        ++num3;
      int num4 = i - num2;
      int num5 = 54 * num3;
      int num6 = (int) Main.tile[i, j].frameY % 90 / 18;
      if (num2 >= 4)
        num2 -= 3;
      int num7 = i - num2;
      int num8 = num1 - num6;
      for (int index1 = num7; index1 < num7 + 3; ++index1)
      {
        for (int index2 = num8; index2 < num8 + 5; ++index2)
        {
          if (Main.tile[index1, index2] == null)
            Main.tile[index1, index2] = new Tile();
          if (!Main.tile[index1, index2].active() || (int) Main.tile[index1, index2].type != type || ((int) Main.tile[index1, index2].frameX != (index1 - num4) * 18 + num5 || (int) Main.tile[index1, index2].frameY != (index2 - num8) * 18))
            flag = true;
        }
      }
      for (int i1 = num7; i1 < num7 + 3; ++i1)
      {
        if (Main.tile[i1, num8 + 5] == null)
          Main.tile[i1, num8 + 5] = new Tile();
        if (!WorldGen.SolidTileAllowBottomSlope(i1, num8 + 5))
        {
          flag = true;
          break;
        }
      }
      if (!flag)
        return;
      WorldGen.destroyObject = true;
      for (int i1 = num7; i1 < num7 + 3; ++i1)
      {
        for (int j1 = num8; j1 < num8 + 5; ++j1)
        {
          if ((int) Main.tile[i1, j1].type == type && Main.tile[i1, j1].active())
            WorldGen.KillTile(i1, j1, false, false, false);
        }
      }
      if (type == 613)
        Item.NewItem(i * 16, j * 16, 32, 32, 4904 + num3, 1, false, 0, false, false);
      WorldGen.destroyObject = false;
      for (int i1 = num7 - 1; i1 < num7 + 4; ++i1)
      {
        for (int j1 = num8 - 1; j1 < num8 + 6; ++j1)
          WorldGen.TileFrame(i1, j1, false, false);
      }
    }

    public static void Check3x6(int i, int j, int type)
    {
      if (WorldGen.destroyObject)
        return;
      bool flag = false;
      int num1 = j;
      int num2 = (int) Main.tile[i, j].frameX / 18;
      int num3 = 0;
      for (; num2 >= 3; num2 -= 3)
        ++num3;
      int num4 = i - num2;
      int num5 = 54 * num3;
      int num6 = (int) Main.tile[i, j].frameY % 96 / 18;
      if (num2 >= 4)
        num2 -= 3;
      int num7 = i - num2;
      int num8 = num1 - num6;
      for (int index1 = num7; index1 < num7 + 3; ++index1)
      {
        for (int index2 = num8; index2 < num8 + 6; ++index2)
        {
          if (Main.tile[index1, index2] == null)
            Main.tile[index1, index2] = new Tile();
          if (!Main.tile[index1, index2].active() || (int) Main.tile[index1, index2].type != type || ((int) Main.tile[index1, index2].frameX != (index1 - num4) * 18 + num5 || (int) Main.tile[index1, index2].frameY != (index2 - num8) * 18))
            flag = true;
        }
      }
      for (int i1 = num7; i1 < num7 + 3; ++i1)
      {
        if (Main.tile[i1, num8 + 6] == null)
          Main.tile[i1, num8 + 6] = new Tile();
        if (!WorldGen.SolidTileAllowBottomSlope(i1, num8 + 6))
        {
          flag = true;
          break;
        }
      }
      if (!flag)
        return;
      WorldGen.destroyObject = true;
      for (int i1 = num7; i1 < num7 + 3; ++i1)
      {
        for (int j1 = num8; j1 < num8 + 6; ++j1)
        {
          if ((int) Main.tile[i1, j1].type == type && Main.tile[i1, j1].active())
            WorldGen.KillTile(i1, j1, false, false, false);
        }
      }
      if (type == 548)
      {
        if (num3 >= 7)
          Item.NewItem(i * 16, j * 16, 32, 32, 4902 + num3 - 7, 1, false, 0, false, false);
        else
          Item.NewItem(i * 16, j * 16, 32, 32, 4435 + num3, 1, false, 0, false, false);
      }
      if (type == 614)
        Item.NewItem(i * 16, j * 16, 32, 32, 4906, 1, false, 0, false, false);
      WorldGen.destroyObject = false;
      for (int i1 = num7 - 1; i1 < num7 + 4; ++i1)
      {
        for (int j1 = num8 - 1; j1 < num8 + 7; ++j1)
          WorldGen.TileFrame(i1, j1, false, false);
      }
    }

    public static void Place3x3(int x, int y, ushort type, int style = 0)
    {
      bool flag = true;
      int num1 = 0;
      if (type == (ushort) 106 || type == (ushort) 212 || (type == (ushort) 219 || type == (ushort) 220) || (type == (ushort) 228 || type == (ushort) 231 || (type == (ushort) 243 || type == (ushort) 247)) || (type == (ushort) 283 || type >= (ushort) 300 && type <= (ushort) 308 || (type == (ushort) 354 || type == (ushort) 355)))
      {
        num1 = -2;
        for (int index1 = x - 1; index1 < x + 2; ++index1)
        {
          for (int index2 = y - 2; index2 < y + 1; ++index2)
          {
            if (Main.tile[index1, index2] == null)
              Main.tile[index1, index2] = new Tile();
            if (Main.tile[index1, index2].active())
              flag = false;
          }
        }
        for (int i = x - 1; i < x + 2; ++i)
        {
          if (Main.tile[i, y + 1] == null)
            Main.tile[i, y + 1] = new Tile();
          if (!WorldGen.SolidTile2(i, y + 1))
          {
            flag = false;
            break;
          }
        }
      }
      else
      {
        for (int index1 = x - 1; index1 < x + 2; ++index1)
        {
          for (int index2 = y; index2 < y + 3; ++index2)
          {
            if (Main.tile[index1, index2] == null)
              Main.tile[index1, index2] = new Tile();
            if (Main.tile[index1, index2].active())
              flag = false;
          }
        }
        if (Main.tile[x, y - 1] == null)
          Main.tile[x, y - 1] = new Tile();
        if (!Main.tile[x, y - 1].nactive() || !Main.tileSolid[(int) Main.tile[x, y - 1].type] || Main.tileSolidTop[(int) Main.tile[x, y - 1].type])
          flag = false;
      }
      if (!flag)
        return;
      int num2 = style * 18 * 3;
      Main.tile[x - 1, y + num1].active(true);
      Main.tile[x - 1, y + num1].frameY = (short) 0;
      Main.tile[x - 1, y + num1].frameX = (short) num2;
      Main.tile[x - 1, y + num1].type = type;
      Main.tile[x, y + num1].active(true);
      Main.tile[x, y + num1].frameY = (short) 0;
      Main.tile[x, y + num1].frameX = (short) (num2 + 18);
      Main.tile[x, y + num1].type = type;
      Main.tile[x + 1, y + num1].active(true);
      Main.tile[x + 1, y + num1].frameY = (short) 0;
      Main.tile[x + 1, y + num1].frameX = (short) (num2 + 36);
      Main.tile[x + 1, y + num1].type = type;
      Main.tile[x - 1, y + 1 + num1].active(true);
      Main.tile[x - 1, y + 1 + num1].frameY = (short) 18;
      Main.tile[x - 1, y + 1 + num1].frameX = (short) num2;
      Main.tile[x - 1, y + 1 + num1].type = type;
      Main.tile[x, y + 1 + num1].active(true);
      Main.tile[x, y + 1 + num1].frameY = (short) 18;
      Main.tile[x, y + 1 + num1].frameX = (short) (num2 + 18);
      Main.tile[x, y + 1 + num1].type = type;
      Main.tile[x + 1, y + 1 + num1].active(true);
      Main.tile[x + 1, y + 1 + num1].frameY = (short) 18;
      Main.tile[x + 1, y + 1 + num1].frameX = (short) (num2 + 36);
      Main.tile[x + 1, y + 1 + num1].type = type;
      Main.tile[x - 1, y + 2 + num1].active(true);
      Main.tile[x - 1, y + 2 + num1].frameY = (short) 36;
      Main.tile[x - 1, y + 2 + num1].frameX = (short) num2;
      Main.tile[x - 1, y + 2 + num1].type = type;
      Main.tile[x, y + 2 + num1].active(true);
      Main.tile[x, y + 2 + num1].frameY = (short) 36;
      Main.tile[x, y + 2 + num1].frameX = (short) (num2 + 18);
      Main.tile[x, y + 2 + num1].type = type;
      Main.tile[x + 1, y + 2 + num1].active(true);
      Main.tile[x + 1, y + 2 + num1].frameY = (short) 36;
      Main.tile[x + 1, y + 2 + num1].frameX = (short) (num2 + 36);
      Main.tile[x + 1, y + 2 + num1].type = type;
    }

    public static void PlaceSunflower(int x, int y, ushort type = 27)
    {
      if ((double) y > Main.worldSurface - 1.0)
        return;
      bool flag = true;
      for (int index1 = x; index1 < x + 2; ++index1)
      {
        for (int index2 = y - 3; index2 < y + 1; ++index2)
        {
          if (Main.tile[index1, index2] == null)
            Main.tile[index1, index2] = new Tile();
          if (Main.tile[index1, index2].active() || Main.tile[index1, index2].wall > (ushort) 0)
            flag = false;
        }
        if (Main.tile[index1, y + 1] == null)
          Main.tile[index1, y + 1] = new Tile();
        if (!Main.tile[index1, y + 1].nactive() || Main.tile[index1, y + 1].halfBrick() || Main.tile[index1, y + 1].slope() != (byte) 0 || Main.tile[index1, y + 1].type != (ushort) 2 && Main.tile[index1, y + 1].type != (ushort) 109)
          flag = false;
      }
      if (!flag)
        return;
      int num1 = WorldGen.genRand.Next(3);
      for (int index1 = 0; index1 < 2; ++index1)
      {
        for (int index2 = -3; index2 < 1; ++index2)
        {
          int num2 = index1 * 18 + WorldGen.genRand.Next(3) * 36;
          if (index2 <= -2)
            num2 = index1 * 18 + num1 * 36;
          int num3 = (index2 + 3) * 18;
          Main.tile[x + index1, y + index2].active(true);
          Main.tile[x + index1, y + index2].frameX = (short) num2;
          Main.tile[x + index1, y + index2].frameY = (short) num3;
          Main.tile[x + index1, y + index2].type = type;
        }
      }
    }

    public static void FixSunflowers()
    {
      for (int i = 5; i < Main.maxTilesX - 5; ++i)
      {
        for (int j = 5; (double) j < Main.worldSurface; ++j)
        {
          if (Main.tile[i, j].active() && Main.tile[i, j].type == (ushort) 27)
            WorldGen.FixSunflower(i, j);
        }
      }
    }

    public static void FixSunflower(int i, int j)
    {
      if (Main.tile[i, j].type != (ushort) 27)
        return;
      int num1 = 0;
      int num2 = j;
      int num3 = num1 + (int) Main.tile[i, j].frameX / 18;
      int num4 = num2 + (int) Main.tile[i, j].frameY / 18 * -1;
      while (num3 > 1)
        num3 -= 2;
      int num5 = num3 * -1 + i;
      int num6 = WorldGen.genRand.Next(3) * 36;
      int num7 = 0;
      for (int index1 = num5; index1 < num5 + 2; ++index1)
      {
        for (int index2 = num4; index2 < num4 + 4; ++index2)
          Main.tile[index1, index2].frameX = (short) (num7 + num6);
        num7 += 18;
      }
    }

    public static void CheckSunflower(int i, int j, int type = 27)
    {
      if (WorldGen.destroyObject)
        return;
      bool flag = false;
      int num1 = 0;
      int num2 = j;
      int num3 = num1 + (int) Main.tile[i, j].frameX / 18;
      int num4 = num2 + (int) Main.tile[i, j].frameY / 18 * -1;
      while (num3 > 1)
        num3 -= 2;
      int num5 = num3 * -1 + i;
      for (int i1 = num5; i1 < num5 + 2; ++i1)
      {
        for (int index = num4; index < num4 + 4; ++index)
        {
          if (Main.tile[i1, index] == null)
            Main.tile[i1, index] = new Tile();
          int num6 = (int) Main.tile[i1, index].frameX / 18;
          while (num6 > 1)
            num6 -= 2;
          if (!Main.tile[i1, index].nactive() || (int) Main.tile[i1, index].type != type || (num6 != i1 - num5 || (int) Main.tile[i1, index].frameY != (index - num4) * 18))
            flag = true;
        }
        if (Main.tile[i1, num4 + 4] == null)
          Main.tile[i1, num4 + 4] = new Tile();
        if (!Main.tile[i1, num4 + 4].nactive() || Main.tile[i1, num4 + 4].type != (ushort) 2 && Main.tile[i1, num4 + 4].type != (ushort) 477 && (Main.tile[i1, num4 + 4].type != (ushort) 492 && Main.tile[i1, num4 + 4].type != (ushort) 109) && Main.tile[i1, num4 + 4].type != (ushort) 60)
          flag = true;
        if (!WorldGen.SolidTile(i1, num4 + 4, false))
          flag = true;
      }
      if (!flag)
        return;
      WorldGen.destroyObject = true;
      for (int i1 = num5; i1 < num5 + 2; ++i1)
      {
        for (int j1 = num4; j1 < num4 + 4; ++j1)
        {
          if ((int) Main.tile[i1, j1].type == type && Main.tile[i1, j1].active())
            WorldGen.KillTile(i1, j1, false, false, false);
        }
      }
      Item.NewItem(i * 16, j * 16, 32, 32, 63, 1, false, 0, false, false);
      WorldGen.destroyObject = false;
    }

    public static void CheckDye(int x, int y)
    {
      switch ((int) Main.tile[x, y].frameX / 34)
      {
        case 6:
          if (Main.tile[x, y + 1].nactive() && Main.tile[x, y + 1].type == (ushort) 80)
            break;
          WorldGen.KillTile(x, y, false, false, false);
          break;
        case 7:
          if (WorldGen.SolidTile(x, y - 1, false))
            break;
          WorldGen.KillTile(x, y, false, false, false);
          break;
        default:
          if (WorldGen.SolidTile(x, y + 1, false))
            break;
          WorldGen.KillTile(x, y, false, false, false);
          break;
      }
    }

    public static void CheckRockGolemHead(int x, int y)
    {
      if (WorldGen.SolidTileAllowBottomSlope(x, y + 1))
        return;
      WorldGen.KillTile(x, y, false, false, false);
    }

    public static void CheckGnome(int x, int j)
    {
      if (WorldGen.destroyObject)
        return;
      int num1 = 567;
      int j1 = j;
      bool flag = true;
      Tile tileSafely1 = Framing.GetTileSafely(x, j1);
      Tile tileSafely2 = Framing.GetTileSafely(x, j1 + 1);
      if (tileSafely1.frameY > (short) 0)
      {
        --j1;
        tileSafely1 = Framing.GetTileSafely(x, j1);
        tileSafely2 = Framing.GetTileSafely(x, j1 + 1);
      }
      int num2 = (int) tileSafely1.frameX / 28;
      if (tileSafely1.frameY == (short) 0 && tileSafely2.frameY == (short) 20 && ((int) tileSafely1.type == num1 && (int) tileSafely2.type == num1))
        flag = false;
      if (Main.tile[x, j1 + 2] == null)
        Main.tile[x, j1 + 2] = new Tile();
      if (!WorldGen.SolidTileAllowBottomSlope(x, j1 + 2) && !TileID.Sets.Platforms[(int) Main.tile[x, j1 + 2].type])
        flag = true;
      if (!flag)
        return;
      WorldGen.destroyObject = true;
      if ((int) tileSafely1.type == num1)
        WorldGen.KillTile(x, j1, false, false, false);
      if ((int) tileSafely2.type == num1)
        WorldGen.KillTile(x, j1 + 1, false, false, false);
      Item.NewItem(x * 16, j1 * 16, 16, 32, 4609, 1, false, 0, false, false);
      WorldGen.destroyObject = false;
    }

    public static void PlaceGnome(int x, int y, int style)
    {
      WorldGen.PlaceObject(x, y, 567, false, style, 0, -1, -1);
    }

    public static void PlaceDye(int x, int y, int style)
    {
      bool flag = false;
      if (Main.tile[x, y + 1] == null || Main.tile[x, y - 1] == null)
        return;
      if (style == 7)
      {
        if (Main.tile[x, y + 1].active() && Main.tile[x, y + 1].type != (ushort) 3 && (Main.tile[x, y + 1].type != (ushort) 51 && Main.tile[x, y + 1].type != (ushort) 61) && (Main.tile[x, y + 1].type != (ushort) 73 && Main.tile[x, y + 1].type != (ushort) 74 && Main.tile[x, y + 1].type != (ushort) 184))
          return;
        if (WorldGen.SolidTile(x, y - 1, false) && !Main.tile[x, y + 1].active())
          flag = true;
      }
      else
      {
        if (Main.tile[x, y - 1].active() && Main.tile[x, y - 1].type != (ushort) 3 && (Main.tile[x, y - 1].type != (ushort) 51 && Main.tile[x, y - 1].type != (ushort) 61) && (Main.tile[x, y - 1].type != (ushort) 73 && Main.tile[x, y - 1].type != (ushort) 74 && Main.tile[x, y - 1].type != (ushort) 184))
          return;
        if (style == 6)
        {
          if (Main.tile[x, y + 1].nactive() && Main.tile[x, y + 1].type == (ushort) 80 && (!Main.tile[x - 1, y + 1].active() && !Main.tile[x + 1, y + 1].active()))
            flag = true;
        }
        else if (WorldGen.SolidTile(x, y + 1, false) && !Main.tile[x, y - 1].active())
        {
          switch (style)
          {
            case 5:
              if (Main.tile[x, y].liquid == byte.MaxValue)
              {
                flag = true;
                break;
              }
              break;
            case 8:
            case 9:
            case 10:
            case 11:
              flag = true;
              break;
            default:
              if (Main.tile[x, y].liquid == (byte) 0)
              {
                if (style == 3 || style == 4)
                {
                  if (Main.tile[x, y].wall == (ushort) 0)
                  {
                    flag = true;
                    break;
                  }
                  break;
                }
                flag = true;
                break;
              }
              break;
          }
        }
      }
      if (!flag)
        return;
      Main.tile[x, y].type = (ushort) 227;
      Main.tile[x, y].active(true);
      Main.tile[x, y].halfBrick(false);
      Main.tile[x, y].slope((byte) 0);
      Main.tile[x, y].frameY = (short) 0;
      Main.tile[x, y].frameX = (short) (34 * style);
    }

    public static bool PlacePot(int x, int y, ushort type = 28, int style = 0)
    {
      bool flag = true;
      for (int index1 = x; index1 < x + 2; ++index1)
      {
        for (int index2 = y - 1; index2 < y + 1; ++index2)
        {
          if (Main.tile[index1, index2] == null)
            Main.tile[index1, index2] = new Tile();
          if (Main.tile[index1, index2].active())
            flag = false;
        }
        if (Main.tile[index1, y + 1] == null)
          Main.tile[index1, y + 1] = new Tile();
        if (!Main.tile[index1, y + 1].nactive() || Main.tile[index1, y + 1].halfBrick() || (Main.tile[index1, y + 1].slope() != (byte) 0 || !Main.tileSolid[(int) Main.tile[index1, y + 1].type]))
          flag = false;
      }
      if (!flag)
        return false;
      int num1 = WorldGen.genRand.Next(3) * 36;
      for (int index1 = 0; index1 < 2; ++index1)
      {
        for (int index2 = -1; index2 < 1; ++index2)
        {
          int num2 = index1 * 18 + num1;
          int num3 = (index2 + 1) * 18;
          Main.tile[x + index1, y + index2].active(true);
          Main.tile[x + index1, y + index2].frameX = (short) num2;
          Main.tile[x + index1, y + index2].frameY = (short) (num3 + style * 36);
          Main.tile[x + index1, y + index2].type = type;
          Main.tile[x + index1, y + index2].halfBrick(false);
        }
      }
      return true;
    }

    public static bool CheckCactus(int i, int j)
    {
      int index1 = j;
      int index2 = i;
      while (Main.tile[index2, index1] != null && Main.tile[index2, index1].active() && Main.tile[index2, index1].type == (ushort) 80)
      {
        ++index1;
        if (Main.tile[index2, index1] == null)
          return false;
        if (!Main.tile[index2, index1].active() || Main.tile[index2, index1].type != (ushort) 80)
        {
          if (Main.tile[index2 - 1, index1] != null && Main.tile[index2 - 1, index1].active() && (Main.tile[index2 - 1, index1].type == (ushort) 80 && Main.tile[index2 - 1, index1 - 1] != null) && (Main.tile[index2 - 1, index1 - 1].active() && Main.tile[index2 - 1, index1 - 1].type == (ushort) 80 && index2 >= i))
            --index2;
          if (Main.tile[index2 + 1, index1] != null && Main.tile[index2 + 1, index1].active() && (Main.tile[index2 + 1, index1].type == (ushort) 80 && Main.tile[index2 + 1, index1 - 1] != null) && (Main.tile[index2 + 1, index1 - 1].active() && Main.tile[index2 + 1, index1 - 1].type == (ushort) 80 && index2 <= i))
            ++index2;
        }
      }
      if (!Main.tile[index2, index1].nactive() || Main.tile[index2, index1].halfBrick() || Main.tile[index2, index1].slope() != (byte) 0 || Main.tile[index2, index1].type != (ushort) 53 && Main.tile[index2, index1].type != (ushort) 112 && (Main.tile[index2, index1].type != (ushort) 116 && Main.tile[index2, index1].type != (ushort) 234))
      {
        WorldGen.KillTile(i, j, false, false, false);
        return true;
      }
      if (i != index2)
      {
        if ((!Main.tile[i, j + 1].active() || Main.tile[i, j + 1].type != (ushort) 80) && (!Main.tile[i - 1, j].active() || Main.tile[i - 1, j].type != (ushort) 80) && (!Main.tile[i + 1, j].active() || Main.tile[i + 1, j].type != (ushort) 80))
        {
          WorldGen.KillTile(i, j, false, false, false);
          return true;
        }
      }
      else if (i == index2 && (!Main.tile[i, j + 1].active() || Main.tile[i, j + 1].type != (ushort) 80 && Main.tile[i, j + 1].type != (ushort) 53 && (Main.tile[i, j + 1].type != (ushort) 112 && Main.tile[i, j + 1].type != (ushort) 116) && Main.tile[i, j + 1].type != (ushort) 234))
      {
        WorldGen.KillTile(i, j, false, false, false);
        return true;
      }
      return false;
    }

    public static void PlantCactus(int i, int j)
    {
      WorldGen.GrowCactus(i, j);
      for (int index = 0; index < 150; ++index)
        WorldGen.GrowCactus(WorldGen.genRand.Next(i - 1, i + 2), WorldGen.genRand.Next(j - 10, j + 2));
    }

    public static void CheckOrb(int i, int j, int type)
    {
      int frameX = (int) Main.tile[i, j].frameX;
      bool flag = false;
      if (frameX >= 36)
        flag = true;
      if (WorldGen.destroyObject)
        return;
      int num1 = Main.tile[i, j].frameX == (short) 0 || Main.tile[i, j].frameX == (short) 36 ? i : i - 1;
      int num2 = Main.tile[i, j].frameY != (short) 0 ? j - 1 : j;
      for (int index1 = 0; index1 < 2; ++index1)
      {
        for (int index2 = 0; index2 < 2; ++index2)
        {
          Tile tile = Main.tile[num1 + index1, num2 + index2];
          if (tile != null && (!tile.nactive() || (int) tile.type != type))
          {
            WorldGen.destroyObject = true;
            break;
          }
        }
        if (!WorldGen.destroyObject)
        {
          if (type == 12)
          {
            Tile tile = Main.tile[num1 + index1, num2 + 2];
            if (tile != null && (!tile.nactive() || !Main.tileSolid[(int) tile.type] || tile.blockType() != 0))
            {
              WorldGen.destroyObject = true;
              break;
            }
          }
        }
        else
          break;
      }
      if (!WorldGen.destroyObject)
        return;
      for (int i1 = num1; i1 < num1 + 2; ++i1)
      {
        for (int j1 = num2; j1 < num2 + 2; ++j1)
        {
          if ((int) Main.tile[i1, j1].type == type)
            WorldGen.KillTile(i1, j1, false, false, false);
        }
      }
      if (Main.netMode != 1 && !WorldGen.noTileActions)
      {
        switch (type)
        {
          case 12:
            Item.NewItem(num1 * 16, num2 * 16, 32, 32, 29, 1, false, 0, false, false);
            break;
          case 31:
            if (flag)
            {
              int num3 = Main.rand.Next(5);
              if (!WorldGen.shadowOrbSmashed)
                num3 = 0;
              switch (num3)
              {
                case 0:
                  Item.NewItem(num1 * 16, num2 * 16, 32, 32, 800, 1, false, -1, false, false);
                  int Stack = WorldGen.genRand.Next(100, 101);
                  Item.NewItem(num1 * 16, num2 * 16, 32, 32, 97, Stack, false, 0, false, false);
                  break;
                case 1:
                  Item.NewItem(num1 * 16, num2 * 16, 32, 32, 1256, 1, false, -1, false, false);
                  break;
                case 2:
                  Item.NewItem(num1 * 16, num2 * 16, 32, 32, 802, 1, false, -1, false, false);
                  break;
                case 3:
                  Item.NewItem(num1 * 16, num2 * 16, 32, 32, 3062, 1, false, -1, false, false);
                  break;
                case 4:
                  Item.NewItem(num1 * 16, num2 * 16, 32, 32, 1290, 1, false, -1, false, false);
                  break;
              }
            }
            else
            {
              int num3 = Main.rand.Next(5);
              if (!WorldGen.shadowOrbSmashed)
                num3 = 0;
              switch (num3)
              {
                case 0:
                  Item.NewItem(num1 * 16, num2 * 16, 32, 32, 96, 1, false, -1, false, false);
                  int Stack = WorldGen.genRand.Next(100, 101);
                  Item.NewItem(num1 * 16, num2 * 16, 32, 32, 97, Stack, false, 0, false, false);
                  break;
                case 1:
                  Item.NewItem(num1 * 16, num2 * 16, 32, 32, 64, 1, false, -1, false, false);
                  break;
                case 2:
                  Item.NewItem(num1 * 16, num2 * 16, 32, 32, 162, 1, false, -1, false, false);
                  break;
                case 3:
                  Item.NewItem(num1 * 16, num2 * 16, 32, 32, 115, 1, false, -1, false, false);
                  break;
                case 4:
                  Item.NewItem(num1 * 16, num2 * 16, 32, 32, 111, 1, false, -1, false, false);
                  break;
              }
            }
            WorldGen.shadowOrbSmashed = true;
            ++WorldGen.shadowOrbCount;
            if (WorldGen.shadowOrbCount >= 3)
            {
              if (!(NPC.AnyNPCs(266) & flag) && (!NPC.AnyNPCs(13) || flag))
              {
                WorldGen.shadowOrbCount = 0;
                float num3 = (float) (num1 * 16);
                float num4 = (float) (num2 * 16);
                float num5 = -1f;
                int plr = 0;
                for (int index = 0; index < (int) byte.MaxValue; ++index)
                {
                  float num6 = Math.Abs(Main.player[index].position.X - num3) + Math.Abs(Main.player[index].position.Y - num4);
                  if ((double) num6 < (double) num5 || (double) num5 == -1.0)
                  {
                    plr = index;
                    num5 = num6;
                  }
                }
                if (flag)
                  NPC.SpawnOnPlayer(plr, 266);
                else
                  NPC.SpawnOnPlayer(plr, 13);
              }
            }
            else
            {
              LocalizedText localizedText = Lang.misc[10];
              if (WorldGen.shadowOrbCount == 2)
                localizedText = Lang.misc[11];
              switch (Main.netMode)
              {
                case 0:
                  Main.NewText(localizedText.ToString(), (byte) 50, byte.MaxValue, (byte) 130);
                  break;
                case 2:
                  ChatHelper.BroadcastChatMessage(NetworkText.FromKey(localizedText.Key), new Color(50, (int) byte.MaxValue, 130), -1);
                  break;
              }
            }
            AchievementsHelper.NotifyProgressionEvent(7);
            break;
        }
      }
      if (flag)
        SoundEngine.PlaySound(4, i * 16, j * 16, 1, 1f, 0.0f);
      else
        SoundEngine.PlaySound(13, i * 16, j * 16, 1, 1f, 0.0f);
      WorldGen.destroyObject = false;
    }

    public static void CheckPalmTree(int i, int j)
    {
      int num1 = -1;
      int num2 = -1;
      int type = (int) Main.tile[i, j].type;
      int frameX = (int) Main.tile[i, j].frameX;
      int frameY = (int) Main.tile[i, j].frameY;
      if (Main.tile[i, j - 1] != null && Main.tile[i, j - 1].active())
        num1 = (int) Main.tile[i, j - 1].type;
      if (Main.tile[i, j + 1] != null && Main.tile[i, j + 1].active())
        num2 = (int) Main.tile[i, j + 1].type;
      if (num2 == 53)
        num2 = 53;
      if (num2 == 234)
        num2 = 53;
      if (num2 == 116)
        num2 = 53;
      if (num2 == 112)
        num2 = 53;
      if (num2 != 53 && num2 != type)
        WorldGen.KillTile(i, j, false, false, false);
      if ((Main.tile[i, j].frameX == (short) 66 || Main.tile[i, j].frameX == (short) 220) && num2 != 53)
        WorldGen.KillTile(i, j, false, false, false);
      if (num1 != type && Main.tile[i, j].frameX <= (short) 44)
        Main.tile[i, j].frameX = (short) (WorldGen.genRand.Next(7, 10) * 22);
      else if (num1 != type && Main.tile[i, j].frameX == (short) 66)
        Main.tile[i, j].frameX = (short) 220;
      if ((int) Main.tile[i, j].frameX == frameX || (int) Main.tile[i, j].frameY == frameY || (frameX < 0 || frameY < 0))
        return;
      WorldGen.TileFrame(i - 1, j, false, false);
      WorldGen.TileFrame(i + 1, j, false, false);
      WorldGen.TileFrame(i, j - 1, false, false);
      WorldGen.TileFrame(i, j + 1, false, false);
    }

    public static void CheckTreeWithSettings(int x, int y, WorldGen.CheckTreeSettings settings)
    {
      int num1 = -1;
      int num2 = -1;
      int num3 = -1;
      int groundTileType = -1;
      Tile tile = Main.tile[x, y];
      int type = (int) tile.type;
      int frameX = (int) tile.frameX;
      int frameY = (int) tile.frameY;
      if (Main.tile[x - 1, y] != null && Main.tile[x - 1, y].active())
        num2 = (int) Main.tile[x - 1, y].type;
      if (Main.tile[x + 1, y] != null && Main.tile[x + 1, y].active())
        num3 = (int) Main.tile[x + 1, y].type;
      if (Main.tile[x, y - 1] != null && Main.tile[x, y - 1].active())
        num1 = (int) Main.tile[x, y - 1].type;
      if (Main.tile[x, y + 1] != null && Main.tile[x, y + 1].active())
        groundTileType = (int) Main.tile[x, y + 1].type;
      bool flag1 = settings.IsGroundValid(groundTileType);
      bool flag2 = num3 == type;
      bool flag3 = num2 == type;
      if (!flag1 && groundTileType != type && (tile.frameX == (short) 0 && tile.frameY <= (short) 130 || tile.frameX == (short) 22 && tile.frameY <= (short) 130 || tile.frameX == (short) 44 && tile.frameY <= (short) 130))
        WorldGen.KillTile(x, y, false, false, false);
      if (tile.frameX >= (short) 22 && tile.frameX <= (short) 44 && (tile.frameY >= (short) 132 && tile.frameY <= (short) 176))
      {
        if (!flag1)
          WorldGen.KillTile(x, y, false, false, false);
        else if (!(tile.frameX == (short) 22 & flag3) && !(tile.frameX == (short) 44 & flag2))
          WorldGen.KillTile(x, y, false, false, false);
      }
      else if (tile.frameX == (short) 88 && tile.frameY >= (short) 0 && tile.frameY <= (short) 44 || tile.frameX == (short) 66 && tile.frameY >= (short) 66 && tile.frameY <= (short) 130 || (tile.frameX == (short) 110 && tile.frameY >= (short) 66 && tile.frameY <= (short) 110 || tile.frameX == (short) 132 && tile.frameY >= (short) 0 && tile.frameY <= (short) 176))
      {
        if (flag3 & flag2)
        {
          if (tile.frameNumber() == (byte) 0)
          {
            tile.frameX = (short) 110;
            tile.frameY = (short) 66;
          }
          if (tile.frameNumber() == (byte) 1)
          {
            tile.frameX = (short) 110;
            tile.frameY = (short) 88;
          }
          if (tile.frameNumber() == (byte) 2)
          {
            tile.frameX = (short) 110;
            tile.frameY = (short) 110;
          }
        }
        else if (flag3)
        {
          if (tile.frameNumber() == (byte) 0)
          {
            tile.frameX = (short) 88;
            tile.frameY = (short) 0;
          }
          if (tile.frameNumber() == (byte) 1)
          {
            tile.frameX = (short) 88;
            tile.frameY = (short) 22;
          }
          if (tile.frameNumber() == (byte) 2)
          {
            tile.frameX = (short) 88;
            tile.frameY = (short) 44;
          }
        }
        else if (flag2)
        {
          if (tile.frameNumber() == (byte) 0)
          {
            tile.frameX = (short) 66;
            tile.frameY = (short) 66;
          }
          if (tile.frameNumber() == (byte) 1)
          {
            tile.frameX = (short) 66;
            tile.frameY = (short) 88;
          }
          if (tile.frameNumber() == (byte) 2)
          {
            tile.frameX = (short) 66;
            tile.frameY = (short) 110;
          }
        }
        else
        {
          if (tile.frameNumber() == (byte) 0)
          {
            tile.frameX = (short) 0;
            tile.frameY = (short) 0;
          }
          if (tile.frameNumber() == (byte) 1)
          {
            tile.frameX = (short) 0;
            tile.frameY = (short) 22;
          }
          if (tile.frameNumber() == (byte) 2)
          {
            tile.frameX = (short) 0;
            tile.frameY = (short) 44;
          }
        }
      }
      if (tile.frameY >= (short) 132 && tile.frameY <= (short) 176 && (tile.frameX == (short) 0 || tile.frameX == (short) 66 || tile.frameX == (short) 88))
      {
        if (!flag1)
          WorldGen.KillTile(x, y, false, false, false);
        if (!flag3 && !flag2)
        {
          if (tile.frameNumber() == (byte) 0)
          {
            tile.frameX = (short) 0;
            tile.frameY = (short) 0;
          }
          if (tile.frameNumber() == (byte) 1)
          {
            tile.frameX = (short) 0;
            tile.frameY = (short) 22;
          }
          if (tile.frameNumber() == (byte) 2)
          {
            tile.frameX = (short) 0;
            tile.frameY = (short) 44;
          }
        }
        else if (!flag3)
        {
          if (tile.frameNumber() == (byte) 0)
          {
            tile.frameX = (short) 0;
            tile.frameY = (short) 132;
          }
          if (tile.frameNumber() == (byte) 1)
          {
            tile.frameX = (short) 0;
            tile.frameY = (short) 154;
          }
          if (tile.frameNumber() == (byte) 2)
          {
            tile.frameX = (short) 0;
            tile.frameY = (short) 176;
          }
        }
        else if (!flag2)
        {
          if (tile.frameNumber() == (byte) 0)
          {
            tile.frameX = (short) 66;
            tile.frameY = (short) 132;
          }
          if (tile.frameNumber() == (byte) 1)
          {
            tile.frameX = (short) 66;
            tile.frameY = (short) 154;
          }
          if (tile.frameNumber() == (byte) 2)
          {
            tile.frameX = (short) 66;
            tile.frameY = (short) 176;
          }
        }
        else
        {
          if (tile.frameNumber() == (byte) 0)
          {
            tile.frameX = (short) 88;
            tile.frameY = (short) 132;
          }
          if (tile.frameNumber() == (byte) 1)
          {
            tile.frameX = (short) 88;
            tile.frameY = (short) 154;
          }
          if (tile.frameNumber() == (byte) 2)
          {
            tile.frameX = (short) 88;
            tile.frameY = (short) 176;
          }
        }
      }
      if (tile.frameX == (short) 66 && (tile.frameY == (short) 0 || tile.frameY == (short) 22 || tile.frameY == (short) 44) || tile.frameX == (short) 44 && (tile.frameY == (short) 198 || tile.frameY == (short) 220 || tile.frameY == (short) 242))
      {
        if (!flag2)
          WorldGen.KillTile(x, y, false, false, false);
      }
      else if (tile.frameX == (short) 88 && (tile.frameY == (short) 66 || tile.frameY == (short) 88 || tile.frameY == (short) 110) || tile.frameX == (short) 66 && (tile.frameY == (short) 198 || tile.frameY == (short) 220 || tile.frameY == (short) 242))
      {
        if (!flag3)
          WorldGen.KillTile(x, y, false, false, false);
      }
      else if (groundTileType == -1)
        WorldGen.KillTile(x, y, false, false, false);
      else if (num1 != type && tile.frameY < (short) 198 && (tile.frameX != (short) 22 && tile.frameX != (short) 44 || tile.frameY < (short) 132))
      {
        if (flag3 | flag2)
        {
          if (groundTileType == type)
          {
            if (flag3 & flag2)
            {
              if (tile.frameNumber() == (byte) 0)
              {
                tile.frameX = (short) 132;
                tile.frameY = (short) 132;
              }
              if (tile.frameNumber() == (byte) 1)
              {
                tile.frameX = (short) 132;
                tile.frameY = (short) 154;
              }
              if (tile.frameNumber() == (byte) 2)
              {
                tile.frameX = (short) 132;
                tile.frameY = (short) 176;
              }
            }
            else if (flag3)
            {
              if (tile.frameNumber() == (byte) 0)
              {
                tile.frameX = (short) 132;
                tile.frameY = (short) 0;
              }
              if (tile.frameNumber() == (byte) 1)
              {
                tile.frameX = (short) 132;
                tile.frameY = (short) 22;
              }
              if (tile.frameNumber() == (byte) 2)
              {
                tile.frameX = (short) 132;
                tile.frameY = (short) 44;
              }
            }
            else if (flag2)
            {
              if (tile.frameNumber() == (byte) 0)
              {
                tile.frameX = (short) 132;
                tile.frameY = (short) 66;
              }
              if (tile.frameNumber() == (byte) 1)
              {
                tile.frameX = (short) 132;
                tile.frameY = (short) 88;
              }
              if (tile.frameNumber() == (byte) 2)
              {
                tile.frameX = (short) 132;
                tile.frameY = (short) 110;
              }
            }
          }
          else if (flag3 & flag2)
          {
            if (tile.frameNumber() == (byte) 0)
            {
              tile.frameX = (short) 154;
              tile.frameY = (short) 132;
            }
            if (tile.frameNumber() == (byte) 1)
            {
              tile.frameX = (short) 154;
              tile.frameY = (short) 154;
            }
            if (tile.frameNumber() == (byte) 2)
            {
              tile.frameX = (short) 154;
              tile.frameY = (short) 176;
            }
          }
          else if (flag3)
          {
            if (tile.frameNumber() == (byte) 0)
            {
              tile.frameX = (short) 154;
              tile.frameY = (short) 0;
            }
            if (tile.frameNumber() == (byte) 1)
            {
              tile.frameX = (short) 154;
              tile.frameY = (short) 22;
            }
            if (tile.frameNumber() == (byte) 2)
            {
              tile.frameX = (short) 154;
              tile.frameY = (short) 44;
            }
          }
          else if (flag2)
          {
            if (tile.frameNumber() == (byte) 0)
            {
              tile.frameX = (short) 154;
              tile.frameY = (short) 66;
            }
            if (tile.frameNumber() == (byte) 1)
            {
              tile.frameX = (short) 154;
              tile.frameY = (short) 88;
            }
            if (tile.frameNumber() == (byte) 2)
            {
              tile.frameX = (short) 154;
              tile.frameY = (short) 110;
            }
          }
        }
        else
        {
          if (tile.frameNumber() == (byte) 0)
          {
            tile.frameX = (short) 110;
            tile.frameY = (short) 0;
          }
          if (tile.frameNumber() == (byte) 1)
          {
            tile.frameX = (short) 110;
            tile.frameY = (short) 22;
          }
          if (tile.frameNumber() == (byte) 2)
          {
            tile.frameX = (short) 110;
            tile.frameY = (short) 44;
          }
        }
      }
      if ((int) tile.frameX == frameX || (int) tile.frameY == frameY || (frameX < 0 || frameY < 0))
        return;
      WorldGen.TileFrame(x - 1, y, false, false);
      WorldGen.TileFrame(x + 1, y, false, false);
      WorldGen.TileFrame(x, y - 1, false, false);
      WorldGen.TileFrame(x, y + 1, false, false);
    }

    public static void CheckTree(int i, int j)
    {
      int num1 = -1;
      int num2 = -1;
      int num3 = -1;
      int num4 = -1;
      int type1 = (int) Main.tile[i, j].type;
      int frameX = (int) Main.tile[i, j].frameX;
      int frameY = (int) Main.tile[i, j].frameY;
      if (Main.tile[i - 1, j] != null && Main.tile[i - 1, j].active())
        num2 = (int) Main.tile[i - 1, j].type;
      if (Main.tile[i + 1, j] != null && Main.tile[i + 1, j].active())
        num3 = (int) Main.tile[i + 1, j].type;
      if (Main.tile[i, j - 1] != null && Main.tile[i, j - 1].active())
        num1 = (int) Main.tile[i, j - 1].type;
      if (Main.tile[i, j + 1] != null && Main.tile[i, j + 1].active())
        num4 = (int) Main.tile[i, j + 1].type;
      if (Main.tile[i - 1, j - 1] != null && Main.tile[i - 1, j - 1].active())
      {
        int type2 = (int) Main.tile[i - 1, j - 1].type;
      }
      if (Main.tile[i + 1, j - 1] != null && Main.tile[i + 1, j - 1].active())
      {
        int type3 = (int) Main.tile[i + 1, j - 1].type;
      }
      if (Main.tile[i - 1, j + 1] != null && Main.tile[i - 1, j + 1].active())
      {
        int type4 = (int) Main.tile[i - 1, j + 1].type;
      }
      if (Main.tile[i + 1, j + 1] != null && Main.tile[i + 1, j + 1].active())
      {
        int type5 = (int) Main.tile[i + 1, j + 1].type;
      }
      if (num4 == 23)
        num4 = 2;
      if (num4 == 477)
        num4 = 2;
      if (num4 == 60)
        num4 = 2;
      if (num4 == 70)
        num4 = 2;
      if (num4 == 109)
        num4 = 2;
      if (num4 == 147)
        num4 = 2;
      if (num4 == 199)
        num4 = 2;
      if (num4 == 492)
        num4 = 2;
      if (num4 != 2 && num4 != type1 && (Main.tile[i, j].frameX == (short) 0 && Main.tile[i, j].frameY <= (short) 130 || Main.tile[i, j].frameX == (short) 22 && Main.tile[i, j].frameY <= (short) 130 || Main.tile[i, j].frameX == (short) 44 && Main.tile[i, j].frameY <= (short) 130))
        WorldGen.KillTile(i, j, false, false, false);
      if (Main.tile[i, j].frameX >= (short) 22 && Main.tile[i, j].frameX <= (short) 44 && (Main.tile[i, j].frameY >= (short) 132 && Main.tile[i, j].frameY <= (short) 176))
      {
        if (num4 != 2)
          WorldGen.KillTile(i, j, false, false, false);
        else if ((Main.tile[i, j].frameX != (short) 22 || num2 != type1) && (Main.tile[i, j].frameX != (short) 44 || num3 != type1))
          WorldGen.KillTile(i, j, false, false, false);
      }
      else if (Main.tile[i, j].frameX == (short) 88 && Main.tile[i, j].frameY >= (short) 0 && Main.tile[i, j].frameY <= (short) 44 || Main.tile[i, j].frameX == (short) 66 && Main.tile[i, j].frameY >= (short) 66 && Main.tile[i, j].frameY <= (short) 130 || (Main.tile[i, j].frameX == (short) 110 && Main.tile[i, j].frameY >= (short) 66 && Main.tile[i, j].frameY <= (short) 110 || Main.tile[i, j].frameX == (short) 132 && Main.tile[i, j].frameY >= (short) 0 && Main.tile[i, j].frameY <= (short) 176))
      {
        if (num2 == type1 && num3 == type1)
        {
          if (Main.tile[i, j].frameNumber() == (byte) 0)
          {
            Main.tile[i, j].frameX = (short) 110;
            Main.tile[i, j].frameY = (short) 66;
          }
          if (Main.tile[i, j].frameNumber() == (byte) 1)
          {
            Main.tile[i, j].frameX = (short) 110;
            Main.tile[i, j].frameY = (short) 88;
          }
          if (Main.tile[i, j].frameNumber() == (byte) 2)
          {
            Main.tile[i, j].frameX = (short) 110;
            Main.tile[i, j].frameY = (short) 110;
          }
        }
        else if (num2 == type1)
        {
          if (Main.tile[i, j].frameNumber() == (byte) 0)
          {
            Main.tile[i, j].frameX = (short) 88;
            Main.tile[i, j].frameY = (short) 0;
          }
          if (Main.tile[i, j].frameNumber() == (byte) 1)
          {
            Main.tile[i, j].frameX = (short) 88;
            Main.tile[i, j].frameY = (short) 22;
          }
          if (Main.tile[i, j].frameNumber() == (byte) 2)
          {
            Main.tile[i, j].frameX = (short) 88;
            Main.tile[i, j].frameY = (short) 44;
          }
        }
        else if (num3 == type1)
        {
          if (Main.tile[i, j].frameNumber() == (byte) 0)
          {
            Main.tile[i, j].frameX = (short) 66;
            Main.tile[i, j].frameY = (short) 66;
          }
          if (Main.tile[i, j].frameNumber() == (byte) 1)
          {
            Main.tile[i, j].frameX = (short) 66;
            Main.tile[i, j].frameY = (short) 88;
          }
          if (Main.tile[i, j].frameNumber() == (byte) 2)
          {
            Main.tile[i, j].frameX = (short) 66;
            Main.tile[i, j].frameY = (short) 110;
          }
        }
        else
        {
          if (Main.tile[i, j].frameNumber() == (byte) 0)
          {
            Main.tile[i, j].frameX = (short) 0;
            Main.tile[i, j].frameY = (short) 0;
          }
          if (Main.tile[i, j].frameNumber() == (byte) 1)
          {
            Main.tile[i, j].frameX = (short) 0;
            Main.tile[i, j].frameY = (short) 22;
          }
          if (Main.tile[i, j].frameNumber() == (byte) 2)
          {
            Main.tile[i, j].frameX = (short) 0;
            Main.tile[i, j].frameY = (short) 44;
          }
        }
      }
      if (Main.tile[i, j].frameY >= (short) 132 && Main.tile[i, j].frameY <= (short) 176 && (Main.tile[i, j].frameX == (short) 0 || Main.tile[i, j].frameX == (short) 66 || Main.tile[i, j].frameX == (short) 88))
      {
        if (num4 != 2)
          WorldGen.KillTile(i, j, false, false, false);
        if (num2 != type1 && num3 != type1)
        {
          if (Main.tile[i, j].frameNumber() == (byte) 0)
          {
            Main.tile[i, j].frameX = (short) 0;
            Main.tile[i, j].frameY = (short) 0;
          }
          if (Main.tile[i, j].frameNumber() == (byte) 1)
          {
            Main.tile[i, j].frameX = (short) 0;
            Main.tile[i, j].frameY = (short) 22;
          }
          if (Main.tile[i, j].frameNumber() == (byte) 2)
          {
            Main.tile[i, j].frameX = (short) 0;
            Main.tile[i, j].frameY = (short) 44;
          }
        }
        else if (num2 != type1)
        {
          if (Main.tile[i, j].frameNumber() == (byte) 0)
          {
            Main.tile[i, j].frameX = (short) 0;
            Main.tile[i, j].frameY = (short) 132;
          }
          if (Main.tile[i, j].frameNumber() == (byte) 1)
          {
            Main.tile[i, j].frameX = (short) 0;
            Main.tile[i, j].frameY = (short) 154;
          }
          if (Main.tile[i, j].frameNumber() == (byte) 2)
          {
            Main.tile[i, j].frameX = (short) 0;
            Main.tile[i, j].frameY = (short) 176;
          }
        }
        else if (num3 != type1)
        {
          if (Main.tile[i, j].frameNumber() == (byte) 0)
          {
            Main.tile[i, j].frameX = (short) 66;
            Main.tile[i, j].frameY = (short) 132;
          }
          if (Main.tile[i, j].frameNumber() == (byte) 1)
          {
            Main.tile[i, j].frameX = (short) 66;
            Main.tile[i, j].frameY = (short) 154;
          }
          if (Main.tile[i, j].frameNumber() == (byte) 2)
          {
            Main.tile[i, j].frameX = (short) 66;
            Main.tile[i, j].frameY = (short) 176;
          }
        }
        else
        {
          if (Main.tile[i, j].frameNumber() == (byte) 0)
          {
            Main.tile[i, j].frameX = (short) 88;
            Main.tile[i, j].frameY = (short) 132;
          }
          if (Main.tile[i, j].frameNumber() == (byte) 1)
          {
            Main.tile[i, j].frameX = (short) 88;
            Main.tile[i, j].frameY = (short) 154;
          }
          if (Main.tile[i, j].frameNumber() == (byte) 2)
          {
            Main.tile[i, j].frameX = (short) 88;
            Main.tile[i, j].frameY = (short) 176;
          }
        }
      }
      if (Main.tile[i, j].frameX == (short) 66 && (Main.tile[i, j].frameY == (short) 0 || Main.tile[i, j].frameY == (short) 22 || Main.tile[i, j].frameY == (short) 44) || Main.tile[i, j].frameX == (short) 44 && (Main.tile[i, j].frameY == (short) 198 || Main.tile[i, j].frameY == (short) 220 || Main.tile[i, j].frameY == (short) 242))
      {
        if (num3 != type1)
          WorldGen.KillTile(i, j, false, false, false);
      }
      else if (Main.tile[i, j].frameX == (short) 88 && (Main.tile[i, j].frameY == (short) 66 || Main.tile[i, j].frameY == (short) 88 || Main.tile[i, j].frameY == (short) 110) || Main.tile[i, j].frameX == (short) 66 && (Main.tile[i, j].frameY == (short) 198 || Main.tile[i, j].frameY == (short) 220 || Main.tile[i, j].frameY == (short) 242))
      {
        if (num2 != type1)
          WorldGen.KillTile(i, j, false, false, false);
      }
      else if (num4 == -1 || num4 == 23)
        WorldGen.KillTile(i, j, false, false, false);
      else if (num1 != type1 && Main.tile[i, j].frameY < (short) 198 && (Main.tile[i, j].frameX != (short) 22 && Main.tile[i, j].frameX != (short) 44 || Main.tile[i, j].frameY < (short) 132))
      {
        if (num2 == type1 || num3 == type1)
        {
          if (num4 == type1)
          {
            if (num2 == type1 && num3 == type1)
            {
              if (Main.tile[i, j].frameNumber() == (byte) 0)
              {
                Main.tile[i, j].frameX = (short) 132;
                Main.tile[i, j].frameY = (short) 132;
              }
              if (Main.tile[i, j].frameNumber() == (byte) 1)
              {
                Main.tile[i, j].frameX = (short) 132;
                Main.tile[i, j].frameY = (short) 154;
              }
              if (Main.tile[i, j].frameNumber() == (byte) 2)
              {
                Main.tile[i, j].frameX = (short) 132;
                Main.tile[i, j].frameY = (short) 176;
              }
            }
            else if (num2 == type1)
            {
              if (Main.tile[i, j].frameNumber() == (byte) 0)
              {
                Main.tile[i, j].frameX = (short) 132;
                Main.tile[i, j].frameY = (short) 0;
              }
              if (Main.tile[i, j].frameNumber() == (byte) 1)
              {
                Main.tile[i, j].frameX = (short) 132;
                Main.tile[i, j].frameY = (short) 22;
              }
              if (Main.tile[i, j].frameNumber() == (byte) 2)
              {
                Main.tile[i, j].frameX = (short) 132;
                Main.tile[i, j].frameY = (short) 44;
              }
            }
            else if (num3 == type1)
            {
              if (Main.tile[i, j].frameNumber() == (byte) 0)
              {
                Main.tile[i, j].frameX = (short) 132;
                Main.tile[i, j].frameY = (short) 66;
              }
              if (Main.tile[i, j].frameNumber() == (byte) 1)
              {
                Main.tile[i, j].frameX = (short) 132;
                Main.tile[i, j].frameY = (short) 88;
              }
              if (Main.tile[i, j].frameNumber() == (byte) 2)
              {
                Main.tile[i, j].frameX = (short) 132;
                Main.tile[i, j].frameY = (short) 110;
              }
            }
          }
          else if (num2 == type1 && num3 == type1)
          {
            if (Main.tile[i, j].frameNumber() == (byte) 0)
            {
              Main.tile[i, j].frameX = (short) 154;
              Main.tile[i, j].frameY = (short) 132;
            }
            if (Main.tile[i, j].frameNumber() == (byte) 1)
            {
              Main.tile[i, j].frameX = (short) 154;
              Main.tile[i, j].frameY = (short) 154;
            }
            if (Main.tile[i, j].frameNumber() == (byte) 2)
            {
              Main.tile[i, j].frameX = (short) 154;
              Main.tile[i, j].frameY = (short) 176;
            }
          }
          else if (num2 == type1)
          {
            if (Main.tile[i, j].frameNumber() == (byte) 0)
            {
              Main.tile[i, j].frameX = (short) 154;
              Main.tile[i, j].frameY = (short) 0;
            }
            if (Main.tile[i, j].frameNumber() == (byte) 1)
            {
              Main.tile[i, j].frameX = (short) 154;
              Main.tile[i, j].frameY = (short) 22;
            }
            if (Main.tile[i, j].frameNumber() == (byte) 2)
            {
              Main.tile[i, j].frameX = (short) 154;
              Main.tile[i, j].frameY = (short) 44;
            }
          }
          else if (num3 == type1)
          {
            if (Main.tile[i, j].frameNumber() == (byte) 0)
            {
              Main.tile[i, j].frameX = (short) 154;
              Main.tile[i, j].frameY = (short) 66;
            }
            if (Main.tile[i, j].frameNumber() == (byte) 1)
            {
              Main.tile[i, j].frameX = (short) 154;
              Main.tile[i, j].frameY = (short) 88;
            }
            if (Main.tile[i, j].frameNumber() == (byte) 2)
            {
              Main.tile[i, j].frameX = (short) 154;
              Main.tile[i, j].frameY = (short) 110;
            }
          }
        }
        else
        {
          if (Main.tile[i, j].frameNumber() == (byte) 0)
          {
            Main.tile[i, j].frameX = (short) 110;
            Main.tile[i, j].frameY = (short) 0;
          }
          if (Main.tile[i, j].frameNumber() == (byte) 1)
          {
            Main.tile[i, j].frameX = (short) 110;
            Main.tile[i, j].frameY = (short) 22;
          }
          if (Main.tile[i, j].frameNumber() == (byte) 2)
          {
            Main.tile[i, j].frameX = (short) 110;
            Main.tile[i, j].frameY = (short) 44;
          }
        }
      }
      if ((int) Main.tile[i, j].frameX == frameX || (int) Main.tile[i, j].frameY == frameY || (frameX < 0 || frameY < 0))
        return;
      WorldGen.TileFrame(i - 1, j, false, false);
      WorldGen.TileFrame(i + 1, j, false, false);
      WorldGen.TileFrame(i, j - 1, false, false);
      WorldGen.TileFrame(i, j + 1, false, false);
    }

    public static void Convert(int i, int j, int conversionType, int size = 4)
    {
      for (int index1 = i - size; index1 <= i + size; ++index1)
      {
        for (int index2 = j - size; index2 <= j + size; ++index2)
        {
          if (WorldGen.InWorld(index1, index2, 1) && Math.Abs(index1 - i) + Math.Abs(index2 - j) < 6)
          {
            int type = (int) Main.tile[index1, index2].type;
            int wall = (int) Main.tile[index1, index2].wall;
            switch (conversionType)
            {
              case 1:
                if (type <= 623 && wall <= 316)
                {
                  if (WallID.Sets.Conversion.Grass[wall] && wall != 69)
                  {
                    Main.tile[index1, index2].wall = (ushort) 69;
                    WorldGen.SquareWallFrame(index1, index2, true);
                    NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                  }
                  else if (WallID.Sets.Conversion.Stone[wall] && wall != 3)
                  {
                    Main.tile[index1, index2].wall = (ushort) 3;
                    WorldGen.SquareWallFrame(index1, index2, true);
                    NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                  }
                  else if (WallID.Sets.Conversion.HardenedSand[wall] && wall != 217)
                  {
                    Main.tile[index1, index2].wall = (ushort) 217;
                    WorldGen.SquareWallFrame(index1, index2, true);
                    NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                  }
                  else if (WallID.Sets.Conversion.Sandstone[wall] && wall != 220)
                  {
                    Main.tile[index1, index2].wall = (ushort) 220;
                    WorldGen.SquareWallFrame(index1, index2, true);
                    NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                  }
                  else if (WallID.Sets.Conversion.NewWall1[wall] && wall != 188)
                  {
                    Main.tile[index1, index2].wall = (ushort) 188;
                    WorldGen.SquareWallFrame(index1, index2, true);
                    NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                  }
                  else if (WallID.Sets.Conversion.NewWall2[wall] && wall != 189)
                  {
                    Main.tile[index1, index2].wall = (ushort) 189;
                    WorldGen.SquareWallFrame(index1, index2, true);
                    NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                  }
                  else if (WallID.Sets.Conversion.NewWall3[wall] && wall != 190)
                  {
                    Main.tile[index1, index2].wall = (ushort) 190;
                    WorldGen.SquareWallFrame(index1, index2, true);
                    NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                  }
                  else if (WallID.Sets.Conversion.NewWall4[wall] && wall != 191)
                  {
                    Main.tile[index1, index2].wall = (ushort) 191;
                    WorldGen.SquareWallFrame(index1, index2, true);
                    NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                  }
                  if ((Main.tileMoss[type] || TileID.Sets.Conversion.Stone[type]) && type != 25)
                  {
                    Main.tile[index1, index2].type = (ushort) 25;
                    WorldGen.SquareTileFrame(index1, index2, true);
                    NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                  }
                  else if (TileID.Sets.Conversion.Grass[type] && type != 23)
                  {
                    Main.tile[index1, index2].type = (ushort) 23;
                    WorldGen.SquareTileFrame(index1, index2, true);
                    NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                  }
                  else if (TileID.Sets.Conversion.Ice[type] && type != 163)
                  {
                    Main.tile[index1, index2].type = (ushort) 163;
                    WorldGen.SquareTileFrame(index1, index2, true);
                    NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                  }
                  else if (TileID.Sets.Conversion.Sand[type] && type != 112)
                  {
                    Main.tile[index1, index2].type = (ushort) 112;
                    WorldGen.SquareTileFrame(index1, index2, true);
                    NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                  }
                  else if (TileID.Sets.Conversion.HardenedSand[type] && type != 398)
                  {
                    Main.tile[index1, index2].type = (ushort) 398;
                    WorldGen.SquareTileFrame(index1, index2, true);
                    NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                  }
                  else if (TileID.Sets.Conversion.Sandstone[type] && type != 400)
                  {
                    Main.tile[index1, index2].type = (ushort) 400;
                    WorldGen.SquareTileFrame(index1, index2, true);
                    NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                  }
                  else if (TileID.Sets.Conversion.Thorn[type] && type != 32)
                  {
                    Main.tile[index1, index2].type = (ushort) 32;
                    WorldGen.SquareTileFrame(index1, index2, true);
                    NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                  }
                  if (type == 59 && (Main.tile[index1 - 1, index2].type == (ushort) 23 || Main.tile[index1 + 1, index2].type == (ushort) 23 || (Main.tile[index1, index2 - 1].type == (ushort) 23 || Main.tile[index1, index2 + 1].type == (ushort) 23)))
                  {
                    Main.tile[index1, index2].type = (ushort) 0;
                    WorldGen.SquareTileFrame(index1, index2, true);
                    NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                    continue;
                  }
                  continue;
                }
                continue;
              case 2:
                if (type <= 623 && wall <= 316)
                {
                  if (WallID.Sets.Conversion.Grass[wall] && wall != 70)
                  {
                    Main.tile[index1, index2].wall = (ushort) 70;
                    WorldGen.SquareWallFrame(index1, index2, true);
                    NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                  }
                  else if (WallID.Sets.Conversion.Stone[wall] && wall != 28)
                  {
                    Main.tile[index1, index2].wall = (ushort) 28;
                    WorldGen.SquareWallFrame(index1, index2, true);
                    NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                  }
                  else if (WallID.Sets.Conversion.HardenedSand[wall] && wall != 219)
                  {
                    Main.tile[index1, index2].wall = (ushort) 219;
                    WorldGen.SquareWallFrame(index1, index2, true);
                    NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                  }
                  else if (WallID.Sets.Conversion.Sandstone[wall] && wall != 222)
                  {
                    Main.tile[index1, index2].wall = (ushort) 222;
                    WorldGen.SquareWallFrame(index1, index2, true);
                    NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                  }
                  else if (WallID.Sets.Conversion.NewWall1[wall] && wall != 200)
                  {
                    Main.tile[index1, index2].wall = (ushort) 200;
                    WorldGen.SquareWallFrame(index1, index2, true);
                    NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                  }
                  else if (WallID.Sets.Conversion.NewWall2[wall] && wall != 201)
                  {
                    Main.tile[index1, index2].wall = (ushort) 201;
                    WorldGen.SquareWallFrame(index1, index2, true);
                    NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                  }
                  else if (WallID.Sets.Conversion.NewWall3[wall] && wall != 202)
                  {
                    Main.tile[index1, index2].wall = (ushort) 202;
                    WorldGen.SquareWallFrame(index1, index2, true);
                    NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                  }
                  else if (WallID.Sets.Conversion.NewWall4[wall] && wall != 203)
                  {
                    Main.tile[index1, index2].wall = (ushort) 203;
                    WorldGen.SquareWallFrame(index1, index2, true);
                    NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                  }
                  if ((Main.tileMoss[type] || TileID.Sets.Conversion.Stone[type]) && type != 117)
                  {
                    Main.tile[index1, index2].type = (ushort) 117;
                    WorldGen.SquareTileFrame(index1, index2, true);
                    NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                  }
                  else if (TileID.Sets.Conversion.GolfGrass[type] && type != 492)
                  {
                    Main.tile[index1, index2].type = (ushort) 492;
                    WorldGen.SquareTileFrame(index1, index2, true);
                    NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                  }
                  else if (TileID.Sets.Conversion.Grass[type] && type != 109 && type != 492)
                  {
                    Main.tile[index1, index2].type = (ushort) 109;
                    WorldGen.SquareTileFrame(index1, index2, true);
                    NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                  }
                  else if (TileID.Sets.Conversion.Ice[type] && type != 164)
                  {
                    Main.tile[index1, index2].type = (ushort) 164;
                    WorldGen.SquareTileFrame(index1, index2, true);
                    NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                  }
                  else if (TileID.Sets.Conversion.Sand[type] && type != 116)
                  {
                    Main.tile[index1, index2].type = (ushort) 116;
                    WorldGen.SquareTileFrame(index1, index2, true);
                    NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                  }
                  else if (TileID.Sets.Conversion.HardenedSand[type] && type != 402)
                  {
                    Main.tile[index1, index2].type = (ushort) 402;
                    WorldGen.SquareTileFrame(index1, index2, true);
                    NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                  }
                  else if (TileID.Sets.Conversion.Sandstone[type] && type != 403)
                  {
                    Main.tile[index1, index2].type = (ushort) 403;
                    WorldGen.SquareTileFrame(index1, index2, true);
                    NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                  }
                  else if (TileID.Sets.Conversion.Thorn[type])
                  {
                    WorldGen.KillTile(index1, index2, false, false, false);
                    if (Main.netMode == 1)
                      NetMessage.SendData(17, -1, -1, (NetworkText) null, 0, (float) index1, (float) index2, 0.0f, 0, 0, 0);
                  }
                  if (type == 59 && (Main.tile[index1 - 1, index2].type == (ushort) 109 || Main.tile[index1 + 1, index2].type == (ushort) 109 || (Main.tile[index1, index2 - 1].type == (ushort) 109 || Main.tile[index1, index2 + 1].type == (ushort) 109)))
                  {
                    Main.tile[index1, index2].type = (ushort) 0;
                    WorldGen.SquareTileFrame(index1, index2, true);
                    NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                    continue;
                  }
                  continue;
                }
                continue;
              case 3:
                if (WallID.Sets.CanBeConvertedToGlowingMushroom[wall])
                {
                  Main.tile[index1, index2].wall = (ushort) 80;
                  WorldGen.SquareWallFrame(index1, index2, true);
                  NetMessage.SendTileSquare(-1, index1, index2, 3, TileChangeType.None);
                }
                if (Main.tile[index1, index2].type == (ushort) 60)
                {
                  Main.tile[index1, index2].type = (ushort) 70;
                  WorldGen.SquareTileFrame(index1, index2, true);
                  NetMessage.SendTileSquare(-1, index1, index2, 3, TileChangeType.None);
                  continue;
                }
                if (TileID.Sets.Conversion.Thorn[type])
                {
                  WorldGen.KillTile(index1, index2, false, false, false);
                  if (Main.netMode == 1)
                  {
                    NetMessage.SendData(17, -1, -1, (NetworkText) null, 0, (float) index1, (float) index2, 0.0f, 0, 0, 0);
                    continue;
                  }
                  continue;
                }
                continue;
              case 4:
                if (type <= 623 && wall <= 316)
                {
                  if (WallID.Sets.Conversion.Grass[wall] && wall != 81)
                  {
                    Main.tile[index1, index2].wall = (ushort) 81;
                    WorldGen.SquareWallFrame(index1, index2, true);
                    NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                  }
                  else if (WallID.Sets.Conversion.Stone[wall] && wall != 83)
                  {
                    Main.tile[index1, index2].wall = (ushort) 83;
                    WorldGen.SquareWallFrame(index1, index2, true);
                    NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                  }
                  else if (WallID.Sets.Conversion.HardenedSand[wall] && wall != 218)
                  {
                    Main.tile[index1, index2].wall = (ushort) 218;
                    WorldGen.SquareWallFrame(index1, index2, true);
                    NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                  }
                  else if (WallID.Sets.Conversion.Sandstone[wall] && wall != 221)
                  {
                    Main.tile[index1, index2].wall = (ushort) 221;
                    WorldGen.SquareWallFrame(index1, index2, true);
                    NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                  }
                  else if (WallID.Sets.Conversion.NewWall1[wall] && wall != 192)
                  {
                    Main.tile[index1, index2].wall = (ushort) 192;
                    WorldGen.SquareWallFrame(index1, index2, true);
                    NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                  }
                  else if (WallID.Sets.Conversion.NewWall2[wall] && wall != 193)
                  {
                    Main.tile[index1, index2].wall = (ushort) 193;
                    WorldGen.SquareWallFrame(index1, index2, true);
                    NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                  }
                  else if (WallID.Sets.Conversion.NewWall3[wall] && wall != 194)
                  {
                    Main.tile[index1, index2].wall = (ushort) 194;
                    WorldGen.SquareWallFrame(index1, index2, true);
                    NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                  }
                  else if (WallID.Sets.Conversion.NewWall4[wall] && wall != 195)
                  {
                    Main.tile[index1, index2].wall = (ushort) 195;
                    WorldGen.SquareWallFrame(index1, index2, true);
                    NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                  }
                  if ((Main.tileMoss[type] || TileID.Sets.Conversion.Stone[type]) && type != 203)
                  {
                    Main.tile[index1, index2].type = (ushort) 203;
                    WorldGen.SquareTileFrame(index1, index2, true);
                    NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                  }
                  else if (TileID.Sets.Conversion.Grass[type] && type != 199)
                  {
                    Main.tile[index1, index2].type = (ushort) 199;
                    WorldGen.SquareTileFrame(index1, index2, true);
                    NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                  }
                  else if (TileID.Sets.Conversion.Ice[type] && type != 200)
                  {
                    Main.tile[index1, index2].type = (ushort) 200;
                    WorldGen.SquareTileFrame(index1, index2, true);
                    NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                  }
                  else if (TileID.Sets.Conversion.Sand[type] && type != 234)
                  {
                    Main.tile[index1, index2].type = (ushort) 234;
                    WorldGen.SquareTileFrame(index1, index2, true);
                    NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                  }
                  else if (TileID.Sets.Conversion.HardenedSand[type] && type != 399)
                  {
                    Main.tile[index1, index2].type = (ushort) 399;
                    WorldGen.SquareTileFrame(index1, index2, true);
                    NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                  }
                  else if (TileID.Sets.Conversion.Sandstone[type] && type != 401)
                  {
                    Main.tile[index1, index2].type = (ushort) 401;
                    WorldGen.SquareTileFrame(index1, index2, true);
                    NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                  }
                  else if (TileID.Sets.Conversion.Thorn[type] && type != 352)
                  {
                    Main.tile[index1, index2].type = (ushort) 352;
                    WorldGen.SquareTileFrame(index1, index2, true);
                    NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                  }
                  if (type == 59 && (Main.tile[index1 - 1, index2].type == (ushort) 199 || Main.tile[index1 + 1, index2].type == (ushort) 199 || (Main.tile[index1, index2 - 1].type == (ushort) 199 || Main.tile[index1, index2 + 1].type == (ushort) 199)))
                  {
                    Main.tile[index1, index2].type = (ushort) 0;
                    WorldGen.SquareTileFrame(index1, index2, true);
                    NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                    continue;
                  }
                  continue;
                }
                continue;
              default:
                if (Main.tile[index1, index2].wall == (ushort) 69 || Main.tile[index1, index2].wall == (ushort) 70 || Main.tile[index1, index2].wall == (ushort) 81)
                {
                  Main.tile[index1, index2].wall = (double) index2 >= Main.worldSurface ? (ushort) 64 : (WorldGen.genRand.Next(10) != 0 ? (ushort) 63 : (ushort) 65);
                  WorldGen.SquareWallFrame(index1, index2, true);
                  NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                }
                else if (WallID.Sets.Conversion.Stone[wall] && wall != 1 && (wall != 262 && wall != 274) && (wall != 61 && wall != 185))
                {
                  Main.tile[index1, index2].wall = (ushort) 1;
                  WorldGen.SquareWallFrame(index1, index2, true);
                  NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                }
                else if (WallID.Sets.Conversion.Stone[wall] && wall == 262)
                {
                  Main.tile[index1, index2].wall = (ushort) 61;
                  WorldGen.SquareWallFrame(index1, index2, true);
                  NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                }
                else if (WallID.Sets.Conversion.Stone[wall] && wall == 274)
                {
                  Main.tile[index1, index2].wall = (ushort) 185;
                  WorldGen.SquareWallFrame(index1, index2, true);
                  NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                }
                if (WallID.Sets.Conversion.NewWall1[wall] && wall != 212)
                {
                  Main.tile[index1, index2].wall = (ushort) 212;
                  WorldGen.SquareWallFrame(index1, index2, true);
                  NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                }
                else if (WallID.Sets.Conversion.NewWall2[wall] && wall != 213)
                {
                  Main.tile[index1, index2].wall = (ushort) 213;
                  WorldGen.SquareWallFrame(index1, index2, true);
                  NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                }
                else if (WallID.Sets.Conversion.NewWall3[wall] && wall != 214)
                {
                  Main.tile[index1, index2].wall = (ushort) 214;
                  WorldGen.SquareWallFrame(index1, index2, true);
                  NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                }
                else if (WallID.Sets.Conversion.NewWall4[wall] && wall != 215)
                {
                  Main.tile[index1, index2].wall = (ushort) 215;
                  WorldGen.SquareWallFrame(index1, index2, true);
                  NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                }
                else if (Main.tile[index1, index2].wall == (ushort) 80)
                {
                  if ((double) index2 < Main.worldSurface + 4.0 + (double) WorldGen.genRand.Next(3) || (double) index2 > ((double) Main.maxTilesY + Main.rockLayer) / 2.0 - 3.0 + (double) WorldGen.genRand.Next(3))
                  {
                    Main.tile[index1, index2].wall = (ushort) 15;
                    WorldGen.SquareWallFrame(index1, index2, true);
                    NetMessage.SendTileSquare(-1, index1, index2, 3, TileChangeType.None);
                  }
                  else
                  {
                    Main.tile[index1, index2].wall = (ushort) 64;
                    WorldGen.SquareWallFrame(index1, index2, true);
                    NetMessage.SendTileSquare(-1, index1, index2, 3, TileChangeType.None);
                  }
                }
                else if (WallID.Sets.Conversion.HardenedSand[wall] && wall != 216)
                {
                  Main.tile[index1, index2].wall = (ushort) 216;
                  WorldGen.SquareWallFrame(index1, index2, true);
                  NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                }
                else if (WallID.Sets.Conversion.Sandstone[wall] && wall != 187)
                {
                  Main.tile[index1, index2].wall = (ushort) 187;
                  WorldGen.SquareWallFrame(index1, index2, true);
                  NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                }
                if (Main.tile[index1, index2].type == (ushort) 492)
                {
                  Main.tile[index1, index2].type = (ushort) 477;
                  WorldGen.SquareTileFrame(index1, index2, true);
                  NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                  continue;
                }
                if (type != 60 && TileID.Sets.Conversion.Grass[type] && (type != 2 && type != 477))
                {
                  Main.tile[index1, index2].type = (ushort) 2;
                  WorldGen.SquareTileFrame(index1, index2, true);
                  NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                  continue;
                }
                if (TileID.Sets.Conversion.Stone[type] && type != 1)
                {
                  Main.tile[index1, index2].type = (ushort) 1;
                  WorldGen.SquareTileFrame(index1, index2, true);
                  NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                  continue;
                }
                if (TileID.Sets.Conversion.Sand[type] && type != 53)
                {
                  Main.tile[index1, index2].type = (ushort) 53;
                  WorldGen.SquareTileFrame(index1, index2, true);
                  NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                  continue;
                }
                if (TileID.Sets.Conversion.HardenedSand[type] && type != 397)
                {
                  Main.tile[index1, index2].type = (ushort) 397;
                  WorldGen.SquareTileFrame(index1, index2, true);
                  NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                  continue;
                }
                if (TileID.Sets.Conversion.Sandstone[type] && type != 396)
                {
                  Main.tile[index1, index2].type = (ushort) 396;
                  WorldGen.SquareTileFrame(index1, index2, true);
                  NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                  continue;
                }
                if (TileID.Sets.Conversion.Ice[type] && type != 161)
                {
                  Main.tile[index1, index2].type = (ushort) 161;
                  WorldGen.SquareTileFrame(index1, index2, true);
                  NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                  continue;
                }
                if (Main.tile[index1, index2].type == (ushort) 70)
                {
                  Main.tile[index1, index2].type = (ushort) 60;
                  WorldGen.SquareTileFrame(index1, index2, true);
                  NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
                  continue;
                }
                if (Main.tile[index1, index2].type == (ushort) 32 || Main.tile[index1, index2].type == (ushort) 352)
                {
                  WorldGen.KillTile(index1, index2, false, false, false);
                  if (Main.netMode == 1)
                  {
                    NetMessage.SendData(17, -1, -1, (NetworkText) null, 0, (float) index1, (float) index2, 0.0f, 0, 0, 0);
                    continue;
                  }
                  continue;
                }
                continue;
            }
          }
        }
      }
    }

    public static void CactusFrame(int i, int j)
    {
      try
      {
        int index1 = j;
        int index2 = i;
        if (WorldGen.CheckCactus(i, j))
          return;
        while (Main.tile[index2, index1].active() && Main.tile[index2, index1].type == (ushort) 80)
        {
          ++index1;
          if (Main.tile[index2, index1] == null)
            return;
          if (!Main.tile[index2, index1].active() || Main.tile[index2, index1].type != (ushort) 80)
          {
            if (Main.tile[index2 - 1, index1] != null && Main.tile[index2 - 1, index1].active() && (Main.tile[index2 - 1, index1].type == (ushort) 80 && Main.tile[index2 - 1, index1 - 1].active()) && (Main.tile[index2 - 1, index1 - 1].type == (ushort) 80 && index2 >= i))
              --index2;
            if (Main.tile[index2 + 1, index1] != null && Main.tile[index2 + 1, index1].active() && (Main.tile[index2 + 1, index1].type == (ushort) 80 && Main.tile[index2 + 1, index1 - 1].active()) && (Main.tile[index2 + 1, index1 - 1].type == (ushort) 80 && index2 <= i))
              ++index2;
          }
        }
        int num1 = index1 - 1;
        int num2 = i - index2;
        num1 = j;
        if (Main.tile[i - 2, j] == null)
          return;
        int type = (int) Main.tile[i - 2, j].type;
        if (Main.tile[i - 1, j] == null)
          return;
        int num3 = (int) Main.tile[i - 1, j].type;
        if (Main.tile[i + 1, j] == null)
          return;
        int num4 = (int) Main.tile[i + 1, j].type;
        if (Main.tile[i, j - 1] == null)
          return;
        int num5 = (int) Main.tile[i, j - 1].type;
        if (num5 == 227)
          num5 = 80;
        int index3 = (int) Main.tile[i, j + 1].type;
        int num6 = (int) Main.tile[i - 1, j + 1].type;
        int num7 = (int) Main.tile[i + 1, j + 1].type;
        if (!Main.tile[i - 1, j].active())
          num3 = -1;
        if (!Main.tile[i + 1, j].active())
          num4 = -1;
        if (!Main.tile[i, j - 1].active())
          num5 = -1;
        if (!Main.tile[i, j + 1].active())
          index3 = -1;
        if (!Main.tile[i - 1, j + 1].active())
          num6 = -1;
        if (!Main.tile[i + 1, j + 1].active())
          num7 = -1;
        short num8 = Main.tile[i, j].frameX;
        short num9 = Main.tile[i, j].frameY;
        switch (num2)
        {
          case -1:
            if (num4 == 80)
            {
              if (num5 != 80 && index3 != 80)
              {
                num8 = (short) 108;
                num9 = (short) 36;
                break;
              }
              if (index3 != 80)
              {
                num8 = (short) 54;
                num9 = (short) 36;
                break;
              }
              if (num5 != 80)
              {
                num8 = (short) 54;
                num9 = (short) 0;
                break;
              }
              num8 = (short) 54;
              num9 = (short) 18;
              break;
            }
            if (num5 != 80)
            {
              num8 = (short) 54;
              num9 = (short) 0;
              break;
            }
            num8 = (short) 54;
            num9 = (short) 18;
            break;
          case 0:
            if (num5 != 80)
            {
              if (num3 == 80 && num4 == 80 && (num6 != 80 && num7 != 80) && type != 80)
              {
                num8 = (short) 90;
                num9 = (short) 0;
                break;
              }
              if (num3 == 80 && num6 != 80 && type != 80)
              {
                num8 = (short) 72;
                num9 = (short) 0;
                break;
              }
              if (num4 == 80 && num7 != 80)
              {
                num8 = (short) 18;
                num9 = (short) 0;
                break;
              }
              num8 = (short) 0;
              num9 = (short) 0;
              break;
            }
            if (num3 == 80 && num4 == 80 && (num6 != 80 && num7 != 80) && type != 80)
            {
              num8 = (short) 90;
              num9 = (short) 36;
              break;
            }
            if (num3 == 80 && num6 != 80 && type != 80)
            {
              num8 = (short) 72;
              num9 = (short) 36;
              break;
            }
            if (num4 == 80 && num7 != 80)
            {
              num8 = (short) 18;
              num9 = (short) 36;
              break;
            }
            if (index3 >= 0 && Main.tileSolid[index3])
            {
              num8 = (short) 0;
              num9 = (short) 36;
              break;
            }
            num8 = (short) 0;
            num9 = (short) 18;
            break;
          case 1:
            if (num3 == 80)
            {
              if (num5 != 80 && index3 != 80)
              {
                num8 = (short) 108;
                num9 = (short) 18;
                break;
              }
              if (index3 != 80)
              {
                num8 = (short) 36;
                num9 = (short) 36;
                break;
              }
              if (num5 != 80)
              {
                num8 = (short) 36;
                num9 = (short) 0;
                break;
              }
              num8 = (short) 36;
              num9 = (short) 18;
              break;
            }
            if (num5 != 80)
            {
              num8 = (short) 36;
              num9 = (short) 0;
              break;
            }
            num8 = (short) 36;
            num9 = (short) 18;
            break;
        }
        if ((int) num8 == (int) Main.tile[i, j].frameX && (int) num9 == (int) Main.tile[i, j].frameY)
          return;
        Main.tile[i, j].frameX = num8;
        Main.tile[i, j].frameY = num9;
        WorldGen.DiamondTileFrame(i, j);
      }
      catch
      {
        Main.tile[i, j].frameX = (short) 0;
        Main.tile[i, j].frameY = (short) 0;
      }
    }

    public static void GrowCactus(int i, int j)
    {
      int index1 = j;
      int i1 = i;
      if (!Main.tile[i, j].nactive() || Main.tile[i, j].halfBrick() || !WorldGen.gen && Main.tile[i, j].slope() != (byte) 0 || Main.tile[i, j - 1].liquid > (byte) 0 || Main.tile[i, j].type != (ushort) 53 && Main.tile[i, j].type != (ushort) 80 && (Main.tile[i, j].type != (ushort) 234 && Main.tile[i, j].type != (ushort) 112) && Main.tile[i, j].type != (ushort) 116)
        return;
      int num1 = 0;
      for (int index2 = i - WorldGen.cactusWaterWidth; index2 < i + WorldGen.cactusWaterWidth; ++index2)
      {
        for (int index3 = j - WorldGen.cactusWaterHeight; index3 < j + WorldGen.cactusWaterHeight; ++index3)
          num1 += (int) Main.tile[index2, index3].liquid;
      }
      if (num1 / (int) byte.MaxValue > WorldGen.cactusWaterLimit)
        return;
      if (Main.tile[i, j].type == (ushort) 53 || Main.tile[i, j].type == (ushort) 112 || (Main.tile[i, j].type == (ushort) 116 || Main.tile[i, j].type == (ushort) 234))
      {
        if (Main.tile[i, j - 1].active() || Main.tile[i - 1, j - 1].active() || Main.tile[i + 1, j - 1].active())
          return;
        int num2 = 0;
        int num3 = 0;
        for (int index2 = i - 6; index2 <= i + 6; ++index2)
        {
          for (int index3 = j - 3; index3 <= j + 1; ++index3)
          {
            try
            {
              if (Main.tile[index2, index3].active())
              {
                if (Main.tile[index2, index3].type == (ushort) 80)
                {
                  ++num2;
                  if (num2 >= 4)
                    return;
                }
                if (Main.tile[index2, index3].type != (ushort) 53 && Main.tile[index2, index3].type != (ushort) 112 && Main.tile[index2, index3].type != (ushort) 116)
                {
                  if (Main.tile[index2, index3].type != (ushort) 234)
                    continue;
                }
                ++num3;
              }
            }
            catch
            {
            }
          }
        }
        if (num3 <= 10)
          return;
        if (WorldGen.gen && WorldGen.genRand.Next(2) == 0)
          Main.tile[i, j].slope((byte) 0);
        Main.tile[i, j - 1].active(true);
        Main.tile[i, j - 1].type = (ushort) 80;
        if (Main.netMode == 2)
          NetMessage.SendTileSquare(-1, i, j - 1, 1, TileChangeType.None);
        WorldGen.SquareTileFrame(i1, index1 - 1, true);
      }
      else
      {
        if (Main.tile[i, j].type != (ushort) 80)
          return;
        while (Main.tile[i1, index1].active() && Main.tile[i1, index1].type == (ushort) 80)
        {
          ++index1;
          if (!Main.tile[i1, index1].active() || Main.tile[i1, index1].type != (ushort) 80)
          {
            if (Main.tile[i1 - 1, index1].active() && Main.tile[i1 - 1, index1].type == (ushort) 80 && (Main.tile[i1 - 1, index1 - 1].active() && Main.tile[i1 - 1, index1 - 1].type == (ushort) 80) && i1 >= i)
              --i1;
            if (Main.tile[i1 + 1, index1].active() && Main.tile[i1 + 1, index1].type == (ushort) 80 && (Main.tile[i1 + 1, index1 - 1].active() && Main.tile[i1 + 1, index1 - 1].type == (ushort) 80) && i1 <= i)
              ++i1;
          }
        }
        int num2 = index1 - 1 - j;
        int num3 = i - i1;
        int num4 = i - num3;
        int num5 = j;
        int num6 = 11 - num2;
        int num7 = 0;
        for (int index2 = num4 - 2; index2 <= num4 + 2; ++index2)
        {
          for (int index3 = num5 - num6; index3 <= num5 + num2; ++index3)
          {
            if (Main.tile[index2, index3].active() && Main.tile[index2, index3].type == (ushort) 80)
              ++num7;
          }
        }
        if (Main.drunkWorld)
        {
          if (num7 >= WorldGen.genRand.Next(11, 20))
            return;
        }
        else if (num7 >= WorldGen.genRand.Next(11, 13))
          return;
        int index4 = i;
        int index5 = j;
        if (num3 == 0)
        {
          if (num2 == 0)
          {
            if (Main.tile[index4, index5 - 1].active())
              return;
            Main.tile[index4, index5 - 1].active(true);
            Main.tile[index4, index5 - 1].type = (ushort) 80;
            WorldGen.SquareTileFrame(index4, index5 - 1, true);
            if (Main.netMode != 2)
              return;
            NetMessage.SendTileSquare(-1, index4, index5 - 1, 1, TileChangeType.None);
          }
          else
          {
            bool flag1 = false;
            bool flag2 = false;
            if (Main.tile[index4, index5 - 1].active() && Main.tile[index4, index5 - 1].type == (ushort) 80)
            {
              if (!Main.tile[index4 - 1, index5].active() && !Main.tile[index4 - 2, index5 + 1].active() && (!Main.tile[index4 - 1, index5 - 1].active() && !Main.tile[index4 - 1, index5 + 1].active()) && !Main.tile[index4 - 2, index5].active())
                flag1 = true;
              if (!Main.tile[index4 + 1, index5].active() && !Main.tile[index4 + 2, index5 + 1].active() && (!Main.tile[index4 + 1, index5 - 1].active() && !Main.tile[index4 + 1, index5 + 1].active()) && !Main.tile[index4 + 2, index5].active())
                flag2 = true;
            }
            int num8 = WorldGen.genRand.Next(3);
            if (num8 == 0 & flag1)
            {
              Main.tile[index4 - 1, index5].active(true);
              Main.tile[index4 - 1, index5].type = (ushort) 80;
              WorldGen.SquareTileFrame(index4 - 1, index5, true);
              if (Main.netMode != 2)
                return;
              NetMessage.SendTileSquare(-1, index4 - 1, index5, 1, TileChangeType.None);
            }
            else if (num8 == 1 & flag2)
            {
              Main.tile[index4 + 1, index5].active(true);
              Main.tile[index4 + 1, index5].type = (ushort) 80;
              WorldGen.SquareTileFrame(index4 + 1, index5, true);
              if (Main.netMode != 2)
                return;
              NetMessage.SendTileSquare(-1, index4 + 1, index5, 1, TileChangeType.None);
            }
            else
            {
              if (num2 >= WorldGen.genRand.Next(2, 8))
                return;
              if (Main.tile[index4 - 1, index5 - 1].active())
              {
                int type = (int) Main.tile[index4 - 1, index5 - 1].type;
              }
              if (Main.tile[index4 + 1, index5 - 1].active() && Main.tile[index4 + 1, index5 - 1].type == (ushort) 80 || Main.tile[index4, index5 - 1].active())
                return;
              Main.tile[index4, index5 - 1].active(true);
              Main.tile[index4, index5 - 1].type = (ushort) 80;
              WorldGen.SquareTileFrame(index4, index5 - 1, true);
              if (Main.netMode != 2)
                return;
              NetMessage.SendTileSquare(-1, index4, index5 - 1, 1, TileChangeType.None);
            }
          }
        }
        else
        {
          if (Main.tile[index4, index5 - 1].active() || Main.tile[index4, index5 - 2].active() || (Main.tile[index4 + num3, index5 - 1].active() || !Main.tile[index4 - num3, index5 - 1].active()) || Main.tile[index4 - num3, index5 - 1].type != (ushort) 80)
            return;
          Main.tile[index4, index5 - 1].active(true);
          Main.tile[index4, index5 - 1].type = (ushort) 80;
          WorldGen.SquareTileFrame(index4, index5 - 1, true);
          if (Main.netMode != 2)
            return;
          NetMessage.SendTileSquare(-1, index4, index5 - 1, 1, TileChangeType.None);
        }
      }
    }

    public static void CheckPot(int i, int j, int type = 28)
    {
      if (WorldGen.destroyObject)
        return;
      bool flag1 = false;
      int num1 = 0;
      int num2 = j;
      int num3 = num1 + (int) Main.tile[i, j].frameX / 18;
      while (num3 > 1)
        num3 -= 2;
      int num4 = num3 * -1 + i;
      int num5 = (int) Main.tile[i, j].frameY / 18;
      int num6 = 0;
      while (num5 > 1)
      {
        num5 -= 2;
        ++num6;
      }
      int num7 = num2 - num5;
      for (int i1 = num4; i1 < num4 + 2; ++i1)
      {
        for (int index = num7; index < num7 + 2; ++index)
        {
          if (Main.tile[i1, index] == null)
            Main.tile[i1, index] = new Tile();
          int num8 = (int) Main.tile[i1, index].frameX / 18;
          while (num8 > 1)
            num8 -= 2;
          if (!Main.tile[i1, index].active() || (int) Main.tile[i1, index].type != type || (num8 != i1 - num4 || (int) Main.tile[i1, index].frameY != (index - num7) * 18 + num6 * 36))
            flag1 = true;
        }
        if (Main.tile[i1, num7 + 2] == null)
          Main.tile[i1, num7 + 2] = new Tile();
        if (!WorldGen.SolidTile2(i1, num7 + 2))
          flag1 = true;
      }
      if (!flag1)
        return;
      WorldGen.destroyObject = true;
      if (num6 >= 7 && num6 <= 9)
        SoundEngine.PlaySound(6, i * 16, j * 16, 1, 1f, 0.0f);
      else if (num6 >= 16 && num6 <= 24)
        SoundEngine.PlaySound(4, i * 16, j * 16, 1, 1f, 0.0f);
      else
        SoundEngine.PlaySound(13, i * 16, j * 16, 1, 1f, 0.0f);
      for (int i1 = num4; i1 < num4 + 2; ++i1)
      {
        for (int j1 = num7; j1 < num7 + 2; ++j1)
        {
          if ((int) Main.tile[i1, j1].type == type && Main.tile[i1, j1].active())
            WorldGen.KillTile(i1, j1, false, false, false);
        }
      }
      float num9 = 1f;
      bool flag2 = false;
      switch (num6)
      {
        case 0:
          Gore.NewGore(new Vector2((float) (i * 16), (float) (j * 16)), new Vector2(), 51, 1f);
          Gore.NewGore(new Vector2((float) (i * 16), (float) (j * 16)), new Vector2(), 52, 1f);
          Gore.NewGore(new Vector2((float) (i * 16), (float) (j * 16)), new Vector2(), 53, 1f);
          break;
        case 1:
          Gore.NewGore(new Vector2((float) (i * 16), (float) (j * 16)), new Vector2(), 166, 1f);
          Gore.NewGore(new Vector2((float) (i * 16), (float) (j * 16)), new Vector2(), 167, 1f);
          Gore.NewGore(new Vector2((float) (i * 16), (float) (j * 16)), new Vector2(), 168, 1f);
          break;
        case 2:
          Gore.NewGore(new Vector2((float) (i * 16), (float) (j * 16)), new Vector2(), 169, 1f);
          Gore.NewGore(new Vector2((float) (i * 16), (float) (j * 16)), new Vector2(), 170, 1f);
          Gore.NewGore(new Vector2((float) (i * 16), (float) (j * 16)), new Vector2(), 171, 1f);
          break;
        case 3:
          Gore.NewGore(new Vector2((float) (i * 16), (float) (j * 16)), new Vector2(), 172, 1f);
          Gore.NewGore(new Vector2((float) (i * 16), (float) (j * 16)), new Vector2(), 173, 1f);
          Gore.NewGore(new Vector2((float) (i * 16), (float) (j * 16)), new Vector2(), 174, 1f);
          break;
        default:
          if (num6 >= 4 && num6 <= 6)
          {
            Gore.NewGore(new Vector2((float) (i * 16), (float) (j * 16)), new Vector2(), 197, 1f);
            Gore.NewGore(new Vector2((float) (i * 16), (float) (j * 16)), new Vector2(), 198, 1f);
            num9 = 1.25f;
            break;
          }
          if (num6 >= 7 && num6 <= 9)
          {
            Gore.NewGore(new Vector2((float) (i * 16), (float) (j * 16)), new Vector2(), 199, 1f);
            Gore.NewGore(new Vector2((float) (i * 16), (float) (j * 16)), new Vector2(), 200, 1f);
            num9 = 1.75f;
            break;
          }
          if (num6 >= 10 && num6 <= 12)
          {
            Gore.NewGore(new Vector2((float) (i * 16), (float) (j * 16)), new Vector2(), 201, 1f);
            Gore.NewGore(new Vector2((float) (i * 16), (float) (j * 16)), new Vector2(), 202, 1f);
            num9 = 1.9f;
            break;
          }
          if (num6 >= 13 && num6 <= 15)
          {
            Gore.NewGore(new Vector2((float) (i * 16), (float) (j * 16)), new Vector2(), 203, 1f);
            Gore.NewGore(new Vector2((float) (i * 16), (float) (j * 16)), new Vector2(), 204, 1f);
            num9 = 2.1f;
            break;
          }
          if (num6 >= 16 && num6 <= 18)
          {
            num9 = 1.6f;
            break;
          }
          if (num6 >= 19 && num6 <= 21)
          {
            num9 = 3.5f;
            break;
          }
          if (num6 >= 22 && num6 <= 24)
          {
            num9 = 1.6f;
            break;
          }
          if (num6 >= 25 && num6 <= 27)
          {
            num9 = 10f;
            Gore.NewGore(new Vector2((float) (i * 16), (float) (j * 16)), new Vector2(), WorldGen.genRand.Next(217, 220), 1f);
            Gore.NewGore(new Vector2((float) (i * 16), (float) (j * 16)), new Vector2(), WorldGen.genRand.Next(217, 220), 1f);
            break;
          }
          if (num6 >= 28 && num6 <= 30)
          {
            Gore.NewGore(new Vector2((float) (i * 16), (float) (j * 16)), new Vector2(), WorldGen.genRand.Next(315, 317), 1f);
            Gore.NewGore(new Vector2((float) (i * 16), (float) (j * 16)), new Vector2(), WorldGen.genRand.Next(315, 317), 1f);
            if (Main.hardMode)
            {
              num9 = 4f;
              break;
            }
            break;
          }
          if (num6 >= 31 && num6 <= 33)
          {
            int num8 = WorldGen.genRand.Next(2, 5);
            for (int index = 0; index < num8; ++index)
              Gore.NewGore(new Vector2((float) (i * 16), (float) (j * 16)), new Vector2(), 698 + WorldGen.genRand.Next(6), 1f);
            num9 = 2f;
            break;
          }
          if (num6 >= 34 && num6 <= 36)
          {
            Gore.NewGore(new Vector2((float) (i * 16), (float) (j * 16)), new Vector2(), 1122, 1f);
            Gore.NewGore(new Vector2((float) (i * 16), (float) (j * 16)), new Vector2(), 1123, 1f);
            Gore.NewGore(new Vector2((float) (i * 16), (float) (j * 16)), new Vector2(), 1124, 1f);
            num9 = 1.25f;
            flag2 = true;
            break;
          }
          break;
      }
      float num10 = (float) (((double) num9 * 2.0 + 1.0) / 3.0);
      int range = (int) (500.0 / (((double) num10 + 1.0) / 2.0));
      if (!WorldGen.gen)
      {
        if ((double) Player.GetClosestRollLuck(i, j, range) == 0.0)
        {
          if (Main.netMode != 1)
            Projectile.NewProjectile((float) (i * 16 + 16), (float) (j * 16 + 16), 0.0f, -12f, 518, 0, 0.0f, Main.myPlayer, 0.0f, 0.0f);
        }
        else if (WorldGen.genRand.Next(35) == 0 && Main.wallDungeon[(int) Main.tile[i, j].wall] && (double) j > Main.worldSurface)
          Item.NewItem(i * 16, j * 16, 16, 16, 327, 1, false, 0, false, false);
        else if (Main.getGoodWorld && WorldGen.genRand.Next(4) == 0)
          Projectile.NewProjectile((float) (i * 16 + 16), (float) (j * 16 + 8), (float) Main.rand.Next(-100, 101) * (1f / 500f), 0.0f, 28, 0, 0.0f, (int) Player.FindClosest(new Vector2((float) (i * 16), (float) (j * 16)), 16, 16), 0.0f, 0.0f);
        else if (WorldGen.genRand.Next(45) == 0 || Main.rand.Next(45) == 0 && Main.expertMode)
        {
          if ((double) j < Main.worldSurface)
          {
            int num8 = WorldGen.genRand.Next(10);
            if (num8 == 0)
              Item.NewItem(i * 16, j * 16, 16, 16, 292, 1, false, 0, false, false);
            if (num8 == 1)
              Item.NewItem(i * 16, j * 16, 16, 16, 298, 1, false, 0, false, false);
            if (num8 == 2)
              Item.NewItem(i * 16, j * 16, 16, 16, 299, 1, false, 0, false, false);
            if (num8 == 3)
              Item.NewItem(i * 16, j * 16, 16, 16, 290, 1, false, 0, false, false);
            if (num8 == 4)
              Item.NewItem(i * 16, j * 16, 16, 16, 2322, 1, false, 0, false, false);
            if (num8 == 5)
              Item.NewItem(i * 16, j * 16, 16, 16, 2324, 1, false, 0, false, false);
            if (num8 == 6)
              Item.NewItem(i * 16, j * 16, 16, 16, 2325, 1, false, 0, false, false);
            if (num8 >= 7)
              Item.NewItem(i * 16, j * 16, 16, 16, 2350, WorldGen.genRand.Next(1, 3), false, 0, false, false);
          }
          else if ((double) j < Main.rockLayer)
          {
            int num8 = WorldGen.genRand.Next(11);
            if (num8 == 0)
              Item.NewItem(i * 16, j * 16, 16, 16, 289, 1, false, 0, false, false);
            if (num8 == 1)
              Item.NewItem(i * 16, j * 16, 16, 16, 298, 1, false, 0, false, false);
            if (num8 == 2)
              Item.NewItem(i * 16, j * 16, 16, 16, 299, 1, false, 0, false, false);
            if (num8 == 3)
              Item.NewItem(i * 16, j * 16, 16, 16, 290, 1, false, 0, false, false);
            if (num8 == 4)
              Item.NewItem(i * 16, j * 16, 16, 16, 303, 1, false, 0, false, false);
            if (num8 == 5)
              Item.NewItem(i * 16, j * 16, 16, 16, 291, 1, false, 0, false, false);
            if (num8 == 6)
              Item.NewItem(i * 16, j * 16, 16, 16, 304, 1, false, 0, false, false);
            if (num8 == 7)
              Item.NewItem(i * 16, j * 16, 16, 16, 2322, 1, false, 0, false, false);
            if (num8 == 8)
              Item.NewItem(i * 16, j * 16, 16, 16, 2329, 1, false, 0, false, false);
            if (num8 >= 7)
              Item.NewItem(i * 16, j * 16, 16, 16, 2350, WorldGen.genRand.Next(1, 3), false, 0, false, false);
          }
          else if (j < Main.UnderworldLayer)
          {
            int num8 = WorldGen.genRand.Next(15);
            if (num8 == 0)
              Item.NewItem(i * 16, j * 16, 16, 16, 296, 1, false, 0, false, false);
            if (num8 == 1)
              Item.NewItem(i * 16, j * 16, 16, 16, 295, 1, false, 0, false, false);
            if (num8 == 2)
              Item.NewItem(i * 16, j * 16, 16, 16, 299, 1, false, 0, false, false);
            if (num8 == 3)
              Item.NewItem(i * 16, j * 16, 16, 16, 302, 1, false, 0, false, false);
            if (num8 == 4)
              Item.NewItem(i * 16, j * 16, 16, 16, 303, 1, false, 0, false, false);
            if (num8 == 5)
              Item.NewItem(i * 16, j * 16, 16, 16, 305, 1, false, 0, false, false);
            if (num8 == 6)
              Item.NewItem(i * 16, j * 16, 16, 16, 301, 1, false, 0, false, false);
            if (num8 == 7)
              Item.NewItem(i * 16, j * 16, 16, 16, 302, 1, false, 0, false, false);
            if (num8 == 8)
              Item.NewItem(i * 16, j * 16, 16, 16, 297, 1, false, 0, false, false);
            if (num8 == 9)
              Item.NewItem(i * 16, j * 16, 16, 16, 304, 1, false, 0, false, false);
            if (num8 == 10)
              Item.NewItem(i * 16, j * 16, 16, 16, 2322, 1, false, 0, false, false);
            if (num8 == 11)
              Item.NewItem(i * 16, j * 16, 16, 16, 2323, 1, false, 0, false, false);
            if (num8 == 12)
              Item.NewItem(i * 16, j * 16, 16, 16, 2327, 1, false, 0, false, false);
            if (num8 == 13)
              Item.NewItem(i * 16, j * 16, 16, 16, 2329, 1, false, 0, false, false);
            if (num8 >= 7)
              Item.NewItem(i * 16, j * 16, 16, 16, 2350, WorldGen.genRand.Next(1, 3), false, 0, false, false);
          }
          else
          {
            int num8 = WorldGen.genRand.Next(14);
            if (num8 == 0)
              Item.NewItem(i * 16, j * 16, 16, 16, 296, 1, false, 0, false, false);
            if (num8 == 1)
              Item.NewItem(i * 16, j * 16, 16, 16, 295, 1, false, 0, false, false);
            if (num8 == 2)
              Item.NewItem(i * 16, j * 16, 16, 16, 293, 1, false, 0, false, false);
            if (num8 == 3)
              Item.NewItem(i * 16, j * 16, 16, 16, 288, 1, false, 0, false, false);
            if (num8 == 4)
              Item.NewItem(i * 16, j * 16, 16, 16, 294, 1, false, 0, false, false);
            if (num8 == 5)
              Item.NewItem(i * 16, j * 16, 16, 16, 297, 1, false, 0, false, false);
            if (num8 == 6)
              Item.NewItem(i * 16, j * 16, 16, 16, 304, 1, false, 0, false, false);
            if (num8 == 7)
              Item.NewItem(i * 16, j * 16, 16, 16, 305, 1, false, 0, false, false);
            if (num8 == 8)
              Item.NewItem(i * 16, j * 16, 16, 16, 301, 1, false, 0, false, false);
            if (num8 == 9)
              Item.NewItem(i * 16, j * 16, 16, 16, 302, 1, false, 0, false, false);
            if (num8 == 10)
              Item.NewItem(i * 16, j * 16, 16, 16, 288, 1, false, 0, false, false);
            if (num8 == 11)
              Item.NewItem(i * 16, j * 16, 16, 16, 300, 1, false, 0, false, false);
            if (num8 == 12)
              Item.NewItem(i * 16, j * 16, 16, 16, 2323, 1, false, 0, false, false);
            if (num8 == 13)
              Item.NewItem(i * 16, j * 16, 16, 16, 2326, 1, false, 0, false, false);
            if (WorldGen.genRand.Next(5) == 0)
              Item.NewItem(i * 16, j * 16, 16, 16, 4870, 1, false, 0, false, false);
          }
        }
        else if (Main.netMode == 2 && Main.rand.Next(30) == 0)
        {
          Item.NewItem(i * 16, j * 16, 16, 16, 2997, 1, false, 0, false, false);
        }
        else
        {
          int num8 = Main.rand.Next(7);
          if (Main.expertMode)
            --num8;
          Player player = Main.player[(int) Player.FindClosest(new Vector2((float) (i * 16), (float) (j * 16)), 16, 16)];
          if (num8 == 0 && player.statLife < player.statLifeMax2)
          {
            Item.NewItem(i * 16, j * 16, 16, 16, 58, 1, false, 0, false, false);
            if (Main.rand.Next(2) == 0)
              Item.NewItem(i * 16, j * 16, 16, 16, 58, 1, false, 0, false, false);
            if (Main.expertMode)
            {
              if (Main.rand.Next(2) == 0)
                Item.NewItem(i * 16, j * 16, 16, 16, 58, 1, false, 0, false, false);
              if (Main.rand.Next(2) == 0)
                Item.NewItem(i * 16, j * 16, 16, 16, 58, 1, false, 0, false, false);
            }
          }
          else
          {
            switch (num8)
            {
              case 1:
                int Stack1 = Main.rand.Next(2, 7);
                if (Main.expertMode)
                  Stack1 += Main.rand.Next(1, 7);
                int Type1 = 8;
                int Type2 = 282;
                if (player.ZoneHallow)
                {
                  Stack1 += Main.rand.Next(2, 7);
                  Type1 = 4387;
                }
                else if (num6 >= 22 && num6 <= 24 || player.ZoneCrimson)
                {
                  Stack1 += Main.rand.Next(2, 7);
                  Type1 = 4386;
                }
                else if (num6 >= 16 && num6 <= 18 || player.ZoneCorrupt)
                {
                  Stack1 += Main.rand.Next(2, 7);
                  Type1 = 4385;
                }
                else if (num6 >= 7 && num6 <= 9)
                {
                  Stack1 += Main.rand.Next(2, 7);
                  Type1 = 4388;
                }
                else if (num6 >= 4 && num6 <= 6)
                {
                  Type1 = 974;
                  Type2 = 286;
                }
                else if (num6 >= 34 && num6 <= 36)
                {
                  Stack1 += Main.rand.Next(2, 7);
                  Type1 = 4383;
                }
                if (Main.tile[i, j].liquid > (byte) 0)
                {
                  Item.NewItem(i * 16, j * 16, 16, 16, Type2, Stack1, false, 0, false, false);
                  break;
                }
                Item.NewItem(i * 16, j * 16, 16, 16, Type1, Stack1, false, 0, false, false);
                break;
              case 2:
                int Stack2 = Main.rand.Next(10, 21);
                int Type3 = 40;
                if ((double) j < Main.rockLayer && WorldGen.genRand.Next(2) == 0)
                  Type3 = !Main.hardMode ? 42 : 168;
                if (j > Main.UnderworldLayer)
                  Type3 = 265;
                else if (Main.hardMode)
                  Type3 = Main.rand.Next(2) != 0 ? 47 : (WorldGen.SavedOreTiers.Silver != 168 ? 278 : 4915);
                Item.NewItem(i * 16, j * 16, 16, 16, Type3, Stack2, false, 0, false, false);
                break;
              case 3:
                int Type4 = 28;
                if (j > Main.UnderworldLayer || Main.hardMode)
                  Type4 = 188;
                int Stack3 = 1;
                if (Main.expertMode && Main.rand.Next(3) != 0)
                  ++Stack3;
                Item.NewItem(i * 16, j * 16, 16, 16, Type4, Stack3, false, 0, false, false);
                break;
              default:
                if (num8 == 4 && (flag2 || (double) j > Main.rockLayer))
                {
                  int Type5 = 166;
                  if (flag2)
                    Type5 = 4423;
                  int Stack4 = Main.rand.Next(4) + 1;
                  if (Main.expertMode)
                    Stack4 += Main.rand.Next(4);
                  Item.NewItem(i * 16, j * 16, 16, 16, Type5, Stack4, false, 0, false, false);
                  break;
                }
                if ((num8 == 4 || num8 == 5) && (j < Main.UnderworldLayer && !Main.hardMode))
                {
                  int Stack4 = Main.rand.Next(20, 41);
                  Item.NewItem(i * 16, j * 16, 16, 16, 965, Stack4, false, 0, false, false);
                  break;
                }
                float num11 = (float) (200 + WorldGen.genRand.Next(-100, 101));
                if ((double) j < Main.worldSurface)
                  num11 *= 0.5f;
                else if ((double) j < Main.rockLayer)
                  num11 *= 0.75f;
                else if (j > Main.maxTilesY - 250)
                  num11 *= 1.25f;
                float num12 = num11 * (float) (1.0 + (double) Main.rand.Next(-20, 21) * 0.00999999977648258);
                if (Main.rand.Next(4) == 0)
                  num12 *= (float) (1.0 + (double) Main.rand.Next(5, 11) * 0.00999999977648258);
                if (Main.rand.Next(8) == 0)
                  num12 *= (float) (1.0 + (double) Main.rand.Next(10, 21) * 0.00999999977648258);
                if (Main.rand.Next(12) == 0)
                  num12 *= (float) (1.0 + (double) Main.rand.Next(20, 41) * 0.00999999977648258);
                if (Main.rand.Next(16) == 0)
                  num12 *= (float) (1.0 + (double) Main.rand.Next(40, 81) * 0.00999999977648258);
                if (Main.rand.Next(20) == 0)
                  num12 *= (float) (1.0 + (double) Main.rand.Next(50, 101) * 0.00999999977648258);
                if (Main.expertMode)
                  num12 *= 2.5f;
                if (Main.expertMode && Main.rand.Next(2) == 0)
                  num12 *= 1.25f;
                if (Main.expertMode && Main.rand.Next(3) == 0)
                  num12 *= 1.5f;
                if (Main.expertMode && Main.rand.Next(4) == 0)
                  num12 *= 1.75f;
                float num13 = num12 * num10;
                if (NPC.downedBoss1)
                  num13 *= 1.1f;
                if (NPC.downedBoss2)
                  num13 *= 1.1f;
                if (NPC.downedBoss3)
                  num13 *= 1.1f;
                if (NPC.downedMechBoss1)
                  num13 *= 1.1f;
                if (NPC.downedMechBoss2)
                  num13 *= 1.1f;
                if (NPC.downedMechBoss3)
                  num13 *= 1.1f;
                if (NPC.downedPlantBoss)
                  num13 *= 1.1f;
                if (NPC.downedQueenBee)
                  num13 *= 1.1f;
                if (NPC.downedGolemBoss)
                  num13 *= 1.1f;
                if (NPC.downedPirates)
                  num13 *= 1.1f;
                if (NPC.downedGoblins)
                  num13 *= 1.1f;
                if (NPC.downedFrost)
                  num13 *= 1.1f;
                while ((int) num13 > 0)
                {
                  if ((double) num13 > 1000000.0)
                  {
                    int Stack4 = (int) ((double) num13 / 1000000.0);
                    if (Stack4 > 50 && Main.rand.Next(2) == 0)
                      Stack4 /= Main.rand.Next(3) + 1;
                    if (Main.rand.Next(2) == 0)
                      Stack4 /= Main.rand.Next(3) + 1;
                    num13 -= (float) (1000000 * Stack4);
                    Item.NewItem(i * 16, j * 16, 16, 16, 74, Stack4, false, 0, false, false);
                  }
                  else if ((double) num13 > 10000.0)
                  {
                    int Stack4 = (int) ((double) num13 / 10000.0);
                    if (Stack4 > 50 && Main.rand.Next(2) == 0)
                      Stack4 /= Main.rand.Next(3) + 1;
                    if (Main.rand.Next(2) == 0)
                      Stack4 /= Main.rand.Next(3) + 1;
                    num13 -= (float) (10000 * Stack4);
                    Item.NewItem(i * 16, j * 16, 16, 16, 73, Stack4, false, 0, false, false);
                  }
                  else if ((double) num13 > 100.0)
                  {
                    int Stack4 = (int) ((double) num13 / 100.0);
                    if (Stack4 > 50 && Main.rand.Next(2) == 0)
                      Stack4 /= Main.rand.Next(3) + 1;
                    if (Main.rand.Next(2) == 0)
                      Stack4 /= Main.rand.Next(3) + 1;
                    num13 -= (float) (100 * Stack4);
                    Item.NewItem(i * 16, j * 16, 16, 16, 72, Stack4, false, 0, false, false);
                  }
                  else
                  {
                    int Stack4 = (int) num13;
                    if (Stack4 > 50 && Main.rand.Next(2) == 0)
                      Stack4 /= Main.rand.Next(3) + 1;
                    if (Main.rand.Next(2) == 0)
                      Stack4 /= Main.rand.Next(4) + 1;
                    if (Stack4 < 1)
                      Stack4 = 1;
                    num13 -= (float) Stack4;
                    Item.NewItem(i * 16, j * 16, 16, 16, 71, Stack4, false, 0, false, false);
                  }
                }
                break;
            }
          }
        }
      }
      WorldGen.destroyObject = false;
    }

    public static int PlaceChest(int x, int y, ushort type = 21, bool notNearOtherChests = false, int style = 0)
    {
      int num = -1;
      if (TileID.Sets.Boulders[(int) Main.tile[x, y + 1].type] || TileID.Sets.Boulders[(int) Main.tile[x + 1, y + 1].type])
        return -1;
      TileObject objectData;
      if (TileObject.CanPlace(x, y, (int) type, style, 1, out objectData, false))
      {
        bool flag = true;
        if (notNearOtherChests && Chest.NearOtherChests(x - 1, y - 1))
          flag = false;
        if (flag)
        {
          TileObject.Place(objectData);
          num = Chest.CreateChest(objectData.xCoord, objectData.yCoord, -1);
        }
      }
      else
        num = -1;
      if (num != -1 && Main.netMode == 1 && type == (ushort) 21)
        NetMessage.SendData(34, -1, -1, (NetworkText) null, 0, (float) x, (float) y, (float) style, 0, 0, 0);
      if (num != -1 && Main.netMode == 1 && type == (ushort) 467)
        NetMessage.SendData(34, -1, -1, (NetworkText) null, 4, (float) x, (float) y, (float) style, 0, 0, 0);
      return num;
    }

    public static void PlaceChestDirect(int x, int y, ushort type, int style, int id)
    {
      Chest.CreateChest(x, y - 1, id);
      for (int index1 = 0; index1 <= 1; ++index1)
      {
        for (int index2 = -1; index2 <= 0; ++index2)
        {
          if (Main.tile[x + index1, y + index2] == null)
            Main.tile[x + index1, y + index2] = new Tile();
        }
      }
      Main.tile[x, y - 1].active(true);
      Main.tile[x, y - 1].frameY = (short) 0;
      Main.tile[x, y - 1].frameX = (short) (36 * style);
      Main.tile[x, y - 1].type = type;
      Main.tile[x, y - 1].halfBrick(false);
      Main.tile[x + 1, y - 1].active(true);
      Main.tile[x + 1, y - 1].frameY = (short) 0;
      Main.tile[x + 1, y - 1].frameX = (short) (18 + 36 * style);
      Main.tile[x + 1, y - 1].type = type;
      Main.tile[x + 1, y - 1].halfBrick(false);
      Main.tile[x, y].active(true);
      Main.tile[x, y].frameY = (short) 18;
      Main.tile[x, y].frameX = (short) (36 * style);
      Main.tile[x, y].type = type;
      Main.tile[x, y].halfBrick(false);
      Main.tile[x + 1, y].active(true);
      Main.tile[x + 1, y].frameY = (short) 18;
      Main.tile[x + 1, y].frameX = (short) (18 + 36 * style);
      Main.tile[x + 1, y].type = type;
      Main.tile[x + 1, y].halfBrick(false);
    }

    public static void PlaceDresserDirect(int x, int y, ushort type, int style, int id)
    {
      Chest.CreateChest(x - 1, y - 1, id);
      for (int index1 = -1; index1 <= 1; ++index1)
      {
        for (int index2 = -1; index2 <= 0; ++index2)
        {
          if (Main.tile[x + index1, y + index2] == null)
            Main.tile[x + index1, y + index2] = new Tile();
        }
      }
      short num = (short) (style * 54);
      Main.tile[x - 1, y - 1].active(true);
      Main.tile[x - 1, y - 1].frameY = (short) 0;
      Main.tile[x - 1, y - 1].frameX = num;
      Main.tile[x - 1, y - 1].type = type;
      Main.tile[x, y - 1].active(true);
      Main.tile[x, y - 1].frameY = (short) 0;
      Main.tile[x, y - 1].frameX = (short) ((int) num + 18);
      Main.tile[x, y - 1].type = type;
      Main.tile[x + 1, y - 1].active(true);
      Main.tile[x + 1, y - 1].frameY = (short) 0;
      Main.tile[x + 1, y - 1].frameX = (short) ((int) num + 36);
      Main.tile[x + 1, y - 1].type = type;
      Main.tile[x - 1, y].active(true);
      Main.tile[x - 1, y].frameY = (short) 18;
      Main.tile[x - 1, y].frameX = num;
      Main.tile[x - 1, y].type = type;
      Main.tile[x, y].active(true);
      Main.tile[x, y].frameY = (short) 18;
      Main.tile[x, y].frameX = (short) ((int) num + 18);
      Main.tile[x, y].type = type;
      Main.tile[x + 1, y].active(true);
      Main.tile[x + 1, y].frameY = (short) 18;
      Main.tile[x + 1, y].frameX = (short) ((int) num + 36);
      Main.tile[x + 1, y].type = type;
    }

    public static void CheckChest(int i, int j, int type)
    {
      if (WorldGen.destroyObject)
        return;
      bool flag = false;
      int num1 = 0;
      int num2 = j;
      int num3 = num1 + (int) Main.tile[i, j].frameX / 18;
      int Y = num2 + (int) Main.tile[i, j].frameY / 18 * -1;
      while (num3 > 1)
        num3 -= 2;
      int X = num3 * -1 + i;
      for (int index1 = X; index1 < X + 2; ++index1)
      {
        for (int index2 = Y; index2 < Y + 2; ++index2)
        {
          if (Main.tile[index1, index2] == null)
            Main.tile[index1, index2] = new Tile();
          int num4 = (int) Main.tile[index1, index2].frameX / 18;
          while (num4 > 1)
            num4 -= 2;
          if (!Main.tile[index1, index2].active() || (int) Main.tile[index1, index2].type != type || (num4 != index1 - X || (int) Main.tile[index1, index2].frameY != (index2 - Y) * 18))
            flag = true;
        }
        if (Main.tile[index1, Y + 2] == null)
          Main.tile[index1, Y + 2] = new Tile();
        if ((!Main.tile[index1, Y + 2].active() || !Main.tileSolid[(int) Main.tile[index1, Y + 2].type]) && Chest.CanDestroyChest(X, Y))
          flag = true;
      }
      if (!flag)
        return;
      int chestItemDrop = WorldGen.GetChestItemDrop(i, j, type);
      WorldGen.destroyObject = true;
      for (int index1 = X; index1 < X + 2; ++index1)
      {
        for (int index2 = Y; index2 < Y + 3; ++index2)
        {
          if ((int) Main.tile[index1, index2].type == type && Main.tile[index1, index2].active())
          {
            Chest.DestroyChest(index1, index2);
            WorldGen.KillTile(index1, index2, false, false, false);
          }
        }
      }
      Item.NewItem(i * 16, j * 16, 32, 32, chestItemDrop, 1, false, 0, false, false);
      WorldGen.destroyObject = false;
    }

    private static int GetChestItemDrop(int x, int y, int type)
    {
      int index = (int) Main.tile[x, y].frameX / 36;
      return type != 467 ? Chest.chestItemSpawn[index] : Chest.chestItemSpawn2[index];
    }

    public static bool PlaceActuator(int i, int j)
    {
      if (Main.tile[i, j].actuator())
        return false;
      SoundEngine.PlaySound(0, i * 16, j * 16, 1, 1f, 0.0f);
      Main.tile[i, j].actuator(true);
      return true;
    }

    public static bool KillActuator(int i, int j)
    {
      if (!Main.tile[i, j].actuator())
        return false;
      SoundEngine.PlaySound(0, i * 16, j * 16, 1, 1f, 0.0f);
      Main.tile[i, j].actuator(false);
      if (Main.netMode != 1)
        Item.NewItem(i * 16, j * 16, 16, 16, 849, 1, false, 0, false, false);
      for (int index = 0; index < 5; ++index)
        Dust.NewDust(new Vector2((float) (i * 16), (float) (j * 16)), 16, 16, 50, 0.0f, 0.0f, 0, new Color(), 1f);
      return true;
    }

    public static bool PlaceWire(int i, int j)
    {
      if (Main.tile[i, j].wire())
        return false;
      SoundEngine.PlaySound(0, i * 16, j * 16, 1, 1f, 0.0f);
      Main.tile[i, j].wire(true);
      return true;
    }

    public static bool KillWire(int i, int j)
    {
      if (!Main.tile[i, j].wire())
        return false;
      SoundEngine.PlaySound(0, i * 16, j * 16, 1, 1f, 0.0f);
      Main.tile[i, j].wire(false);
      if (Main.netMode != 1)
        Item.NewItem(i * 16, j * 16, 16, 16, 530, 1, false, 0, false, false);
      for (int index = 0; index < 5; ++index)
        Dust.NewDust(new Vector2((float) (i * 16), (float) (j * 16)), 16, 16, 50, 0.0f, 0.0f, 0, new Color(), 1f);
      return true;
    }

    public static bool PlaceWire2(int i, int j)
    {
      if (Main.tile[i, j].wire2())
        return false;
      SoundEngine.PlaySound(0, i * 16, j * 16, 1, 1f, 0.0f);
      Main.tile[i, j].wire2(true);
      return true;
    }

    public static bool KillWire2(int i, int j)
    {
      if (!Main.tile[i, j].wire2())
        return false;
      SoundEngine.PlaySound(0, i * 16, j * 16, 1, 1f, 0.0f);
      Main.tile[i, j].wire2(false);
      if (Main.netMode != 1)
        Item.NewItem(i * 16, j * 16, 16, 16, 530, 1, false, 0, false, false);
      for (int index = 0; index < 5; ++index)
        Dust.NewDust(new Vector2((float) (i * 16), (float) (j * 16)), 16, 16, 50, 0.0f, 0.0f, 0, new Color(), 1f);
      return true;
    }

    public static bool PlaceWire3(int i, int j)
    {
      if (Main.tile[i, j].wire3())
        return false;
      SoundEngine.PlaySound(0, i * 16, j * 16, 1, 1f, 0.0f);
      Main.tile[i, j].wire3(true);
      return true;
    }

    public static bool KillWire3(int i, int j)
    {
      if (!Main.tile[i, j].wire3())
        return false;
      SoundEngine.PlaySound(0, i * 16, j * 16, 1, 1f, 0.0f);
      Main.tile[i, j].wire3(false);
      if (Main.netMode != 1)
        Item.NewItem(i * 16, j * 16, 16, 16, 530, 1, false, 0, false, false);
      for (int index = 0; index < 5; ++index)
        Dust.NewDust(new Vector2((float) (i * 16), (float) (j * 16)), 16, 16, 50, 0.0f, 0.0f, 0, new Color(), 1f);
      return true;
    }

    public static bool PlaceWire4(int i, int j)
    {
      if (Main.tile[i, j].wire4())
        return false;
      SoundEngine.PlaySound(0, i * 16, j * 16, 1, 1f, 0.0f);
      Main.tile[i, j].wire4(true);
      return true;
    }

    public static bool KillWire4(int i, int j)
    {
      if (!Main.tile[i, j].wire4())
        return false;
      SoundEngine.PlaySound(0, i * 16, j * 16, 1, 1f, 0.0f);
      Main.tile[i, j].wire4(false);
      if (Main.netMode != 1)
        Item.NewItem(i * 16, j * 16, 16, 16, 530, 1, false, 0, false, false);
      for (int index = 0; index < 5; ++index)
        Dust.NewDust(new Vector2((float) (i * 16), (float) (j * 16)), 16, 16, 50, 0.0f, 0.0f, 0, new Color(), 1f);
      return true;
    }

    public static bool IsFitToPlaceFlowerIn(int x, int y, int typeAttemptedToPlace)
    {
      if (y < 1 || y > Main.maxTilesY - 1)
        return false;
      Tile tile = Main.tile[x, y + 1];
      if (!tile.active() || tile.slope() != (byte) 0 || tile.halfBrick())
        return false;
      if ((tile.type == (ushort) 2 || tile.type == (ushort) 78 || (tile.type == (ushort) 380 || tile.type == (ushort) 477) || tile.type == (ushort) 579) && typeAttemptedToPlace == 3 || (tile.type == (ushort) 23 && typeAttemptedToPlace == 24 || (tile.type == (ushort) 109 || tile.type == (ushort) 492) && typeAttemptedToPlace == 110))
        return true;
      return tile.type == (ushort) 199 && typeAttemptedToPlace == 201;
    }

    private static bool SeaOatWaterCheck(int x, int y)
    {
      int num1 = 45;
      int num2 = 20;
      int num3 = 20;
      int num4 = -1;
      int num5 = num1 + 1;
      int num6 = 0;
      bool flag = false;
      if (x <= WorldGen.beachDistance || x >= Main.maxTilesX - WorldGen.beachDistance)
      {
        flag = true;
        num4 = 40;
        num1 = 65;
        num2 += 5;
      }
      for (int index1 = x - num1; index1 <= x + num1; ++index1)
      {
        for (int index2 = y - num2; index2 <= y + num2; ++index2)
        {
          if (WorldGen.InWorld(index1, index2, 0) && !WorldGen.SolidTile(index1, index2, false) && Main.tile[index1, index2].liquid > (byte) 0)
          {
            num6 += (int) Main.tile[index1, index2].liquid;
            int num7 = Math.Abs(index1 - x);
            if (num7 < num5)
              num5 = num7;
          }
        }
      }
      if (num6 / (int) byte.MaxValue >= num3)
      {
        if (!flag)
          return true;
        return false;
      }
      return flag;
    }

    private static bool PlantSeaOat(int x, int y)
    {
      if (Main.tile[x, y].wall > (ushort) 0 || Main.tile[x, y].active() || (Main.tile[x, y].liquid > (byte) 0 || !WorldGen.SolidTileAllowBottomSlope(x, y + 1)) || (!TileID.Sets.Conversion.Sand[(int) Main.tile[x, y + 1].type] || !WorldGen.SeaOatWaterCheck(x, y)))
        return false;
      Main.tile[x, y].active(true);
      Main.tile[x, y].slope((byte) 0);
      Main.tile[x, y].halfBrick(false);
      Main.tile[x, y].type = (ushort) 529;
      Main.tile[x, y].frameX = (short) (WorldGen.genRand.Next(5) * 18);
      int num = 0;
      Main.tile[x, y].frameY = (short) (num * 34);
      if (Main.netMode == 2)
        NetMessage.SendTileSquare(-1, x, y, 1, TileChangeType.None);
      return true;
    }

    private static bool CheckSeaOat(int x, int y)
    {
      if (WorldGen.SeaOatWaterCheck(x, y))
        return true;
      WorldGen.KillTile(x, y, false, false, false);
      if (Main.netMode == 2)
        NetMessage.SendData(17, -1, -1, (NetworkText) null, 0, (float) x, (float) y, 0.0f, 0, 0, 0);
      return false;
    }

    private static bool GrowSeaOat(int x, int y)
    {
      if (Main.tile[x, y].frameX < (short) 180)
        Main.tile[x, y].frameX += (short) 90;
      if (Main.netMode == 2)
        NetMessage.SendTileSquare(-1, x, y, 1, TileChangeType.None);
      return false;
    }

    private static int GetWaterDepth(int x, int y)
    {
      int j1 = y;
      while (!WorldGen.SolidTile(x, j1, false))
      {
        ++j1;
        if (j1 > Main.maxTilesY - 1)
          return 0;
      }
      int num = j1 - 1;
      int j2 = num;
      while (Main.tile[x, j2].liquid > (byte) 0 && !WorldGen.SolidTile(x, j2, false))
        --j2;
      return num - j2;
    }

    private static int CountGrowingPlantTiles(int x, int y, int range, int type)
    {
      int num = 0;
      for (int index1 = x - range; index1 <= x + range; ++index1)
      {
        for (int index2 = y - range * 3; index2 <= y + range * 3; ++index2)
        {
          if (Main.tile[index1, index2].active() && (int) Main.tile[index1, index2].type == type)
            ++num;
        }
      }
      return num;
    }

    private static bool PlaceBamboo(int x, int y)
    {
      int num1 = 2;
      int num2 = 5;
      int num3 = WorldGen.genRand.Next(1, 21);
      if (Main.tile[x, y].wall > (ushort) 0)
        return false;
      Tile tile1 = Main.tile[x, y + 1];
      if (tile1.type != (ushort) 571 && tile1.type != (ushort) 60)
        return false;
      int waterDepth = WorldGen.GetWaterDepth(x, y);
      if (waterDepth < num1 || waterDepth > num2)
        return false;
      int num4 = WorldGen.CountGrowingPlantTiles(x, y, 5, 571);
      int num5 = 1;
      if (tile1.type == (ushort) 571)
      {
        while (!WorldGen.SolidTile(x, y + num5, false))
          ++num5;
        if (num5 + num4 / WorldGen.genRand.Next(1, 21) > num3)
          return false;
      }
      else
        num4 += 25;
      if (num4 + num5 * 2 > WorldGen.genRand.Next(40, 61))
        return false;
      Tile tile2 = Main.tile[x, y];
      tile2.active(true);
      tile2.type = (ushort) 571;
      tile2.frameX = (short) 0;
      tile2.frameY = (short) 0;
      tile2.slope((byte) 0);
      tile2.halfBrick(false);
      WorldGen.SquareTileFrame(x, y, true);
      return true;
    }

    public static void CheckBamboo(int x, int y)
    {
      Tile tile1 = Main.tile[x, y + 1];
      if (tile1 == null)
        return;
      if (!tile1.active() || tile1.type != (ushort) 60 && tile1.type != (ushort) 571)
      {
        WorldGen.KillTile(x, y, false, false, false);
        if (Main.netMode == 2)
          NetMessage.SendData(17, -1, -1, (NetworkText) null, 0, (float) x, (float) y, 0.0f, 0, 0, 0);
        WorldGen.SquareTileFrame(x, y, true);
      }
      else
      {
        Tile tile2 = Main.tile[x, y - 1];
        if (tile2 == null)
          return;
        Tile tile3 = Main.tile[x, y];
        if (tile3 == null)
          return;
        int num1 = !tile2.active() ? 0 : (tile2.type == (ushort) 571 ? 1 : 0);
        bool flag = tile1.active() && tile1.type == (ushort) 571;
        int num2 = (int) tile3.frameX / 18;
        tile3.frameY = (short) 0;
        if (num1 != 0)
        {
          if (flag)
          {
            if ((num2 < 5 ? 0 : (num2 <= 14 ? 1 : 0)) != 0)
              return;
            tile3.frameX = (short) (WorldGen.genRand.Next(5, 15) * 18);
            if (Main.netMode != 2)
              return;
            NetMessage.SendTileSquare(-1, x, y, 1, TileChangeType.None);
          }
          else
          {
            if ((num2 < 1 ? 0 : (num2 <= 4 ? 1 : 0)) != 0)
              return;
            tile3.frameX = (short) (WorldGen.genRand.Next(1, 5) * 18);
            if (Main.netMode != 2)
              return;
            NetMessage.SendTileSquare(-1, x, y, 1, TileChangeType.None);
          }
        }
        else if (flag)
        {
          if ((num2 < 15 ? 0 : (num2 <= 19 ? 1 : 0)) != 0)
            return;
          tile3.frameX = (short) (WorldGen.genRand.Next(15, 20) * 18);
          if (Main.netMode != 2)
            return;
          NetMessage.SendTileSquare(-1, x, y, 1, TileChangeType.None);
        }
        else
        {
          if ((uint) num2 <= 0U)
            return;
          tile3.frameX = (short) 0;
          if (Main.netMode != 2)
            return;
          NetMessage.SendTileSquare(-1, x, y, 1, TileChangeType.None);
        }
      }
    }

    public static void PlaceUnderwaterPlant(ushort type, int x, int y)
    {
      if (!WorldGen.CanUnderwaterPlantGrowHere(type, x, y, false))
        return;
      Tile tileSafely1 = Framing.GetTileSafely(x, y + 1);
      tileSafely1.slope((byte) 0);
      tileSafely1.halfBrick(false);
      Tile tileSafely2 = Framing.GetTileSafely(x, y);
      tileSafely2.active(true);
      tileSafely2.type = type;
      tileSafely2.frameX = (short) 0;
      tileSafely2.frameY = (short) 0;
      tileSafely2.slope((byte) 0);
      tileSafely2.halfBrick(false);
      WorldGen.SquareTileFrame(x, y, true);
    }

    public static bool CanUnderwaterPlantGrowHere(ushort type, int x, int y, bool ignoreSelf)
    {
      if (!WorldGen.InWorld(x, y, 50))
        return false;
      Tile tileSafely1 = Framing.GetTileSafely(x, y);
      if (!ignoreSelf && tileSafely1.active())
        return false;
      for (int index = 0; index < 3; ++index)
      {
        Tile tileSafely2 = Framing.GetTileSafely(x, y - index);
        if (tileSafely2.liquid == (byte) 0 || tileSafely2.liquidType() != (byte) 0)
          return false;
      }
      Tile tileSafely3 = Framing.GetTileSafely(x, y + 1);
      if (!tileSafely3.nactive() || (TileID.Sets.Conversion.Sand[(int) tileSafely3.type] ? 1 : ((int) type == (int) tileSafely3.type ? 1 : 0)) == 0)
        return false;
      switch (Framing.GetTileSafely(x, y).wall)
      {
        case 0:
        case 63:
        case 64:
        case 65:
        case 66:
        case 67:
        case 68:
        case 69:
        case 80:
        case 81:
          return true;
        default:
          return false;
      }
    }

    public static void CheckUnderwaterPlant(ushort type, int x, int y)
    {
      if (!WorldGen.CanUnderwaterPlantGrowHere(type, x, y, true))
      {
        WorldGen.KillTile(x, y, false, false, false);
        if (Main.netMode == 2)
          NetMessage.SendData(17, -1, -1, (NetworkText) null, 0, (float) x, (float) y, 0.0f, 0, 0, 0);
        WorldGen.SquareTileFrame(x, y, true);
      }
      else
      {
        Tile tileSafely1 = Framing.GetTileSafely(x, y - 1);
        Tile tileSafely2 = Framing.GetTileSafely(x, y);
        Tile tileSafely3 = Framing.GetTileSafely(x, y + 1);
        int num1 = !tileSafely1.active() ? 0 : ((int) tileSafely1.type == (int) type ? 1 : 0);
        bool flag = tileSafely3.active() && (int) tileSafely3.type == (int) type;
        int num2 = (int) tileSafely2.frameX / 18;
        tileSafely2.frameY = (short) 0;
        if (num1 != 0)
        {
          if ((1 > num2 ? 0 : (num2 <= 7 ? 1 : 0)) != 0)
            return;
          tileSafely2.frameX = (short) (WorldGen.genRand.Next(1, 8) * 18);
          if (Main.netMode != 2)
            return;
          NetMessage.SendTileSquare(-1, x, y, 1, TileChangeType.None);
        }
        else if (flag)
        {
          if ((7 > num2 ? 0 : (num2 <= 12 ? 1 : 0)) != 0)
            return;
          tileSafely2.frameX = (short) (WorldGen.genRand.Next(7, 13) * 18);
          if (Main.netMode != 2)
            return;
          NetMessage.SendTileSquare(-1, x, y, 1, TileChangeType.None);
        }
        else
        {
          if ((uint) num2 <= 0U)
            return;
          tileSafely2.frameX = (short) 0;
          if (Main.netMode != 2)
            return;
          NetMessage.SendTileSquare(-1, x, y, 1, TileChangeType.None);
        }
      }
    }

    public static Point PlaceCatTail(int x, int j)
    {
      int index1 = j;
      Point point = new Point(-1, -1);
      if (x < 50 || x > Main.maxTilesX - 50 || (index1 < 50 || index1 > Main.maxTilesY - 50) || (Main.tile[x, index1].active() && Main.tile[x, index1].type != (ushort) 71 || (Main.tile[x, index1].liquid == (byte) 0 || Main.tile[x, index1].liquidType() != (byte) 0)))
        return point;
      while (Main.tile[x, index1].liquid > (byte) 0 && index1 > 50)
        --index1;
      int index2 = index1 + 1;
      if (Main.tile[x, index2].active() || Main.tile[x, index2 - 1].active() || (Main.tile[x, index2].liquid == (byte) 0 || Main.tile[x, index2].liquidType() != (byte) 0) || Main.tile[x, index2].wall != (ushort) 0 && Main.tile[x, index2].wall != (ushort) 80 && (Main.tile[x, index2].wall != (ushort) 81 && Main.tile[x, index2].wall != (ushort) 69) && (Main.tile[x, index2].wall < (ushort) 63 || Main.tile[x, index2].wall > (ushort) 68))
        return point;
      int num1 = 7;
      int num2 = 0;
      for (int index3 = x - num1; index3 <= x + num1; ++index3)
      {
        for (int index4 = index2 - num1; index4 <= index2 + num1; ++index4)
        {
          if (Main.tile[index3, index4].active() && Main.tile[index3, index4].type == (ushort) 519)
          {
            ++num2;
            break;
          }
        }
      }
      if (num2 > 3)
        return point;
      int index5;
      for (index5 = index2; (!Main.tile[x, index5].active() || !Main.tileSolid[(int) Main.tile[x, index5].type] || Main.tileSolidTop[(int) Main.tile[x, index5].type]) && index5 < Main.maxTilesY - 50; ++index5)
      {
        if (Main.tile[x, index5].active() && Main.tile[x, index5].type != (ushort) 71)
          return point;
      }
      int num3 = WorldGen.catTailDistance - 1;
      if (index5 - index2 > num3 || index5 - index2 < 2)
        return point;
      int type = (int) Main.tile[x, index5].type;
      if (!Main.tile[x, index5].nactive())
        return point;
      int num4 = -1;
      switch (type)
      {
        case 2:
        case 477:
          num4 = 0;
          break;
        case 23:
        case 112:
          num4 = 72;
          break;
        case 53:
          if (x < WorldGen.beachDistance || x > Main.maxTilesX - WorldGen.beachDistance)
            return point;
          num4 = 18;
          break;
        case 70:
          num4 = 90;
          break;
        case 199:
        case 234:
          num4 = 54;
          break;
      }
      if (num4 < 0)
        return point;
      if (Main.tile[x, index5].topSlope() && WorldGen.gen && WorldGen.genRand.Next(3) != 0)
        Main.tile[x, index5].slope((byte) 0);
      else if (Main.tile[x, index5].topSlope() || Main.tile[x, index5].halfBrick())
        return point;
      int index6 = index5 - 1;
      Main.tile[x, index6].active(true);
      Main.tile[x, index6].type = (ushort) 519;
      Main.tile[x, index6].frameX = (short) 0;
      Main.tile[x, index6].frameY = (short) num4;
      Main.tile[x, index6].halfBrick(false);
      Main.tile[x, index6].slope((byte) 0);
      WorldGen.SquareTileFrame(x, index6, true);
      point = new Point(x, index6);
      return point;
    }

    public static void CheckCatTail(int x, int j)
    {
      if (Main.tile[x, j] == null)
        return;
      int num1 = j;
      bool flag = false;
      int index1 = num1;
      while ((!Main.tile[x, index1].active() || !Main.tileSolid[(int) Main.tile[x, index1].type] || Main.tileSolidTop[(int) Main.tile[x, index1].type]) && index1 < Main.maxTilesY - 50)
      {
        if (Main.tile[x, index1].active() && Main.tile[x, index1].type != (ushort) 519)
          flag = true;
        if (Main.tile[x, index1].active())
        {
          ++index1;
          if (Main.tile[x, index1] == null)
            return;
        }
        else
          break;
      }
      int index2 = index1 - 1;
      if (Main.tile[x, index2] == null)
        return;
      while (Main.tile[x, index2] != null && Main.tile[x, index2].liquid > (byte) 0 && index2 > 50)
      {
        if (Main.tile[x, index2].active() && Main.tile[x, index2].type != (ushort) 519 || Main.tile[x, index2].liquidType() != (byte) 0)
          flag = true;
        --index2;
        if (Main.tile[x, index2] == null)
          return;
      }
      int index3 = index2 + 1;
      if (Main.tile[x, index3] == null)
        return;
      int num2 = index3;
      int catTailDistance = WorldGen.catTailDistance;
      if (index1 - num2 > catTailDistance)
        flag = true;
      int type = (int) Main.tile[x, index1].type;
      int num3 = -1;
      switch (type)
      {
        case 2:
        case 477:
          num3 = 0;
          break;
        case 23:
        case 112:
          num3 = 72;
          break;
        case 53:
          num3 = 18;
          break;
        case 70:
          num3 = 90;
          break;
        case 199:
        case 234:
          num3 = 54;
          break;
      }
      if (!Main.tile[x, index1].nactive())
        flag = true;
      if (num3 < 0)
        flag = true;
      int index4 = index1 - 1;
      if (Main.tile[x, index4] != null && !Main.tile[x, index4].active())
      {
        for (int index5 = index4; index5 >= num2; --index5)
        {
          if (Main.tile[x, index5] == null)
            return;
          if (Main.tile[x, index5].active() && Main.tile[x, index5].type == (ushort) 519)
          {
            index4 = index5;
            break;
          }
        }
      }
      while (Main.tile[x, index4] != null && Main.tile[x, index4].active() && Main.tile[x, index4].type == (ushort) 519)
        --index4;
      int tileY = index4 + 1;
      if (Main.tile[x, index1 - 1] != null && Main.tile[x, index1 - 1].liquid < (byte) 127 && WorldGen.genRand.Next(4) == 0)
        flag = true;
      if (Main.tile[x, tileY] != null && Main.tile[x, tileY].frameX >= (short) 180 && (Main.tile[x, tileY].liquid > (byte) 127 && WorldGen.genRand.Next(4) == 0))
        flag = true;
      if (Main.tile[x, tileY] != null && Main.tile[x, index1 - 1] != null && Main.tile[x, tileY].frameX > (short) 18)
      {
        if (Main.tile[x, index1 - 1].frameX < (short) 36 || Main.tile[x, index1 - 1].frameX > (short) 72)
          flag = true;
        else if (Main.tile[x, tileY].frameX < (short) 90)
          flag = true;
        else if (Main.tile[x, tileY].frameX >= (short) 108 && Main.tile[x, tileY].frameX <= (short) 162)
          Main.tile[x, tileY].frameX = (short) 90;
      }
      if (index1 > tileY + 4 && Main.tile[x, tileY + 4] != null && (Main.tile[x, tileY + 3] != null && Main.tile[x, tileY + 4].liquid == (byte) 0) && Main.tile[x, tileY + 3].type == (ushort) 519)
        flag = true;
      if (flag)
      {
        int num4 = num2;
        if (tileY < num2)
          num4 = tileY;
        for (int j1 = num4 - 4; j1 <= index1; ++j1)
        {
          if (Main.tile[x, j1] != null && Main.tile[x, j1].active() && Main.tile[x, j1].type == (ushort) 519)
          {
            WorldGen.KillTile(x, j1, false, false, false);
            if (Main.netMode == 2)
              NetMessage.SendData(17, -1, -1, (NetworkText) null, 0, (float) x, (float) j1, 0.0f, 0, 0, 0);
            WorldGen.SquareTileFrame(x, j1, true);
          }
        }
      }
      else
      {
        if (num3 == (int) Main.tile[x, tileY].frameY)
          return;
        for (int index5 = tileY; index5 < index1; ++index5)
        {
          if (Main.tile[x, index5] != null && Main.tile[x, index5].active() && Main.tile[x, index5].type == (ushort) 519)
          {
            Main.tile[x, index5].frameY = (short) num3;
            if (Main.netMode == 2)
              NetMessage.SendTileSquare(-1, x, tileY, 2, TileChangeType.None);
          }
        }
      }
    }

    public static void GrowCheckSeaweed(int x, int y)
    {
      int maxValue = 1;
      if (Main.netMode == 1)
        return;
      if (Main.tile[x, y].type == (ushort) 549 && Main.tile[x, y].liquid < (byte) 200 || Main.tile[x, y - 1].liquid < (byte) 200)
      {
        if (!Main.tile[x, y].active() || Main.tile[x, y].type != (ushort) 549 || WorldGen.genRand.Next(2) != 0)
          return;
        WorldGen.KillTile(x, y, false, false, false);
        if (Main.netMode != 2)
          return;
        NetMessage.SendData(17, -1, -1, (NetworkText) null, 0, (float) x, (float) y, 0.0f, 0, 0, 0);
      }
      else
      {
        if (Main.tile[x, y - 1].active() || Main.tile[x, y - 2].active() || (WorldGen.genRand.Next(maxValue) != 0 || Main.tile[x, y - 2].liquid != byte.MaxValue) || Main.tile[x, y - 3].liquid != byte.MaxValue)
          return;
        int num1 = 17;
        int num2 = 4;
        int num3 = 30;
        int num4 = 0;
        for (int index1 = x - num2; index1 <= x + num2; ++index1)
        {
          for (int index2 = y; index2 <= y + num2 * 3; ++index2)
          {
            if (Main.tile[index1, index2].active() && Main.tile[index1, index2].type == (ushort) 549)
            {
              ++num4;
              if (num4 > num3)
                return;
            }
          }
        }
        int j = y;
        while (!WorldGen.SolidTile(x, j, false) && j < Main.maxTilesY - 50)
          ++j;
        if (j - y >= num1 - WorldGen.genRand.Next(20))
          return;
        WorldGen.PlaceTile(x, y - 1, 549, true, false, -1, 0);
        if (Main.netMode != 2)
          return;
        NetMessage.SendTileSquare(-1, x, y - 1, 2, TileChangeType.None);
      }
    }

    public static void GrowCatTail(int x, int j)
    {
      if (Main.netMode == 1)
        return;
      int index1 = j;
      while (Main.tile[x, index1].liquid > (byte) 0 && index1 > 50)
        --index1;
      int index2 = index1 + 1;
      while ((!Main.tile[x, index2].active() || !Main.tileSolid[(int) Main.tile[x, index2].type] || Main.tileSolidTop[(int) Main.tile[x, index2].type]) && index2 < Main.maxTilesY - 50)
        ++index2;
      int index3 = index2 - 1;
      while (Main.tile[x, index3].active() && Main.tile[x, index3].type == (ushort) 519)
        --index3;
      int index4 = index3 + 1;
      if (Main.tile[x, index4].frameX == (short) 90 && Main.tile[x, index4 - 1].active() && Main.tileCut[(int) Main.tile[x, index4 - 1].type])
      {
        WorldGen.KillTile(x, index4 - 1, false, false, false);
        if (Main.netMode == 2)
          NetMessage.SendData(17, -1, -1, (NetworkText) null, 0, (float) x, (float) (index4 - 1), 0.0f, 0, 0, 0);
      }
      if (Main.tile[x, index4 - 1].active())
        return;
      if (Main.tile[x, index4].frameX == (short) 0)
      {
        Main.tile[x, index4].frameX = (short) 18;
        WorldGen.SquareTileFrame(x, index4, true);
        if (Main.netMode == 2)
          NetMessage.SendTileSquare(-1, x, index4, 2, TileChangeType.None);
      }
      else if (Main.tile[x, index4].frameX == (short) 18)
      {
        Main.tile[x, index4].frameX = (short) (18 * WorldGen.genRand.Next(2, 5));
        Main.tile[x, index4 - 1].active(true);
        Main.tile[x, index4 - 1].type = (ushort) 519;
        Main.tile[x, index4 - 1].frameX = (short) 90;
        Main.tile[x, index4 - 1].frameY = Main.tile[x, index4].frameY;
        Main.tile[x, index4 - 1].halfBrick(false);
        Main.tile[x, index4 - 1].slope((byte) 0);
        WorldGen.SquareTileFrame(x, index4, true);
        if (Main.netMode == 2)
          NetMessage.SendTileSquare(-1, x, index4, 2, TileChangeType.None);
      }
      else if (Main.tile[x, index4].frameX == (short) 90)
      {
        if (Main.tile[x, index4 - 1].liquid == (byte) 0)
        {
          if (!Main.tile[x, index4 - 2].active() && (Main.tile[x, index4].liquid > (byte) 0 || Main.tile[x, index4 + 1].liquid > (byte) 0 || Main.tile[x, index4 + 2].liquid > (byte) 0) && WorldGen.genRand.Next(3) == 0)
          {
            Main.tile[x, index4].frameX = (short) 108;
            Main.tile[x, index4 - 1].active(true);
            Main.tile[x, index4 - 1].type = (ushort) 519;
            Main.tile[x, index4 - 1].frameX = (short) 90;
            Main.tile[x, index4 - 1].frameY = Main.tile[x, index4].frameY;
            Main.tile[x, index4 - 1].halfBrick(false);
            Main.tile[x, index4 - 1].slope((byte) 0);
            WorldGen.SquareTileFrame(x, index4, true);
          }
          else
          {
            int num = WorldGen.genRand.Next(3);
            Main.tile[x, index4].frameX = (short) (126 + num * 18);
            Main.tile[x, index4 - 1].active(true);
            Main.tile[x, index4 - 1].type = (ushort) 519;
            Main.tile[x, index4 - 1].frameX = (short) (180 + num * 18);
            Main.tile[x, index4 - 1].frameY = Main.tile[x, index4].frameY;
            Main.tile[x, index4 - 1].halfBrick(false);
            Main.tile[x, index4 - 1].slope((byte) 0);
            WorldGen.SquareTileFrame(x, index4, true);
          }
        }
        else
        {
          Main.tile[x, index4].frameX = (short) 108;
          Main.tile[x, index4 - 1].active(true);
          Main.tile[x, index4 - 1].type = (ushort) 519;
          Main.tile[x, index4 - 1].frameX = (short) 90;
          Main.tile[x, index4 - 1].frameY = Main.tile[x, index4].frameY;
          Main.tile[x, index4 - 1].halfBrick(false);
          Main.tile[x, index4 - 1].slope((byte) 0);
          WorldGen.SquareTileFrame(x, index4, true);
        }
      }
      WorldGen.SquareTileFrame(x, index4 - 1, false);
      if (Main.netMode != 2)
        return;
      NetMessage.SendTileSquare(-1, x, index4, 2, TileChangeType.None);
    }

    public static bool PlaceLilyPad(int x, int j)
    {
      int index1 = j;
      if (x < 50 || x > Main.maxTilesX - 50 || (index1 < 50 || index1 > Main.maxTilesY - 50) || (Main.tile[x, index1].active() || Main.tile[x, index1].liquid == (byte) 0 || Main.tile[x, index1].liquidType() != (byte) 0))
        return false;
      while (Main.tile[x, index1].liquid > (byte) 0 && index1 > 50)
        --index1;
      int j1 = index1 + 1;
      if (Main.tile[x, j1].active() || Main.tile[x, j1 - 1].active() || (Main.tile[x, j1].liquid == (byte) 0 || Main.tile[x, j1].liquidType() != (byte) 0) || Main.tile[x, j1].wall != (ushort) 0 && Main.tile[x, j1].wall != (ushort) 15 && Main.tile[x, j1].wall != (ushort) 70 && (Main.tile[x, j1].wall < (ushort) 63 || Main.tile[x, j1].wall > (ushort) 68))
        return false;
      int num1 = 5;
      int num2 = 0;
      for (int index2 = x - num1; index2 <= x + num1; ++index2)
      {
        for (int index3 = j1 - num1; index3 <= j1 + num1; ++index3)
        {
          if (Main.tile[index2, index3].active() && Main.tile[index2, index3].type == (ushort) 518)
            ++num2;
        }
      }
      if (num2 > 3)
        return false;
      int index4;
      for (index4 = j1; (!Main.tile[x, index4].active() || !Main.tileSolid[(int) Main.tile[x, index4].type] || Main.tileSolidTop[(int) Main.tile[x, index4].type]) && index4 < Main.maxTilesY - 50; ++index4)
      {
        if (Main.tile[x, index4].active() && Main.tile[x, index4].type == (ushort) 519)
          return false;
      }
      int num3 = 12;
      if (index4 - j1 > num3 || index4 - j1 < 3)
        return false;
      int type = (int) Main.tile[x, index4].type;
      int num4 = -1;
      if (type == 2 || type == 477)
        num4 = 0;
      if (type == 109 || type == 109 || type == 116)
        num4 = 18;
      if (type == 60)
        num4 = 36;
      if (num4 < 0)
        return false;
      Main.tile[x, j1].active(true);
      Main.tile[x, j1].type = (ushort) 518;
      if (WorldGen.genRand.Next(2) == 0)
        Main.tile[x, j1].frameX = (short) (18 * WorldGen.genRand.Next(3));
      else if (WorldGen.genRand.Next(15) == 0)
      {
        Main.tile[x, j1].frameX = (short) (18 * WorldGen.genRand.Next(18));
      }
      else
      {
        int num5 = Main.maxTilesX / 5;
        Main.tile[x, j1].frameX = x >= num5 ? (x >= num5 * 2 ? (x >= num5 * 3 ? (x >= num5 * 4 ? (short) (18 * WorldGen.genRand.Next(12, 15)) : (short) (18 * WorldGen.genRand.Next(15, 18))) : (short) (18 * WorldGen.genRand.Next(3, 6))) : (short) (18 * WorldGen.genRand.Next(9, 12))) : (short) (18 * WorldGen.genRand.Next(6, 9));
      }
      Main.tile[x, j1].frameY = (short) num4;
      Main.tile[x, j1].halfBrick(false);
      Main.tile[x, j1].slope((byte) 0);
      WorldGen.SquareTileFrame(x, j1, true);
      return true;
    }

    public static void CheckLilyPad(int x, int y)
    {
      if (Main.netMode == 1)
        return;
      if (Main.tile[x, y].liquidType() != (byte) 0)
      {
        WorldGen.KillTile(x, y, false, false, false);
        if (Main.netMode != 2)
          return;
        NetMessage.SendData(17, -1, -1, (NetworkText) null, 0, (float) x, (float) y, 0.0f, 0, 0, 0);
      }
      else
      {
        int index = y;
        while ((!Main.tile[x, index].active() || !Main.tileSolid[(int) Main.tile[x, index].type] || Main.tileSolidTop[(int) Main.tile[x, index].type]) && index < Main.maxTilesY - 50)
        {
          ++index;
          if (Main.tile[x, index] == null)
            return;
        }
        int type = (int) Main.tile[x, index].type;
        int num = -1;
        if (type == 2 || type == 477)
          num = 0;
        if (type == 109 || type == 109 || type == 116)
          num = 18;
        if (type == 60)
          num = 36;
        if (num >= 0)
        {
          if (num != (int) Main.tile[x, y].frameY)
          {
            Main.tile[x, y].frameY = (short) num;
            if (Main.netMode == 2)
              NetMessage.SendTileSquare(-1, x, y, 2, TileChangeType.None);
          }
          if (Main.tile[x, y - 1].liquid > (byte) 0 && !Main.tile[x, y - 1].active())
          {
            Main.tile[x, y - 1].active(true);
            Main.tile[x, y - 1].type = (ushort) 518;
            Main.tile[x, y - 1].frameX = Main.tile[x, y].frameX;
            Main.tile[x, y - 1].frameY = Main.tile[x, y].frameY;
            Main.tile[x, y - 1].halfBrick(false);
            Main.tile[x, y - 1].slope((byte) 0);
            Main.tile[x, y].active(false);
            Main.tile[x, y].type = (ushort) 0;
            WorldGen.SquareTileFrame(x, y - 1, false);
            if (Main.netMode != 2)
              return;
            NetMessage.SendTileSquare(-1, x, y - 1, 3, TileChangeType.None);
          }
          else
          {
            if (Main.tile[x, y].liquid != (byte) 0)
              return;
            Tile tileSafely = Framing.GetTileSafely(x, y + 1);
            if (!tileSafely.active())
            {
              Main.tile[x, y + 1].active(true);
              Main.tile[x, y + 1].type = (ushort) 518;
              Main.tile[x, y + 1].frameX = Main.tile[x, y].frameX;
              Main.tile[x, y + 1].frameY = Main.tile[x, y].frameY;
              Main.tile[x, y + 1].halfBrick(false);
              Main.tile[x, y + 1].slope((byte) 0);
              Main.tile[x, y].active(false);
              Main.tile[x, y].type = (ushort) 0;
              WorldGen.SquareTileFrame(x, y + 1, false);
              if (Main.netMode != 2)
                return;
              NetMessage.SendTileSquare(-1, x, y, 3, TileChangeType.None);
            }
            else
            {
              if (!tileSafely.active() || TileID.Sets.Platforms[(int) tileSafely.type] || Main.tileSolid[(int) tileSafely.type] && !Main.tileSolidTop[(int) tileSafely.type])
                return;
              WorldGen.KillTile(x, y, false, false, false);
              if (Main.netMode != 2)
                return;
              NetMessage.SendData(17, -1, -1, (NetworkText) null, 0, (float) x, (float) y, 0.0f, 0, 0, 0);
            }
          }
        }
        else
        {
          WorldGen.KillTile(x, y, false, false, false);
          if (Main.netMode != 2)
            return;
          NetMessage.SendData(17, -1, -1, (NetworkText) null, 0, (float) x, (float) y, 0.0f, 0, 0, 0);
        }
      }
    }

    public static bool PlaceTile(
      int i,
      int j,
      int Type,
      bool mute = false,
      bool forced = false,
      int plr = -1,
      int style = 0)
    {
      int index1 = Type;
      if (WorldGen.gen && Main.tile[i, j].active() && Main.tile[i, j].type == (ushort) 488 || index1 >= 623)
        return false;
      bool flag = false;
      if (i >= 0 && j >= 0 && (i < Main.maxTilesX && j < Main.maxTilesY))
      {
        Tile trackCache = Main.tile[i, j];
        if (trackCache == null)
        {
          trackCache = new Tile();
          Main.tile[i, j] = trackCache;
        }
        if (forced || Collision.EmptyTile(i, j, false) || !Main.tileSolid[index1] || index1 == 23 && trackCache.type == (ushort) 0 && trackCache.active() || (index1 == 199 && trackCache.type == (ushort) 0 && trackCache.active() || index1 == 2 && trackCache.type == (ushort) 0 && trackCache.active()) || (index1 == 109 && trackCache.type == (ushort) 0 && trackCache.active() || index1 == 60 && trackCache.type == (ushort) 59 && trackCache.active() || index1 == 70 && trackCache.type == (ushort) 59 && trackCache.active()) || Main.tileMoss[index1] && (trackCache.type == (ushort) 1 || trackCache.type == (ushort) 38) && trackCache.active())
        {
          if (index1 == 23 && (trackCache.type != (ushort) 0 || !trackCache.active()) || index1 == 199 && (trackCache.type != (ushort) 0 || !trackCache.active()) || (index1 == 2 && (trackCache.type != (ushort) 0 || !trackCache.active()) || index1 == 109 && (trackCache.type != (ushort) 0 || !trackCache.active())) || (index1 == 60 && (trackCache.type != (ushort) 59 || !trackCache.active()) || index1 == 70 && (trackCache.type != (ushort) 59 || !trackCache.active())))
            return false;
          if (Main.tileMoss[index1])
          {
            if (trackCache.type != (ushort) 1 && trackCache.type != (ushort) 38 || !trackCache.active())
              return false;
            if (trackCache.type == (ushort) 38)
            {
              switch (index1)
              {
                case 381:
                  index1 = 517;
                  break;
                case 534:
                  index1 = 535;
                  break;
                case 536:
                  index1 = 537;
                  break;
                case 539:
                  index1 = 540;
                  break;
                default:
                  index1 = 512 + index1 - 179;
                  break;
              }
            }
          }
          if (index1 == 81)
          {
            if (Main.tile[i, j - 1] == null)
              Main.tile[i, j - 1] = new Tile();
            if (Main.tile[i, j + 1] == null)
              Main.tile[i, j + 1] = new Tile();
            if (Main.tile[i, j - 1].active() || !Main.tile[i, j + 1].active() || (!Main.tileSolid[(int) Main.tile[i, j + 1].type] || Main.tile[i, j + 1].halfBrick()) || Main.tile[i, j + 1].slope() != (byte) 0)
              return false;
          }
          if ((index1 == 373 || index1 == 375 || (index1 == 374 || index1 == 461)) && (Main.tile[i, j - 1] == null || Main.tile[i, j - 1].bottomSlope()))
            return false;
          if (trackCache.liquid > (byte) 0 || trackCache.checkingLiquid())
          {
            switch (index1)
            {
              case 3:
              case 20:
              case 24:
              case 27:
              case 32:
              case 51:
              case 69:
              case 72:
              case 201:
              case 352:
              case 529:
                return false;
              case 4:
                if (style != 8 && style != 11 && style != 17)
                  return false;
                break;
            }
          }
          if (TileID.Sets.ResetsHalfBrickPlacementAttempt[index1] && (!trackCache.active() || !Main.tileFrameImportant[(int) trackCache.type]))
          {
            trackCache.halfBrick(false);
            trackCache.frameY = (short) 0;
            trackCache.frameX = (short) 0;
          }
          if (index1 == 3 || index1 == 24 || (index1 == 110 || index1 == 201))
          {
            if (WorldGen.IsFitToPlaceFlowerIn(i, j, index1))
            {
              if (index1 == 24 && WorldGen.genRand.Next(13) == 0)
              {
                trackCache.active(true);
                trackCache.type = (ushort) 32;
                WorldGen.SquareTileFrame(i, j, true);
              }
              else if (index1 == 201 && WorldGen.genRand.Next(13) == 0)
              {
                trackCache.active(true);
                trackCache.type = (ushort) 352;
                WorldGen.SquareTileFrame(i, j, true);
              }
              else if (Main.tile[i, j + 1].type == (ushort) 78 || Main.tile[i, j + 1].type == (ushort) 380 || Main.tile[i, j + 1].type == (ushort) 579)
              {
                trackCache.active(true);
                trackCache.type = (ushort) index1;
                int num = WorldGen.genRand.NextFromList<int>(6, 7, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 24, 27, 30, 33, 36, 39, 42);
                switch (num)
                {
                  case 21:
                  case 24:
                  case 27:
                  case 30:
                  case 33:
                  case 36:
                  case 39:
                  case 42:
                    num += WorldGen.genRand.Next(3);
                    break;
                }
                trackCache.frameX = (short) (num * 18);
              }
              else if ((trackCache.wall == (ushort) 0 || trackCache.wall == (ushort) 106 || trackCache.wall == (ushort) 107 || trackCache.wall >= (ushort) 63 && trackCache.wall <= (ushort) 70) && (Main.tile[i, j + 1].wall == (ushort) 0 || Main.tile[i, j + 1].wall == (ushort) 106 || Main.tile[i, j + 1].wall == (ushort) 107 || Main.tile[i, j + 1].wall >= (ushort) 63 && Main.tile[i, j + 1].wall <= (ushort) 70))
              {
                if (WorldGen.genRand.Next(50) == 0 || (index1 == 24 || index1 == 201) && WorldGen.genRand.Next(40) == 0)
                {
                  trackCache.active(true);
                  trackCache.type = (ushort) index1;
                  trackCache.frameX = index1 != 201 ? (short) 144 : (short) 270;
                }
                else if (WorldGen.genRand.Next(35) == 0 || Main.tile[i, j].wall >= (ushort) 63 && Main.tile[i, j].wall <= (ushort) 70)
                {
                  trackCache.active(true);
                  trackCache.type = (ushort) index1;
                  int num = WorldGen.genRand.NextFromList<int>(6, 7, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20);
                  if (index1 == 201)
                    num = WorldGen.genRand.NextFromList<int>(6, 7, 8, 9, 10, 11, 12, 13, 14, 16, 17, 18, 19, 20, 21, 22);
                  trackCache.frameX = (short) (num * 18);
                }
                else
                {
                  trackCache.active(true);
                  trackCache.type = (ushort) index1;
                  trackCache.frameX = (short) (WorldGen.genRand.Next(6) * 18);
                }
              }
            }
          }
          else
          {
            switch (index1)
            {
              case 61:
                if (j + 1 < Main.maxTilesY && Main.tile[i, j + 1].active() && (Main.tile[i, j + 1].slope() == (byte) 0 && !Main.tile[i, j + 1].halfBrick()) && Main.tile[i, j + 1].type == (ushort) 60)
                {
                  if (WorldGen.genRand.Next(16) == 0 && (double) j > Main.worldSurface)
                  {
                    trackCache.active(true);
                    trackCache.type = (ushort) 69;
                    WorldGen.SquareTileFrame(i, j, true);
                    break;
                  }
                  if (WorldGen.genRand.Next(60) == 0 && (double) j > Main.rockLayer)
                  {
                    trackCache.active(true);
                    trackCache.type = (ushort) index1;
                    trackCache.frameX = (short) 144;
                    break;
                  }
                  if (WorldGen.genRand.Next(230) == 0 && (double) j > Main.rockLayer)
                  {
                    trackCache.active(true);
                    trackCache.type = (ushort) index1;
                    trackCache.frameX = (short) 162;
                    break;
                  }
                  if (WorldGen.genRand.Next(15) == 0)
                  {
                    trackCache.active(true);
                    trackCache.type = (ushort) index1;
                    trackCache.frameX = WorldGen.genRand.Next(3) == 0 ? (short) (WorldGen.genRand.Next(13) * 18 + 180) : (short) (WorldGen.genRand.Next(2) * 18 + 108);
                    break;
                  }
                  trackCache.active(true);
                  trackCache.type = (ushort) index1;
                  trackCache.frameX = (short) (WorldGen.genRand.Next(6) * 18);
                  break;
                }
                break;
              case 71:
                if (j + 1 < Main.maxTilesY && Main.tile[i, j + 1].active() && (Main.tile[i, j + 1].slope() == (byte) 0 && !Main.tile[i, j + 1].halfBrick()) && Main.tile[i, j + 1].type == (ushort) 70)
                {
                  Point point = new Point(-1, -1);
                  if ((double) j > Main.worldSurface)
                    point = WorldGen.PlaceCatTail(i, j);
                  if (WorldGen.InWorld(point.X, point.Y, 0))
                  {
                    if (WorldGen.gen)
                    {
                      int num = WorldGen.genRand.Next(14);
                      for (int index2 = 0; index2 < num; ++index2)
                        WorldGen.GrowCatTail(point.X, point.Y);
                      WorldGen.SquareTileFrame(point.X, point.Y, true);
                      break;
                    }
                    break;
                  }
                  trackCache.active(true);
                  trackCache.type = (ushort) index1;
                  trackCache.frameX = (short) (WorldGen.genRand.Next(5) * 18);
                  break;
                }
                break;
              case 129:
                if (WorldGen.SolidTile(i - 1, j, false) || WorldGen.SolidTile(i + 1, j, false) || (WorldGen.SolidTile(i, j - 1, false) || WorldGen.SolidTile(i, j + 1, false)))
                {
                  trackCache.active(true);
                  trackCache.type = (ushort) index1;
                  trackCache.frameX = (short) (WorldGen.genRand.Next(18) * 18);
                  if (plr <= -1 && WorldGen.genRand.Next(50) == 0)
                    trackCache.frameX = (short) ((18 + WorldGen.genRand.Next(6)) * 18);
                  WorldGen.SquareTileFrame(i, j, true);
                  break;
                }
                break;
              case 171:
                WorldGen.PlaceXmasTree(i, j, (ushort) 171);
                break;
              case 178:
                if (WorldGen.SolidTile(i - 1, j, true) || WorldGen.SolidTile(i + 1, j, true) || (WorldGen.SolidTile(i, j - 1, false) || WorldGen.SolidTile(i, j + 1, false)))
                {
                  trackCache.active(true);
                  trackCache.type = (ushort) index1;
                  trackCache.frameX = (short) (style * 18);
                  trackCache.frameY = (short) (WorldGen.genRand.Next(3) * 18);
                  WorldGen.SquareTileFrame(i, j, true);
                  break;
                }
                break;
              case 184:
                if (Main.tileMoss[(int) Main.tile[i - 1, j].type] && WorldGen.SolidTile(i - 1, j, false) || Main.tileMoss[(int) Main.tile[i + 1, j].type] && WorldGen.SolidTile(i + 1, j, false) || (Main.tileMoss[(int) Main.tile[i, j - 1].type] && WorldGen.SolidTile(i, j - 1, false) || Main.tileMoss[(int) Main.tile[i, j + 1].type] && WorldGen.SolidTile(i, j + 1, false)))
                {
                  trackCache.active(true);
                  trackCache.type = (ushort) index1;
                  trackCache.frameX = (short) (style * 18);
                  trackCache.frameY = (short) (WorldGen.genRand.Next(3) * 18);
                  WorldGen.SquareTileFrame(i, j, true);
                }
                if (TileID.Sets.tileMossBrick[(int) Main.tile[i - 1, j].type] && WorldGen.SolidTile(i - 1, j, false) || TileID.Sets.tileMossBrick[(int) Main.tile[i + 1, j].type] && WorldGen.SolidTile(i + 1, j, false) || (TileID.Sets.tileMossBrick[(int) Main.tile[i, j - 1].type] && WorldGen.SolidTile(i, j - 1, false) || TileID.Sets.tileMossBrick[(int) Main.tile[i, j + 1].type] && WorldGen.SolidTile(i, j + 1, false)))
                {
                  trackCache.active(true);
                  trackCache.type = (ushort) index1;
                  trackCache.frameX = (short) (style * 18);
                  trackCache.frameY = (short) (WorldGen.genRand.Next(3) * 18);
                  WorldGen.SquareTileFrame(i, j, true);
                  break;
                }
                break;
              case 254:
                WorldGen.Place2x2Style(i, j, (ushort) index1, style);
                break;
              case 485:
                WorldGen.PlaceObject(i, j, index1, false, style, 0, -1, -1);
                break;
              case 518:
                WorldGen.PlaceLilyPad(i, j);
                break;
              case 519:
                WorldGen.PlaceCatTail(i, j);
                break;
              case 529:
                WorldGen.PlantSeaOat(i, j);
                break;
              case 549:
                WorldGen.PlaceUnderwaterPlant((ushort) 549, i, j);
                break;
              case 571:
                WorldGen.PlaceBamboo(i, j);
                break;
              default:
                if (index1 == 335 || index1 == 564 || index1 == 594)
                {
                  WorldGen.Place2x2(i, j, (ushort) index1, 0);
                  break;
                }
                if (index1 == 319 || index1 == 132 || (index1 == 484 || index1 == 138) || (index1 == 142 || index1 == 143 || index1 == 282) || (index1 >= 288 && index1 <= 295 || index1 >= 316 && index1 <= 318))
                {
                  WorldGen.Place2x2(i, j, (ushort) index1, 0);
                  break;
                }
                switch (index1)
                {
                  case 4:
                    if (Main.tile[i - 1, j] == null)
                      Main.tile[i - 1, j] = new Tile();
                    if (Main.tile[i + 1, j] == null)
                      Main.tile[i + 1, j] = new Tile();
                    if (Main.tile[i, j + 1] == null)
                      Main.tile[i, j + 1] = new Tile();
                    Tile tile1 = Main.tile[i - 1, j];
                    Tile tile2 = Main.tile[i + 1, j];
                    Tile tile3 = Main.tile[i, j + 1];
                    if (trackCache.wall > (ushort) 0 || tile1.active() && (tile1.slope() == (byte) 0 || (int) tile1.slope() % 2 != 1) && (Main.tileSolid[(int) tile1.type] && !Main.tileSolidTop[(int) tile1.type] && !TileID.Sets.NotReallySolid[(int) tile1.type] || TileID.Sets.IsBeam[(int) tile1.type] || WorldGen.IsTreeType((int) tile1.type) && WorldGen.IsTreeType((int) Main.tile[i - 1, j - 1].type) && WorldGen.IsTreeType((int) Main.tile[i - 1, j + 1].type)) || (tile2.active() && (tile2.slope() == (byte) 0 || (int) tile2.slope() % 2 != 0) && (Main.tileSolid[(int) tile2.type] && !Main.tileSolidTop[(int) tile2.type] && !TileID.Sets.NotReallySolid[(int) tile2.type] || TileID.Sets.IsBeam[(int) tile2.type] || WorldGen.IsTreeType((int) tile2.type) && WorldGen.IsTreeType((int) Main.tile[i + 1, j - 1].type) && WorldGen.IsTreeType((int) Main.tile[i + 1, j + 1].type)) || tile3.active() && Main.tileSolid[(int) tile3.type] && (TileID.Sets.Platforms[(int) tile3.type] && WorldGen.TopEdgeCanBeAttachedTo(i, j + 1) || (!Main.tileSolidTop[(int) tile3.type] || tile3.type == (ushort) 380 && tile3.slope() == (byte) 0) && (!TileID.Sets.NotReallySolid[(int) tile3.type] && !tile3.halfBrick() && tile3.slope() == (byte) 0))))
                    {
                      trackCache.active(true);
                      trackCache.type = (ushort) index1;
                      trackCache.frameY = (short) (22 * style);
                      WorldGen.SquareTileFrame(i, j, true);
                      break;
                    }
                    break;
                  case 10:
                    if (Main.tile[i, j - 1] == null)
                      Main.tile[i, j - 1] = new Tile();
                    if (Main.tile[i, j - 2] == null)
                      Main.tile[i, j - 2] = new Tile();
                    if (Main.tile[i, j - 3] == null)
                      Main.tile[i, j - 3] = new Tile();
                    if (Main.tile[i, j + 1] == null)
                      Main.tile[i, j + 1] = new Tile();
                    if (Main.tile[i, j + 2] == null)
                      Main.tile[i, j + 2] = new Tile();
                    if (Main.tile[i, j + 3] == null)
                      Main.tile[i, j + 3] = new Tile();
                    if (!Main.tile[i, j - 1].active() && !Main.tile[i, j - 2].active() && (Main.tile[i, j - 3].active() && Main.tileSolid[(int) Main.tile[i, j - 3].type]))
                    {
                      WorldGen.PlaceDoor(i, j - 1, index1, style);
                      WorldGen.SquareTileFrame(i, j, true);
                      break;
                    }
                    if (Main.tile[i, j + 1].active() || Main.tile[i, j + 2].active() || (!Main.tile[i, j + 3].active() || !Main.tileSolid[(int) Main.tile[i, j + 3].type]))
                      return false;
                    WorldGen.PlaceDoor(i, j + 1, index1, style);
                    WorldGen.SquareTileFrame(i, j, true);
                    break;
                  case 136:
                    if (Main.tile[i - 1, j] == null)
                      Main.tile[i - 1, j] = new Tile();
                    if (Main.tile[i + 1, j] == null)
                      Main.tile[i + 1, j] = new Tile();
                    if (Main.tile[i, j + 1] == null)
                      Main.tile[i, j + 1] = new Tile();
                    if (Main.tile[i - 1, j].nactive() && !Main.tile[i - 1, j].halfBrick() && (!TileID.Sets.NotReallySolid[(int) Main.tile[i - 1, j].type] && Main.tile[i - 1, j].slope() == (byte) 0) && (WorldGen.SolidTile(i - 1, j, false) || TileID.Sets.IsBeam[(int) Main.tile[i - 1, j].type] || Main.tile[i - 1, j].type == (ushort) 5 && Main.tile[i - 1, j - 1].type == (ushort) 5 && Main.tile[i - 1, j + 1].type == (ushort) 5) || Main.tile[i + 1, j].nactive() && !Main.tile[i + 1, j].halfBrick() && (!TileID.Sets.NotReallySolid[(int) Main.tile[i + 1, j].type] && Main.tile[i + 1, j].slope() == (byte) 0) && (WorldGen.SolidTile(i + 1, j, false) || TileID.Sets.IsBeam[(int) Main.tile[i + 1, j].type] || Main.tile[i + 1, j].type == (ushort) 5 && Main.tile[i + 1, j - 1].type == (ushort) 5 && Main.tile[i + 1, j + 1].type == (ushort) 5) || (Main.tile[i, j + 1].nactive() && !Main.tile[i, j + 1].halfBrick() && (WorldGen.SolidTile(i, j + 1, false) && Main.tile[i, j + 1].slope() == (byte) 0) || trackCache.wall > (ushort) 0))
                    {
                      trackCache.active(true);
                      trackCache.type = (ushort) index1;
                      WorldGen.SquareTileFrame(i, j, true);
                      break;
                    }
                    break;
                  case 137:
                    trackCache.active(true);
                    trackCache.type = (ushort) index1;
                    trackCache.frameY = (short) (18 * style);
                    break;
                  case 411:
                    WorldGen.Place2x2(i, j, (ushort) index1, 0);
                    break;
                  case 442:
                    if (Main.tile[i - 1, j] == null)
                      Main.tile[i - 1, j] = new Tile();
                    if (Main.tile[i + 1, j] == null)
                      Main.tile[i + 1, j] = new Tile();
                    if (Main.tile[i, j + 1] == null)
                      Main.tile[i, j + 1] = new Tile();
                    if (Main.tile[i - 1, j].nactive() && !Main.tile[i - 1, j].halfBrick() && (!TileID.Sets.NotReallySolid[(int) Main.tile[i - 1, j].type] && Main.tile[i - 1, j].slope() == (byte) 0) && (WorldGen.SolidTile(i - 1, j, false) || TileID.Sets.IsBeam[(int) Main.tile[i - 1, j].type] || Main.tile[i - 1, j].type == (ushort) 5 && Main.tile[i - 1, j - 1].type == (ushort) 5 && Main.tile[i - 1, j + 1].type == (ushort) 5) || Main.tile[i + 1, j].nactive() && !Main.tile[i + 1, j].halfBrick() && (!TileID.Sets.NotReallySolid[(int) Main.tile[i + 1, j].type] && Main.tile[i + 1, j].slope() == (byte) 0) && (WorldGen.SolidTile(i + 1, j, false) || TileID.Sets.IsBeam[(int) Main.tile[i + 1, j].type] || Main.tile[i + 1, j].type == (ushort) 5 && Main.tile[i + 1, j - 1].type == (ushort) 5 && Main.tile[i + 1, j + 1].type == (ushort) 5) || Main.tile[i, j + 1].nactive() && !Main.tile[i, j + 1].halfBrick() && (WorldGen.SolidTile(i, j + 1, false) && Main.tile[i, j + 1].slope() == (byte) 0))
                    {
                      trackCache.active(true);
                      trackCache.type = (ushort) index1;
                      WorldGen.SquareTileFrame(i, j, true);
                      break;
                    }
                    break;
                  case 457:
                    WorldGen.Place2x2Horizontal(i, j, (ushort) 457, style);
                    break;
                  default:
                    if (index1 >= 275 && index1 <= 281 || (index1 == 296 || index1 == 297) || (index1 == 309 || index1 == 358 || (index1 == 359 || index1 == 413)) || (index1 == 414 || index1 == 542))
                    {
                      WorldGen.Place6x3(i, j, (ushort) index1, -1, 0);
                      break;
                    }
                    if (index1 == 237 || index1 == 244 || (index1 == 285 || index1 == 286) || (index1 == 298 || index1 == 299 || (index1 == 310 || index1 == 339)) || (index1 == 538 || index1 >= 361 && index1 <= 364 || (index1 == 532 || index1 == 533 || (index1 == 486 || index1 == 488))) || (index1 == 544 || index1 == 582 || index1 == 619))
                    {
                      WorldGen.Place3x2(i, j, (ushort) index1, 0);
                      break;
                    }
                    switch (index1)
                    {
                      case 128:
                        WorldGen.PlaceMan(i, j, style);
                        WorldGen.SquareTileFrame(i, j, true);
                        break;
                      case 149:
                        if (WorldGen.SolidTile(i - 1, j, false) || WorldGen.SolidTile(i + 1, j, false) || (WorldGen.SolidTile(i, j - 1, false) || WorldGen.SolidTile(i, j + 1, false)))
                        {
                          trackCache.frameX = (short) (18 * style);
                          trackCache.active(true);
                          trackCache.type = (ushort) index1;
                          WorldGen.SquareTileFrame(i, j, true);
                          break;
                        }
                        break;
                      case 269:
                        WorldGen.PlaceWoman(i, j, style);
                        WorldGen.SquareTileFrame(i, j, true);
                        break;
                      case 334:
                        int style1 = 0;
                        if (style == -1)
                          style1 = 1;
                        WorldGen.Place3x3Wall(i, j, (ushort) 334, style1);
                        WorldGen.SquareTileFrame(i, j, true);
                        break;
                      default:
                        if (index1 == 139 || index1 == 35)
                        {
                          WorldGen.PlaceMB(i, j, (ushort) index1, style);
                          WorldGen.SquareTileFrame(i, j, true);
                          break;
                        }
                        switch (index1)
                        {
                          case 34:
                            WorldGen.PlaceChand(i, j, (ushort) index1, style);
                            WorldGen.SquareTileFrame(i, j, true);
                            break;
                          case 165:
                            WorldGen.PlaceTight(i, j, false);
                            WorldGen.SquareTileFrame(i, j, true);
                            break;
                          case 235:
                            WorldGen.Place3x1(i, j, (ushort) index1, 0);
                            WorldGen.SquareTileFrame(i, j, true);
                            break;
                          case 240:
                            WorldGen.Place3x3Wall(i, j, (ushort) index1, style);
                            break;
                          case 241:
                            WorldGen.Place4x3Wall(i, j, (ushort) index1, style);
                            break;
                          case 242:
                            WorldGen.Place6x4Wall(i, j, (ushort) index1, style);
                            break;
                          case 245:
                            WorldGen.Place2x3Wall(i, j, (ushort) index1, style);
                            break;
                          case 246:
                            WorldGen.Place3x2Wall(i, j, (ushort) index1, style);
                            break;
                          case 440:
                            WorldGen.Place3x3Wall(i, j, (ushort) index1, style);
                            break;
                          default:
                            if (index1 == 106 || index1 == 212 || (index1 == 219 || index1 == 220) || (index1 == 228 || index1 == 231 || (index1 == 243 || index1 == 247)) || (index1 == 283 || index1 >= 300 && index1 <= 308 || (index1 == 354 || index1 == 355 || index1 == 491)))
                            {
                              WorldGen.Place3x3(i, j, (ushort) index1, style);
                              WorldGen.SquareTileFrame(i, j, true);
                              break;
                            }
                            if (index1 == 13 || index1 == 33 || (index1 == 49 || index1 == 50) || (index1 == 78 || index1 == 174 || index1 == 372))
                            {
                              WorldGen.PlaceOnTable1x1(i, j, index1, style);
                              WorldGen.SquareTileFrame(i, j, true);
                              break;
                            }
                            if (index1 == 14 || index1 == 469 || (index1 == 26 || index1 == 86) || (index1 == 87 || index1 == 88 || (index1 == 89 || index1 == 114)) || (index1 == 186 || index1 == 187 || (index1 == 215 || index1 == 217) || (index1 == 218 || index1 == 377)))
                            {
                              WorldGen.Place3x2(i, j, (ushort) index1, style);
                              WorldGen.SquareTileFrame(i, j, true);
                              break;
                            }
                            switch (index1)
                            {
                              case 20:
                                if (Main.tile[i, j + 1] == null)
                                  Main.tile[i, j + 1] = new Tile();
                                int type = (int) Main.tile[i, j + 1].type;
                                if (Main.tile[i, j + 1].active() && (type == 2 || type == 109 || (type == 147 || type == 60) || (type == 23 || type == 199 || (type == 53 || type == 234)) || (type == 116 || type == 112)))
                                {
                                  WorldGen.Place1x2(i, j, (ushort) index1, style);
                                  WorldGen.SquareTileFrame(i, j, true);
                                  break;
                                }
                                break;
                              case 236:
                                WorldGen.PlaceJunglePlant(i, j, (ushort) index1, WorldGen.genRand.Next(3), 0);
                                WorldGen.SquareTileFrame(i, j, true);
                                break;
                              case 238:
                                WorldGen.PlaceJunglePlant(i, j, (ushort) index1, 0, 0);
                                WorldGen.SquareTileFrame(i, j, true);
                                break;
                              default:
                                if (index1 == 15 || index1 == 216 || (index1 == 338 || index1 == 390))
                                {
                                  if (Main.tile[i, j - 1] == null)
                                    Main.tile[i, j - 1] = new Tile();
                                  if (Main.tile[i, j] == null)
                                    Main.tile[i, j] = new Tile();
                                  WorldGen.Place1x2(i, j, (ushort) index1, style);
                                  WorldGen.SquareTileFrame(i, j, true);
                                  break;
                                }
                                switch (index1)
                                {
                                  case 227:
                                    WorldGen.PlaceDye(i, j, style);
                                    WorldGen.SquareTileFrame(i, j, true);
                                    break;
                                  case 567:
                                    WorldGen.PlaceGnome(i, j, style);
                                    WorldGen.SquareTileFrame(i, j, true);
                                    break;
                                  default:
                                    if (index1 == 16 || index1 == 18 || (index1 == 29 || index1 == 103) || (index1 == 134 || index1 == 462))
                                    {
                                      WorldGen.Place2x1(i, j, (ushort) index1, style);
                                      WorldGen.SquareTileFrame(i, j, true);
                                      break;
                                    }
                                    if (index1 == 92 || index1 == 93 || index1 == 453)
                                    {
                                      WorldGen.Place1xX(i, j, (ushort) index1, style);
                                      WorldGen.SquareTileFrame(i, j, true);
                                      break;
                                    }
                                    if (index1 == 104 || index1 == 105 || (index1 == 320 || index1 == 337) || (index1 == 349 || index1 == 356 || (index1 == 378 || index1 == 456)) || (index1 == 506 || index1 == 545))
                                    {
                                      WorldGen.Place2xX(i, j, (ushort) index1, style);
                                      WorldGen.SquareTileFrame(i, j, true);
                                      break;
                                    }
                                    if (index1 == 17 || index1 == 77 || index1 == 133)
                                    {
                                      WorldGen.Place3x2(i, j, (ushort) index1, style);
                                      WorldGen.SquareTileFrame(i, j, true);
                                      break;
                                    }
                                    if (index1 == 207)
                                    {
                                      WorldGen.Place2xX(i, j, (ushort) index1, style);
                                      WorldGen.SquareTileFrame(i, j, true);
                                      break;
                                    }
                                    if (index1 == 410 || index1 == 480 || index1 == 509)
                                    {
                                      WorldGen.Place2xX(i, j, (ushort) index1, style);
                                      WorldGen.SquareTileFrame(i, j, true);
                                      break;
                                    }
                                    if (index1 == 465 || index1 == 531 || (index1 == 591 || index1 == 592))
                                    {
                                      WorldGen.Place2xX(i, j, (ushort) index1, style);
                                      WorldGen.SquareTileFrame(i, j, true);
                                      break;
                                    }
                                    if (TileID.Sets.BasicChest[index1])
                                    {
                                      WorldGen.PlaceChest(i, j, (ushort) index1, false, style);
                                      WorldGen.SquareTileFrame(i, j, true);
                                      break;
                                    }
                                    switch (index1)
                                    {
                                      case 27:
                                        WorldGen.PlaceSunflower(i, j, (ushort) 27);
                                        WorldGen.SquareTileFrame(i, j, true);
                                        break;
                                      case 28:
                                        WorldGen.PlacePot(i, j, (ushort) 28, WorldGen.genRand.Next(4));
                                        WorldGen.SquareTileFrame(i, j, true);
                                        break;
                                      case 36:
                                      case 135:
                                      case 141:
                                      case 144:
                                      case 210:
                                      case 239:
                                      case 324:
                                      case 476:
                                      case 494:
                                        WorldGen.Place1x1(i, j, index1, style);
                                        WorldGen.SquareTileFrame(i, j, true);
                                        break;
                                      case 42:
                                      case 270:
                                      case 271:
                                        WorldGen.Place1x2Top(i, j, (ushort) index1, style);
                                        WorldGen.SquareTileFrame(i, j, true);
                                        break;
                                      case 55:
                                      case 425:
                                      case 510:
                                      case 511:
                                        WorldGen.PlaceSign(i, j, (ushort) index1, style);
                                        break;
                                      case 85:
                                      case 376:
                                        WorldGen.Place2x2Horizontal(i, j, (ushort) index1, style);
                                        break;
                                      case 91:
                                        WorldGen.PlaceBanner(i, j, (ushort) index1, style);
                                        WorldGen.SquareTileFrame(i, j, true);
                                        break;
                                      case 101:
                                      case 102:
                                      case 463:
                                        WorldGen.Place3x4(i, j, (ushort) index1, style);
                                        WorldGen.SquareTileFrame(i, j, true);
                                        break;
                                      case 419:
                                      case 420:
                                      case 423:
                                      case 424:
                                      case 429:
                                      case 445:
                                        WorldGen.PlaceLogicTiles(i, j, index1, style);
                                        WorldGen.SquareTileFrame(i, j, true);
                                        break;
                                      case 464:
                                      case 466:
                                        WorldGen.Place5x4(i, j, (ushort) index1, style);
                                        WorldGen.SquareTileFrame(i, j, true);
                                        break;
                                      default:
                                        if (Main.tileAlch[index1])
                                        {
                                          WorldGen.PlaceAlch(i, j, style);
                                          break;
                                        }
                                        switch (index1)
                                        {
                                          case 19:
                                            trackCache.frameY = (short) (18 * style);
                                            trackCache.active(true);
                                            trackCache.type = (ushort) index1;
                                            break;
                                          case 79:
                                          case 90:
                                            int direction = 1;
                                            if (plr > -1)
                                              direction = Main.player[plr].direction;
                                            WorldGen.Place4x2(i, j, (ushort) index1, direction, style);
                                            break;
                                          case 81:
                                            trackCache.frameX = (short) (26 * WorldGen.genRand.Next(6));
                                            trackCache.active(true);
                                            trackCache.type = (ushort) index1;
                                            break;
                                          case 94:
                                          case 95:
                                          case 97:
                                          case 98:
                                          case 99:
                                          case 100:
                                          case 125:
                                          case 126:
                                          case 172:
                                          case 173:
                                          case 287:
                                            WorldGen.Place2x2(i, j, (ushort) index1, style);
                                            break;
                                          case 96:
                                            WorldGen.Place2x2Style(i, j, (ushort) index1, style);
                                            break;
                                          case 209:
                                            WorldGen.PlaceCannon(i, j, (ushort) index1, style);
                                            break;
                                          case 314:
                                            Minecart.PlaceTrack(trackCache, style);
                                            break;
                                          case 380:
                                            trackCache.frameY = (short) (18 * style);
                                            trackCache.active(true);
                                            trackCache.type = (ushort) index1;
                                            break;
                                          default:
                                            trackCache.active(true);
                                            trackCache.type = (ushort) index1;
                                            break;
                                        }
                                        break;
                                    }
                                    break;
                                }
                                break;
                            }
                            break;
                        }
                        break;
                    }
                    break;
                }
                break;
            }
          }
          if (trackCache.active())
          {
            if (TileID.Sets.BlocksWaterDrawingBehindSelf[(int) trackCache.type])
              WorldGen.SquareWallFrame(i, j, true);
            WorldGen.SquareTileFrame(i, j, true);
            flag = true;
            if (!mute)
            {
              switch (index1)
              {
                case (int) sbyte.MaxValue:
                  SoundEngine.PlaySound(SoundID.Item30, i * 16, j * 16);
                  break;
                case 314:
                  SoundEngine.PlaySound(SoundID.Item52, i * 16, j * 16);
                  break;
                case 330:
                case 331:
                case 332:
                case 333:
                  SoundEngine.PlaySound(18, i * 16, j * 16, 1, 1f, 0.0f);
                  break;
                default:
                  SoundEngine.PlaySound(0, i * 16, j * 16, 1, 1f, 0.0f);
                  break;
              }
              if (index1 == 22 || index1 == 140)
              {
                for (int index2 = 0; index2 < 3; ++index2)
                  Dust.NewDust(new Vector2((float) (i * 16), (float) (j * 16)), 16, 16, 14, 0.0f, 0.0f, 0, new Color(), 1f);
              }
            }
          }
        }
      }
      return flag;
    }

    public static void KillWall(int i, int j, bool fail = false)
    {
      if (i < 0 || j < 0 || (i >= Main.maxTilesX || j >= Main.maxTilesY))
        return;
      Tile tileCache = Main.tile[i, j];
      if (tileCache == null)
      {
        tileCache = new Tile();
        Main.tile[i, j] = tileCache;
      }
      if (tileCache.wall <= (ushort) 0)
        return;
      fail = WorldGen.KillWall_CheckFailure(fail, tileCache);
      WorldGen.KillWall_PlaySounds(i, j, tileCache);
      int num = 10;
      if (fail)
        num = 3;
      for (int index = 0; index < num; ++index)
        WorldGen.KillWall_MakeWallDust(i, j, tileCache);
      if (fail)
      {
        WorldGen.SquareWallFrame(i, j, true);
      }
      else
      {
        WorldGen.KillWall_DropItems(i, j, tileCache);
        tileCache.wall = (ushort) 0;
        tileCache.wallColor((byte) 0);
        WorldGen.SquareWallFrame(i, j, true);
        if (tileCache.type < (ushort) 0 || tileCache.type >= (ushort) 623 || !TileID.Sets.FramesOnKillWall[(int) tileCache.type])
          return;
        WorldGen.TileFrame(i, j, false, false);
      }
    }

    private static bool KillWall_CheckFailure(bool fail, Tile tileCache)
    {
      if (Main.wallDungeon[(int) tileCache.wall] && !NPC.downedBoss3)
        fail = true;
      if (tileCache.wall == (ushort) 87 && !NPC.downedGolemBoss)
        fail = true;
      return fail;
    }

    private static void KillWall_PlaySounds(int i, int j, Tile tileCache)
    {
      if (tileCache.wall == (ushort) 241 || tileCache.wall >= (ushort) 88 && tileCache.wall <= (ushort) 93 || (tileCache.wall == (ushort) 21 || tileCache.wall == (ushort) 186 || (tileCache.wall == (ushort) 136 || tileCache.wall == (ushort) 137)) || (tileCache.wall == (ushort) 168 || tileCache.wall == (ushort) 169 || (tileCache.wall == (ushort) 172 || tileCache.wall == (ushort) 226) || (tileCache.wall == (ushort) 227 || tileCache.wall == (ushort) 242 || tileCache.wall == (ushort) 243)))
        SoundEngine.PlaySound(13, i * 16, j * 16, 1, 1f, 0.0f);
      else if (tileCache.wall >= (ushort) 63 && tileCache.wall <= (ushort) 70 || (tileCache.wall == (ushort) 264 || tileCache.wall == (ushort) 268) || tileCache.wall == (ushort) 265)
        SoundEngine.PlaySound(6, i * 16, j * 16, 1, 1f, 0.0f);
      else
        SoundEngine.PlaySound(0, i * 16, j * 16, 1, 1f, 0.0f);
    }

    private static void KillWall_DropItems(int i, int j, Tile tileCache)
    {
      int itemDrops = WorldGen.KillWall_GetItemDrops(tileCache);
      if (itemDrops <= 0)
        return;
      Item.NewItem(i * 16, j * 16, 16, 16, itemDrops, 1, false, 0, false, false);
    }

    private static int KillWall_GetItemDrops(Tile tileCache)
    {
      switch (tileCache.wall)
      {
        case 237:
          return 4233;
        case 238:
          return 4234;
        case 239:
          return 4235;
        case 240:
          return 4236;
        case 246:
          return 4486;
        case 247:
          return 4487;
        case 248:
          return 4488;
        case 249:
          return 4489;
        case 250:
          return 4490;
        case 251:
          return 4491;
        case 252:
          return 4492;
        case 253:
          return 4493;
        case 254:
          return 4494;
        case (ushort) byte.MaxValue:
          return 4495;
        case 256:
          return 4496;
        case 257:
          return 4497;
        case 258:
          return 4498;
        case 259:
          return 4499;
        case 260:
          return 4500;
        case 261:
          return 4501;
        case 262:
          return 4502;
        case 263:
          return 4503;
        case 264:
          return 4504;
        case 265:
          return 4505;
        case 266:
          return 4506;
        case 267:
          return 4507;
        case 268:
          return 4508;
        case 269:
          return 4509;
        case 270:
          return 4510;
        case 271:
          return 4511;
        case 274:
          return 4512;
        case 275:
          return 3273;
        case 276:
          return 4513;
        case 277:
          return 4514;
        case 278:
          return 4515;
        case 279:
          return 4516;
        case 280:
          return 4517;
        case 281:
          return 4518;
        case 282:
          return 4519;
        case 283:
          return 4520;
        case 284:
          return 4521;
        case 285:
          return 4522;
        case 286:
          return 4523;
        case 287:
          return 4524;
        case 288:
          return 4525;
        case 289:
          return 4526;
        case 290:
          return 4527;
        case 291:
          return 4528;
        case 292:
          return 4529;
        case 293:
          return 4530;
        case 294:
          return 4531;
        case 295:
          return 4532;
        case 296:
          return 4533;
        case 297:
          return 4534;
        case 298:
          return 4535;
        case 299:
          return 4536;
        case 300:
          return 4537;
        case 301:
          return 4538;
        case 302:
          return 4539;
        case 303:
          return 4540;
        case 304:
          return 3340;
        case 305:
          return 3341;
        case 306:
          return 3342;
        case 307:
          return 3343;
        case 308:
          return 3344;
        case 309:
          return 3345;
        case 310:
          return 3346;
        case 311:
          return 3348;
        case 314:
          return 4647;
        default:
          int num = 0;
          if (tileCache.wall == (ushort) 168)
            num = 2696;
          if (tileCache.wall == (ushort) 169)
            num = 2698;
          if (tileCache.wall == (ushort) 226)
            num = 3752;
          if (tileCache.wall == (ushort) 227)
            num = 3753;
          if (tileCache.wall == (ushort) 228)
            num = 3760;
          if (tileCache.wall == (ushort) 229)
            num = 3761;
          if (tileCache.wall == (ushort) 230)
            num = 3762;
          if (tileCache.wall == (ushort) 142)
            num = 2263;
          if (tileCache.wall == (ushort) 143)
            num = 2264;
          if (tileCache.wall == (ushort) 144)
            num = 2271;
          if (tileCache.wall == (ushort) 149)
            num = 2505;
          if (tileCache.wall == (ushort) 150)
            num = 2507;
          if (tileCache.wall == (ushort) 151)
            num = 2506;
          if (tileCache.wall == (ushort) 152)
            num = 2508;
          if (tileCache.wall == (ushort) 245)
            num = 4424;
          if (tileCache.wall == (ushort) 315)
            num = 4667;
          if (tileCache.wall == (ushort) 1)
            num = 26;
          if (tileCache.wall == (ushort) 4)
            num = 93;
          if (tileCache.wall == (ushort) 5)
            num = 130;
          if (tileCache.wall == (ushort) 6)
            num = 132;
          if (tileCache.wall == (ushort) 7)
            num = 135;
          if (tileCache.wall == (ushort) 8)
            num = 138;
          if (tileCache.wall == (ushort) 9)
            num = 140;
          if (tileCache.wall == (ushort) 10)
            num = 142;
          if (tileCache.wall == (ushort) 11)
            num = 144;
          if (tileCache.wall == (ushort) 12)
            num = 146;
          if (tileCache.wall == (ushort) 14)
            num = 330;
          if (tileCache.wall == (ushort) 224)
            num = 3472;
          if (tileCache.wall == (ushort) 177)
            num = 3067;
          if (tileCache.wall == (ushort) 167)
            num = 2691;
          if (tileCache.wall == (ushort) 60)
            num = 3584;
          if (tileCache.wall == (ushort) 231)
            num = 3952;
          if (tileCache.wall == (ushort) 232)
            num = 3954;
          if (tileCache.wall == (ushort) 225)
            num = 3751;
          if (tileCache.wall == (ushort) 233)
            num = 3956;
          if (tileCache.wall == (ushort) 234)
            num = 4052;
          if (tileCache.wall == (ushort) 235)
            num = 4053;
          if (tileCache.wall == (ushort) 236)
            num = 4140;
          if (tileCache.wall == (ushort) 312)
            num = 4565;
          if (tileCache.wall == (ushort) 313)
            num = 4548;
          if (tileCache.wall == (ushort) 179)
            num = 3083;
          if (tileCache.wall == (ushort) 183)
            num = 3082;
          if (tileCache.wall == (ushort) 181)
            num = 3089;
          if (tileCache.wall == (ushort) 184)
            num = 3088;
          if (tileCache.wall == (ushort) 186)
            num = 3238;
          if (tileCache.wall >= (ushort) 153 && tileCache.wall <= (ushort) 166)
          {
            switch (tileCache.wall)
            {
              case 153:
                num = 2677;
                break;
              case 154:
                num = 2679;
                break;
              case 155:
                num = 2681;
                break;
              case 156:
                num = 2683;
                break;
              case 157:
                num = 2678;
                break;
              case 158:
                num = 2680;
                break;
              case 159:
                num = 2682;
                break;
              case 160:
                num = 2684;
                break;
              case 161:
                num = 2686;
                break;
              case 162:
                num = 2688;
                break;
              case 163:
                num = 2690;
                break;
              case 164:
                num = 2685;
                break;
              case 165:
                num = 2687;
                break;
              case 166:
                num = 2689;
                break;
            }
          }
          if (tileCache.wall == (ushort) 136)
            num = 2169;
          if (tileCache.wall == (ushort) 137)
            num = 2170;
          if (tileCache.wall == (ushort) 172)
            num = 2788;
          if (tileCache.wall == (ushort) 242)
            num = 4279;
          if (tileCache.wall == (ushort) 243)
            num = 4280;
          if (tileCache.wall == (ushort) 145)
            num = 2333;
          if (tileCache.wall == (ushort) 16)
            num = 30;
          if (tileCache.wall == (ushort) 17)
            num = 135;
          if (tileCache.wall == (ushort) 18)
            num = 138;
          if (tileCache.wall == (ushort) 19)
            num = 140;
          if (tileCache.wall == (ushort) 20)
            num = 330;
          if (tileCache.wall == (ushort) 21)
            num = 392;
          if (tileCache.wall == (ushort) 86 || tileCache.wall == (ushort) 108)
            num = 1126;
          if (tileCache.wall == (ushort) 173)
            num = 2789;
          if (tileCache.wall == (ushort) 174)
            num = 2790;
          if (tileCache.wall == (ushort) 175)
            num = 2791;
          if (tileCache.wall == (ushort) 176)
            num = 2861;
          if (tileCache.wall == (ushort) 182)
            num = 3101;
          if (tileCache.wall == (ushort) 133)
            num = 2158;
          if (tileCache.wall == (ushort) 134)
            num = 2159;
          if (tileCache.wall == (ushort) 135)
            num = 2160;
          else if (tileCache.wall == (ushort) 113)
            num = 1726;
          else if (tileCache.wall == (ushort) 114)
            num = 1728;
          else if (tileCache.wall == (ushort) 115)
            num = 1730;
          else if (tileCache.wall == (ushort) 146)
            num = 2432;
          else if (tileCache.wall == (ushort) 147)
            num = 2433;
          else if (tileCache.wall == (ushort) 148)
            num = 2434;
          if (tileCache.wall >= (ushort) 116 && tileCache.wall <= (ushort) 125)
            num = 1948 + (int) tileCache.wall - 116;
          if (tileCache.wall >= (ushort) 126 && tileCache.wall <= (ushort) 132)
            num = 2008 + (int) tileCache.wall - 126;
          if (tileCache.wall == (ushort) 22)
            num = 417;
          if (tileCache.wall == (ushort) 23)
            num = 418;
          if (tileCache.wall == (ushort) 24)
            num = 419;
          if (tileCache.wall == (ushort) 25)
            num = 420;
          if (tileCache.wall == (ushort) 26)
            num = 421;
          if (tileCache.wall == (ushort) 29)
            num = 587;
          if (tileCache.wall == (ushort) 30)
            num = 592;
          if (tileCache.wall == (ushort) 31)
            num = 595;
          if (tileCache.wall == (ushort) 32)
            num = 605;
          if (tileCache.wall == (ushort) 33)
            num = 606;
          if (tileCache.wall == (ushort) 34)
            num = 608;
          if (tileCache.wall == (ushort) 35)
            num = 610;
          if (tileCache.wall == (ushort) 36)
            num = 615;
          if (tileCache.wall == (ushort) 37)
            num = 616;
          if (tileCache.wall == (ushort) 38)
            num = 617;
          if (tileCache.wall == (ushort) 39)
            num = 618;
          if (tileCache.wall == (ushort) 41)
            num = 622;
          if (tileCache.wall == (ushort) 42)
            num = 623;
          if (tileCache.wall == (ushort) 43)
            num = 624;
          if (tileCache.wall == (ushort) 44)
            num = 663;
          if (tileCache.wall == (ushort) 45)
            num = 720;
          if (tileCache.wall == (ushort) 46)
            num = 721;
          if (tileCache.wall == (ushort) 47)
            num = 722;
          if (tileCache.wall == (ushort) 66)
            num = 745;
          if (tileCache.wall == (ushort) 67)
            num = 746;
          if (tileCache.wall == (ushort) 68)
            num = 747;
          if (tileCache.wall == (ushort) 84)
            num = 884;
          if (tileCache.wall == (ushort) 72)
            num = 750;
          if (tileCache.wall == (ushort) 73)
            num = 752;
          if (tileCache.wall == (ushort) 74)
            num = 764;
          if (tileCache.wall == (ushort) 85)
            num = 927;
          if (tileCache.wall == (ushort) 75)
            num = 768;
          if (tileCache.wall == (ushort) 76)
            num = 769;
          if (tileCache.wall == (ushort) 77)
            num = 770;
          if (tileCache.wall == (ushort) 82)
            num = 825;
          if (tileCache.wall == (ushort) 27)
            num = 479;
          if (tileCache.wall == (ushort) 106)
            num = 1447;
          if (tileCache.wall == (ushort) 107)
            num = 1448;
          if (tileCache.wall == (ushort) 109)
            num = 1590;
          if (tileCache.wall == (ushort) 110)
            num = 1592;
          if (tileCache.wall == (ushort) 111)
            num = 1594;
          if (tileCache.wall == (ushort) 78)
            num = 1723;
          if (tileCache.wall == (ushort) 87 || tileCache.wall == (ushort) 112)
            num = 1102;
          if (tileCache.wall == (ushort) 94 || tileCache.wall == (ushort) 100)
            num = 1378;
          if (tileCache.wall == (ushort) 95 || tileCache.wall == (ushort) 101)
            num = 1379;
          if (tileCache.wall == (ushort) 96 || tileCache.wall == (ushort) 102)
            num = 1380;
          if (tileCache.wall == (ushort) 97 || tileCache.wall == (ushort) 103)
            num = 1381;
          if (tileCache.wall == (ushort) 98 || tileCache.wall == (ushort) 104)
            num = 1382;
          if (tileCache.wall == (ushort) 99 || tileCache.wall == (ushort) 105)
            num = 1383;
          if (tileCache.wall == (ushort) 241)
            num = 4260;
          if (tileCache.wall >= (ushort) 88 && tileCache.wall <= (ushort) 93)
            num = 1267 + (int) tileCache.wall - 88;
          if (tileCache.wall >= (ushort) 138 && tileCache.wall <= (ushort) 141)
            num = 2210 + (int) tileCache.wall - 138;
          return num;
      }
    }

    private static void KillWall_MakeWallDust(int i, int j, Tile tileCache)
    {
      int Type = 0;
      switch (tileCache.wall)
      {
        case 3:
        case 246:
          Type = WorldGen.genRand.Next(2) != 0 ? 1 : 14;
          break;
        case 7:
        case 17:
        case 94:
        case 95:
        case 100:
        case 101:
          Type = 275;
          break;
        case 8:
        case 18:
        case 98:
        case 99:
        case 104:
        case 105:
          Type = 276;
          break;
        case 9:
        case 19:
        case 96:
        case 97:
        case 102:
        case 103:
          Type = 277;
          break;
        case 15:
        case 247:
          Type = 38;
          break;
        case 22:
        case 28:
        case 248:
          Type = 51;
          break;
        case 40:
        case 249:
          Type = 51;
          break;
        case 48:
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
        case 58:
        case 185:
        case 250:
        case 251:
        case 252:
        case 253:
        case 254:
        case (ushort) byte.MaxValue:
        case 256:
        case 257:
        case 258:
        case 259:
        case 260:
        case 274:
        case 314:
          Type = 1;
          break;
        case 59:
        case 61:
        case 261:
        case 262:
          Type = 0;
          break;
        case 62:
        case 263:
          Type = 0;
          break;
        case 69:
        case 264:
          Type = WorldGen.genRand.Next(2) != 0 ? 17 : 14;
          break;
        case 70:
        case 265:
          Type = 47;
          break;
        case 71:
        case 266:
          Type = 80;
          break;
        case 79:
        case 267:
          Type = 37;
          break;
        case 81:
        case 268:
          Type = 123;
          break;
        case 83:
        case 234:
        case 269:
          Type = WorldGen.genRand.Next(2) != 0 ? 117 : 1;
          break;
        case 170:
        case 171:
        case 270:
        case 271:
          Type = 0;
          break;
        case 187:
        case 275:
          Type = 0;
          break;
        case 188:
        case 189:
        case 190:
        case 191:
        case 276:
        case 277:
        case 278:
        case 279:
          Type = 37;
          break;
        case 192:
        case 193:
        case 194:
        case 195:
        case 280:
        case 281:
        case 282:
        case 283:
          Type = 117;
          break;
        case 196:
        case 197:
        case 198:
        case 199:
        case 284:
        case 285:
        case 286:
        case 287:
          Type = 0;
          break;
        case 200:
        case 202:
        case 288:
        case 290:
          Type = WorldGen.genRand.Next(2) != 0 ? 70 : 69;
          break;
        case 201:
        case 289:
          Type = 17;
          break;
        case 203:
        case 291:
          Type = WorldGen.genRand.Next(2) != 0 ? 68 : 69;
          break;
        case 204:
        case 205:
        case 207:
        case 292:
        case 293:
        case 295:
          Type = 0;
          break;
        case 206:
        case 294:
          Type = 1;
          break;
        case 208:
        case 209:
        case 210:
        case 211:
        case 296:
        case 297:
        case 298:
        case 299:
          Type = WorldGen.genRand.Next(2) != 0 ? 125 : 155;
          break;
        case 212:
        case 213:
        case 214:
        case 215:
        case 300:
        case 301:
        case 302:
        case 303:
          Type = 1;
          break;
        case 216:
        case 304:
          Type = 0;
          break;
        case 217:
        case 305:
          Type = 37;
          break;
        case 218:
        case 306:
          Type = 155;
          break;
        case 219:
        case 307:
          Type = 17;
          break;
        case 220:
        case 308:
          Type = 37;
          break;
        case 221:
        case 309:
          Type = 155;
          break;
        case 222:
        case 310:
          Type = 37;
          break;
        case 223:
        case 311:
          Type = 0;
          break;
        case 231:
          Type = 8;
          break;
        case 232:
          Type = 82;
          break;
        case 233:
          Type = 18;
          break;
        case 237:
          Type = 6;
          break;
        case 238:
          Type = 61;
          break;
        case 239:
          Type = 242;
          break;
        case 240:
          Type = 135;
          break;
        case 312:
        case 313:
        case 315:
          Type = -1;
          break;
      }
      if (tileCache.wall == (ushort) 148)
        Type = -1;
      if (tileCache.wall == (ushort) 1 || tileCache.wall == (ushort) 5 || (tileCache.wall == (ushort) 6 || tileCache.wall == (ushort) 107))
        Type = 1;
      if (tileCache.wall == (ushort) 35)
        Type = 37;
      if (tileCache.wall == (ushort) 4 || tileCache.wall == (ushort) 106)
        Type = 7;
      if (tileCache.wall == (ushort) 12)
        Type = 9;
      if (tileCache.wall == (ushort) 10)
        Type = 10;
      if (tileCache.wall == (ushort) 11)
        Type = 11;
      if (tileCache.wall == (ushort) 21)
        Type = 13;
      if (tileCache.wall == (ushort) 34)
        Type = 32;
      if (tileCache.wall == (ushort) 225)
        Type = 1;
      if (tileCache.wall == (ushort) 145)
        Type = 8;
      if (tileCache.wall == (ushort) 23)
        Type = 38;
      if (tileCache.wall == (ushort) 24)
        Type = 36;
      if (tileCache.wall == (ushort) 25)
        Type = 48;
      if (tileCache.wall == (ushort) 179 || tileCache.wall == (ushort) 178 || tileCache.wall == (ushort) 183)
        Type = 236;
      if (tileCache.wall == (ushort) 181 || tileCache.wall == (ushort) 180 || tileCache.wall == (ushort) 184)
        Type = 240;
      if (tileCache.wall == (ushort) 113)
        Type = 189;
      if (tileCache.wall == (ushort) 114)
        Type = 190;
      if (tileCache.wall == (ushort) 115)
        Type = 191;
      if (tileCache.wall == (ushort) 177 || tileCache.wall == (ushort) 13)
        Type = 25;
      if (tileCache.wall == (ushort) 186)
        Type = WorldGen.genRand.Next(68, 71);
      if (tileCache.wall == (ushort) 142)
        Type = 210;
      if (tileCache.wall == (ushort) 143)
        Type = 210;
      if (tileCache.wall == (ushort) 224)
        Type = 265;
      if (tileCache.wall == (ushort) 173)
        Type = 128;
      if (tileCache.wall == (ushort) 174)
        Type = 117;
      if (tileCache.wall == (ushort) 175)
        Type = 42;
      if (tileCache.wall == (ushort) 176)
        Type = 226;
      if (tileCache.wall == (ushort) 182)
        Type = WorldGen.genRand.Next(2) != 0 ? 23 : 6;
      if (tileCache.wall >= (ushort) 153 && tileCache.wall <= (ushort) 166)
      {
        switch (tileCache.wall)
        {
          case 153:
          case 157:
            Type = 138;
            break;
          case 154:
          case 158:
            Type = 86;
            break;
          case 155:
          case 159:
            Type = 91;
            break;
          case 156:
          case 160:
            Type = 89;
            break;
          case 161:
          case 164:
            Type = 90;
            break;
          case 162:
          case 165:
            Type = 88;
            break;
          case 163:
          case 166:
            Type = 87;
            break;
        }
      }
      if (tileCache.wall == (ushort) 26 || tileCache.wall == (ushort) 30)
        Type = 49;
      if (tileCache.wall == (ushort) 29 || tileCache.wall == (ushort) 32)
        Type = 50;
      if (tileCache.wall == (ushort) 31)
        Type = 51;
      if (tileCache.wall == (ushort) 14 || tileCache.wall == (ushort) 20)
        Type = 109;
      if (tileCache.wall == (ushort) 241)
        Type = 286;
      if (tileCache.wall >= (ushort) 88 && tileCache.wall <= (ushort) 93)
      {
        Type = 86 + (int) tileCache.wall - 88;
        if (tileCache.wall == (ushort) 93)
          Type = WorldGen.genRand.Next(88, 94);
      }
      if (tileCache.wall == (ushort) 33)
        Type = 14;
      if (tileCache.wall == (ushort) 41)
        Type = 77;
      if (tileCache.wall == (ushort) 42)
        Type = 78;
      if (tileCache.wall == (ushort) 43)
        Type = 78;
      if (tileCache.wall == (ushort) 36)
        Type = 26;
      if (tileCache.wall == (ushort) 37)
        Type = 32;
      if (tileCache.wall == (ushort) 38)
        Type = 2;
      if (tileCache.wall == (ushort) 39)
        Type = 1;
      if (tileCache.wall == (ushort) 45)
        Type = 81;
      if (tileCache.wall == (ushort) 46)
        Type = 83;
      if (tileCache.wall == (ushort) 47)
        Type = 84;
      if (tileCache.wall == (ushort) 85)
        Type = 126;
      if (tileCache.wall == (ushort) 63)
        Type = 3;
      if (tileCache.wall == (ushort) 65)
        Type = 3;
      if (tileCache.wall == (ushort) 66)
        Type = 3;
      if (tileCache.wall == (ushort) 68)
        Type = 3;
      if (tileCache.wall == (ushort) 64)
        Type = 40;
      if (tileCache.wall == (ushort) 67)
        Type = 40;
      if (tileCache.wall == (ushort) 84)
        Type = 80;
      if (tileCache.wall == (ushort) 60)
        Type = 3;
      if (tileCache.wall == (ushort) 167)
        Type = 81;
      if (tileCache.wall == (ushort) 147)
        Type = 51;
      if (tileCache.wall == (ushort) 146)
        Type = 9;
      if (tileCache.wall == (ushort) 109)
        Type = 144;
      if (tileCache.wall == (ushort) 110)
        Type = 145;
      if (tileCache.wall == (ushort) 111)
        Type = 146;
      if (tileCache.wall == (ushort) 86 || tileCache.wall == (ushort) 108)
        Type = 147;
      if (tileCache.wall == (ushort) 87)
        Type = 148;
      if (tileCache.wall == (ushort) 136)
        Type = 13;
      if (tileCache.wall == (ushort) 137)
        Type = 13;
      if (tileCache.wall == (ushort) 168)
        Type = 13;
      if (tileCache.wall == (ushort) 169)
        Type = 13;
      if (tileCache.wall == (ushort) 172)
        Type = 13;
      if (tileCache.wall == (ushort) 226)
        Type = 13;
      if (tileCache.wall == (ushort) 227)
        Type = 13;
      if (tileCache.wall == (ushort) 242)
        Type = 13;
      if (tileCache.wall == (ushort) 243)
        Type = 13;
      if (tileCache.wall == (ushort) 72)
        Type = 40;
      if (tileCache.wall == (ushort) 73)
        Type = 16;
      if (tileCache.wall == (ushort) 74 || tileCache.wall == (ushort) 80)
        Type = 26;
      if (tileCache.wall == (ushort) 144)
        Type = WorldGen.genRand.Next(2) != 0 ? 118 : 10;
      if (tileCache.wall == (ushort) 75)
        Type = 26;
      if (tileCache.wall == (ushort) 76)
        Type = 4;
      if (tileCache.wall == (ushort) 77 || tileCache.wall == (ushort) 81)
        Type = 5;
      if (tileCache.wall == (ushort) 78 || tileCache.wall == (ushort) 244)
        Type = 7;
      if (tileCache.wall == (ushort) 82)
        Type = 36;
      if (tileCache.wall == (ushort) 27)
        Type = WorldGen.genRand.Next(2) != 0 ? 1 : 7;
      if (tileCache.wall == (ushort) 138)
        Type = 77;
      if (tileCache.wall == (ushort) 139)
        Type = 78;
      if (tileCache.wall == (ushort) 140)
        Type = 79;
      if (tileCache.wall == (ushort) 141)
        Type = 126;
      if (tileCache.wall == (ushort) 149 || tileCache.wall == (ushort) 150)
        Type = 214;
      if (tileCache.wall == (ushort) 151 || tileCache.wall == (ushort) 152)
        Type = 215;
      if (tileCache.wall == (ushort) 245)
        Type = 195;
      if (tileCache.wall == (ushort) 44)
      {
        int index = Dust.NewDust(new Vector2((float) (i * 16), (float) (j * 16)), 16, 16, 66, 0.0f, 0.0f, 100, new Color(Main.DiscoR, Main.DiscoG, Main.DiscoB), 0.75f);
        Main.dust[index].noGravity = true;
      }
      else
      {
        if (tileCache.wall >= (ushort) 133 && tileCache.wall <= (ushort) 135 || tileCache.wall >= (ushort) 116 && tileCache.wall <= (ushort) 125 || tileCache.wall >= (ushort) 126 && tileCache.wall <= (ushort) 132)
          return;
        if (tileCache.wall == (ushort) 76)
        {
          Dust.NewDust(new Vector2((float) (i * 16), (float) (j * 16)), 16, 16, Type, 0.0f, 0.0f, 75, new Color(0, 80, (int) byte.MaxValue, 100), 0.75f);
        }
        else
        {
          if (Type < 0)
            return;
          Dust.NewDust(new Vector2((float) (i * 16), (float) (j * 16)), 16, 16, Type, 0.0f, 0.0f, 0, new Color(), 1f);
        }
      }
    }

    public static void LaunchRocket(int x, int y)
    {
      int frameY = (int) Main.tile[x, y].frameY;
      int num1 = 0;
      while (frameY >= 40)
      {
        frameY -= 40;
        ++num1;
      }
      if (frameY == 18)
        --y;
      Vector2 vector2 = new Vector2((float) (x * 16 + 8), (float) (y * 16 + 4));
      int Type = 167 + num1;
      int Damage = 150;
      int num2 = 7;
      int index = Projectile.NewProjectile(vector2.X, vector2.Y + 2f, 0.0f, -8f, Type, Damage, (float) num2, Main.myPlayer, 0.0f, 0.0f);
      Main.projectile[index].originatedFromActivableTile = true;
      Main.tile[x, y].active(false);
      Main.tile[x, y + 1].active(false);
      NetMessage.SendTileSquare(-1, x - 1, y, 3, TileChangeType.None);
    }

    public static void LaunchRocketSmall(int x, int y)
    {
      if (Main.tile[x, y].frameX == (short) 18)
        --x;
      if (Main.tile[x, y].frameY == (short) 18)
        --y;
      Vector2 vector2 = new Vector2((float) (x * 16 + 16), (float) (y * 16));
      int Type = 415 + Main.rand.Next(4);
      int Damage = 0;
      int num = 0;
      int index = Projectile.NewProjectile(vector2.X, vector2.Y + 2f, 0.0f, -8f, Type, Damage, (float) num, Main.myPlayer, 0.0f, 0.0f);
      Main.projectile[index].originatedFromActivableTile = true;
    }

    public static bool CanKillTile(int i, int j, WorldGen.SpecialKillTileContext context)
    {
      if (context == WorldGen.SpecialKillTileContext.MowingTheGrass)
      {
        Tile tile = Main.tile[i, j];
        if (tile == null)
          return false;
        if (tile.type == (ushort) 2 || tile.type == (ushort) 109)
          return true;
      }
      return WorldGen.CanKillTile(i, j);
    }

    public static bool CanKillTile(int i, int j)
    {
      return WorldGen.CanKillTile(i, j, out bool _);
    }

    public static bool CanKillTile(int i, int j, out bool blockDamaged)
    {
      blockDamaged = false;
      if (i < 0 || j < 0 || (i >= Main.maxTilesX || j >= Main.maxTilesY))
        return false;
      Tile t1 = Main.tile[i, j];
      Tile tile = (Tile) null;
      if (t1 == null || !t1.active())
        return false;
      if (j >= 1)
        tile = Main.tile[i, j - 1];
      if (tile != null && tile.active())
      {
        int type = (int) tile.type;
        if (TileID.Sets.IsATreeTrunk[type] && (int) t1.type != type && (tile.frameX != (short) 66 || tile.frameY < (short) 0 || tile.frameY > (short) 44) && ((tile.frameX != (short) 88 || tile.frameY < (short) 66 || tile.frameY > (short) 110) && tile.frameY < (short) 198))
          return false;
        switch (type)
        {
          case 21:
          case 26:
          case 72:
          case 77:
          case 88:
          case 467:
          case 488:
            if ((int) t1.type != type)
              return false;
            break;
          case 80:
            if ((int) t1.type != type)
            {
              switch ((int) tile.frameX / 18)
              {
                case 0:
                case 1:
                case 4:
                case 5:
                  return false;
              }
            }
            else
              break;
            break;
          case 323:
            if ((int) t1.type != type && (tile.frameX == (short) 66 || tile.frameX == (short) 220))
              return false;
            break;
        }
      }
      switch (t1.type)
      {
        case 10:
          if (WorldGen.IsLockedDoor(t1))
          {
            blockDamaged = true;
            return false;
          }
          break;
        case 21:
        case 467:
          if (!Chest.CanDestroyChest(i - (int) t1.frameX / 18 % 2, j - (int) t1.frameY / 18))
            return false;
          break;
        case 88:
          if (!Chest.CanDestroyChest(i - (int) t1.frameX / 18 % 3, j - (int) t1.frameY / 18))
            return false;
          break;
        case 138:
          if (WorldGen.CheckBoulderChest(i, j))
          {
            blockDamaged = true;
            return false;
          }
          break;
        case 235:
          int num = i - (int) t1.frameX % 54 / 18;
          for (int index = 0; index < 3; ++index)
          {
            Tile t2 = Main.tile[num + index, j - 1];
            if (t2.active() && WorldGen.IsAContainer(t2))
            {
              blockDamaged = true;
              return false;
            }
          }
          break;
      }
      return true;
    }

    public static bool IsTileReplacable(int x, int y)
    {
      Tile tile1 = Main.tile[x, y];
      if (y >= 1)
      {
        Tile tile2 = Main.tile[x, y - 1];
        if (tile1 == null || tile2 == null)
          return false;
        if (tile2.active())
        {
          if (tile2.type == (ushort) 80 || tile2.type == (ushort) 488)
            return false;
          if (TileID.Sets.PreventsTileReplaceIfOnTopOfIt[(int) tile2.type] && (int) tile1.type != (int) tile2.type)
            return TileID.Sets.IsATreeTrunk[(int) tile2.type] ? tile2.frameX == (short) 66 && tile2.frameY >= (short) 0 && tile2.frameY <= (short) 44 || tile2.frameX == (short) 88 && tile2.frameY >= (short) 66 && tile2.frameY <= (short) 110 || tile2.frameY >= (short) 198 : tile2.type == (ushort) 323 && tile2.frameX != (short) 66 && tile2.frameX != (short) 220;
        }
      }
      return true;
    }

    public static int CheckTileBreakability(int x, int y)
    {
      Tile t1 = Main.tile[x, y];
      if (y >= 1 && y <= Main.maxTilesY - 1)
      {
        Tile t2 = Main.tile[x, y - 1];
        Tile tile = Main.tile[x, y + 1];
        if (tile != null && tile.active() && WorldGen.IsLockedDoor(x, y + 1))
          return 2;
        if (!Main.tileSolid[(int) t1.type] && !Main.tileSolidTop[(int) t1.type])
          return 0;
        if (t2.active())
        {
          if (((!TileID.Sets.PreventsTileRemovalIfOnTopOfIt[(int) t2.type] ? 0 : ((int) t1.type != (int) t2.type ? 1 : 0)) | (WorldGen.IsLockedDoor(x, y - 1) ? 1 : 0) | (t2.type != (ushort) 77 || t1.type == (ushort) 77 ? 0 : (!Main.hardMode ? 1 : 0)) | (!WorldGen.IsAContainer(t2) ? 0 : (!WorldGen.IsAContainer(t1) ? 1 : 0))) != 0)
            return TileID.Sets.IsATreeTrunk[(int) t2.type] ? (t2.frameX == (short) 66 && t2.frameY >= (short) 0 && t2.frameY <= (short) 44 || t2.frameX == (short) 88 && t2.frameY >= (short) 66 && t2.frameY <= (short) 110 || t2.frameY >= (short) 198 ? 0 : 2) : (t2.type == (ushort) 323 && t2.frameX != (short) 66 && t2.frameX != (short) 220 ? 0 : 2);
          if (t2.type == (ushort) 80 && (int) t2.type != (int) t1.type)
          {
            switch ((int) t2.frameX / 18)
            {
              case 0:
              case 1:
              case 4:
              case 5:
                return 2;
            }
          }
          if (t1.type == (ushort) 10 && t1.frameY >= (short) 594 && t1.frameY <= (short) 646)
            return 1;
          if (t1.type == (ushort) 138 || t1.type == (ushort) 484)
            return WorldGen.CheckBoulderChest(x, y) ? 1 : 0;
        }
        if (t1.type == (ushort) 235)
        {
          int frameX = (int) t1.frameX;
          int num = x - frameX % 54 / 18;
          for (int index = 0; index < 3; ++index)
          {
            if (Main.tile[num + index, y - 1].active() && WorldGen.IsAContainer(Main.tile[num + index, y - 1]))
              return 2;
          }
        }
      }
      return 0;
    }

    public static bool CheckTileBreakability2_ShouldTileSurvive(int x, int y)
    {
      if (Main.netMode == 1)
        return false;
      Tile tile = Main.tile[x, y];
      if (TileID.Sets.BasicChest[(int) tile.type])
      {
        int num = (int) tile.frameX / 18;
        int Y = y - (int) tile.frameY / 18;
        while (num > 1)
          num -= 2;
        if (!Chest.DestroyChest(x - num, Y))
          return true;
      }
      if (tile.type == (ushort) 88)
      {
        int num1 = (int) tile.frameX / 18;
        int Y = y - (int) tile.frameY / 18;
        int num2 = num1 % 3;
        if (!Chest.DestroyChest(x - num2, Y))
          return true;
      }
      if (tile.type == (ushort) 470)
        return !TEDisplayDoll.IsBreakable(x, y);
      return tile.type == (ushort) 475 && !TEHatRack.IsBreakable(x, y);
    }

    public static bool ReplaceWall(int x, int y, ushort targetWall)
    {
      if (targetWall >= (ushort) 316)
        return false;
      Tile tileCache = Main.tile[x, y];
      if (tileCache.wall == (ushort) 0 || targetWall == (ushort) 0 || WorldGen.KillWall_CheckFailure(false, tileCache))
        return false;
      int num = 10;
      for (int index = 0; index < num; ++index)
        WorldGen.KillWall_MakeWallDust(x, y, tileCache);
      WorldGen.KillWall_PlaySounds(x, y, tileCache);
      WorldGen.KillWall_DropItems(x, y, tileCache);
      tileCache.wall = targetWall;
      tileCache.wallColor((byte) 0);
      WorldGen.SquareWallFrame(x, y, true);
      return true;
    }

    public static bool ReplaceTile(int x, int y, ushort targetType, int targetStyle)
    {
      Tile tileSafely = Framing.GetTileSafely(x, y);
      if (!WorldGen.WouldTileReplacementWork(targetType, x, y) || !WorldGen.IsTileReplacable(x, y))
        return false;
      WorldGen.MoveReplaceTileAnchor(ref x, ref y, targetType, tileSafely);
      int tileDustAmount = WorldGen.KillTile_GetTileDustAmount(false, tileSafely);
      for (int index = 0; index < tileDustAmount; ++index)
        WorldGen.KillTile_MakeTileDust(x, y, tileSafely);
      WorldGen.KillTile_PlaySounds(x, y, false, tileSafely);
      WorldGen.KillTile_DropItems(x, y, tileSafely, true);
      WorldGen.AttemptFossilShattering(x, y, tileSafely, false);
      WorldGen.ReplaceTIle_DoActualReplacement(targetType, targetStyle, x, y, tileSafely);
      return true;
    }

    private static void ReplaceTIle_DoActualReplacement(
      ushort targetType,
      int targetStyle,
      int topLeftX,
      int topLeftY,
      Tile t)
    {
      if (TileID.Sets.BasicChest[(int) targetType])
      {
        if (WorldGen.IsChestRigged(topLeftX, topLeftY) && Main.netMode != 1)
        {
          Wiring.HitSwitch(topLeftX, topLeftY);
          NetMessage.SendData(59, -1, -1, (NetworkText) null, topLeftX, (float) topLeftY, 0.0f, 0.0f, 0, 0, 0);
        }
        WorldGen.ReplaceTile_DoActualReplacement_Area(targetType, targetStyle, topLeftX, topLeftY, 2, 2);
      }
      else if (TileID.Sets.BasicDresser[(int) targetType])
        WorldGen.ReplaceTile_DoActualReplacement_Area(targetType, targetStyle, topLeftX, topLeftY, 3, 2);
      else
        WorldGen.ReplaceTile_DoActualReplacement_Single(targetType, targetStyle, topLeftX, topLeftY, t);
    }

    private static void ReplaceTile_DoActualReplacement_Single(
      ushort targetType,
      int targetStyle,
      int topLeftX,
      int topLeftY,
      Tile t)
    {
      WorldGen.ReplaceTile_EliminateNaturalExtras(topLeftX, topLeftY);
      int type = (int) t.type;
      t.type = targetType;
      if (TileID.Sets.Platforms[(int) t.type])
        t.frameY = (short) (targetStyle * 18);
      t.color((byte) 0);
      bool flag = !WorldGen.CanPoundTile(topLeftX, topLeftY);
      if (TileID.Sets.Platforms[type] && TileID.Sets.Platforms[(int) t.type])
        flag = false;
      if (flag)
      {
        t.slope((byte) 0);
        t.halfBrick(false);
      }
      WorldGen.SquareTileFrame(topLeftX, topLeftY, true);
    }

    private static void ReplaceTile_EliminateNaturalExtras(int x, int y)
    {
      if (!WorldGen.InWorld(x, y, 2))
        return;
      if (Main.tile[x, y - 1] != null && Main.tile[x, y - 1].active() && (TileID.Sets.ReplaceTileBreakUp[(int) Main.tile[x, y - 1].type] || Main.tile[x, y - 1].type == (ushort) 165 && (Main.tile[x, y - 1].frameY == (short) 36 || Main.tile[x, y - 1].frameY == (short) 54 || Main.tile[x, y - 1].frameY == (short) 90)))
        WorldGen.KillTile(x, y - 1, false, false, false);
      if (Main.tile[x, y + 1] == null || !Main.tile[x, y + 1].active() || !TileID.Sets.ReplaceTileBreakDown[(int) Main.tile[x, y + 1].type] && (Main.tile[x, y + 1].type != (ushort) 165 || Main.tile[x, y + 1].frameY != (short) 0 && Main.tile[x, y + 1].frameY != (short) 18 && Main.tile[x, y + 1].frameY != (short) 72))
        return;
      WorldGen.KillTile(x, y + 1, false, false, false);
    }

    private static void ReplaceTile_DoActualReplacement_Area(
      ushort targetType,
      int targetStyle,
      int topLeftX,
      int topLeftY,
      int areaSizeX,
      int areaSizeY)
    {
      for (int index1 = 0; index1 < areaSizeX; ++index1)
      {
        for (int index2 = 0; index2 < areaSizeY; ++index2)
        {
          Tile tile = Main.tile[topLeftX + index1, topLeftY + index2];
          tile.type = targetType;
          tile.frameX = (short) (targetStyle * (areaSizeX * 18) + index1 * 18);
          tile.frameY = (short) (index2 * 18);
          tile.color((byte) 0);
        }
      }
      for (int index1 = 0; index1 < areaSizeX; ++index1)
      {
        for (int index2 = 0; index2 < areaSizeY; ++index2)
          WorldGen.SquareTileFrame(topLeftX + index1, topLeftY + index2, true);
      }
    }

    private static void MoveReplaceTileAnchor(ref int x, ref int y, ushort targetType, Tile t)
    {
      if (TileID.Sets.BasicChest[(int) t.type])
      {
        x -= (int) t.frameX % 36 / 18;
        y -= (int) t.frameY % 36 / 18;
      }
      if (!TileID.Sets.BasicDresser[(int) t.type])
        return;
      x -= (int) t.frameX % 54 / 18;
      y -= (int) t.frameY % 36 / 18;
    }

    public static bool WouldTileReplacementBeBlockedByLiquid(int x, int y, int liquidType)
    {
      if (Main.tile[x - 1, y].liquid > (byte) 0 && (int) Main.tile[x - 1, y].liquidType() == liquidType || Main.tile[x + 1, y].liquid > (byte) 0 && (int) Main.tile[x + 1, y].liquidType() == liquidType)
        return true;
      return Main.tile[x, y - 1].liquid > (byte) 0 && (int) Main.tile[x, y - 1].liquidType() == liquidType;
    }

    public static bool WouldTileReplacementWork(ushort attemptingToReplaceWith, int x, int y)
    {
      Tile t = Main.tile[x, y];
      if (attemptingToReplaceWith >= (ushort) 623 || TileID.Sets.Conversion.Grass[(int) attemptingToReplaceWith])
        return false;
      bool flag1 = !WorldGen.ReplaceTile_IsValidSolid((int) attemptingToReplaceWith) || !WorldGen.ReplaceTile_IsValidSolid((int) t.type);
      int num1 = !WorldGen.ReplaceTile_IsValidPlatform((int) attemptingToReplaceWith) ? 1 : (!WorldGen.ReplaceTile_IsValidPlatform((int) t.type) ? 1 : 0);
      bool flag2 = !WorldGen.ReplaceTile_IsValidSolid((int) attemptingToReplaceWith) && !WorldGen.ReplaceTile_IsValidPlatform((int) attemptingToReplaceWith) || !WorldGen.ReplaceTile_IsValidSolid((int) t.type) && !WorldGen.ReplaceTile_IsValidPlatform((int) t.type);
      bool flag3 = !WorldGen.ReplaceTile_IsValidChest((int) attemptingToReplaceWith) || !WorldGen.ReplaceTile_IsValidChest((int) t.type) || Chest.IsLocked(t);
      bool flag4 = !WorldGen.ReplaceTile_IsValidDresser((int) attemptingToReplaceWith) || !WorldGen.ReplaceTile_IsValidDresser((int) t.type);
      int num2 = flag1 ? 1 : 0;
      return (num1 & num2 & (flag2 ? 1 : 0) & (flag3 ? 1 : 0) & (flag4 ? 1 : 0)) == 0;
    }

    private static bool ReplaceTile_IsValidSolid(int type)
    {
      return Main.tileSolid[type] && !Main.tileSolidTop[type] && !Main.tileFrameImportant[type];
    }

    private static bool ReplaceTile_IsValidChest(int type)
    {
      return TileID.Sets.BasicChest[type];
    }

    private static bool ReplaceTile_IsValidDresser(int type)
    {
      return TileID.Sets.BasicDresser[type];
    }

    private static bool ReplaceTile_IsValidPlatform(int type)
    {
      return TileID.Sets.Platforms[type];
    }

    public static bool GetVanityTreeFoliageData(
      int i,
      int j,
      int xoffset,
      ref int treeFrame,
      ref int treeStyle,
      out int floorY,
      out int topTextureFrameWidth,
      out int topTextureFrameHeight)
    {
      Tile tile1 = Main.tile[i, j];
      int index1 = i + xoffset;
      topTextureFrameWidth = 114;
      topTextureFrameHeight = 96;
      floorY = j;
      for (int index2 = 0; index2 < 100; ++index2)
      {
        floorY = j + index2;
        Tile tile2 = Main.tile[index1, floorY];
        if (tile2 == null)
          return false;
        if (TileID.Sets.Conversion.Grass[(int) tile2.type])
        {
          switch (tile1.type)
          {
            case 596:
              treeStyle = 29;
              return true;
            case 616:
              treeStyle = 30;
              return true;
            default:
              continue;
          }
        }
      }
      return false;
    }

    public static bool GetGemTreeFoliageData(
      int i,
      int j,
      int xoffset,
      ref int treeFrame,
      ref int treeStyle,
      out int floorY,
      out int topTextureFrameWidth,
      out int topTextureFrameHeight)
    {
      Tile tile1 = Main.tile[i, j];
      int index1 = i + xoffset;
      topTextureFrameWidth = 114;
      topTextureFrameHeight = 96;
      floorY = j;
      for (int index2 = 0; index2 < 100; ++index2)
      {
        floorY = j + index2;
        Tile tile2 = Main.tile[index1, floorY];
        if (tile2 == null)
          return false;
        if (TileID.Sets.Conversion.Stone[(int) tile2.type])
        {
          switch (tile1.type)
          {
            case 583:
              treeStyle = 22;
              return true;
            case 584:
              treeStyle = 23;
              return true;
            case 585:
              treeStyle = 24;
              return true;
            case 586:
              treeStyle = 25;
              return true;
            case 587:
              treeStyle = 26;
              return true;
            case 588:
              treeStyle = 27;
              return true;
            case 589:
              treeStyle = 28;
              return true;
            default:
              continue;
          }
        }
      }
      return false;
    }

    public static bool GetCommonTreeFoliageData(
      int i,
      int j,
      int xoffset,
      ref int treeFrame,
      ref int treeStyle,
      out int floorY,
      out int topTextureFrameWidth,
      out int topTextureFrameHeight)
    {
      Tile tile1 = Main.tile[i, j];
      int index1 = i + xoffset;
      topTextureFrameWidth = 80;
      topTextureFrameHeight = 80;
      floorY = j;
      for (int index2 = 0; index2 < 100; ++index2)
      {
        floorY = j + index2;
        Tile tile2 = Main.tile[index1, floorY];
        if (tile2 == null)
          return false;
        switch (tile2.type)
        {
          case 2:
          case 477:
            int num = index1 > Main.treeX[0] ? (index1 > Main.treeX[1] ? (index1 > Main.treeX[2] ? WorldGen.TreeTops.GetTreeStyle(3) : WorldGen.TreeTops.GetTreeStyle(2)) : WorldGen.TreeTops.GetTreeStyle(1)) : WorldGen.TreeTops.GetTreeStyle(0);
            switch (num)
            {
              case 0:
                treeStyle = 0;
                break;
              case 5:
                treeStyle = 10;
                break;
              default:
                treeStyle = 5 + num;
                break;
            }
            return true;
          case 23:
            treeStyle = 1;
            return true;
          case 60:
            topTextureFrameHeight = 96;
            topTextureFrameWidth = 114;
            treeStyle = 2;
            if (WorldGen.TreeTops.GetTreeStyle(5) == 1)
              treeStyle = 11;
            if ((double) floorY > Main.worldSurface)
              treeStyle = 13;
            return true;
          case 70:
            treeStyle = 14;
            return true;
          case 109:
          case 492:
            topTextureFrameHeight = 140;
            int treeFoliageStyle = WorldGen.GetHollowTreeFoliageStyle();
            treeStyle = treeFoliageStyle;
            if (treeFoliageStyle == 19)
              topTextureFrameWidth = 114;
            if (treeFoliageStyle == 20)
            {
              treeStyle = 20;
              if (i % 6 == 1)
                treeFrame += 3;
              else if (i % 6 == 2)
                treeFrame += 6;
              else if (i % 6 == 3)
                treeFrame += 9;
              else if (i % 6 == 4)
                treeFrame += 12;
              else if (i % 6 == 5)
                treeFrame += 15;
            }
            else if (i % 3 == 1)
              treeFrame += 3;
            else if (i % 3 == 2)
              treeFrame += 6;
            return true;
          case 147:
            treeStyle = 4;
            int treeStyle1 = WorldGen.TreeTops.GetTreeStyle(6);
            if (treeStyle1 == 0)
            {
              treeStyle = 12;
              if (i % 10 == 0)
                treeStyle = 18;
            }
            if (treeStyle1 == 2 || treeStyle1 == 3 || (treeStyle1 == 32 || treeStyle1 == 4) || (treeStyle1 == 42 || treeStyle1 == 5 || treeStyle1 == 7))
              treeStyle = treeStyle1 % 2 != 0 ? (i <= Main.maxTilesX / 2 ? 17 : 16) : (i >= Main.maxTilesX / 2 ? 17 : 16);
            return true;
          case 199:
            treeStyle = 5;
            return true;
          default:
            continue;
        }
      }
      return false;
    }

    public static int GetHollowTreeFoliageStyle()
    {
      WorldGen.TreeTops.GetTreeStyle(7);
      switch (WorldGen.hallowBG)
      {
        case 2:
        case 3:
          return 20;
        case 4:
          return 19;
        default:
          return 3;
      }
    }

    public static int GetTreeFrame(Tile t)
    {
      if (t.frameY == (short) 220)
        return 1;
      return t.frameY == (short) 242 ? 2 : 0;
    }

    public static TreeTypes GetTreeType(int tileType)
    {
      switch (tileType)
      {
        case 2:
        case 477:
          return TreeTypes.Forest;
        case 23:
          return TreeTypes.Corrupt;
        case 53:
          return TreeTypes.Palm;
        case 60:
          return TreeTypes.Jungle;
        case 70:
          return TreeTypes.Mushroom;
        case 109:
        case 492:
          return TreeTypes.Hallowed;
        case 112:
          return TreeTypes.PalmCorrupt;
        case 116:
          return TreeTypes.PalmHallowed;
        case 147:
          return TreeTypes.Snow;
        case 199:
          return TreeTypes.Crimson;
        case 234:
          return TreeTypes.PalmCrimson;
        default:
          return TreeTypes.None;
      }
    }

    public static bool IsThisAMushroomTree(int i, int j)
    {
      int x;
      int y;
      WorldGen.GetTreeBottom(i, j, out x, out y);
      return WorldGen.GetTreeType((int) Main.tile[x, y].type) == TreeTypes.Mushroom;
    }

    private static void ShakeTree(int i, int j)
    {
      if (WorldGen.numTreeShakes == WorldGen.maxTreeShakes)
        return;
      int x;
      int y;
      WorldGen.GetTreeBottom(i, j, out x, out y);
      int index1 = y;
      TreeTypes treeType = WorldGen.GetTreeType((int) Main.tile[x, y].type);
      if (treeType == TreeTypes.None)
        return;
      for (int index2 = 0; index2 < WorldGen.numTreeShakes; ++index2)
      {
        if (WorldGen.treeShakeX[index2] == x && WorldGen.treeShakeY[index2] == y)
          return;
      }
      WorldGen.treeShakeX[WorldGen.numTreeShakes] = x;
      WorldGen.treeShakeY[WorldGen.numTreeShakes] = y;
      ++WorldGen.numTreeShakes;
      --y;
      while (y > 10 && Main.tile[x, y].active() && TileID.Sets.IsShakeable[(int) Main.tile[x, y].type])
        --y;
      ++y;
      if (!WorldGen.IsTileALeafyTreeTop(x, y) || Collision.SolidTiles(x - 2, x + 2, y - 2, y + 2))
        return;
      bool flag = false;
      if (Main.getGoodWorld && WorldGen.genRand.Next(15) == 0)
        Projectile.NewProjectile((float) (x * 16), (float) (y * 16), (float) Main.rand.Next(-100, 101) * (1f / 500f), 0.0f, 28, 0, 0.0f, (int) Player.FindClosest(new Vector2((float) (x * 16), (float) (y * 16)), 16, 16), 0.0f, 0.0f);
      else if (WorldGen.genRand.Next(1000) == 0 && treeType == TreeTypes.Forest)
      {
        flag = true;
        Item.NewItem(x * 16, y * 16, 16, 16, 4366, 1, false, 0, false, false);
      }
      else if (WorldGen.genRand.Next(7) == 0 && (treeType == TreeTypes.Forest || treeType == TreeTypes.Snow || treeType == TreeTypes.Hallowed))
      {
        flag = true;
        Item.NewItem(x * 16, y * 16, 16, 16, 27, WorldGen.genRand.Next(1, 3), false, 0, false, false);
      }
      else if (WorldGen.genRand.Next(8) == 0 && treeType == TreeTypes.Mushroom)
      {
        flag = true;
        Item.NewItem(x * 16, y * 16, 16, 16, 194, WorldGen.genRand.Next(1, 2), false, 0, false, false);
      }
      else if (WorldGen.genRand.Next(35) == 0 && Main.halloween)
      {
        flag = true;
        Item.NewItem(x * 16, y * 16, 16, 16, 1809, WorldGen.genRand.Next(1, 3), false, 0, false, false);
      }
      else if (WorldGen.genRand.Next(12) == 0)
      {
        flag = true;
        int dropItem = 0;
        WorldGen.KillTile_GetItemDrops(i, j, Main.tile[i, j], out dropItem, out int _, out int _, out int _, false);
        Item.NewItem(x * 16, y * 16, 16, 16, dropItem, WorldGen.genRand.Next(1, 4), false, 0, false, false);
      }
      else if (WorldGen.genRand.Next(20) == 0)
      {
        flag = true;
        int Type = 71;
        int Stack = WorldGen.genRand.Next(50, 100);
        if (WorldGen.genRand.Next(30) == 0)
        {
          Type = 73;
          Stack = 1;
          if (WorldGen.genRand.Next(5) == 0)
            ++Stack;
          if (WorldGen.genRand.Next(10) == 0)
            ++Stack;
        }
        else if (WorldGen.genRand.Next(10) == 0)
        {
          Type = 72;
          Stack = WorldGen.genRand.Next(1, 21);
          if (WorldGen.genRand.Next(3) == 0)
            Stack += WorldGen.genRand.Next(1, 21);
          if (WorldGen.genRand.Next(4) == 0)
            Stack += WorldGen.genRand.Next(1, 21);
        }
        Item.NewItem(x * 16, y * 16, 16, 16, Type, Stack, false, 0, false, false);
      }
      else if (WorldGen.genRand.Next(15) == 0 && (treeType == TreeTypes.Forest || treeType == TreeTypes.Hallowed))
      {
        flag = true;
        int Type;
        switch (WorldGen.genRand.Next(5))
        {
          case 0:
            Type = 74;
            break;
          case 1:
            Type = 297;
            break;
          case 2:
            Type = 298;
            break;
          case 3:
            Type = 299;
            break;
          default:
            Type = 538;
            break;
        }
        if ((double) Player.GetClosestRollLuck(x, y, NPC.goldCritterChance) == 0.0)
          Type = WorldGen.genRand.Next(2) != 0 ? 539 : 442;
        NPC.NewNPC(x * 16, y * 16, Type, 0, 0.0f, 0.0f, 0.0f, 0.0f, (int) byte.MaxValue);
      }
      else if (WorldGen.genRand.Next(50) == 0 && treeType == TreeTypes.Hallowed && !Main.dayTime)
      {
        flag = true;
        NPC.NewNPC(x * 16, y * 16, (int) Main.rand.NextFromList<short>((short) 583, (short) 584, (short) 585), 0, 0.0f, 0.0f, 0.0f, 0.0f, (int) byte.MaxValue);
      }
      else if (WorldGen.genRand.Next(50) == 0 && treeType == TreeTypes.Forest && !Main.dayTime)
      {
        flag = true;
        NPC npc = Main.npc[NPC.NewNPC(x * 16, y * 16, 611, 0, 0.0f, 0.0f, 0.0f, 0.0f, (int) byte.MaxValue)];
        npc.velocity.Y = 1f;
        npc.netUpdate = true;
      }
      else if (WorldGen.genRand.Next(40) == 0 && treeType == TreeTypes.Forest && (!Main.dayTime && Main.halloween))
      {
        flag = true;
        NPC.NewNPC(x * 16, y * 16, 301, 0, 0.0f, 0.0f, 0.0f, 0.0f, (int) byte.MaxValue);
      }
      else if (WorldGen.genRand.Next(50) == 0 && (treeType == TreeTypes.Forest || treeType == TreeTypes.Hallowed))
      {
        flag = true;
        for (int index2 = 0; index2 < 5; ++index2)
        {
          Point point = new Point(x + Main.rand.Next(-2, 2), y - 1 + Main.rand.Next(-2, 2));
          int Type;
          if ((double) Player.GetClosestRollLuck(x, y, NPC.goldCritterChance) == 0.0)
            Type = 442;
          else
            Type = (int) Main.rand.NextFromList<short>((short) 74, (short) 297, (short) 298);
          NPC npc = Main.npc[NPC.NewNPC(point.X * 16, point.Y * 16, Type, 0, 0.0f, 0.0f, 0.0f, 0.0f, (int) byte.MaxValue)];
          npc.velocity = Main.rand.NextVector2CircularEdge(3f, 3f);
          npc.netUpdate = true;
        }
      }
      else if (WorldGen.genRand.Next(40) == 0 && treeType == TreeTypes.Jungle)
      {
        flag = true;
        for (int index2 = 0; index2 < 5; ++index2)
        {
          Point point = new Point(x + Main.rand.Next(-2, 2), y - 1 + Main.rand.Next(-2, 2));
          NPC npc = Main.npc[NPC.NewNPC(point.X * 16, point.Y * 16, (int) Main.rand.NextFromList<short>((short) 210, (short) 211), 0, 0.0f, 0.0f, 0.0f, 0.0f, (int) byte.MaxValue)];
          npc.ai[1] = 65f;
          npc.netUpdate = true;
        }
      }
      else if (WorldGen.genRand.Next(20) == 0 && (treeType == TreeTypes.Palm || treeType == TreeTypes.PalmCorrupt || (treeType == TreeTypes.PalmCrimson || treeType == TreeTypes.PalmHallowed)) && !WorldGen.IsPalmOasisTree(x))
      {
        flag = true;
        NPC.NewNPC(x * 16, y * 16, 603, 0, 0.0f, 0.0f, 0.0f, 0.0f, (int) byte.MaxValue);
      }
      else if (WorldGen.genRand.Next(30) == 0 && (treeType == TreeTypes.Crimson || treeType == TreeTypes.PalmCrimson))
      {
        flag = true;
        NPC.NewNPC(x * 16 + 8, (y - 1) * 16, -22, 0, 0.0f, 0.0f, 0.0f, 0.0f, (int) byte.MaxValue);
      }
      else if (WorldGen.genRand.Next(30) == 0 && (treeType == TreeTypes.Corrupt || treeType == TreeTypes.PalmCorrupt))
      {
        flag = true;
        NPC.NewNPC(x * 16 + 8, (y - 1) * 16, -11, 0, 0.0f, 0.0f, 0.0f, 0.0f, (int) byte.MaxValue);
      }
      else if (WorldGen.genRand.Next(30) == 0 && treeType == TreeTypes.Jungle && !Main.dayTime)
      {
        flag = true;
        NPC.NewNPC(x * 16, y * 16, 51, 0, 0.0f, 0.0f, 0.0f, 0.0f, (int) byte.MaxValue);
      }
      else if (WorldGen.genRand.Next(40) == 0 && treeType == TreeTypes.Jungle)
      {
        flag = true;
        Projectile.NewProjectile((float) (x * 16 + 8), (float) ((y - 1) * 16), 0.0f, 0.0f, 655, 0, 0.0f, Main.myPlayer, 0.0f, 0.0f);
      }
      else if (WorldGen.genRand.Next(20) == 0 && (treeType == TreeTypes.Forest || treeType == TreeTypes.Hallowed) && (!Main.raining && !NPC.TooWindyForButterflies && Main.dayTime))
      {
        flag = true;
        int Type = 356;
        if ((double) Player.GetClosestRollLuck(x, y, NPC.goldCritterChance) == 0.0)
          Type = 444;
        NPC.NewNPC(x * 16, y * 16, Type, 0, 0.0f, 0.0f, 0.0f, 0.0f, (int) byte.MaxValue);
      }
      else if (WorldGen.genRand.Next(15) == 0 && treeType == TreeTypes.Forest)
      {
        flag = true;
        int Type;
        switch (WorldGen.genRand.Next(5))
        {
          case 0:
            Type = 4009;
            break;
          case 1:
            Type = 4293;
            break;
          case 2:
            Type = 4282;
            break;
          case 3:
            Type = 4290;
            break;
          default:
            Type = 4291;
            break;
        }
        Item.NewItem(x * 16, y * 16, 16, 16, Type, 1, false, 0, false, false);
      }
      else if (WorldGen.genRand.Next(15) == 0 && treeType == TreeTypes.Snow)
      {
        flag = true;
        int Type = WorldGen.genRand.Next(2) != 0 ? 4295 : 4286;
        Item.NewItem(x * 16, y * 16, 16, 16, Type, 1, false, 0, false, false);
      }
      else if (WorldGen.genRand.Next(15) == 0 && treeType == TreeTypes.Jungle)
      {
        flag = true;
        int Type = WorldGen.genRand.Next(2) != 0 ? 4292 : 4294;
        Item.NewItem(x * 16, y * 16, 16, 16, Type, 1, false, 0, false, false);
      }
      else if (WorldGen.genRand.Next(15) == 0 && (treeType == TreeTypes.Palm || treeType == TreeTypes.PalmCorrupt || (treeType == TreeTypes.PalmCrimson || treeType == TreeTypes.PalmHallowed)) && !WorldGen.IsPalmOasisTree(x))
      {
        flag = true;
        int Type = WorldGen.genRand.Next(2) != 0 ? 4287 : 4283;
        Item.NewItem(x * 16, y * 16, 16, 16, Type, 1, false, 0, false, false);
      }
      else if (WorldGen.genRand.Next(15) == 0 && (treeType == TreeTypes.Corrupt || treeType == TreeTypes.PalmCorrupt))
      {
        flag = true;
        int Type = WorldGen.genRand.Next(2) != 0 ? 4289 : 4284;
        Item.NewItem(x * 16, y * 16, 16, 16, Type, 1, false, 0, false, false);
      }
      else if (WorldGen.genRand.Next(15) == 0 && (treeType == TreeTypes.Hallowed || treeType == TreeTypes.PalmHallowed))
      {
        flag = true;
        int Type = WorldGen.genRand.Next(2) != 0 ? 4288 : 4297;
        Item.NewItem(x * 16, y * 16, 16, 16, Type, 1, false, 0, false, false);
      }
      else if (WorldGen.genRand.Next(15) == 0 && (treeType == TreeTypes.Crimson || treeType == TreeTypes.PalmCrimson))
      {
        flag = true;
        int Type = WorldGen.genRand.Next(2) != 0 ? 4285 : 4296;
        Item.NewItem(x * 16, y * 16, 16, 16, Type, 1, false, 0, false, false);
      }
      if (!flag)
        return;
      int treeHeight = 0;
      int treeFrame = 0;
      int passStyle = 0;
      WorldGen.GetTreeLeaf(x, Main.tile[x, y], Main.tile[x, index1], ref treeHeight, out treeFrame, out passStyle);
      if (Main.netMode == 2)
        NetMessage.SendData(112, -1, -1, (NetworkText) null, 1, (float) x, (float) y, 1f, passStyle, 0, 0);
      if (Main.netMode != 0)
        return;
      WorldGen.TreeGrowFX(x, y, 1, passStyle, true);
    }

    private static void GetTreeBottom(int i, int j, out int x, out int y)
    {
      x = i;
      y = j;
      Tile tileSafely1 = Framing.GetTileSafely(x, y);
      if (tileSafely1.type == (ushort) 323)
      {
        for (; y < Main.maxTilesY - 50 && (!tileSafely1.active() || tileSafely1.type == (ushort) 323); tileSafely1 = Framing.GetTileSafely(x, y))
          ++y;
      }
      else
      {
        int num1 = (int) tileSafely1.frameX / 22;
        int num2 = (int) tileSafely1.frameY / 22;
        if (num1 == 3 && num2 <= 2)
          ++x;
        else if (num1 == 4 && num2 >= 3 && num2 <= 5)
          --x;
        else if (num1 == 1 && num2 >= 6 && num2 <= 8)
          --x;
        else if (num1 == 2 && num2 >= 6 && num2 <= 8)
          ++x;
        else if (num1 == 2 && num2 >= 9)
          ++x;
        else if (num1 == 3 && num2 >= 9)
          --x;
        for (Tile tileSafely2 = Framing.GetTileSafely(x, y); y < Main.maxTilesY - 50 && (!tileSafely2.active() || TileID.Sets.IsATreeTrunk[(int) tileSafely2.type] || tileSafely2.type == (ushort) 72); tileSafely2 = Framing.GetTileSafely(x, y))
          ++y;
      }
    }

    private static void AttemptFossilShattering(int i, int j, Tile tileCache, bool fail)
    {
      if (tileCache.type != (ushort) 404 || Main.netMode == 1 || WorldGen.fossilBreak)
        return;
      WorldGen.fossilBreak = true;
      for (int i1 = i - 1; i1 <= i + 1; ++i1)
      {
        for (int j1 = j - 1; j1 <= j + 1; ++j1)
        {
          int maxValue = 15;
          if (!WorldGen.SolidTile(i1, j1 + 1, false))
            maxValue = 4;
          else if (i1 == i && j1 == j - 1 && !fail)
            maxValue = 4;
          if ((i1 != i || j1 != j) && (Main.tile[i1, j1].active() && Main.tile[i1, j1].type == (ushort) 404) && WorldGen.genRand.Next(maxValue) == 0)
          {
            WorldGen.KillTile(i1, j1, false, false, true);
            if (Main.netMode == 2)
              NetMessage.SendData(17, -1, -1, (NetworkText) null, 0, (float) i1, (float) j1, 0.0f, 0, 0, 0);
          }
        }
      }
      WorldGen.fossilBreak = false;
    }

    public static void KillTile(int i, int j, bool fail = false, bool effectOnly = false, bool noItem = false)
    {
      if (i < 0 || j < 0 || (i >= Main.maxTilesX || j >= Main.maxTilesY))
        return;
      Tile tileCache = Main.tile[i, j];
      if (tileCache == null)
      {
        tileCache = new Tile();
        Main.tile[i, j] = tileCache;
      }
      if (!tileCache.active())
        return;
      if (j >= 1 && Main.tile[i, j - 1] == null)
        Main.tile[i, j - 1] = new Tile();
      int num1 = WorldGen.CheckTileBreakability(i, j);
      if (num1 == 1)
        fail = true;
      if (num1 == 2)
        return;
      if (WorldGen.gen)
        noItem = true;
      if (!effectOnly && !WorldGen.stopDrops)
      {
        if (!noItem && FixExploitManEaters.SpotProtected(i, j))
          return;
        if (!WorldGen.gen && !Main.gameMenu)
          WorldGen.KillTile_PlaySounds(i, j, fail, tileCache);
      }
      if (tileCache.type == (ushort) 128 || tileCache.type == (ushort) 269)
      {
        int index1 = i;
        int frameX1 = (int) tileCache.frameX;
        int frameX2 = (int) tileCache.frameX;
        while (frameX2 >= 100)
          frameX2 -= 100;
        while (frameX2 >= 36)
          frameX2 -= 36;
        if (frameX2 == 18)
        {
          frameX1 = (int) Main.tile[i - 1, j].frameX;
          --index1;
        }
        if (frameX1 >= 100)
        {
          int index2 = 0;
          while (frameX1 >= 100)
          {
            frameX1 -= 100;
            ++index2;
          }
          int num2 = (int) Main.tile[index1, j].frameY / 18;
          if (num2 == 0)
            Item.NewItem(i * 16, j * 16, 16, 16, Item.headType[index2], 1, false, 0, false, false);
          if (num2 == 1)
            Item.NewItem(i * 16, j * 16, 16, 16, Item.bodyType[index2], 1, false, 0, false, false);
          if (num2 == 2)
            Item.NewItem(i * 16, j * 16, 16, 16, Item.legType[index2], 1, false, 0, false, false);
          int frameX3 = (int) Main.tile[index1, j].frameX;
          while (frameX3 >= 100)
            frameX3 -= 100;
          Main.tile[index1, j].frameX = (short) frameX3;
        }
      }
      if (tileCache.type == (ushort) 334)
      {
        int index = i;
        int frameX1 = (int) tileCache.frameX;
        int num2 = (int) tileCache.frameX;
        int num3 = 0;
        while (num2 >= 5000)
        {
          num2 -= 5000;
          ++num3;
        }
        if (num3 != 0)
          num2 = (num3 - 1) * 18;
        int num4 = num2 % 54;
        if (num4 == 18)
        {
          frameX1 = (int) Main.tile[i - 1, j].frameX;
          --index;
        }
        if (num4 == 36)
        {
          frameX1 = (int) Main.tile[i - 2, j].frameX;
          index -= 2;
        }
        if (frameX1 >= 5000)
        {
          int num5 = frameX1 % 5000 - 100;
          int frameX2 = (int) Main.tile[index + 1, j].frameX;
          int pre = frameX2 < 25000 ? frameX2 - 10000 : frameX2 - 25000;
          if (Main.netMode != 1)
          {
            Item obj = new Item();
            obj.netDefaults(num5);
            obj.Prefix(pre);
            int number = Item.NewItem(i * 16, j * 16, 16, 16, num5, 1, true, 0, false, false);
            obj.position = Main.item[number].position;
            Main.item[number] = obj;
            NetMessage.SendData(21, -1, -1, (NetworkText) null, number, 0.0f, 0.0f, 0.0f, 0, 0, 0);
          }
          int num6 = (int) Main.tile[index, j].frameX;
          int num7 = 0;
          while (num6 >= 5000)
          {
            num6 -= 5000;
            ++num7;
          }
          if (num7 != 0)
            num6 = (num7 - 1) * 18;
          Main.tile[index, j].frameX = (short) num6;
          Main.tile[index + 1, j].frameX = (short) (num6 + 18);
        }
      }
      if (tileCache.type == (ushort) 395)
      {
        int index = TEItemFrame.Find(i - (int) tileCache.frameX % 36 / 18, j - (int) tileCache.frameY % 36 / 18);
        if (index != -1 && ((TEItemFrame) TileEntity.ByID[index]).item.stack > 0)
        {
          ((TEItemFrame) TileEntity.ByID[index]).DropItem();
          if (Main.netMode == 2)
            return;
          Main.LocalPlayer.InterruptItemUsageIfOverTile(395);
          return;
        }
      }
      if (tileCache.type == (ushort) 520)
      {
        int index = TEFoodPlatter.Find(i, j);
        if (index != -1 && ((TEFoodPlatter) TileEntity.ByID[index]).item.stack > 0)
        {
          ((TEFoodPlatter) TileEntity.ByID[index]).DropItem();
          if (Main.netMode == 2)
            return;
          Main.LocalPlayer.InterruptItemUsageIfOverTile(520);
          return;
        }
      }
      if (tileCache.type == (ushort) 471 && TEWeaponsRack.KillTileDropItem(tileCache, i, j) || tileCache.type == (ushort) 470 && WorldGen.CheckTileBreakability2_ShouldTileSurvive(i, j) | fail || tileCache.type == (ushort) 475 && WorldGen.CheckTileBreakability2_ShouldTileSurvive(i, j) | fail)
        return;
      int tileDustAmount = WorldGen.KillTile_GetTileDustAmount(fail, tileCache);
      for (int index = 0; index < tileDustAmount; ++index)
        WorldGen.KillTile_MakeTileDust(i, j, tileCache);
      if (effectOnly)
        return;
      WorldGen.AttemptFossilShattering(i, j, tileCache, fail);
      if (fail)
      {
        if (Main.netMode != 1 && TileID.Sets.IsShakeable[(int) tileCache.type])
          WorldGen.ShakeTree(i, j);
        if (tileCache.type == (ushort) 2 || tileCache.type == (ushort) 23 || (tileCache.type == (ushort) 109 || tileCache.type == (ushort) 199) || (tileCache.type == (ushort) 477 || tileCache.type == (ushort) 492))
          tileCache.type = (ushort) 0;
        if (tileCache.type == (ushort) 60 || tileCache.type == (ushort) 70)
          tileCache.type = (ushort) 59;
        if (Main.tileMoss[(int) tileCache.type])
          tileCache.type = (ushort) 1;
        if (TileID.Sets.tileMossBrick[(int) tileCache.type])
          tileCache.type = (ushort) 38;
        WorldGen.SquareTileFrame(i, j, true);
      }
      else
      {
        if (Main.getGoodWorld && Main.netMode != 1 && tileCache.type == (ushort) 57)
        {
          for (int index1 = 0; index1 < 8; ++index1)
          {
            int maxValue = 2;
            int i1 = i;
            int j1 = j;
            if (index1 == 0)
              --i1;
            else if (index1 == 1)
              ++i1;
            else if (index1 == 2)
              --j1;
            else if (index1 == 3)
              ++j1;
            else if (index1 == 4)
            {
              --i1;
              --j1;
            }
            else if (index1 == 5)
            {
              ++i1;
              --j1;
            }
            else if (index1 == 6)
            {
              --i1;
              ++j1;
            }
            else if (index1 == 7)
            {
              ++i1;
              ++j1;
            }
            Tile tile = Main.tile[i1, j1];
            if (tile.active() && WorldGen.genRand.Next(maxValue) == 0 && (tile.type == (ushort) 57 && !WorldGen.SolidTile(i1, j1 + 1, false)))
            {
              WorldGen.KillTile(i1, j1, false, false, true);
              int index2 = Projectile.NewProjectile((float) (i1 * 16 + 8), (float) (j1 * 16 + 8), 0.0f, 0.41f, 40, 15, 0.0f, Main.myPlayer, 0.0f, 0.0f);
              Main.projectile[index2].netUpdate = true;
            }
          }
        }
        if (Main.netMode != 1 && tileCache.type >= (ushort) 481 && tileCache.type <= (ushort) 483)
        {
          for (int index = 0; index < 8; ++index)
          {
            int maxValue = 6;
            int i1 = i;
            int j1 = j;
            if (index == 0)
              --i1;
            else if (index == 1)
              ++i1;
            else if (index == 2)
            {
              --j1;
              maxValue /= 2;
            }
            else if (index == 3)
              ++j1;
            else if (index == 4)
            {
              --i1;
              --j1;
            }
            else if (index == 5)
            {
              ++i1;
              --j1;
            }
            else if (index == 6)
            {
              --i1;
              ++j1;
            }
            else if (index == 7)
            {
              ++i1;
              ++j1;
            }
            Tile tile = Main.tile[i1, j1];
            if (tile.active() && WorldGen.genRand.Next(maxValue) == 0 && (tile.type >= (ushort) 481 && tile.type <= (ushort) 483))
            {
              tileCache.active(false);
              WorldGen.KillTile(i1, j1, false, false, true);
            }
          }
          int Type = (int) tileCache.type - 481 + 736;
          int Damage = 20;
          switch (Main.netMode)
          {
            case 0:
              Projectile.NewProjectile((float) (i * 16 + 8), (float) (j * 16 + 8), 0.0f, 0.41f, Type, Damage, 0.0f, Main.myPlayer, 0.0f, 0.0f);
              break;
            case 2:
              int index1 = Projectile.NewProjectile((float) (i * 16 + 8), (float) (j * 16 + 8), 0.0f, 0.41f, Type, Damage, 0.0f, Main.myPlayer, 0.0f, 0.0f);
              Main.projectile[index1].netUpdate = true;
              break;
          }
        }
        if (WorldGen.CheckTileBreakability2_ShouldTileSurvive(i, j))
          return;
        if (tileCache.type == (ushort) 51 && tileCache.wall == (ushort) 62 && WorldGen.genRand.Next(4) != 0)
          noItem = true;
        if (!noItem && !WorldGen.stopDrops && Main.netMode != 1)
        {
          WorldGen.KillTile_DropBait(i, j, tileCache);
          WorldGen.KillTile_DropItems(i, j, tileCache, false);
        }
        if (Main.netMode != 2)
          AchievementsHelper.NotifyTileDestroyed(Main.player[Main.myPlayer], tileCache.type);
        tileCache.active(false);
        tileCache.halfBrick(false);
        tileCache.frameX = (short) -1;
        tileCache.frameY = (short) -1;
        tileCache.color((byte) 0);
        tileCache.frameNumber((byte) 0);
        if (tileCache.type == (ushort) 58 && j > Main.UnderworldLayer)
        {
          tileCache.lava(true);
          tileCache.liquid = (byte) 128;
        }
        else if (tileCache.type == (ushort) 419)
          Wiring.PokeLogicGate(i, j + 1);
        else if (TileID.Sets.BlocksWaterDrawingBehindSelf[(int) tileCache.type])
          WorldGen.SquareWallFrame(i, j, true);
        tileCache.type = (ushort) 0;
        tileCache.inActive(false);
        WorldGen.SquareTileFrame(i, j, true);
      }
    }

    private static Player GetPlayerForTile(int x, int y)
    {
      return Main.player[(int) Player.FindClosest(new Vector2((float) x, (float) y) * 16f, 16, 16)];
    }

    private static void KillTile_DropItems(
      int x,
      int y,
      Tile tileCache,
      bool includeLargeObjectDrops = false)
    {
      int dropItem;
      int dropItemStack;
      int secondaryItem;
      int secondaryItemStack;
      WorldGen.KillTile_GetItemDrops(x, y, tileCache, out dropItem, out dropItemStack, out secondaryItem, out secondaryItemStack, includeLargeObjectDrops);
      if (Main.getGoodWorld && !tileCache.active())
        return;
      if (dropItem > 0)
      {
        int i = Item.NewItem(x * 16, y * 16, 16, 16, dropItem, dropItemStack, false, -1, false, false);
        Main.item[i].TryCombiningIntoNearbyItems(i);
      }
      if (secondaryItem <= 0)
        return;
      int i1 = Item.NewItem(x * 16, y * 16, 16, 16, secondaryItem, secondaryItemStack, false, -1, false, false);
      Main.item[i1].TryCombiningIntoNearbyItems(i1);
    }

    public static void KillTile_GetItemDrops(
      int x,
      int y,
      Tile tileCache,
      out int dropItem,
      out int dropItemStack,
      out int secondaryItem,
      out int secondaryItemStack,
      bool includeLargeObjectDrops = false)
    {
      dropItem = 0;
      dropItemStack = 1;
      secondaryItem = 0;
      secondaryItemStack = 1;
      if (includeLargeObjectDrops)
      {
        switch (tileCache.type)
        {
          case 21:
          case 467:
            dropItem = WorldGen.GetChestItemDrop(x, y, (int) tileCache.type);
            break;
          case 88:
            int style1 = (int) tileCache.frameX / 54;
            dropItem = WorldGen.GetDresserItemDrop(style1);
            break;
        }
      }
      switch (tileCache.type)
      {
        case 0:
        case 2:
        case 109:
        case 199:
        case 477:
        case 492:
          dropItem = 2;
          break;
        case 1:
          dropItem = 3;
          break;
        case 3:
          if (tileCache.frameX == (short) 144)
          {
            dropItem = 5;
            break;
          }
          if (!WorldGen.KillTile_ShouldDropSeeds(x, y))
            break;
          dropItem = 283;
          break;
        case 4:
          int num1 = (int) tileCache.frameY / 22;
          switch (num1)
          {
            case 0:
              dropItem = 8;
              return;
            case 8:
              dropItem = 523;
              return;
            case 9:
              dropItem = 974;
              return;
            case 10:
              dropItem = 1245;
              return;
            case 11:
              dropItem = 1333;
              return;
            case 12:
              dropItem = 2274;
              return;
            case 13:
              dropItem = 3004;
              return;
            case 14:
              dropItem = 3045;
              return;
            case 15:
              dropItem = 3114;
              return;
            case 16:
              dropItem = 4383;
              return;
            case 17:
              dropItem = 4384;
              return;
            case 18:
              dropItem = 4385;
              return;
            case 19:
              dropItem = 4386;
              return;
            case 20:
              dropItem = 4387;
              return;
            case 21:
              dropItem = 4388;
              return;
            default:
              dropItem = 426 + num1;
              return;
          }
        case 5:
        case 596:
        case 616:
          bool bonusWood = false;
          WorldGen.KillTile_GetTreeDrops(x, y, tileCache, ref bonusWood, ref dropItem, ref secondaryItem);
          if (!bonusWood)
            break;
          ++dropItemStack;
          break;
        case 6:
          dropItem = 11;
          break;
        case 7:
          dropItem = 12;
          break;
        case 8:
          dropItem = 13;
          break;
        case 9:
          dropItem = 14;
          break;
        case 13:
          switch ((int) tileCache.frameX / 18)
          {
            case 1:
              dropItem = 28;
              return;
            case 2:
              dropItem = 110;
              return;
            case 3:
              dropItem = 350;
              return;
            case 4:
              dropItem = 351;
              return;
            case 5:
              dropItem = 2234;
              return;
            case 6:
              dropItem = 2244;
              return;
            case 7:
              dropItem = 2257;
              return;
            case 8:
              dropItem = 2258;
              return;
            default:
              dropItem = 31;
              return;
          }
        case 19:
          int num2 = (int) tileCache.frameY / 18;
          switch (num2)
          {
            case 0:
              dropItem = 94;
              return;
            case 1:
              dropItem = 631;
              return;
            case 2:
              dropItem = 632;
              return;
            case 3:
              dropItem = 633;
              return;
            case 4:
              dropItem = 634;
              return;
            case 5:
              dropItem = 913;
              return;
            case 6:
              dropItem = 1384;
              return;
            case 7:
              dropItem = 1385;
              return;
            case 8:
              dropItem = 1386;
              return;
            case 9:
              dropItem = 1387;
              return;
            case 10:
              dropItem = 1388;
              return;
            case 11:
              dropItem = 1389;
              return;
            case 12:
              dropItem = 1418;
              return;
            case 13:
              dropItem = 1457;
              return;
            case 14:
              dropItem = 1702;
              return;
            case 15:
              dropItem = 1796;
              return;
            case 16:
              dropItem = 1818;
              return;
            case 17:
              dropItem = 2518;
              return;
            case 18:
              dropItem = 2549;
              return;
            case 19:
              dropItem = 2566;
              return;
            case 20:
              dropItem = 2581;
              return;
            case 21:
              dropItem = 2627;
              return;
            case 22:
              dropItem = 2628;
              return;
            case 23:
              dropItem = 2629;
              return;
            case 24:
              dropItem = 2630;
              return;
            case 25:
              dropItem = 2744;
              return;
            case 26:
              dropItem = 2822;
              return;
            case 27:
              dropItem = 3144;
              return;
            case 28:
              dropItem = 3146;
              return;
            case 29:
              dropItem = 3145;
              return;
            default:
              if (num2 >= 30 && num2 <= 35)
              {
                dropItem = 3903 + num2 - 30;
                return;
              }
              switch (num2)
              {
                case 36:
                  dropItem = 3945;
                  return;
                case 37:
                  dropItem = 3957;
                  return;
                case 38:
                  dropItem = 4159;
                  return;
                case 39:
                  dropItem = 4180;
                  return;
                case 40:
                  dropItem = 4201;
                  return;
                case 41:
                  dropItem = 4222;
                  return;
                case 42:
                  dropItem = 4311;
                  return;
                case 43:
                  dropItem = 4416;
                  return;
                case 44:
                  dropItem = 4580;
                  return;
                default:
                  return;
              }
          }
        case 22:
          dropItem = 56;
          break;
        case 23:
          dropItem = 2;
          break;
        case 24:
          if (tileCache.frameX != (short) 144)
            break;
          dropItem = 60;
          break;
        case 25:
          dropItem = 61;
          break;
        case 30:
          dropItem = 9;
          break;
        case 33:
          int num3 = (int) tileCache.frameY / 22;
          dropItem = 105;
          switch (num3)
          {
            case 1:
              dropItem = 1405;
              return;
            case 2:
              dropItem = 1406;
              return;
            case 3:
              dropItem = 1407;
              return;
            default:
              if (num3 >= 4 && num3 <= 13)
              {
                dropItem = 2045 + num3 - 4;
                return;
              }
              if (num3 >= 14 && num3 <= 16)
              {
                dropItem = 2153 + num3 - 14;
                return;
              }
              switch (num3)
              {
                case 17:
                  dropItem = 2236;
                  return;
                case 18:
                  dropItem = 2523;
                  return;
                case 19:
                  dropItem = 2542;
                  return;
                case 20:
                  dropItem = 2556;
                  return;
                case 21:
                  dropItem = 2571;
                  return;
                case 22:
                  dropItem = 2648;
                  return;
                case 23:
                  dropItem = 2649;
                  return;
                case 24:
                  dropItem = 2650;
                  return;
                case 25:
                  dropItem = 2651;
                  return;
                case 26:
                  dropItem = 2818;
                  return;
                case 27:
                  dropItem = 3171;
                  return;
                case 28:
                  dropItem = 3173;
                  return;
                case 29:
                  dropItem = 3172;
                  return;
                case 30:
                  dropItem = 3890;
                  return;
                case 31:
                  dropItem = 3936;
                  return;
                case 32:
                  dropItem = 3962;
                  return;
                case 33:
                  dropItem = 4150;
                  return;
                case 34:
                  dropItem = 4171;
                  return;
                case 35:
                  dropItem = 4192;
                  return;
                case 36:
                  dropItem = 4213;
                  return;
                case 37:
                  dropItem = 4303;
                  return;
                case 38:
                  dropItem = 4571;
                  return;
                default:
                  return;
              }
          }
        case 36:
          dropItem = 1869;
          break;
        case 37:
          dropItem = 116;
          break;
        case 38:
          dropItem = 129;
          break;
        case 39:
          dropItem = 131;
          break;
        case 40:
          dropItem = 133;
          break;
        case 41:
          dropItem = 134;
          break;
        case 43:
          dropItem = 137;
          break;
        case 44:
          dropItem = 139;
          break;
        case 45:
          dropItem = 141;
          break;
        case 46:
          dropItem = 143;
          break;
        case 47:
          dropItem = 145;
          break;
        case 48:
          dropItem = 147;
          break;
        case 49:
          dropItem = 148;
          break;
        case 50:
          if (tileCache.frameX == (short) 90)
          {
            dropItem = 165;
            break;
          }
          dropItem = 149;
          break;
        case 51:
          dropItem = 150;
          break;
        case 52:
        case 62:
        case 382:
          if (Main.rand.Next(2) != 0 || !WorldGen.GetPlayerForTile(x, y).cordage)
            break;
          dropItem = 2996;
          break;
        case 53:
          dropItem = 169;
          break;
        case 54:
          dropItem = 170;
          break;
        case 56:
          dropItem = 173;
          break;
        case 57:
          dropItem = 172;
          break;
        case 58:
          dropItem = 174;
          break;
        case 59:
        case 60:
          dropItem = 176;
          break;
        case 61:
        case 74:
          if (tileCache.frameX == (short) 144 && tileCache.type == (ushort) 61)
          {
            dropItem = 331;
            dropItemStack = Main.rand.Next(2, 4);
            break;
          }
          if (tileCache.frameX == (short) 162 && tileCache.type == (ushort) 61)
          {
            dropItem = 223;
            break;
          }
          if (tileCache.frameX >= (short) 108 && tileCache.frameX <= (short) 126 && (tileCache.type == (ushort) 61 && Main.rand.Next(20) == 0))
          {
            dropItem = 208;
            break;
          }
          if (Main.rand.Next(100) != 0)
            break;
          dropItem = 195;
          break;
        case 63:
        case 64:
        case 65:
        case 66:
        case 67:
        case 68:
          dropItem = (int) tileCache.type - 63 + 177;
          break;
        case 70:
          dropItem = 176;
          break;
        case 71:
        case 72:
          if (Main.rand.Next(40) == 0)
          {
            dropItem = 194;
            break;
          }
          if (Main.rand.Next(2) != 0)
            break;
          dropItem = 183;
          break;
        case 73:
          if (!WorldGen.KillTile_ShouldDropSeeds(x, y))
            break;
          dropItem = 283;
          break;
        case 75:
          dropItem = 192;
          break;
        case 76:
          dropItem = 214;
          break;
        case 78:
          dropItem = 222;
          break;
        case 80:
          dropItem = 276;
          break;
        case 81:
          dropItem = 275;
          break;
        case 83:
        case 84:
          int style2 = (int) tileCache.frameX / 18;
          dropItem = 313 + style2;
          int num4 = 307 + style2;
          if (style2 == 6)
          {
            dropItem = 2358;
            num4 = 2357;
          }
          bool flag = WorldGen.IsHarvestableHerbWithSeed((int) tileCache.type, style2);
          if (WorldGen.GetPlayerForTile(x, y).HeldItem.type == 213)
          {
            dropItemStack = Main.rand.Next(1, 3);
            secondaryItem = num4;
            secondaryItemStack = Main.rand.Next(1, 6);
            break;
          }
          if (!flag)
            break;
          secondaryItem = num4;
          secondaryItemStack = Main.rand.Next(1, 4);
          break;
        case 107:
          dropItem = 364;
          break;
        case 108:
          dropItem = 365;
          break;
        case 110:
          if (tileCache.frameX != (short) 144)
            break;
          dropItem = 5;
          break;
        case 111:
          dropItem = 366;
          break;
        case 112:
          dropItem = 370;
          break;
        case 116:
          dropItem = 408;
          break;
        case 117:
          dropItem = 409;
          break;
        case 118:
          dropItem = 412;
          break;
        case 119:
          dropItem = 413;
          break;
        case 120:
          dropItem = 414;
          break;
        case 121:
          dropItem = 415;
          break;
        case 122:
          dropItem = 416;
          break;
        case 123:
          dropItem = 424;
          break;
        case 124:
          dropItem = 480;
          break;
        case 129:
          if (tileCache.frameX >= (short) 324)
          {
            dropItem = 4988;
            break;
          }
          dropItem = 502;
          break;
        case 130:
          dropItem = 511;
          break;
        case 131:
          dropItem = 512;
          break;
        case 135:
          int num5 = (int) tileCache.frameY / 18;
          if (num5 == 0)
            dropItem = 529;
          if (num5 == 1)
            dropItem = 541;
          if (num5 == 2)
            dropItem = 542;
          if (num5 == 3)
            dropItem = 543;
          if (num5 == 4)
            dropItem = 852;
          if (num5 == 5)
            dropItem = 853;
          if (num5 != 6)
            break;
          dropItem = 1151;
          break;
        case 136:
          dropItem = 538;
          break;
        case 137:
          int num6 = (int) tileCache.frameY / 18;
          if (num6 == 0)
            dropItem = 539;
          if (num6 == 1)
            dropItem = 1146;
          if (num6 == 2)
            dropItem = 1147;
          if (num6 == 3)
            dropItem = 1148;
          if (num6 != 4)
            break;
          dropItem = 1149;
          break;
        case 140:
          dropItem = 577;
          break;
        case 141:
          dropItem = 580;
          break;
        case 144:
          if (tileCache.frameX == (short) 0)
            dropItem = 583;
          if (tileCache.frameX == (short) 18)
            dropItem = 584;
          if (tileCache.frameX == (short) 36)
            dropItem = 585;
          if (tileCache.frameX == (short) 54)
            dropItem = 4484;
          if (tileCache.frameX != (short) 72)
            break;
          dropItem = 4485;
          break;
        case 145:
          dropItem = 586;
          break;
        case 146:
          dropItem = 591;
          break;
        case 147:
          dropItem = 593;
          break;
        case 148:
          dropItem = 594;
          break;
        case 149:
          if (tileCache.frameX == (short) 0 || tileCache.frameX == (short) 54)
          {
            dropItem = 596;
            break;
          }
          if (tileCache.frameX == (short) 18 || tileCache.frameX == (short) 72)
          {
            dropItem = 597;
            break;
          }
          if (tileCache.frameX != (short) 36 && tileCache.frameX != (short) 90)
            break;
          dropItem = 598;
          break;
        case 150:
          dropItem = 604;
          break;
        case 151:
          dropItem = 607;
          break;
        case 152:
          dropItem = 609;
          break;
        case 153:
          dropItem = 611;
          break;
        case 154:
          dropItem = 612;
          break;
        case 155:
          dropItem = 613;
          break;
        case 156:
          dropItem = 614;
          break;
        case 157:
          dropItem = 619;
          break;
        case 158:
          dropItem = 620;
          break;
        case 159:
          dropItem = 621;
          break;
        case 160:
          dropItem = 662;
          break;
        case 161:
          dropItem = 664;
          break;
        case 163:
          dropItem = 833;
          break;
        case 164:
          dropItem = 834;
          break;
        case 166:
          dropItem = 699;
          break;
        case 167:
          dropItem = 700;
          break;
        case 168:
          dropItem = 701;
          break;
        case 169:
          dropItem = 702;
          break;
        case 170:
          dropItem = 1872;
          break;
        case 171:
          if (tileCache.frameX < (short) 10)
            break;
          WorldGen.dropXmasTree(x, y, 0);
          WorldGen.dropXmasTree(x, y, 1);
          WorldGen.dropXmasTree(x, y, 2);
          WorldGen.dropXmasTree(x, y, 3);
          break;
        case 174:
          dropItem = 713;
          break;
        case 175:
          dropItem = 717;
          break;
        case 176:
          dropItem = 718;
          break;
        case 177:
          dropItem = 719;
          break;
        case 178:
          switch ((int) tileCache.frameX / 18)
          {
            case 0:
              dropItem = 181;
              return;
            case 1:
              dropItem = 180;
              return;
            case 2:
              dropItem = 177;
              return;
            case 3:
              dropItem = 179;
              return;
            case 4:
              dropItem = 178;
              return;
            case 5:
              dropItem = 182;
              return;
            case 6:
              dropItem = 999;
              return;
            default:
              return;
          }
        case 179:
        case 180:
        case 181:
        case 182:
        case 183:
        case 381:
        case 534:
        case 536:
        case 539:
          dropItem = 3;
          break;
        case 188:
          dropItem = 276;
          break;
        case 189:
          dropItem = 751;
          break;
        case 190:
          dropItem = 183;
          break;
        case 191:
          dropItem = 9;
          break;
        case 193:
          dropItem = 762;
          break;
        case 194:
          dropItem = 154;
          break;
        case 195:
          dropItem = 763;
          break;
        case 196:
          dropItem = 765;
          break;
        case 197:
          dropItem = 767;
          break;
        case 198:
          dropItem = 775;
          break;
        case 200:
          dropItem = 835;
          break;
        case 201:
          if (tileCache.frameX != (short) 270)
            break;
          dropItem = 2887;
          break;
        case 202:
          dropItem = 824;
          break;
        case 203:
          dropItem = 836;
          break;
        case 204:
          dropItem = 880;
          break;
        case 206:
          dropItem = 883;
          break;
        case 208:
          dropItem = 911;
          break;
        case 210:
          dropItem = 937;
          break;
        case 211:
          dropItem = 947;
          break;
        case 213:
          dropItem = 965;
          break;
        case 214:
          dropItem = 85;
          break;
        case 221:
          dropItem = 1104;
          break;
        case 222:
          dropItem = 1105;
          break;
        case 223:
          dropItem = 1106;
          break;
        case 224:
          dropItem = 1103;
          break;
        case 225:
          if (Main.rand.Next(3) == 0)
          {
            tileCache.honey(true);
            tileCache.liquid = byte.MaxValue;
            break;
          }
          dropItem = 1124;
          if (Main.netMode == 1 || Main.rand.Next(2) != 0)
            break;
          int num7 = 1;
          if (Main.rand.Next(3) == 0)
            num7 = 2;
          for (int index1 = 0; index1 < num7; ++index1)
          {
            int Type = Main.rand.Next(210, 212);
            int index2 = NPC.NewNPC(x * 16 + 8, y * 16 + 15, Type, 1, 0.0f, 0.0f, 0.0f, 0.0f, (int) byte.MaxValue);
            Main.npc[index2].velocity.X = (float) Main.rand.Next(-200, 201) * (1f / 500f);
            Main.npc[index2].velocity.Y = (float) Main.rand.Next(-200, 201) * (1f / 500f);
            Main.npc[index2].netUpdate = true;
          }
          break;
        case 226:
          dropItem = 1101;
          break;
        case 227:
          int num8 = (int) tileCache.frameX / 34;
          dropItem = 1107 + num8;
          if (num8 < 8 || num8 > 11)
            break;
          dropItem = 3385 + num8 - 8;
          break;
        case 229:
          dropItem = 1125;
          break;
        case 230:
          dropItem = 1127;
          break;
        case 232:
          dropItem = 1150;
          break;
        case 234:
          dropItem = 1246;
          break;
        case 239:
          int num9 = (int) tileCache.frameX / 18;
          if (num9 == 0)
            dropItem = 20;
          if (num9 == 1)
            dropItem = 703;
          if (num9 == 2)
            dropItem = 22;
          if (num9 == 3)
            dropItem = 704;
          if (num9 == 4)
            dropItem = 21;
          if (num9 == 5)
            dropItem = 705;
          if (num9 == 6)
            dropItem = 19;
          if (num9 == 7)
            dropItem = 706;
          if (num9 == 8)
            dropItem = 57;
          if (num9 == 9)
            dropItem = 117;
          if (num9 == 10)
            dropItem = 175;
          if (num9 == 11)
            dropItem = 381;
          if (num9 == 12)
            dropItem = 1184;
          if (num9 == 13)
            dropItem = 382;
          if (num9 == 14)
            dropItem = 1191;
          if (num9 == 15)
            dropItem = 391;
          if (num9 == 16)
            dropItem = 1198;
          if (num9 == 17)
            dropItem = 1006;
          if (num9 == 18)
            dropItem = 1225;
          if (num9 == 19)
            dropItem = 1257;
          if (num9 == 20)
            dropItem = 1552;
          if (num9 == 21)
            dropItem = 3261;
          if (num9 != 22)
            break;
          dropItem = 3467;
          break;
        case 248:
          dropItem = 1589;
          break;
        case 249:
          dropItem = 1591;
          break;
        case 250:
          dropItem = 1593;
          break;
        case 251:
          dropItem = 1725;
          break;
        case 252:
          dropItem = 1727;
          break;
        case 253:
          dropItem = 1729;
          break;
        case (ushort) byte.MaxValue:
        case 256:
        case 257:
        case 258:
        case 259:
        case 260:
        case 261:
          dropItem = 1970 + (int) tileCache.type - (int) byte.MaxValue;
          break;
        case 262:
        case 263:
        case 264:
        case 265:
        case 266:
        case 267:
        case 268:
          dropItem = 1970 + (int) tileCache.type - 262;
          break;
        case 272:
          dropItem = 1344;
          break;
        case 273:
          dropItem = 2119;
          break;
        case 274:
          dropItem = 2120;
          break;
        case 284:
          dropItem = 2173;
          break;
        case 311:
          dropItem = 2260;
          break;
        case 312:
          dropItem = 2261;
          break;
        case 313:
          dropItem = 2262;
          break;
        case 314:
          dropItem = Minecart.GetTrackItem(tileCache);
          break;
        case 315:
          dropItem = 2435;
          break;
        case 321:
          dropItem = 2503;
          break;
        case 322:
          dropItem = 2504;
          break;
        case 323:
          dropItem = 2504;
          if (tileCache.frameX <= (short) 132 && tileCache.frameX >= (short) 88)
            secondaryItem = 27;
          int index3 = x;
          int index4 = y;
          while (!Main.tile[index3, index4].active() || !Main.tileSolid[(int) Main.tile[index3, index4].type])
            ++index4;
          if (!Main.tile[index3, index4].active())
            break;
          switch (Main.tile[index3, index4].type)
          {
            case 112:
              dropItem = 619;
              return;
            case 116:
              dropItem = 621;
              return;
            case 234:
              dropItem = 911;
              return;
            default:
              return;
          }
        case 324:
          switch ((int) tileCache.frameY / 22)
          {
            case 0:
              dropItem = 2625;
              return;
            case 1:
              dropItem = 2626;
              return;
            case 2:
              dropItem = 4072;
              return;
            case 3:
              dropItem = 4073;
              return;
            case 4:
              dropItem = 4071;
              return;
            default:
              return;
          }
        case 325:
          dropItem = 2692;
          break;
        case 326:
          dropItem = 2693;
          break;
        case 327:
          dropItem = 2694;
          break;
        case 328:
          dropItem = 2695;
          break;
        case 329:
          dropItem = 2697;
          break;
        case 330:
          dropItem = 71;
          break;
        case 331:
          dropItem = 72;
          break;
        case 332:
          dropItem = 73;
          break;
        case 333:
          dropItem = 74;
          break;
        case 336:
          dropItem = 2701;
          break;
        case 340:
          dropItem = 2751;
          break;
        case 341:
          dropItem = 2752;
          break;
        case 342:
          dropItem = 2753;
          break;
        case 343:
          dropItem = 2754;
          break;
        case 344:
          dropItem = 2755;
          break;
        case 345:
          dropItem = 2787;
          break;
        case 346:
          dropItem = 2792;
          break;
        case 347:
          dropItem = 2793;
          break;
        case 348:
          dropItem = 2794;
          break;
        case 350:
          dropItem = 2860;
          break;
        case 351:
          dropItem = 2868;
          break;
        case 353:
          dropItem = 2996;
          break;
        case 357:
          dropItem = 3066;
          break;
        case 365:
          dropItem = 3077;
          break;
        case 366:
          dropItem = 3078;
          break;
        case 367:
          dropItem = 3081;
          break;
        case 368:
          dropItem = 3086;
          break;
        case 369:
          dropItem = 3087;
          break;
        case 370:
          dropItem = 3100;
          break;
        case 371:
          dropItem = 3113;
          break;
        case 372:
          dropItem = 3117;
          break;
        case 379:
          dropItem = 3214;
          break;
        case 380:
          int num10 = (int) tileCache.frameY / 18;
          dropItem = 3215 + num10;
          break;
        case 383:
          dropItem = 620;
          break;
        case 385:
          dropItem = 3234;
          break;
        case 396:
          dropItem = 3271;
          break;
        case 397:
          dropItem = 3272;
          break;
        case 398:
          dropItem = 3274;
          break;
        case 399:
          dropItem = 3275;
          break;
        case 400:
          dropItem = 3276;
          break;
        case 401:
          dropItem = 3277;
          break;
        case 402:
          dropItem = 3338;
          break;
        case 403:
          dropItem = 3339;
          break;
        case 404:
          dropItem = 3347;
          break;
        case 407:
          dropItem = 3380;
          break;
        case 408:
          dropItem = 3460;
          break;
        case 409:
          dropItem = 3461;
          break;
        case 415:
          dropItem = 3573;
          break;
        case 416:
          dropItem = 3574;
          break;
        case 417:
          dropItem = 3575;
          break;
        case 418:
          dropItem = 3576;
          break;
        case 419:
          switch ((int) tileCache.frameX / 18)
          {
            case 0:
              dropItem = 3602;
              return;
            case 1:
              dropItem = 3618;
              return;
            case 2:
              dropItem = 3663;
              return;
            default:
              return;
          }
        case 420:
          switch ((int) tileCache.frameY / 18)
          {
            case 0:
              dropItem = 3603;
              return;
            case 1:
              dropItem = 3604;
              return;
            case 2:
              dropItem = 3605;
              return;
            case 3:
              dropItem = 3606;
              return;
            case 4:
              dropItem = 3607;
              return;
            case 5:
              dropItem = 3608;
              return;
            default:
              return;
          }
        case 421:
          dropItem = 3609;
          break;
        case 422:
          dropItem = 3610;
          break;
        case 423:
          TELogicSensor.Kill(x, y);
          switch ((int) tileCache.frameY / 18)
          {
            case 0:
              dropItem = 3613;
              return;
            case 1:
              dropItem = 3614;
              return;
            case 2:
              dropItem = 3615;
              return;
            case 3:
              dropItem = 3726;
              return;
            case 4:
              dropItem = 3727;
              return;
            case 5:
              dropItem = 3728;
              return;
            case 6:
              dropItem = 3729;
              return;
            default:
              return;
          }
        case 424:
          dropItem = 3616;
          break;
        case 426:
          dropItem = 3621;
          break;
        case 427:
          dropItem = 3622;
          break;
        case 428:
          switch ((int) tileCache.frameY / 18)
          {
            case 0:
              dropItem = 3630;
              break;
            case 1:
              dropItem = 3632;
              break;
            case 2:
              dropItem = 3631;
              break;
            case 3:
              dropItem = 3626;
              break;
          }
          PressurePlateHelper.DestroyPlate(new Point(x, y));
          break;
        case 429:
          dropItem = 3629;
          break;
        case 430:
          dropItem = 3633;
          break;
        case 431:
          dropItem = 3634;
          break;
        case 432:
          dropItem = 3635;
          break;
        case 433:
          dropItem = 3636;
          break;
        case 434:
          dropItem = 3637;
          break;
        case 435:
          dropItem = 3638;
          break;
        case 436:
          dropItem = 3639;
          break;
        case 437:
          dropItem = 3640;
          break;
        case 438:
          dropItem = 3641;
          break;
        case 439:
          dropItem = 3642;
          break;
        case 442:
          dropItem = 3707;
          break;
        case 445:
          dropItem = 3725;
          break;
        case 446:
          dropItem = 3736;
          break;
        case 447:
          dropItem = 3737;
          break;
        case 448:
          dropItem = 3738;
          break;
        case 449:
          dropItem = 3739;
          break;
        case 450:
          dropItem = 3740;
          break;
        case 451:
          dropItem = 3741;
          break;
        case 458:
          dropItem = 3754;
          break;
        case 459:
          dropItem = 3755;
          break;
        case 460:
          dropItem = 3756;
          break;
        case 472:
          dropItem = 3951;
          break;
        case 473:
          dropItem = 3953;
          break;
        case 474:
          dropItem = 3955;
          break;
        case 476:
          dropItem = 4040;
          break;
        case 478:
          dropItem = 4050;
          break;
        case 479:
          dropItem = 4051;
          break;
        case 494:
          dropItem = 4089;
          break;
        case 495:
          dropItem = 4090;
          break;
        case 496:
          dropItem = 4091;
          break;
        case 498:
          dropItem = 4139;
          break;
        case 500:
          dropItem = 4229;
          break;
        case 501:
          dropItem = 4230;
          break;
        case 502:
          dropItem = 4231;
          break;
        case 503:
          dropItem = 4232;
          break;
        case 507:
          dropItem = 4277;
          break;
        case 508:
          dropItem = 4278;
          break;
        case 512:
        case 513:
        case 514:
        case 515:
        case 516:
        case 517:
        case 535:
        case 537:
        case 540:
          dropItem = 129;
          break;
        case 519:
          if (tileCache.frameY != (short) 90 || WorldGen.genRand.Next(2) != 0)
            break;
          dropItem = 183;
          break;
        case 520:
          dropItem = 4326;
          break;
        case 528:
          if (WorldGen.genRand.Next(2) != 0)
            break;
          dropItem = 183;
          break;
        case 541:
          dropItem = 4392;
          break;
        case 546:
        case 557:
          dropItem = 4422;
          break;
        case 561:
          dropItem = 4554;
          break;
        case 562:
          dropItem = 4564;
          break;
        case 563:
          dropItem = 4547;
          break;
        case 566:
          dropItem = 999;
          break;
        case 571:
          dropItem = 4564;
          dropItemStack = WorldGen.genRand.Next(1, 3);
          break;
        case 574:
          dropItem = 4717;
          break;
        case 575:
          dropItem = 4718;
          break;
        case 576:
          dropItem = 4719;
          break;
        case 577:
          dropItem = 4720;
          break;
        case 578:
          dropItem = 4721;
          break;
        case 579:
          dropItem = 4761;
          break;
        case 583:
          WorldGen.SetGemTreeDrops(180, 4851, tileCache, ref dropItem, ref secondaryItem);
          if (dropItem != 3)
            break;
          dropItemStack = Main.rand.Next(1, 3);
          break;
        case 584:
          WorldGen.SetGemTreeDrops(181, 4852, tileCache, ref dropItem, ref secondaryItem);
          if (dropItem != 3)
            break;
          dropItemStack = Main.rand.Next(1, 3);
          break;
        case 585:
          WorldGen.SetGemTreeDrops(177, 4853, tileCache, ref dropItem, ref secondaryItem);
          if (dropItem != 3)
            break;
          dropItemStack = Main.rand.Next(1, 3);
          break;
        case 586:
          WorldGen.SetGemTreeDrops(179, 4854, tileCache, ref dropItem, ref secondaryItem);
          if (dropItem != 3)
            break;
          dropItemStack = Main.rand.Next(1, 3);
          break;
        case 587:
          WorldGen.SetGemTreeDrops(178, 4855, tileCache, ref dropItem, ref secondaryItem);
          if (dropItem != 3)
            break;
          dropItemStack = Main.rand.Next(1, 3);
          break;
        case 588:
          WorldGen.SetGemTreeDrops(182, 4856, tileCache, ref dropItem, ref secondaryItem);
          if (dropItem != 3)
            break;
          dropItemStack = Main.rand.Next(1, 3);
          break;
        case 589:
          WorldGen.SetGemTreeDrops(999, 4857, tileCache, ref dropItem, ref secondaryItem);
          if (dropItem != 3)
            break;
          dropItemStack = Main.rand.Next(1, 3);
          break;
        case 593:
          dropItem = 4868;
          break;
        case 618:
          dropItem = 4962;
          break;
      }
    }

    private static void SetGemTreeDrops(
      int gemType,
      int seedType,
      Tile tileCache,
      ref int dropItem,
      ref int secondaryItem)
    {
      dropItem = Main.rand.Next(10) != 0 ? 3 : gemType;
      if (tileCache.frameX < (short) 22 || tileCache.frameY < (short) 198 || Main.rand.Next(2) != 0)
        return;
      secondaryItem = seedType;
    }

    private static void SetVanityTreeDrops(int dropType, Tile tileCache, ref int dropItem)
    {
      if (Main.rand.Next(2) != 0)
        return;
      dropItem = dropType;
    }

    public static bool IsHarvestableHerbWithSeed(int type, int style)
    {
      bool flag = false;
      if (type == 84)
        flag = true;
      if (style == 0 && Main.dayTime)
        flag = true;
      if (style == 1 && !Main.dayTime)
        flag = true;
      if (style == 3 && !Main.dayTime && (Main.bloodMoon || Main.moonPhase == 0))
        flag = true;
      if (style == 4 && (Main.raining || (double) Main.cloudAlpha > 0.0))
        flag = true;
      if (style == 5 && !Main.raining && (Main.dayTime && Main.time > 40500.0))
        flag = true;
      return flag;
    }

    private static bool KillTile_ShouldDropSeeds(int x, int y)
    {
      if (Main.rand.Next(2) != 0)
        return false;
      return WorldGen.GetPlayerForTile(x, y).HasItem(281) || WorldGen.GetPlayerForTile(x, y).HasItem(986);
    }

    private static void KillTile_GetTreeDrops(
      int i,
      int j,
      Tile tileCache,
      ref bool bonusWood,
      ref int dropItem,
      ref int secondaryItem)
    {
      if (tileCache.frameX >= (short) 22 && tileCache.frameY >= (short) 198)
      {
        if (Main.netMode != 1)
        {
          if (WorldGen.genRand.Next(2) == 0)
          {
            int index = j;
            while (Main.tile[i, index] != null && (!Main.tile[i, index].active() || !Main.tileSolid[(int) Main.tile[i, index].type] || Main.tileSolidTop[(int) Main.tile[i, index].type]))
              ++index;
            if (Main.tile[i, index] != null)
            {
              Tile tile = Main.tile[i, index];
              if (tile.type == (ushort) 2 || tile.type == (ushort) 109 || (tile.type == (ushort) 477 || tile.type == (ushort) 492) || (tile.type == (ushort) 147 || tile.type == (ushort) 199 || tile.type == (ushort) 23))
              {
                dropItem = 9;
                secondaryItem = 27;
              }
              else
                dropItem = 9;
            }
          }
          else
            dropItem = 9;
        }
      }
      else
        dropItem = 9;
      if (dropItem != 9)
        return;
      int x;
      int y;
      WorldGen.GetTreeBottom(i, j, out x, out y);
      if (Main.tile[x, y].active())
      {
        switch (Main.tile[x, y].type)
        {
          case 23:
            dropItem = 619;
            break;
          case 60:
            dropItem = 620;
            break;
          case 70:
            dropItem = WorldGen.genRand.Next(2) != 0 ? 0 : 183;
            break;
          case 109:
          case 492:
            dropItem = 621;
            break;
          case 147:
            dropItem = 2503;
            break;
          case 199:
            dropItem = 911;
            break;
        }
      }
      int closest = (int) Player.FindClosest(new Vector2((float) (x * 16), (float) (y * 16)), 16, 16);
      if (WorldGen.genRand.Next(100) >= Main.player[closest].inventory[Main.player[closest].selectedItem].axe && Main.rand.Next(3) != 0)
        return;
      bonusWood = true;
    }

    private static void KillTile_DropBait(int i, int j, Tile tileCache)
    {
      int maxValue1 = -1;
      int maxValue2 = -1;
      int maxValue3 = -1;
      int closest = (int) Player.FindClosest(new Vector2((float) (i * 16), (float) (j * 16)), 16, 16);
      if (tileCache.type == (ushort) 3)
      {
        maxValue1 = 400;
        maxValue2 = 100;
        if (Main.player[closest].flowerBoots && tileCache.frameX >= (short) 108)
        {
          maxValue1 *= 10000;
          maxValue2 *= 10000;
        }
      }
      if (tileCache.type == (ushort) 73)
      {
        maxValue1 = 200;
        maxValue2 = 50;
        if (Main.player[closest].flowerBoots && tileCache.frameX >= (short) 108)
        {
          maxValue1 *= 10000;
          maxValue2 *= 10000;
        }
      }
      if (tileCache.type == (ushort) 61)
      {
        maxValue3 = 80;
        if (Main.player[closest].flowerBoots && tileCache.frameX >= (short) 108)
          maxValue3 *= 10000;
      }
      if (tileCache.type == (ushort) 74)
      {
        maxValue3 = 40;
        if (Main.player[closest].flowerBoots && tileCache.frameX >= (short) 108)
          maxValue3 *= 10000;
      }
      if (tileCache.type == (ushort) 62)
        maxValue3 = 250;
      if (tileCache.type == (ushort) 185)
      {
        if (tileCache.frameY == (short) 0 && tileCache.frameX < (short) 214)
          maxValue1 = 6;
        if (tileCache.frameY == (short) 18 && (tileCache.frameX < (short) 214 || tileCache.frameX >= (short) 1368))
          maxValue1 = 6;
      }
      else if (tileCache.type == (ushort) 186)
      {
        if (tileCache.frameX >= (short) 378 && tileCache.frameX <= (short) 700)
          maxValue1 = 6;
      }
      else if (tileCache.type == (ushort) 187)
      {
        if (tileCache.frameX >= (short) 756 && tileCache.frameX <= (short) 916)
          maxValue1 = 6;
        if (tileCache.frameX <= (short) 322)
          maxValue1 = 6;
      }
      else if (tileCache.type == (ushort) 233)
        maxValue3 = 10;
      int Type1 = 357;
      if (Main.player[closest].ZoneGraveyard)
        Type1 = 606;
      if (maxValue1 > 0 && NPC.CountNPCS(Type1) < 5 && WorldGen.genRand.Next(maxValue1) == 0)
      {
        int Type2 = Type1;
        if (Type1 == 357 && (double) Player.GetClosestRollLuck(i, j, NPC.goldCritterChance) == 0.0)
          Type2 = 448;
        int index = NPC.NewNPC(i * 16 + 10, j * 16, Type2, 0, 0.0f, 0.0f, 0.0f, 0.0f, (int) byte.MaxValue);
        Main.npc[index].TargetClosest(true);
        Main.npc[index].velocity.Y = (float) WorldGen.genRand.Next(-50, -21) * 0.1f;
        Main.npc[index].velocity.X = (float) WorldGen.genRand.Next(0, 26) * 0.1f * (float) -Main.npc[index].direction;
        Main.npc[index].direction *= -1;
        Main.npc[index].netUpdate = true;
      }
      if (maxValue2 > 0 && NPC.CountNPCS(377) < 5 && WorldGen.genRand.Next(maxValue2) == 0)
      {
        int Type2 = 377;
        if ((double) Player.GetClosestRollLuck(i, j, NPC.goldCritterChance) == 0.0)
          Type2 = 446;
        int index = NPC.NewNPC(i * 16 + 10, j * 16, Type2, 0, 0.0f, 0.0f, 0.0f, 0.0f, (int) byte.MaxValue);
        Main.npc[index].TargetClosest(true);
        Main.npc[index].velocity.Y = (float) WorldGen.genRand.Next(-50, -21) * 0.1f;
        Main.npc[index].velocity.X = (float) WorldGen.genRand.Next(0, 26) * 0.1f * (float) -Main.npc[index].direction;
        Main.npc[index].direction *= -1;
        Main.npc[index].netUpdate = true;
      }
      if (maxValue3 <= 0 || NPC.CountNPCS(485) + NPC.CountNPCS(486) + NPC.CountNPCS(487) >= 8 || WorldGen.genRand.Next(maxValue3) != 0)
        return;
      int Type3 = 485;
      if (WorldGen.genRand.Next(4) == 0)
        Type3 = 486;
      if (WorldGen.genRand.Next(12) == 0)
        Type3 = 487;
      int index1 = NPC.NewNPC(i * 16 + 10, j * 16, Type3, 0, 0.0f, 0.0f, 0.0f, 0.0f, (int) byte.MaxValue);
      Main.npc[index1].TargetClosest(true);
      Main.npc[index1].velocity.Y = (float) WorldGen.genRand.Next(-50, -21) * 0.1f;
      Main.npc[index1].velocity.X = (float) WorldGen.genRand.Next(0, 26) * 0.1f * (float) -Main.npc[index1].direction;
      Main.npc[index1].direction *= -1;
      Main.npc[index1].netUpdate = true;
    }

    public static void KillTile_PlaySounds(int i, int j, bool fail, Tile tileCache)
    {
      if (WorldGen.gen)
        return;
      int type = (int) tileCache.type;
      if (type == (int) sbyte.MaxValue)
        SoundEngine.PlaySound(SoundID.Item27, i * 16, j * 16);
      else if (type == 147 || type == 224)
      {
        if (WorldGen.genRand.Next(2) == 0)
          SoundEngine.PlaySound(SoundID.Item48, i * 16, j * 16);
        else
          SoundEngine.PlaySound(SoundID.Item49, i * 16, j * 16);
      }
      else if (type == 161 || type == 163 || (type == 164 || type == 200) || type == 541)
        SoundEngine.PlaySound(SoundID.Item50, i * 16, j * 16);
      else if (type == 518 || type == 519 || (type == 528 || type == 529) || type == 549)
        SoundEngine.PlaySound(6, i * 16, j * 16, 1, 1f, 0.0f);
      else if (type == 530 && tileCache.frameX < (short) 270)
        SoundEngine.PlaySound(6, i * 16, j * 16, 1, 1f, 0.0f);
      else if (type == 3 || type == 110)
      {
        SoundEngine.PlaySound(6, i * 16, j * 16, 1, 1f, 0.0f);
      }
      else
      {
        switch (type)
        {
          case 24:
            SoundEngine.PlaySound(6, i * 16, j * 16, 1, 1f, 0.0f);
            break;
          case 254:
            SoundEngine.PlaySound(6, i * 16, j * 16, 1, 1f, 0.0f);
            break;
          default:
            if (Main.tileAlch[type] || type == 384 || (type == 227 || type == 32) || (type == 51 || type == 52 || (type == 61 || type == 62)) || (type == 69 || type == 71 || (type == 73 || type == 74) || (type == 113 || type == 115 || (type == 184 || type == 192))) || (type == 205 || type == 233 || (type == 352 || type == 382)))
            {
              SoundEngine.PlaySound(6, i * 16, j * 16, 1, 1f, 0.0f);
              break;
            }
            switch (type)
            {
              case 201:
                SoundEngine.PlaySound(6, i * 16, j * 16, 1, 1f, 0.0f);
                break;
              case 485:
                SoundEngine.PlaySound(4, i * 16, j * 16, 11, 1f, 0.0f);
                break;
              default:
                if (type == 481 || type == 482 || type == 483)
                {
                  SoundEngine.PlaySound(SoundID.Item127, i * 16, j * 16);
                  break;
                }
                if (type == 1 || type == 6 || (type == 7 || type == 8) || (type == 9 || type == 22 || (type == 140 || type == 25)) || (type == 37 || type == 38 || (type == 39 || type == 41) || (type == 43 || type == 44 || (type == 45 || type == 46))) || (type == 47 || type == 48 || (type == 56 || type == 58) || (type == 63 || type == 64 || (type == 65 || type == 66)) || (type == 67 || type == 68 || (type == 75 || type == 76) || (type == 107 || type == 108 || (type == 111 || type == 117)))) || (type == 118 || type == 119 || (type == 120 || type == 121) || (type == 122 || type == 150 || (type == 151 || type == 152)) || (type == 153 || type == 154 || (type == 155 || type == 156) || (type == 160 || type == 161 || (type == 166 || type == 167))) || (type == 168 || type == 169 || (type == 175 || type == 176) || (type == 177 || type == 203 || (type == 202 || type == 204)) || (type == 206 || type == 211 || (type == 221 || type == 222) || (type == 223 || type == 226 || (type == 248 || type == 249))))) || (type == 250 || type == 272 || (type == 273 || type == 274) || (type == 478 || type == 284 || (type == 325 || type == 346)) || (type == 347 || type == 348 || (type == 350 || type == 367) || (type == 357 || type == 368 || (type == 369 || type == 370))) || (type == 407 || type == 472 || (type == 473 || type == 500) || (type == 501 || type == 502 || (type == 503 || type == 546)) || (type == 557 || type == 566 || type == 618))))
                {
                  SoundEngine.PlaySound(21, i * 16, j * 16, 1, 1f, 0.0f);
                  break;
                }
                if (type == 231 || type == 195 || type == 474)
                {
                  SoundEngine.PlaySound(4, i * 16, j * 16, 1, 1f, 0.0f);
                  break;
                }
                if (type == 26 && tileCache.frameX >= (short) 54)
                {
                  SoundEngine.PlaySound(4, i * 16, j * 16, 1, 1f, 0.0f);
                  break;
                }
                if (type == 314)
                {
                  SoundEngine.PlaySound(SoundID.Item52, i * 16, j * 16);
                  break;
                }
                if (type >= 330 && type <= 333)
                {
                  SoundEngine.PlaySound(18, i * 16, j * 16, 1, 1f, 0.0f);
                  break;
                }
                if ((type == 162 || type == 385 || type == 129 || type == 165 && tileCache.frameX < (short) 54) && !fail)
                {
                  SoundEngine.PlaySound(SoundID.Item27, i * 16, j * 16);
                  break;
                }
                if (type != 138)
                {
                  SoundEngine.PlaySound(0, i * 16, j * 16, 1, 1f, 0.0f);
                  break;
                }
                break;
            }
            break;
        }
      }
      if (fail)
        return;
      if (tileCache.type == (ushort) 13)
        SoundEngine.PlaySound(13, i * 16, j * 16, 1, 1f, 0.0f);
      else if (tileCache.type == (ushort) 54)
        SoundEngine.PlaySound(13, i * 16, j * 16, 1, 1f, 0.0f);
      else if (tileCache.type == (ushort) 326)
        SoundEngine.PlaySound(13, i * 16, j * 16, 1, 1f, 0.0f);
      else if (tileCache.type == (ushort) 327)
        SoundEngine.PlaySound(13, i * 16, j * 16, 1, 1f, 0.0f);
      else if (tileCache.type == (ushort) 458)
        SoundEngine.PlaySound(13, i * 16, j * 16, 1, 1f, 0.0f);
      else if (tileCache.type == (ushort) 459)
        SoundEngine.PlaySound(13, i * 16, j * 16, 1, 1f, 0.0f);
      else if (tileCache.type == (ushort) 345)
        SoundEngine.PlaySound(13, i * 16, j * 16, 1, 1f, 0.0f);
      else if (tileCache.type == (ushort) 328)
        SoundEngine.PlaySound(13, i * 16, j * 16, 1, 1f, 0.0f);
      else if (tileCache.type == (ushort) 329)
        SoundEngine.PlaySound(13, i * 16, j * 16, 1, 1f, 0.0f);
      else if (tileCache.type == (ushort) 507)
      {
        SoundEngine.PlaySound(13, i * 16, j * 16, 1, 1f, 0.0f);
      }
      else
      {
        if (tileCache.type != (ushort) 508)
          return;
        SoundEngine.PlaySound(13, i * 16, j * 16, 1, 1f, 0.0f);
      }
    }

    public static Microsoft.Xna.Framework.Rectangle? GetTileVisualHitbox(int x, int y)
    {
      Tile tile = Main.tile[x, y];
      if (tile == null || !tile.nactive())
        return new Microsoft.Xna.Framework.Rectangle?();
      Microsoft.Xna.Framework.Rectangle rectangle = new Microsoft.Xna.Framework.Rectangle(x * 16, y * 16, 16, 16);
      if (tile.type == (ushort) 323)
        rectangle.X += (int) tile.frameY;
      if (tile.halfBrick())
      {
        rectangle.Y += 8;
        rectangle.Height = 8;
      }
      return new Microsoft.Xna.Framework.Rectangle?(rectangle);
    }

    public static int KillTile_GetTileDustAmount(bool fail, Tile tileCache)
    {
      switch (tileCache.type)
      {
        case 125:
        case 138:
        case 172:
        case 287:
        case 300:
        case 301:
        case 302:
        case 303:
        case 304:
        case 305:
        case 306:
        case 307:
        case 308:
        case 354:
        case 355:
        case 373:
        case 374:
        case 375:
        case 376:
        case 461:
        case 484:
        case 499:
        case 564:
        case 565:
        case 593:
        case 594:
        case 617:
          return 0;
        case 184:
          if ((int) tileCache.frameX / 22 >= 5)
            return 5;
          return !fail ? 10 : 3;
        case 231:
          return !fail ? 6 : 3;
        case 481:
        case 482:
        case 483:
          return 3;
        case 534:
        case 536:
        case 539:
          return !fail ? 5 : 3;
        case 541:
          return 1;
        case 549:
          return 2;
        default:
          return !fail ? 10 : 3;
      }
    }

    public static int KillTile_MakeTileDust(int i, int j, Tile tileCache)
    {
      int Type1 = 0;
      if (tileCache.type == (ushort) 216)
        Type1 = -1;
      if (tileCache.type == (ushort) 324)
        Type1 = tileCache.frameY != (short) 0 ? 281 + (int) tileCache.frameX / 18 : 280;
      if (tileCache.type == (ushort) 216)
        Type1 = -1;
      if (tileCache.type == (ushort) 335)
        Type1 = -1;
      if (tileCache.type == (ushort) 338)
        Type1 = -1;
      if (tileCache.type == (ushort) 0)
        Type1 = 0;
      if (tileCache.type == (ushort) 192)
        Type1 = 3;
      if (tileCache.type == (ushort) 208)
        Type1 = 126;
      else if (tileCache.type == (ushort) 408 || tileCache.type == (ushort) 409)
        Type1 = 265;
      if (tileCache.type == (ushort) 16)
      {
        Type1 = 1;
        if (tileCache.frameX >= (short) 36)
          Type1 = 82;
      }
      else if (tileCache.type == (ushort) 415 || tileCache.type == (ushort) 500)
        Type1 = 6;
      else if (tileCache.type == (ushort) 416 || tileCache.type == (ushort) 501)
        Type1 = 61;
      else if (tileCache.type == (ushort) 417 || tileCache.type == (ushort) 502)
        Type1 = 242;
      else if (tileCache.type == (ushort) 418 || tileCache.type == (ushort) 503)
        Type1 = 135;
      else if (tileCache.type == (ushort) 474)
        Type1 = 18;
      if (tileCache.type == (ushort) 1 || tileCache.type == (ushort) 17 || (tileCache.type == (ushort) 38 || tileCache.type == (ushort) 39) || (tileCache.type == (ushort) 41 || tileCache.type == (ushort) 43 || (tileCache.type == (ushort) 44 || tileCache.type == (ushort) 481)) || (tileCache.type == (ushort) 482 || tileCache.type == (ushort) 483 || (tileCache.type == (ushort) 48 || Main.tileStone[(int) tileCache.type]) || (tileCache.type == (ushort) 85 || tileCache.type == (ushort) 90 || (tileCache.type == (ushort) 92 || tileCache.type == (ushort) 96))) || (tileCache.type == (ushort) 97 || tileCache.type == (ushort) 99 || (tileCache.type == (ushort) 117 || tileCache.type == (ushort) 130) || (tileCache.type == (ushort) 131 || tileCache.type == (ushort) 132 || (tileCache.type == (ushort) 135 || tileCache.type == (ushort) 135)) || (tileCache.type == (ushort) 142 || tileCache.type == (ushort) 143 || (tileCache.type == (ushort) 144 || tileCache.type == (ushort) 210) || (tileCache.type == (ushort) 207 || tileCache.type == (ushort) 235 || (tileCache.type == (ushort) 247 || tileCache.type == (ushort) 272)))) || (tileCache.type == (ushort) 273 || tileCache.type == (ushort) 283 || (tileCache.type == (ushort) 410 || tileCache.type == (ushort) 480) || (tileCache.type == (ushort) 509 || tileCache.type == (ushort) 618)))
        Type1 = 1;
      if (tileCache.type == (ushort) 379)
        Type1 = 257;
      if (tileCache.type == (ushort) 311)
        Type1 = 207;
      if (tileCache.type == (ushort) 312)
        Type1 = 208;
      if (tileCache.type == (ushort) 313)
        Type1 = 209;
      if (tileCache.type == (ushort) 104)
        Type1 = -1;
      if (tileCache.type == (ushort) 95 || tileCache.type == (ushort) 98 || (tileCache.type == (ushort) 100 || tileCache.type == (ushort) 174) || tileCache.type == (ushort) 173)
        Type1 = 6;
      if (tileCache.type == (ushort) 30 || tileCache.type == (ushort) 86 || (tileCache.type == (ushort) 94 || tileCache.type == (ushort) 106) || (tileCache.type == (ushort) 114 || tileCache.type == (ushort) 124 || (tileCache.type == (ushort) 128 || tileCache.type == (ushort) 269)))
        Type1 = 7;
      if (tileCache.type == (ushort) 372)
        Type1 = 242;
      if (tileCache.type == (ushort) 371)
        Type1 = 243;
      if (tileCache.type == (ushort) 334)
        Type1 = 7;
      switch (tileCache.type)
      {
        case 10:
        case 11:
        case 87:
        case 89:
        case 93:
        case 139:
        case 209:
        case 319:
        case 320:
        case 386:
        case 387:
        case 390:
        case 405:
        case 406:
        case 411:
        case 412:
        case 419:
        case 420:
        case 421:
        case 422:
        case 423:
        case 424:
        case 425:
        case 428:
        case 429:
        case 441:
        case 442:
        case 445:
        case 446:
        case 447:
        case 448:
        case 449:
        case 450:
        case 451:
        case 452:
        case 453:
        case 455:
        case 456:
        case 457:
        case 462:
        case 463:
        case 464:
        case 465:
        case 466:
        case 468:
        case 476:
        case 486:
        case 487:
        case 489:
        case 490:
        case 491:
        case 493:
        case 494:
        case 497:
        case 510:
        case 511:
        case 520:
        case 521:
        case 522:
        case 523:
        case 524:
        case 525:
        case 526:
        case 527:
        case 531:
        case 545:
        case 547:
        case 548:
        case 560:
        case 564:
        case 565:
        case 567:
        case 572:
        case 579:
        case 591:
        case 592:
        case 593:
        case 594:
        case 613:
        case 614:
        case 621:
        case 622:
          Type1 = -1;
          break;
        case 41:
        case 481:
          Type1 = 275;
          break;
        case 43:
        case 482:
          Type1 = 276;
          break;
        case 44:
        case 483:
          Type1 = 277;
          break;
        case 184:
          int num1 = (int) tileCache.frameX / 22;
          switch (num1)
          {
            case 5:
              Type1 = 258;
              break;
            case 6:
              Type1 = 299;
              break;
            case 7:
              Type1 = 300;
              break;
            case 8:
              Type1 = 301;
              break;
            default:
              Type1 = 93 + num1;
              break;
          }
          break;
        case 407:
          Type1 = 10;
          break;
        case 454:
          Type1 = 139;
          break;
        case 472:
        case 546:
        case 557:
          Type1 = 8;
          break;
        case 473:
          Type1 = 82;
          break;
        case 498:
          Type1 = 30;
          break;
        case 512:
          Type1 = 93;
          break;
        case 513:
          Type1 = 94;
          break;
        case 514:
          Type1 = 95;
          break;
        case 515:
          Type1 = 96;
          break;
        case 516:
          Type1 = 97;
          break;
        case 517:
          Type1 = 258;
          break;
        case 535:
          Type1 = 299;
          break;
        case 537:
          Type1 = 300;
          break;
        case 540:
          Type1 = 301;
          break;
        case 541:
          Type1 = 226;
          break;
        case 583:
          Type1 = WorldGen.genRand.Next(10) == 0 ? 87 : 1;
          break;
        case 584:
          Type1 = WorldGen.genRand.Next(10) == 0 ? 86 : 1;
          break;
        case 585:
          Type1 = WorldGen.genRand.Next(10) == 0 ? 88 : 1;
          break;
        case 586:
          Type1 = WorldGen.genRand.Next(10) == 0 ? 89 : 1;
          break;
        case 587:
          Type1 = WorldGen.genRand.Next(10) == 0 ? 90 : 1;
          break;
        case 588:
          Type1 = WorldGen.genRand.Next(10) == 0 ? 91 : 1;
          break;
        case 589:
          Type1 = WorldGen.genRand.Next(10) == 0 ? 138 : 1;
          break;
        case 590:
          Type1 = 1;
          break;
        case 595:
          Type1 = 78;
          break;
        case 596:
          Type1 = 78;
          break;
        case 615:
          Type1 = 78;
          break;
        case 616:
          Type1 = 78;
          break;
      }
      if (Main.tileMoss[(int) tileCache.type])
        Type1 = tileCache.type != (ushort) 381 ? (tileCache.type != (ushort) 534 ? (tileCache.type != (ushort) 536 ? (tileCache.type != (ushort) 539 ? (int) tileCache.type - 179 + 93 : 301) : 300) : 299) : 258;
      if (tileCache.type == (ushort) 240)
      {
        int num2 = (int) tileCache.frameX / 54;
        if (tileCache.frameY >= (short) 54)
          num2 += 36;
        Type1 = 7;
        if (num2 == 16 || num2 == 17)
          Type1 = 26;
        if (num2 >= 46 && num2 <= 49)
          Type1 = -1;
      }
      if (tileCache.type == (ushort) 241)
        Type1 = 1;
      if (tileCache.type == (ushort) 242)
        Type1 = -1;
      int num3;
      if (tileCache.type == (ushort) 529)
      {
        switch (Main.tile[i, j + 1].type)
        {
          case 112:
            Type1 = num3 = 17;
            break;
          case 116:
            Type1 = num3 = 47;
            break;
          case 234:
            Type1 = num3 = 125;
            break;
          default:
            Type1 = i < WorldGen.beachDistance || i > Main.maxTilesX - WorldGen.beachDistance ? 290 : 289;
            break;
        }
      }
      if (tileCache.type == (ushort) 356)
        Type1 = -1;
      if (tileCache.type == (ushort) 351)
        Type1 = -1;
      if (tileCache.type == (ushort) 246)
        Type1 = -1;
      if (tileCache.type == (ushort) 36)
        Type1 = -1;
      if (tileCache.type == (ushort) 365)
        Type1 = 239;
      if (tileCache.type == (ushort) 366)
        Type1 = 30;
      if (tileCache.type == (ushort) 504)
        Type1 = -1;
      if (tileCache.type == (ushort) 357 || tileCache.type == (ushort) 367 || tileCache.type == (ushort) 561)
        Type1 = 236;
      if (tileCache.type == (ushort) 368 || tileCache.type == (ushort) 369 || tileCache.type == (ushort) 576)
        Type1 = 240;
      if (tileCache.type == (ushort) 170)
        Type1 = 196;
      if (tileCache.type == (ushort) 315)
        Type1 = 225;
      if (tileCache.type == (ushort) 346)
        Type1 = 128;
      if (tileCache.type == (ushort) 347)
        Type1 = 117;
      if (tileCache.type == (ushort) 348)
        Type1 = 42;
      if (tileCache.type == (ushort) 350)
        Type1 = 226;
      if (tileCache.type == (ushort) 370)
        Type1 = WorldGen.genRand.Next(2) != 0 ? 23 : 6;
      if (tileCache.type == (ushort) 171)
        Type1 = WorldGen.genRand.Next(2) != 0 ? -1 : 196;
      if (tileCache.type == (ushort) 326)
        Type1 = 13;
      if (tileCache.type == (ushort) 327)
        Type1 = 13;
      if (tileCache.type == (ushort) 345)
        Type1 = 13;
      if (tileCache.type == (ushort) 458)
        Type1 = 13;
      if (tileCache.type == (ushort) 459)
        Type1 = 13;
      if (tileCache.type == (ushort) 336)
        Type1 = 6;
      if (tileCache.type == (ushort) 340)
        Type1 = 75;
      if (tileCache.type == (ushort) 341)
        Type1 = 65;
      if (tileCache.type == (ushort) 342)
        Type1 = 135;
      if (tileCache.type == (ushort) 343)
        Type1 = 169;
      if (tileCache.type == (ushort) 344)
        Type1 = 156;
      if (tileCache.type == (ushort) 328)
        Type1 = 13;
      if (tileCache.type == (ushort) 329)
        Type1 = 13;
      if (tileCache.type == (ushort) 507)
        Type1 = 13;
      if (tileCache.type == (ushort) 508)
        Type1 = 13;
      if (tileCache.type == (ushort) 562)
        Type1 = -1;
      if (tileCache.type == (ushort) 571)
        Type1 = 40;
      if (tileCache.type == (ushort) 563)
        Type1 = -1;
      if (tileCache.type == (ushort) 330)
        Type1 = 9;
      if (tileCache.type == (ushort) 331)
        Type1 = 11;
      if (tileCache.type == (ushort) 332)
        Type1 = 19;
      if (tileCache.type == (ushort) 333)
        Type1 = 11;
      if (tileCache.type == (ushort) 101)
        Type1 = -1;
      if (tileCache.type == (ushort) 19)
      {
        switch ((int) tileCache.frameY / 18)
        {
          case 0:
            Type1 = 7;
            break;
          case 1:
            Type1 = 77;
            break;
          case 2:
            Type1 = 78;
            break;
          case 3:
            Type1 = 79;
            break;
          case 4:
            Type1 = 26;
            break;
          case 5:
            Type1 = 126;
            break;
          case 6:
            Type1 = 275;
            break;
          case 7:
            Type1 = 277;
            break;
          case 8:
            Type1 = 276;
            break;
          case 9:
            Type1 = 1;
            break;
          case 10:
            Type1 = 214;
            break;
          case 11:
            Type1 = 214;
            break;
          case 12:
            Type1 = 214;
            break;
          case 13:
            Type1 = 109;
            break;
          case 14:
            Type1 = 13;
            break;
          case 15:
            Type1 = 189;
            break;
          case 16:
            Type1 = 191;
            break;
          case 17:
            Type1 = 215;
            break;
          case 18:
            Type1 = 26;
            break;
          case 19:
            Type1 = 214;
            break;
          case 20:
            Type1 = 4;
            break;
          case 21:
            Type1 = 10;
            break;
          case 22:
            Type1 = 32;
            break;
          case 23:
            Type1 = 78;
            break;
          case 24:
            Type1 = 147;
            break;
          case 25:
            Type1 = 40;
            break;
          case 26:
            Type1 = 226;
            break;
          case 27:
            Type1 = 23;
            break;
          case 28:
            Type1 = 240;
            break;
          case 29:
            Type1 = 236;
            break;
          case 30:
            Type1 = 68 + Main.rand.Next(3);
            break;
          case 31:
            Type1 = 10;
            break;
          case 32:
            Type1 = 78;
            break;
          case 33:
            Type1 = 148;
            break;
          case 34:
            Type1 = 5;
            break;
          case 35:
            Type1 = 80;
            break;
          case 37:
            Type1 = 18;
            break;
          case 38:
            Type1 = 6;
            break;
          case 39:
            Type1 = 61;
            break;
          case 40:
            Type1 = 242;
            break;
          case 41:
            Type1 = 135;
            break;
          case 42:
            Type1 = 287;
            break;
          case 44:
            Type1 = -1;
            break;
          default:
            Type1 = 1;
            break;
        }
      }
      if (tileCache.type == (ushort) 79)
      {
        int num2 = (int) tileCache.frameY / 36;
        Type1 = num2 != 0 ? (num2 != 1 ? (num2 != 2 ? (num2 != 3 ? (num2 != 4 ? (num2 != 8 ? (num2 < 9 ? 1 : -1) : 109) : 126) : 79) : 78) : 77) : 7;
      }
      if (tileCache.type == (ushort) 18)
      {
        switch ((int) tileCache.frameX / 36)
        {
          case 0:
            Type1 = 7;
            break;
          case 1:
            Type1 = 77;
            break;
          case 2:
            Type1 = 78;
            break;
          case 3:
            Type1 = 79;
            break;
          case 4:
            Type1 = 26;
            break;
          case 5:
            Type1 = 40;
            break;
          case 6:
            Type1 = 5;
            break;
          case 7:
            Type1 = 26;
            break;
          case 8:
            Type1 = 4;
            break;
          case 9:
            Type1 = 126;
            break;
          case 10:
            Type1 = 148;
            break;
          case 11:
          case 12:
          case 13:
            Type1 = 1;
            break;
          case 14:
            Type1 = 109;
            break;
          case 15:
            Type1 = 126;
            break;
          default:
            Type1 = -1;
            break;
        }
      }
      if (tileCache.type == (ushort) 14 || tileCache.type == (ushort) 87 || (tileCache.type == (ushort) 88 || tileCache.type == (ushort) 469))
        Type1 = -1;
      if (tileCache.type >= (ushort) byte.MaxValue && tileCache.type <= (ushort) 261)
      {
        int num2 = (int) tileCache.type - (int) byte.MaxValue;
        Type1 = 86 + num2;
        if (num2 == 6)
          Type1 = 138;
      }
      if (tileCache.type >= (ushort) 262 && tileCache.type <= (ushort) 268)
      {
        int num2 = (int) tileCache.type - 262;
        Type1 = 86 + num2;
        if (num2 == 6)
          Type1 = 138;
      }
      if (tileCache.type == (ushort) 178)
      {
        int num2 = (int) tileCache.frameX / 18;
        Type1 = 86 + num2;
        if (num2 == 6)
          Type1 = 138;
      }
      if (tileCache.type == (ushort) 440)
      {
        switch ((int) tileCache.frameX / 54)
        {
          case 0:
            Type1 = 90;
            break;
          case 1:
            Type1 = 88;
            break;
          case 2:
            Type1 = 89;
            break;
          case 3:
            Type1 = 87;
            break;
          case 4:
            Type1 = 86;
            break;
          case 5:
            Type1 = 91;
            break;
          case 6:
            Type1 = 138;
            break;
          default:
            Type1 = -1;
            break;
        }
        if (tileCache.frameY < (short) 54)
          Type1 = -1;
      }
      switch (tileCache.type)
      {
        case 426:
        case 427:
          Type1 = 90;
          break;
        case 430:
        case 435:
          Type1 = 89;
          break;
        case 431:
        case 436:
          Type1 = 88;
          break;
        case 432:
        case 437:
          Type1 = 87;
          break;
        case 433:
        case 438:
          Type1 = 86;
          break;
        case 434:
        case 439:
          Type1 = 91;
          break;
        case 496:
          Type1 = 109;
          break;
        case 549:
          Type1 = 3;
          break;
        case 552:
          Type1 = 32;
          break;
      }
      if (tileCache.type == (ushort) 186)
        Type1 = tileCache.frameX > (short) 360 ? (tileCache.frameX > (short) 846 ? (tileCache.frameX > (short) 954 ? (tileCache.frameX > (short) 1062 ? (tileCache.frameX > (short) 1170 ? (tileCache.frameX > (short) 1332 ? (tileCache.frameX > (short) 1386 ? 80 : 10) : 0) : 10) : 11) : 9) : 1) : 26;
      if (tileCache.type == (ushort) 187)
      {
        if (tileCache.frameX <= (short) 144)
          Type1 = 1;
        else if (tileCache.frameX <= (short) 306)
          Type1 = 38;
        else if (tileCache.frameX <= (short) 468)
          Type1 = 36;
        else if (tileCache.frameX <= (short) 738)
          Type1 = 30;
        else if (tileCache.frameX <= (short) 970)
          Type1 = 1;
        else if (tileCache.frameX <= (short) 1132)
          Type1 = 148;
        else if (tileCache.frameX <= (short) 1132)
          Type1 = 155;
        else if (tileCache.frameX <= (short) 1348)
          Type1 = 1;
        else if (tileCache.frameX <= (short) 1564)
          Type1 = 0;
        else if (tileCache.frameX <= (short) 1890)
          Type1 = 250;
        else if (tileCache.frameX <= (short) 2196)
          Type1 = 240;
        else if (tileCache.frameX <= (short) 2520)
          Type1 = 236;
      }
      if (tileCache.type == (ushort) 105)
      {
        Type1 = 1;
        if (tileCache.frameX >= (short) 1548 && tileCache.frameX <= (short) 1654 && tileCache.frameY < (short) 54)
          Type1 = 148;
      }
      if (tileCache.type == (ushort) 349)
        Type1 = 1;
      if (tileCache.type == (ushort) 337 || tileCache.type == (ushort) 506)
        Type1 = 1;
      if (tileCache.type == (ushort) 239)
      {
        int num2 = (int) tileCache.frameX / 18;
        if (num2 == 0)
          Type1 = 9;
        if (num2 == 1)
          Type1 = 81;
        if (num2 == 2)
          Type1 = 8;
        if (num2 == 3)
          Type1 = 82;
        if (num2 == 4)
          Type1 = 11;
        if (num2 == 5)
          Type1 = 83;
        if (num2 == 6)
          Type1 = 10;
        if (num2 == 7)
          Type1 = 84;
        if (num2 == 8)
          Type1 = 14;
        if (num2 == 9)
          Type1 = 23;
        if (num2 == 10)
          Type1 = 25;
        if (num2 == 11)
          Type1 = 48;
        if (num2 == 12)
          Type1 = 144;
        if (num2 == 13)
          Type1 = 49;
        if (num2 == 14)
          Type1 = 145;
        if (num2 == 15)
          Type1 = 50;
        if (num2 == 16)
          Type1 = 146;
        if (num2 == 17)
          Type1 = 128;
        if (num2 == 18)
          Type1 = 84;
        if (num2 == 19)
          Type1 = 117;
        if (num2 == 20)
          Type1 = 42;
        if (num2 == 21)
          Type1 = -1;
        if (num2 == 22)
          Type1 = 265;
      }
      if (tileCache.type == (ushort) 185)
      {
        if (tileCache.frameY == (short) 18)
        {
          int num2 = (int) tileCache.frameX / 36;
          if (num2 < 6)
            Type1 = 1;
          else if (num2 < 16)
          {
            Type1 = 26;
          }
          else
          {
            switch (num2)
            {
              case 16:
                Type1 = 9;
                break;
              case 17:
                Type1 = 11;
                break;
              case 18:
                Type1 = 10;
                break;
              case 19:
                Type1 = 86;
                break;
              case 20:
                Type1 = 87;
                break;
              case 21:
                Type1 = 88;
                break;
              case 22:
                Type1 = 89;
                break;
              case 23:
                Type1 = 90;
                break;
              case 24:
                Type1 = 91;
                break;
              default:
                if (num2 < 31)
                {
                  Type1 = 80;
                  break;
                }
                if (num2 < 33)
                {
                  Type1 = 7;
                  break;
                }
                if (num2 < 34)
                {
                  Type1 = 8;
                  break;
                }
                if (num2 < 39)
                {
                  Type1 = 30;
                  break;
                }
                if (num2 < 42)
                {
                  Type1 = 1;
                  break;
                }
                if (num2 < 48)
                {
                  Type1 = 32;
                  break;
                }
                if (num2 < 54)
                {
                  Type1 = 240;
                  break;
                }
                if (num2 < 60)
                {
                  Type1 = 236;
                  break;
                }
                break;
            }
          }
        }
        else
        {
          int num2 = (int) tileCache.frameX / 18;
          if (num2 < 6)
            Type1 = 1;
          else if (num2 < 12)
            Type1 = 0;
          else if (num2 < 27)
            Type1 = 26;
          else if (num2 < 32)
            Type1 = 1;
          else if (num2 < 35)
            Type1 = 0;
          else if (num2 < 46)
            Type1 = 80;
          else if (num2 < 52)
            Type1 = 30;
          else if (num2 < 58)
            Type1 = 32;
          else if (num2 < 64)
            Type1 = 240;
          else if (num2 < 70)
            Type1 = 236;
        }
      }
      if (tileCache.type == (ushort) 237)
        Type1 = 148;
      if (tileCache.type == (ushort) 157)
        Type1 = 77;
      if (tileCache.type == (ushort) 158 || tileCache.type == (ushort) 232 || (tileCache.type == (ushort) 383 || tileCache.type == (ushort) 575))
        Type1 = 78;
      if (tileCache.type == (ushort) 159)
        Type1 = 78;
      if (tileCache.type == (ushort) 15)
        Type1 = -1;
      if (tileCache.type == (ushort) 191)
        Type1 = 7;
      if (tileCache.type == (ushort) 5)
      {
        Type1 = 7;
        if (i > 5 && i < Main.maxTilesX - 5)
        {
          int index1 = i;
          int index2 = j;
          if (tileCache.frameX == (short) 66 && tileCache.frameY <= (short) 45)
            ++index1;
          if (tileCache.frameX == (short) 88 && tileCache.frameY >= (short) 66 && tileCache.frameY <= (short) 110)
            --index1;
          if (tileCache.frameX == (short) 22 && tileCache.frameY >= (short) 132 && tileCache.frameY <= (short) 176)
            --index1;
          if (tileCache.frameX == (short) 44 && tileCache.frameY >= (short) 132 && tileCache.frameY <= (short) 176)
            ++index1;
          if (tileCache.frameX == (short) 44 && tileCache.frameY >= (short) 132 && tileCache.frameY <= (short) 176)
            ++index1;
          if (tileCache.frameX == (short) 44 && tileCache.frameY >= (short) 198)
            ++index1;
          if (tileCache.frameX == (short) 66 && tileCache.frameY >= (short) 198)
            --index1;
          while (Main.tile[index1, index2] != null && (!Main.tile[index1, index2].active() || !Main.tileSolid[(int) Main.tile[index1, index2].type]))
            ++index2;
          if (Main.tile[index1, index2] != null)
          {
            if (Main.tile[index1, index2].active() && Main.tile[index1, index2].type == (ushort) 23)
              Type1 = 77;
            if (Main.tile[index1, index2].active() && Main.tile[index1, index2].type == (ushort) 60)
              Type1 = 78;
            if (Main.tile[index1, index2].active() && Main.tile[index1, index2].type == (ushort) 70)
              Type1 = 26;
            if (Main.tile[index1, index2].active() && Main.tile[index1, index2].type == (ushort) 109)
              Type1 = 79;
            if (Main.tile[index1, index2].active() && Main.tile[index1, index2].type == (ushort) 199)
              Type1 = 121;
            if (Main.tile[index1, index2].active() && Main.tile[index1, index2].type == (ushort) 147)
              Type1 = 122;
          }
        }
      }
      if (tileCache.type == (ushort) 323)
      {
        Type1 = 215;
        if (i > 5 && i < Main.maxTilesX - 5)
        {
          int index1 = i;
          int index2 = j;
          while (Main.tile[index1, index2] != null && (!Main.tile[index1, index2].active() || !Main.tileSolid[(int) Main.tile[index1, index2].type]))
            ++index2;
          if (Main.tile[index1, index2] != null)
          {
            if (Main.tile[index1, index2].active() && Main.tile[index1, index2].type == (ushort) 234)
              Type1 = 121;
            if (Main.tile[index1, index2].active() && Main.tile[index1, index2].type == (ushort) 116)
              Type1 = 79;
            if (Main.tile[index1, index2].active() && Main.tile[index1, index2].type == (ushort) 112)
              Type1 = 77;
          }
        }
      }
      if (tileCache.type == (ushort) 137)
      {
        Type1 = 1;
        if ((int) tileCache.frameY / 18 > 0)
          Type1 = 148;
      }
      if (tileCache.type == (ushort) 443)
        Type1 = 1;
      if (tileCache.type == (ushort) 444)
        Type1 = -1;
      if (tileCache.type == (ushort) 212)
        Type1 = -1;
      if (tileCache.type == (ushort) 213)
        Type1 = 129;
      if (tileCache.type == (ushort) 214)
        Type1 = 1;
      if (tileCache.type == (ushort) 215)
        Type1 = -6;
      if (tileCache.type == (ushort) 325)
        Type1 = 81;
      if (tileCache.type == (ushort) 251)
        Type1 = 189;
      if (tileCache.type == (ushort) 252)
        Type1 = 190;
      if (tileCache.type == (ushort) 253)
        Type1 = 191;
      if (tileCache.type == (ushort) 254)
      {
        if (tileCache.frameX < (short) 72)
          Type1 = 3;
        else if (tileCache.frameX < (short) 108)
        {
          Type1 = 3;
          if (WorldGen.genRand.Next(3) == 0)
            Type1 = 189;
        }
        else if (tileCache.frameX < (short) 144)
        {
          Type1 = 3;
          if (WorldGen.genRand.Next(2) == 0)
            Type1 = 189;
        }
        else
        {
          Type1 = 3;
          if (WorldGen.genRand.Next(4) != 0)
            Type1 = 189;
        }
      }
      if (tileCache.type == (ushort) 467)
        Type1 = -1;
      if (tileCache.type == (ushort) 21)
        Type1 = tileCache.frameX < (short) 1008 ? (tileCache.frameX < (short) 612 ? (tileCache.frameX < (short) 576 ? (tileCache.frameX < (short) 540 ? (tileCache.frameX < (short) 504 ? (tileCache.frameX < (short) 468 ? (tileCache.frameX < (short) 432 ? (tileCache.frameX < (short) 396 ? (tileCache.frameX < (short) 360 ? (tileCache.frameX < (short) 324 ? (tileCache.frameX < (short) 288 ? (tileCache.frameX < (short) 252 ? (tileCache.frameX < (short) 216 ? (tileCache.frameX < (short) 180 ? (tileCache.frameX < (short) 108 ? (tileCache.frameX < (short) 36 ? 7 : 10) : 37) : 7) : 1) : 77) : 78) : 79) : 10) : 11) : 7) : 116) : 126) : 26) : 148) : 11) : -1;
      if (tileCache.type == (ushort) 382)
        Type1 = 3;
      if (tileCache.type == (ushort) 2 || tileCache.type == (ushort) 477)
        Type1 = WorldGen.genRand.Next(2) != 0 ? 2 : 0;
      if (tileCache.type == (ushort) sbyte.MaxValue)
        Type1 = 67;
      if (tileCache.type == (ushort) 91)
        Type1 = -1;
      if (tileCache.type == (ushort) 198)
        Type1 = 109;
      if (tileCache.type == (ushort) 26)
        Type1 = tileCache.frameX < (short) 54 ? 8 : 5;
      if (tileCache.type == (ushort) 34)
        Type1 = -1;
      if (tileCache.type == (ushort) 6)
        Type1 = 8;
      if (tileCache.type == (ushort) 7 || tileCache.type == (ushort) 47 || tileCache.type == (ushort) 284)
        Type1 = 9;
      if (tileCache.type == (ushort) 8 || tileCache.type == (ushort) 45 || tileCache.type == (ushort) 102)
        Type1 = 10;
      if (tileCache.type == (ushort) 9 || tileCache.type == (ushort) 42 || (tileCache.type == (ushort) 46 || tileCache.type == (ushort) 126) || tileCache.type == (ushort) 136)
        Type1 = 11;
      if (tileCache.type == (ushort) 166 || tileCache.type == (ushort) 175)
        Type1 = 81;
      if (tileCache.type == (ushort) 167)
        Type1 = 82;
      if (tileCache.type == (ushort) 168 || tileCache.type == (ushort) 176)
        Type1 = 83;
      if (tileCache.type == (ushort) 169 || tileCache.type == (ushort) 177)
        Type1 = 84;
      if (tileCache.type == (ushort) 199)
        Type1 = 117;
      if (tileCache.type == (ushort) 205)
        Type1 = 125;
      if (tileCache.type == (ushort) 201)
        Type1 = 125;
      if (tileCache.type == (ushort) 211)
        Type1 = 128;
      if (tileCache.type == (ushort) 227)
      {
        switch ((int) tileCache.frameX / 34)
        {
          case 0:
          case 1:
            Type1 = 26;
            break;
          case 2:
          case 4:
          case 5:
          case 6:
            Type1 = 40;
            break;
          case 3:
            Type1 = 3;
            break;
          case 7:
            Type1 = 117;
            break;
          case 8:
            Type1 = 17;
            break;
          case 9:
            Type1 = 6;
            break;
          case 10:
            Type1 = 3;
            break;
          case 11:
            Type1 = 26;
            break;
        }
      }
      if (tileCache.type == (ushort) 204 || tileCache.type == (ushort) 478)
      {
        Type1 = 117;
        if (WorldGen.genRand.Next(2) == 0)
          Type1 = 1;
      }
      if (tileCache.type == (ushort) 203)
        Type1 = 117;
      if (tileCache.type == (ushort) 243)
        Type1 = WorldGen.genRand.Next(2) != 0 ? 13 : 7;
      if (tileCache.type == (ushort) 244)
        Type1 = WorldGen.genRand.Next(2) != 0 ? 13 : 1;
      if (tileCache.type == (ushort) 597)
        Type1 = -1;
      else if (tileCache.type >= (ushort) 358 && tileCache.type <= (ushort) 364 || tileCache.type >= (ushort) 275 && tileCache.type <= (ushort) 282 || (tileCache.type == (ushort) 285 || tileCache.type == (ushort) 286 || tileCache.type >= (ushort) 288 && tileCache.type <= (ushort) 297) || (tileCache.type >= (ushort) 316 && tileCache.type <= (ushort) 318 || (tileCache.type == (ushort) 298 || tileCache.type == (ushort) 299) || (tileCache.type == (ushort) 309 || tileCache.type == (ushort) 310 || (tileCache.type == (ushort) 339 || tileCache.type == (ushort) 538))) || (tileCache.type == (ushort) 413 || tileCache.type == (ushort) 414 || (tileCache.type == (ushort) 505 || tileCache.type == (ushort) 521) || (tileCache.type == (ushort) 522 || tileCache.type == (ushort) 523 || (tileCache.type == (ushort) 524 || tileCache.type == (ushort) 525)) || (tileCache.type == (ushort) 526 || tileCache.type == (ushort) 527 || (tileCache.type == (ushort) 532 || tileCache.type == (ushort) 543) || (tileCache.type == (ushort) 544 || tileCache.type == (ushort) 550 || (tileCache.type == (ushort) 551 || tileCache.type == (ushort) 533)))) || (tileCache.type == (ushort) 553 || tileCache.type == (ushort) 554 || (tileCache.type == (ushort) 555 || tileCache.type == (ushort) 556) || (tileCache.type == (ushort) 558 || tileCache.type == (ushort) 559 || (tileCache.type == (ushort) 542 || tileCache.type == (ushort) 391)) || (tileCache.type == (ushort) 394 || tileCache.type == (ushort) 392 || (tileCache.type == (ushort) 393 || tileCache.type == (ushort) 568) || (tileCache.type == (ushort) 569 || tileCache.type == (ushort) 570 || (tileCache.type == (ushort) 582 || tileCache.type == (ushort) 580))) || (tileCache.type == (ushort) 598 || tileCache.type == (ushort) 599 || (tileCache.type == (ushort) 600 || tileCache.type == (ushort) 601) || (tileCache.type == (ushort) 602 || tileCache.type == (ushort) 603 || (tileCache.type == (ushort) 604 || tileCache.type == (ushort) 605)) || (tileCache.type == (ushort) 606 || tileCache.type == (ushort) 607 || (tileCache.type == (ushort) 608 || tileCache.type == (ushort) 609) || (tileCache.type == (ushort) 610 || tileCache.type == (ushort) 611 || (tileCache.type == (ushort) 612 || tileCache.type == (ushort) 619))))) || tileCache.type == (ushort) 620)
      {
        Type1 = 13;
        if (WorldGen.genRand.Next(3) != 0)
          Type1 = -1;
      }
      if (tileCache.type == (ushort) 13)
        Type1 = tileCache.frameX < (short) 90 ? 13 : -1;
      if (tileCache.type == (ushort) 189)
        Type1 = 16;
      if (tileCache.type == (ushort) 460)
        Type1 = 16;
      if (tileCache.type == (ushort) 530)
      {
        switch (Main.tile[i, j + 2 - (int) tileCache.frameY / 18].type)
        {
          case 112:
            Type1 = 17;
            break;
          case 116:
            Type1 = 47;
            break;
          case 234:
            Type1 = 125;
            break;
          default:
            Type1 = tileCache.frameX >= (short) 270 ? 291 : 40;
            break;
        }
      }
      if (tileCache.type == (ushort) 518)
      {
        if (tileCache.frameY == (short) 0)
          Type1 = 3;
        else if (tileCache.frameY == (short) 18)
          Type1 = 47;
        else if (tileCache.frameY == (short) 36)
          Type1 = 40;
      }
      else if (tileCache.type == (ushort) 519)
      {
        if (tileCache.frameY == (short) 0)
          Type1 = 3;
        else if (tileCache.frameY == (short) 18)
          Type1 = 40;
        else if (tileCache.frameY == (short) 36)
          Type1 = 47;
        else if (tileCache.frameY == (short) 54)
          Type1 = 125;
        else if (tileCache.frameY == (short) 72)
          Type1 = 17;
        else if (tileCache.frameY == (short) 90)
          Type1 = 26;
      }
      else if (tileCache.type == (ushort) 528)
        Type1 = 26;
      if (tileCache.type == (ushort) 12)
        Type1 = 12;
      if (tileCache.type == (ushort) 3 || tileCache.type == (ushort) 73)
        Type1 = 3;
      if (tileCache.type == (ushort) 54)
        Type1 = 13;
      if (tileCache.type == (ushort) 22 || tileCache.type == (ushort) 140)
        Type1 = 14;
      if (tileCache.type == (ushort) 78)
        Type1 = 22;
      if (tileCache.type == (ushort) 28)
      {
        Type1 = 22;
        if (tileCache.frameY >= (short) 72 && tileCache.frameY <= (short) 90)
          Type1 = 1;
        if (tileCache.frameY >= (short) 144 && tileCache.frameY <= (short) 234)
          Type1 = 48;
        if (tileCache.frameY >= (short) 252 && tileCache.frameY <= (short) 358)
          Type1 = 85;
        if (tileCache.frameY >= (short) 360 && tileCache.frameY <= (short) 466)
          Type1 = 26;
        if (tileCache.frameY >= (short) 468 && tileCache.frameY <= (short) 574)
          Type1 = 36;
        if (tileCache.frameY >= (short) 576 && tileCache.frameY <= (short) 790)
          Type1 = 18;
        if (tileCache.frameY >= (short) 792 && tileCache.frameY <= (short) 898)
          Type1 = 5;
        if (tileCache.frameY >= (short) 900 && tileCache.frameY <= (short) 1006)
          Type1 = 0;
        if (tileCache.frameY >= (short) 1008 && tileCache.frameY <= (short) 1114)
          Type1 = 148;
        if (tileCache.frameY >= (short) 1116 && tileCache.frameY <= (short) 1222)
          Type1 = 241;
        if (tileCache.frameY >= (short) 1224 && tileCache.frameY <= (short) 1330)
          Type1 = 287;
      }
      if (tileCache.type == (ushort) 163)
        Type1 = 118;
      if (tileCache.type == (ushort) 164)
        Type1 = 119;
      if (tileCache.type == (ushort) 200)
        Type1 = 120;
      if (tileCache.type == (ushort) 221 || tileCache.type == (ushort) 248)
        Type1 = 144;
      if (tileCache.type == (ushort) 222 || tileCache.type == (ushort) 249)
        Type1 = 145;
      if (tileCache.type == (ushort) 223 || tileCache.type == (ushort) 250)
        Type1 = 146;
      if (tileCache.type == (ushort) 224)
        Type1 = 149;
      if (tileCache.type == (ushort) 225)
        Type1 = 147;
      if (tileCache.type == (ushort) 229)
        Type1 = 153;
      if (tileCache.type == (ushort) 231)
      {
        Type1 = 153;
        if (WorldGen.genRand.Next(3) == 0)
          Type1 = 26;
      }
      if (tileCache.type == (ushort) 226)
        Type1 = 148;
      if (tileCache.type == (ushort) 103)
        Type1 = -1;
      if (tileCache.type == (ushort) 29)
        Type1 = 23;
      if (tileCache.type == (ushort) 40)
        Type1 = 28;
      if (tileCache.type == (ushort) 49)
        Type1 = 29;
      if (tileCache.type == (ushort) 50)
        Type1 = 22;
      if (tileCache.type == (ushort) 51)
        Type1 = 30;
      if (tileCache.type == (ushort) 52 || tileCache.type == (ushort) 353)
        Type1 = 3;
      if (tileCache.type == (ushort) 53 || tileCache.type == (ushort) 81 || (tileCache.type == (ushort) 151 || tileCache.type == (ushort) 202) || (tileCache.type == (ushort) 274 || tileCache.type == (ushort) 495))
        Type1 = 32;
      if (tileCache.type == (ushort) 56 || tileCache.type == (ushort) 152)
        Type1 = 37;
      if (tileCache.type == (ushort) 75)
        Type1 = 109;
      if (tileCache.type == (ushort) 57 || tileCache.type == (ushort) 119 || (tileCache.type == (ushort) 141 || tileCache.type == (ushort) 234))
        Type1 = 36;
      if (tileCache.type == (ushort) 59 || tileCache.type == (ushort) 120)
        Type1 = 38;
      if (tileCache.type == (ushort) 61 || tileCache.type == (ushort) 62 || (tileCache.type == (ushort) 74 || tileCache.type == (ushort) 80) || (tileCache.type == (ushort) 188 || tileCache.type == (ushort) 233 || (tileCache.type == (ushort) 236 || tileCache.type == (ushort) 384)))
        Type1 = 40;
      if (tileCache.type == (ushort) 485)
        Type1 = 32;
      if (tileCache.type == (ushort) 238)
        Type1 = WorldGen.genRand.Next(3) != 0 ? 166 : 167;
      if (tileCache.type == (ushort) 69)
        Type1 = 7;
      if (tileCache.type == (ushort) 71 || tileCache.type == (ushort) 72 || (tileCache.type == (ushort) 190 || tileCache.type == (ushort) 578))
        Type1 = 26;
      if (tileCache.type == (ushort) 70)
        Type1 = 17;
      if (tileCache.type == (ushort) 112)
        Type1 = 14;
      if (tileCache.type == (ushort) 123)
        Type1 = 53;
      if (tileCache.type == (ushort) 161)
        Type1 = 80;
      if (tileCache.type == (ushort) 206)
        Type1 = 80;
      if (tileCache.type == (ushort) 162)
        Type1 = 80;
      if (tileCache.type == (ushort) 165)
      {
        switch ((int) tileCache.frameX / 54)
        {
          case 0:
            Type1 = 80;
            break;
          case 1:
            Type1 = 1;
            break;
          case 2:
            Type1 = 30;
            break;
          case 3:
            Type1 = 147;
            break;
          case 4:
            Type1 = 1;
            break;
          case 5:
            Type1 = 14;
            break;
          case 6:
            Type1 = 117;
            break;
          case 7:
            Type1 = 250;
            break;
          case 8:
            Type1 = 240;
            break;
          case 9:
            Type1 = 236;
            break;
          default:
            Type1 = 1;
            break;
        }
      }
      if (tileCache.type == (ushort) 193)
        Type1 = 4;
      if (tileCache.type == (ushort) 194)
        Type1 = 26;
      if (tileCache.type == (ushort) 195)
        Type1 = 5;
      if (tileCache.type == (ushort) 196)
        Type1 = 108;
      if (tileCache.type == (ushort) 460)
        Type1 = 108;
      if (tileCache.type == (ushort) 197)
        Type1 = 4;
      if (tileCache.type == (ushort) 153)
        Type1 = 26;
      if (tileCache.type == (ushort) 154)
        Type1 = 32;
      if (tileCache.type == (ushort) 155)
        Type1 = 2;
      if (tileCache.type == (ushort) 156)
        Type1 = 1;
      if (tileCache.type == (ushort) 116 || tileCache.type == (ushort) 118 || (tileCache.type == (ushort) 147 || tileCache.type == (ushort) 148))
        Type1 = 51;
      if (tileCache.type == (ushort) 109 || tileCache.type == (ushort) 492)
        Type1 = WorldGen.genRand.Next(2) != 0 ? 47 : 0;
      if (tileCache.type == (ushort) 110 || tileCache.type == (ushort) 113 || tileCache.type == (ushort) 115)
        Type1 = 47;
      if (tileCache.type == (ushort) 107 || tileCache.type == (ushort) 121)
        Type1 = 48;
      if (tileCache.type == (ushort) 108 || tileCache.type == (ushort) 122 || tileCache.type == (ushort) 146)
        Type1 = 49;
      if (tileCache.type == (ushort) 111 || tileCache.type == (ushort) 145 || tileCache.type == (ushort) 150)
        Type1 = 50;
      if (tileCache.type == (ushort) 133)
      {
        Type1 = 50;
        if (tileCache.frameX >= (short) 54)
          Type1 = 146;
      }
      if (tileCache.type == (ushort) 134)
      {
        Type1 = 49;
        if (tileCache.frameX >= (short) 36)
          Type1 = 145;
      }
      if (tileCache.type == (ushort) 149)
        Type1 = 49;
      if (Main.tileAlch[(int) tileCache.type])
      {
        int num2 = (int) tileCache.frameX / 18;
        if (num2 == 0)
          Type1 = 3;
        if (num2 == 1)
          Type1 = 3;
        if (num2 == 2)
          Type1 = 7;
        if (num2 == 3)
          Type1 = 17;
        if (num2 == 4)
          Type1 = 289;
        if (num2 == 5)
          Type1 = 6;
        if (num2 == 6)
          Type1 = 224;
      }
      if (tileCache.type == (ushort) 58 || tileCache.type == (ushort) 76 || tileCache.type == (ushort) 77)
        Type1 = WorldGen.genRand.Next(2) != 0 ? 25 : 6;
      if (tileCache.type == (ushort) 37)
        Type1 = WorldGen.genRand.Next(2) != 0 ? 23 : 6;
      if (tileCache.type == (ushort) 32)
        Type1 = WorldGen.genRand.Next(2) != 0 ? 24 : 14;
      if (tileCache.type == (ushort) 352)
        Type1 = WorldGen.genRand.Next(3) != 0 ? 125 : 5;
      if (tileCache.type == (ushort) 23 || tileCache.type == (ushort) 24)
        Type1 = WorldGen.genRand.Next(2) != 0 ? 17 : 14;
      if (tileCache.type == (ushort) 25 || tileCache.type == (ushort) 31)
        Type1 = tileCache.type != (ushort) 31 || tileCache.frameX < (short) 36 ? (WorldGen.genRand.Next(2) != 0 ? 1 : 14) : 5;
      if (tileCache.type == (ushort) 20)
      {
        switch ((int) tileCache.frameX / 54)
        {
          case 1:
            Type1 = 122;
            break;
          case 2:
            Type1 = 78;
            break;
          case 3:
            Type1 = 77;
            break;
          case 4:
            Type1 = 121;
            break;
          case 5:
            Type1 = 79;
            break;
          default:
            Type1 = 7;
            break;
        }
      }
      if (tileCache.type == (ushort) 27)
        Type1 = WorldGen.genRand.Next(2) != 0 ? 19 : 3;
      if (tileCache.type == (ushort) 129)
      {
        if (tileCache.frameX >= (short) 324)
          num3 = 69;
        Type1 = tileCache.frameX == (short) 0 || tileCache.frameX == (short) 54 || tileCache.frameX == (short) 108 ? 68 : (tileCache.frameX == (short) 18 || tileCache.frameX == (short) 72 || tileCache.frameX == (short) 126 ? 69 : 70);
      }
      if (tileCache.type == (ushort) 385)
        Type1 = WorldGen.genRand.Next(68, 71);
      if (tileCache.type == (ushort) 4)
      {
        int index = (int) tileCache.frameY / 22;
        Type1 = TorchID.Dust[index];
      }
      if (tileCache.type == (ushort) 35)
      {
        Type1 = 189;
        if (tileCache.frameX < (short) 36 && WorldGen.genRand.Next(2) == 0)
          Type1 = 6;
      }
      if ((tileCache.type == (ushort) 34 || tileCache.type == (ushort) 42) && WorldGen.genRand.Next(2) == 0)
        Type1 = 6;
      if (tileCache.type == (ushort) 270)
        Type1 = -1;
      if (tileCache.type == (ushort) 271)
        Type1 = -1;
      if (tileCache.type == (ushort) 581)
        Type1 = -1;
      if (tileCache.type == (ushort) 79 || tileCache.type == (ushort) 90 || tileCache.type == (ushort) 101)
        Type1 = -1;
      if (tileCache.type == (ushort) 33 || tileCache.type == (ushort) 34 || (tileCache.type == (ushort) 42 || tileCache.type == (ushort) 93) || tileCache.type == (ushort) 100)
        Type1 = -1;
      if (tileCache.type == (ushort) 321 || tileCache.type == (ushort) 574)
        Type1 = 214;
      if (tileCache.type == (ushort) 322)
        Type1 = 215;
      bool flag = tileCache.type == (ushort) 178 || tileCache.type == (ushort) 440;
      switch (tileCache.type)
      {
        case 178:
        case 426:
        case 427:
        case 430:
        case 431:
        case 432:
        case 433:
        case 434:
        case 435:
        case 436:
        case 437:
        case 438:
        case 439:
        case 440:
          flag = true;
          break;
      }
      if (Type1 < 0)
        return 6000;
      if (tileCache.type == (ushort) 518)
      {
        int num2 = (int) tileCache.liquid / 16 - 3;
        if (WorldGen.SolidTile(i, j - 1, false) && num2 > 8)
          num2 = 8;
        return Dust.NewDust(new Vector2((float) (i * 16), (float) (j * 16 - num2)), 16, 16, Type1, 0.0f, 0.0f, 0, new Color(), 1f);
      }
      if (tileCache.type == (ushort) 352 && Type1 == 5)
      {
        int index = Dust.NewDust(new Vector2((float) (i * 16), (float) (j * 16)), 16, 16, 5, 0.0f, 0.0f, 100, new Color(), 1f);
        Main.dust[index].scale = 1.5f;
        Main.dust[index].noGravity = true;
        Main.dust[index].velocity *= 1.65f;
        Main.dust[index].fadeIn = 1.6f;
        return index;
      }
      if (tileCache.type == (ushort) 160)
      {
        int index = Dust.NewDust(new Vector2((float) (i * 16), (float) (j * 16)), 16, 16, 66, 0.0f, 0.0f, 100, new Color(Main.DiscoR, Main.DiscoG, Main.DiscoB), 0.75f);
        Main.dust[index].noGravity = true;
        return index;
      }
      if (tileCache.type == (ushort) 323)
      {
        int frameY = (int) tileCache.frameY;
        return Dust.NewDust(new Vector2((float) (i * 16 + frameY), (float) (j * 16)), 16, 16, Type1, 0.0f, 0.0f, 0, new Color(), 1f);
      }
      if (tileCache.type == (ushort) 314)
      {
        int index = Dust.NewDust(new Vector2((float) (i * 16), (float) (j * 16)), 16, 16, 213, (float) WorldGen.genRand.Next(-2, 3), (float) WorldGen.genRand.Next(-2, 3), 0, new Color(), 1f);
        Main.dust[index].noGravity = true;
        Main.dust[index].fadeIn = (float) ((double) Main.dust[index].scale + 1.0 + 0.00999999977648258 * (double) WorldGen.genRand.Next(0, 51));
        Main.dust[index].noGravity = true;
        return index;
      }
      if (flag)
      {
        int index = Dust.NewDust(new Vector2((float) (i * 16), (float) (j * 16)), 16, 16, Type1, 0.0f, 0.0f, 75, new Color(), 0.75f);
        Main.dust[index].noLight = true;
        return index;
      }
      if (tileCache.type == (ushort) 193 || tileCache.type == (ushort) 18 && Type1 == 4 || tileCache.type == (ushort) 19 && Type1 == 4)
        return Dust.NewDust(new Vector2((float) (i * 16), (float) (j * 16)), 16, 16, Type1, 0.0f, 0.0f, 75, new Color(0, 80, (int) byte.MaxValue, 100), 0.75f);
      if (tileCache.type == (ushort) 197)
        return Dust.NewDust(new Vector2((float) (i * 16), (float) (j * 16)), 16, 16, Type1, 0.0f, 0.0f, 75, new Color(97, 200, (int) byte.MaxValue, 100), 0.75f);
      if (tileCache.type == (ushort) 185 && Type1 >= 86 && Type1 <= 91)
      {
        int index = Dust.NewDust(new Vector2((float) (i * 16), (float) (j * 16)), 16, 16, Type1, 0.0f, 0.0f, 75, new Color(), 0.75f);
        Main.dust[index].noLight = true;
        return index;
      }
      if (tileCache.type == (ushort) 4 && Type1 == 66)
      {
        int index = Dust.NewDust(new Vector2((float) (i * 16), (float) (j * 16)), 16, 16, Type1, 0.0f, 0.0f, 0, new Color((float) Main.DiscoR / (float) byte.MaxValue, (float) Main.DiscoG / (float) byte.MaxValue, (float) Main.DiscoB / (float) byte.MaxValue), 1f);
        Main.dust[index].noGravity = true;
        return index;
      }
      if (Type1 != 139)
        return Dust.NewDust(new Vector2((float) (i * 16), (float) (j * 16)), 16, 16, Type1, 0.0f, 0.0f, 0, new Color(), 1f);
      int Type2 = Type1 + Main.rand.Next(4);
      return Dust.NewDust(new Vector2((float) (i * 16), (float) (j * 16)), 16, 16, Type2, 0.0f, 0.0f, 0, new Color(), 1f);
    }

    public static bool IsOpenDoorAnchorFrame(int x, int y)
    {
      Tile tile = Main.tile[x, y];
      if (!tile.active() || tile.type != (ushort) 11)
        return false;
      int num = (int) tile.frameX % 72;
      return num < 18 || num >= 54;
    }

    public static bool IsLockedDoor(int x, int y)
    {
      return WorldGen.IsLockedDoor(Main.tile[x, y]);
    }

    public static bool IsLockedDoor(Tile t)
    {
      return t.type == (ushort) 10 && t.frameY >= (short) 594 && t.frameY <= (short) 646 && t.frameX < (short) 54;
    }

    public static void DropDoorItem(int x, int y, int doorStyle)
    {
      int Type = 0;
      switch (doorStyle)
      {
        case 0:
          Type = 25;
          break;
        case 9:
          Type = 837;
          break;
        case 10:
          Type = 912;
          break;
        case 12:
          Type = 1137;
          break;
        case 13:
          Type = 1138;
          break;
        case 14:
          Type = 1139;
          break;
        case 15:
          Type = 1140;
          break;
        case 16:
          Type = 1411;
          break;
        case 17:
          Type = 1412;
          break;
        case 18:
          Type = 1413;
          break;
        case 19:
          Type = 1458;
          break;
        default:
          if (doorStyle >= 20 && doorStyle <= 23)
          {
            Type = 1709 + doorStyle - 20;
            break;
          }
          switch (doorStyle)
          {
            case 24:
              Type = 1793;
              break;
            case 25:
              Type = 1815;
              break;
            case 26:
              Type = 1924;
              break;
            case 27:
              Type = 2044;
              break;
            case 28:
              Type = 2265;
              break;
            case 29:
              Type = 2528;
              break;
            case 30:
              Type = 2561;
              break;
            case 31:
              Type = 2576;
              break;
            case 32:
              Type = 2815;
              break;
            case 33:
              Type = 3129;
              break;
            case 34:
              Type = 3131;
              break;
            case 35:
              Type = 3130;
              break;
            case 36:
              Type = 3888;
              break;
            case 37:
              Type = 3941;
              break;
            case 38:
              Type = 3967;
              break;
            case 39:
              Type = 4155;
              break;
            case 40:
              Type = 4176;
              break;
            case 41:
              Type = 4197;
              break;
            case 42:
              Type = 4218;
              break;
            case 43:
              Type = 4307;
              break;
            case 44:
              Type = 4415;
              break;
            case 45:
              Type = 4576;
              break;
            default:
              if (doorStyle >= 4 && doorStyle <= 8)
              {
                Type = 812 + doorStyle;
                break;
              }
              if (doorStyle != 11)
              {
                Type = 649 + doorStyle;
                break;
              }
              break;
          }
          break;
      }
      if (Type == 0)
        return;
      Item.NewItem(x * 16, y * 16, 16, 16, Type, 1, false, 0, false, false);
    }

    public static bool PlayerLOS(int x, int y)
    {
      Microsoft.Xna.Framework.Rectangle rectangle1 = new Microsoft.Xna.Framework.Rectangle(x * 16, y * 16, 16, 16);
      for (int index = 0; index < (int) byte.MaxValue; ++index)
      {
        if (Main.player[index].active)
        {
          Microsoft.Xna.Framework.Rectangle rectangle2 = new Microsoft.Xna.Framework.Rectangle((int) ((double) Main.player[index].position.X + (double) Main.player[index].width * 0.5 - (double) NPC.sWidth * 0.6), (int) ((double) Main.player[index].position.Y + (double) Main.player[index].height * 0.5 - (double) NPC.sHeight * 0.6), (int) ((double) NPC.sWidth * 1.2), (int) ((double) NPC.sHeight * 1.2));
          if (rectangle1.Intersects(rectangle2))
            return true;
        }
      }
      return false;
    }

    public static bool Chlorophyte(int i, int j)
    {
      int num1 = 40;
      int num2 = 130;
      int num3 = 35;
      int num4 = 85;
      if ((double) j < Main.rockLayer)
      {
        num1 /= 2;
        num2 /= 2;
        num3 = (int) ((double) num3 * 1.5);
        num4 = (int) ((double) num4 * 1.5);
      }
      int num5 = 0;
      for (int x = i - num3; x < i + num3; ++x)
      {
        for (int y = j - num3; y < j + num3; ++y)
        {
          if (WorldGen.InWorld(x, y, 0) && Main.tile[x, y].active() && Main.tile[x, y].type == (ushort) 211)
            ++num5;
        }
      }
      if (num5 > num1)
        return false;
      int num6 = 0;
      for (int x = i - num4; x < i + num4; ++x)
      {
        for (int y = j - num4; y < j + num4; ++y)
        {
          if (WorldGen.InWorld(x, y, 0) && Main.tile[x, y].active() && Main.tile[x, y].type == (ushort) 211)
            ++num6;
        }
      }
      return num6 <= num2;
    }

    private static bool nearbyChlorophyte(int i, int j)
    {
      float num1 = 0.0f;
      int num2 = 5;
      if (i <= num2 + 5 || i >= Main.maxTilesX - num2 - 5 || (j <= num2 + 5 || j >= Main.maxTilesY - num2 - 5))
        return false;
      for (int index1 = i - num2; index1 <= i + num2; ++index1)
      {
        for (int index2 = j - num2; index2 <= j + num2; ++index2)
        {
          if (Main.tile[index1, index2].active() && (Main.tile[index1, index2].type == (ushort) 211 || Main.tile[index1, index2].type == (ushort) 346))
          {
            ++num1;
            if ((double) num1 >= 4.0)
              return true;
          }
        }
      }
      return (double) num1 > 0.0 && (double) WorldGen.genRand.Next(5) < (double) num1;
    }

    private static int CountNearBlocksTypes(
      int i,
      int j,
      int radius,
      int cap = 0,
      params int[] tiletypes)
    {
      if (tiletypes.Length == 0)
        return 0;
      int num1 = i - radius;
      int num2 = i + radius;
      int num3 = j - radius;
      int num4 = j + radius;
      int max = Main.maxTilesX - 1;
      int num5 = Utils.Clamp<int>(num1, 0, max);
      int num6 = Utils.Clamp<int>(num2, 0, Main.maxTilesX - 1);
      int num7 = Utils.Clamp<int>(num3, 0, Main.maxTilesY - 1);
      int num8 = Utils.Clamp<int>(num4, 0, Main.maxTilesY - 1);
      int num9 = 0;
      for (int index1 = num5; index1 <= num6; ++index1)
      {
        for (int index2 = num7; index2 <= num8; ++index2)
        {
          if (Main.tile[index1, index2].active())
          {
            foreach (int tiletype in tiletypes)
            {
              if (tiletype == (int) Main.tile[index1, index2].type)
              {
                ++num9;
                if (cap > 0 && num9 >= cap)
                  return num9;
                break;
              }
            }
          }
        }
      }
      return num9;
    }

    public static void hardUpdateWorld(int i, int j)
    {
      if (!Main.hardMode || Main.tile[i, j].inActive())
        return;
      int type = (int) Main.tile[i, j].type;
      switch (type)
      {
        case 117:
        case 164:
          if ((double) j > Main.rockLayer && WorldGen.genRand.Next(110) == 0)
          {
            int num1 = WorldGen.genRand.Next(4);
            int num2 = 0;
            int num3 = 0;
            switch (num1)
            {
              case 0:
                num2 = -1;
                break;
              case 1:
                num2 = 1;
                break;
              default:
                num3 = num1 != 0 ? 1 : -1;
                break;
            }
            if (!Main.tile[i + num2, j + num3].active())
            {
              int num4 = 0;
              int num5 = 6;
              for (int index1 = i - num5; index1 <= i + num5; ++index1)
              {
                for (int index2 = j - num5; index2 <= j + num5; ++index2)
                {
                  if (Main.tile[index1, index2].active() && Main.tile[index1, index2].type == (ushort) 129)
                    ++num4;
                }
              }
              if (num4 < 2)
              {
                WorldGen.PlaceTile(i + num2, j + num3, 129, true, false, -1, 0);
                NetMessage.SendTileSquare(-1, i + num2, j + num3, 1, TileChangeType.None);
                break;
              }
              break;
            }
            break;
          }
          break;
      }
      if ((double) j > (Main.worldSurface + Main.rockLayer) / 2.0)
      {
        if (type == 60 && WorldGen.genRand.Next(300) == 0)
        {
          int index1 = i + WorldGen.genRand.Next(-10, 11);
          int index2 = j + WorldGen.genRand.Next(-10, 11);
          if (WorldGen.InWorld(index1, index2, 2) && Main.tile[index1, index2].active() && Main.tile[index1, index2].type == (ushort) 59 && (!Main.tile[index1, index2 - 1].active() || Main.tile[index1, index2 - 1].type != (ushort) 5 && Main.tile[index1, index2 - 1].type != (ushort) 236 && Main.tile[index1, index2 - 1].type != (ushort) 238) && WorldGen.Chlorophyte(index1, index2))
          {
            Main.tile[index1, index2].type = (ushort) 211;
            WorldGen.SquareTileFrame(index1, index2, true);
            if (Main.netMode == 2)
              NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
          }
        }
        if (type == 211 && WorldGen.genRand.Next(3) != 0)
        {
          int index1 = i;
          int index2 = j;
          int num = WorldGen.genRand.Next(4);
          if (num == 0)
            ++index1;
          if (num == 1)
            --index1;
          if (num == 2)
            ++index2;
          if (num == 3)
            --index2;
          if (WorldGen.InWorld(index1, index2, 2) && Main.tile[index1, index2].active() && (Main.tile[index1, index2].type == (ushort) 59 || Main.tile[index1, index2].type == (ushort) 60) && WorldGen.Chlorophyte(index1, index2))
          {
            Main.tile[index1, index2].type = (ushort) 211;
            WorldGen.SquareTileFrame(index1, index2, true);
            if (Main.netMode == 2)
              NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
          }
          bool flag = true;
          while (flag)
          {
            flag = false;
            int index3 = i + Main.rand.Next(-6, 7);
            int index4 = j + Main.rand.Next(-6, 7);
            if (WorldGen.InWorld(index3, index4, 2) && Main.tile[index3, index4].active())
            {
              if (Main.tile[index3, index4].type == (ushort) 23 || Main.tile[index3, index4].type == (ushort) 199 || (Main.tile[index3, index4].type == (ushort) 2 || Main.tile[index3, index4].type == (ushort) 477) || (Main.tile[index3, index4].type == (ushort) 492 || Main.tile[index3, index4].type == (ushort) 109))
              {
                Main.tile[index3, index4].type = (ushort) 60;
                WorldGen.SquareTileFrame(index3, index4, true);
                if (Main.netMode == 2)
                  NetMessage.SendTileSquare(-1, index3, index4, 1, TileChangeType.None);
                flag = true;
              }
              else if (Main.tile[index3, index4].type == (ushort) 0)
              {
                Main.tile[index3, index4].type = (ushort) 59;
                WorldGen.SquareTileFrame(index3, index4, true);
                if (Main.netMode == 2)
                  NetMessage.SendTileSquare(-1, index3, index4, 1, TileChangeType.None);
                flag = true;
              }
            }
          }
        }
      }
      if (NPC.downedPlantBoss && WorldGen.genRand.Next(2) != 0 || !WorldGen.AllowedToSpreadInfections)
        return;
      if (type == 23 || type == 25 || (type == 32 || type == 112) || (type == 163 || type == 400 || type == 398))
      {
        bool flag = true;
        while (flag)
        {
          flag = false;
          int index1 = i + WorldGen.genRand.Next(-3, 4);
          int index2 = j + WorldGen.genRand.Next(-3, 4);
          if (!WorldGen.nearbyChlorophyte(index1, index2))
          {
            if (WorldGen.CountNearBlocksTypes(index1, index2, 2, 1, 27) <= 0)
            {
              if (Main.tile[index1, index2].type == (ushort) 2)
              {
                if (WorldGen.genRand.Next(2) == 0)
                  flag = true;
                Main.tile[index1, index2].type = (ushort) 23;
                WorldGen.SquareTileFrame(index1, index2, true);
                NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
              }
              else if (Main.tile[index1, index2].type == (ushort) 1 || Main.tileMoss[(int) Main.tile[index1, index2].type])
              {
                if (WorldGen.genRand.Next(2) == 0)
                  flag = true;
                Main.tile[index1, index2].type = (ushort) 25;
                WorldGen.SquareTileFrame(index1, index2, true);
                NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
              }
              else if (Main.tile[index1, index2].type == (ushort) 53)
              {
                if (WorldGen.genRand.Next(2) == 0)
                  flag = true;
                Main.tile[index1, index2].type = (ushort) 112;
                WorldGen.SquareTileFrame(index1, index2, true);
                NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
              }
              else if (Main.tile[index1, index2].type == (ushort) 396)
              {
                if (WorldGen.genRand.Next(2) == 0)
                  flag = true;
                Main.tile[index1, index2].type = (ushort) 400;
                WorldGen.SquareTileFrame(index1, index2, true);
                NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
              }
              else if (Main.tile[index1, index2].type == (ushort) 397)
              {
                if (WorldGen.genRand.Next(2) == 0)
                  flag = true;
                Main.tile[index1, index2].type = (ushort) 398;
                WorldGen.SquareTileFrame(index1, index2, true);
                NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
              }
              else if (Main.tile[index1, index2].type == (ushort) 59)
              {
                if (WorldGen.genRand.Next(2) == 0)
                  flag = true;
                Main.tile[index1, index2].type = (ushort) 0;
                WorldGen.SquareTileFrame(index1, index2, true);
                NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
              }
              else if (Main.tile[index1, index2].type == (ushort) 60)
              {
                if (WorldGen.genRand.Next(2) == 0)
                  flag = true;
                Main.tile[index1, index2].type = (ushort) 23;
                WorldGen.SquareTileFrame(index1, index2, true);
                NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
              }
              else if (Main.tile[index1, index2].type == (ushort) 69)
              {
                if (WorldGen.genRand.Next(2) == 0)
                  flag = true;
                Main.tile[index1, index2].type = (ushort) 32;
                WorldGen.SquareTileFrame(index1, index2, true);
                NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
              }
              else if (Main.tile[index1, index2].type == (ushort) 161)
              {
                if (WorldGen.genRand.Next(2) == 0)
                  flag = true;
                Main.tile[index1, index2].type = (ushort) 163;
                WorldGen.SquareTileFrame(index1, index2, true);
                NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
              }
            }
          }
        }
      }
      if (type == 199 || type == 200 || (type == 201 || type == 203) || (type == 205 || type == 234 || (type == 352 || type == 401)) || type == 399)
      {
        bool flag = true;
        while (flag)
        {
          flag = false;
          int index1 = i + WorldGen.genRand.Next(-3, 4);
          int index2 = j + WorldGen.genRand.Next(-3, 4);
          if (!WorldGen.nearbyChlorophyte(index1, index2))
          {
            if (WorldGen.CountNearBlocksTypes(index1, index2, 2, 1, 27) <= 0)
            {
              if (Main.tile[index1, index2].type == (ushort) 2)
              {
                if (WorldGen.genRand.Next(2) == 0)
                  flag = true;
                Main.tile[index1, index2].type = (ushort) 199;
                WorldGen.SquareTileFrame(index1, index2, true);
                NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
              }
              else if (Main.tile[index1, index2].type == (ushort) 1 || Main.tileMoss[(int) Main.tile[index1, index2].type])
              {
                if (WorldGen.genRand.Next(2) == 0)
                  flag = true;
                Main.tile[index1, index2].type = (ushort) 203;
                WorldGen.SquareTileFrame(index1, index2, true);
                NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
              }
              else if (Main.tile[index1, index2].type == (ushort) 53)
              {
                if (WorldGen.genRand.Next(2) == 0)
                  flag = true;
                Main.tile[index1, index2].type = (ushort) 234;
                WorldGen.SquareTileFrame(index1, index2, true);
                NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
              }
              else if (Main.tile[index1, index2].type == (ushort) 396)
              {
                if (WorldGen.genRand.Next(2) == 0)
                  flag = true;
                Main.tile[index1, index2].type = (ushort) 401;
                WorldGen.SquareTileFrame(index1, index2, true);
                NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
              }
              else if (Main.tile[index1, index2].type == (ushort) 397)
              {
                if (WorldGen.genRand.Next(2) == 0)
                  flag = true;
                Main.tile[index1, index2].type = (ushort) 399;
                WorldGen.SquareTileFrame(index1, index2, true);
                NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
              }
              else if (Main.tile[index1, index2].type == (ushort) 59)
              {
                if (WorldGen.genRand.Next(2) == 0)
                  flag = true;
                Main.tile[index1, index2].type = (ushort) 0;
                WorldGen.SquareTileFrame(index1, index2, true);
                NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
              }
              else if (Main.tile[index1, index2].type == (ushort) 60)
              {
                if (WorldGen.genRand.Next(2) == 0)
                  flag = true;
                Main.tile[index1, index2].type = (ushort) 199;
                WorldGen.SquareTileFrame(index1, index2, true);
                NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
              }
              else if (Main.tile[index1, index2].type == (ushort) 69)
              {
                if (WorldGen.genRand.Next(2) == 0)
                  flag = true;
                Main.tile[index1, index2].type = (ushort) 352;
                WorldGen.SquareTileFrame(index1, index2, true);
                NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
              }
              else if (Main.tile[index1, index2].type == (ushort) 161)
              {
                if (WorldGen.genRand.Next(2) == 0)
                  flag = true;
                Main.tile[index1, index2].type = (ushort) 200;
                WorldGen.SquareTileFrame(index1, index2, true);
                NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
              }
            }
          }
        }
      }
      if (type != 109 && type != 110 && (type != 113 && type != 115) && (type != 116 && type != 117 && (type != 164 && type != 402)) && (type != 403 && type != 492))
        return;
      bool flag1 = true;
      while (flag1)
      {
        flag1 = false;
        int index1 = i + WorldGen.genRand.Next(-3, 4);
        int index2 = j + WorldGen.genRand.Next(-3, 4);
        if (WorldGen.CountNearBlocksTypes(index1, index2, 2, 1, 27) <= 0)
        {
          if (Main.tile[index1, index2].type == (ushort) 2)
          {
            if (WorldGen.genRand.Next(2) == 0)
              flag1 = true;
            Main.tile[index1, index2].type = (ushort) 109;
            WorldGen.SquareTileFrame(index1, index2, true);
            NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
          }
          else if (Main.tile[index1, index2].type == (ushort) 477)
          {
            if (WorldGen.genRand.Next(2) == 0)
              flag1 = true;
            Main.tile[index1, index2].type = (ushort) 492;
            WorldGen.SquareTileFrame(index1, index2, true);
            NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
          }
          else if (Main.tile[index1, index2].type == (ushort) 1 || Main.tileMoss[(int) Main.tile[index1, index2].type])
          {
            if (WorldGen.genRand.Next(2) == 0)
              flag1 = true;
            Main.tile[index1, index2].type = (ushort) 117;
            WorldGen.SquareTileFrame(index1, index2, true);
            NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
          }
          else if (Main.tile[index1, index2].type == (ushort) 53)
          {
            if (WorldGen.genRand.Next(2) == 0)
              flag1 = true;
            Main.tile[index1, index2].type = (ushort) 116;
            WorldGen.SquareTileFrame(index1, index2, true);
            NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
          }
          else if (Main.tile[index1, index2].type == (ushort) 396)
          {
            if (WorldGen.genRand.Next(2) == 0)
              flag1 = true;
            Main.tile[index1, index2].type = (ushort) 403;
            WorldGen.SquareTileFrame(index1, index2, true);
            NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
          }
          else if (Main.tile[index1, index2].type == (ushort) 397)
          {
            if (WorldGen.genRand.Next(2) == 0)
              flag1 = true;
            Main.tile[index1, index2].type = (ushort) 402;
            WorldGen.SquareTileFrame(index1, index2, true);
            NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
          }
          else if (Main.tile[index1, index2].type == (ushort) 161)
          {
            if (WorldGen.genRand.Next(2) == 0)
              flag1 = true;
            Main.tile[index1, index2].type = (ushort) 164;
            WorldGen.SquareTileFrame(index1, index2, true);
            NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
          }
        }
      }
    }

    public static bool SolidTile(Tile testTile)
    {
      try
      {
        if (testTile == null)
          return true;
        if (testTile.active())
        {
          if (Main.tileSolid[(int) testTile.type])
          {
            if (!Main.tileSolidTop[(int) testTile.type])
            {
              if (!testTile.halfBrick())
              {
                if (testTile.slope() == (byte) 0)
                {
                  if (!testTile.inActive())
                    return true;
                }
              }
            }
          }
        }
      }
      catch
      {
      }
      return false;
    }

    public static bool TileEmpty(int i, int j)
    {
      return Main.tile[i, j] == null || !Main.tile[i, j].active() || Main.tile[i, j].inActive();
    }

    public static bool SolidOrSlopedTile(Tile tile)
    {
      return tile != null && tile.active() && (Main.tileSolid[(int) tile.type] && !Main.tileSolidTop[(int) tile.type]) && !tile.inActive();
    }

    public static int TileType(int x, int y)
    {
      return !Main.tile[x, y].active() ? -1 : (int) Main.tile[x, y].type;
    }

    public static bool SolidOrSlopedTile(int x, int y)
    {
      return WorldGen.SolidOrSlopedTile(Main.tile[x, y]);
    }

    public static bool SolidTile(Point p)
    {
      return WorldGen.SolidTile(p.X, p.Y, false);
    }

    public static bool SolidTile(int i, int j, bool noDoors = false)
    {
      try
      {
        if (Main.tile[i, j] == null)
          return true;
        if (Main.tile[i, j].active())
        {
          if (Main.tileSolid[(int) Main.tile[i, j].type])
          {
            if (!Main.tileSolidTop[(int) Main.tile[i, j].type])
            {
              if (!Main.tile[i, j].halfBrick())
              {
                if (Main.tile[i, j].slope() == (byte) 0)
                {
                  if (!Main.tile[i, j].inActive())
                    return !noDoors || Main.tile[i, j].type != (ushort) 10;
                }
              }
            }
          }
        }
      }
      catch
      {
      }
      return false;
    }

    public static bool SolidTile2(Tile testTile)
    {
      try
      {
        if (testTile == null)
          return true;
        if (testTile.active())
        {
          if (Main.tileSolid[(int) testTile.type])
          {
            if (testTile.slope() == (byte) 0)
            {
              if (!testTile.halfBrick())
              {
                if (!testTile.inActive())
                  return true;
              }
            }
          }
        }
      }
      catch
      {
      }
      return false;
    }

    public static bool PlatformProperTopFrame(short frameX)
    {
      int num = (int) frameX / TileObjectData.PlatformFrameWidth();
      if (num >= 0 && num <= 7 || num >= 12 && num <= 16)
        return true;
      return num >= 25 && num <= 26;
    }

    public static bool SolidTileAllowBottomSlope(int i, int j)
    {
      try
      {
        Tile tile = Main.tile[i, j];
        if (tile == null)
          return true;
        if (tile.active())
        {
          if (!Main.tileSolid[(int) tile.type])
          {
            if (!Main.tileSolidTop[(int) tile.type])
              goto label_12;
          }
          if (tile.topSlope())
          {
            if (TileID.Sets.Platforms[(int) tile.type])
            {
              if (!WorldGen.PlatformProperTopFrame(tile.frameX))
                goto label_12;
            }
            else
              goto label_12;
          }
          if (!tile.halfBrick())
          {
            if (!tile.inActive())
              return true;
          }
        }
      }
      catch
      {
      }
label_12:
      return false;
    }

    public static bool SolidTileAllowTopSlope(int i, int j)
    {
      try
      {
        Tile tile = Main.tile[i, j];
        if (tile == null)
          return true;
        if (tile.active())
        {
          if (Main.tileSolid[(int) tile.type])
          {
            if (tile.bottomSlope())
            {
              if (TileID.Sets.Platforms[(int) tile.type])
              {
                if (!tile.halfBrick())
                  goto label_10;
              }
              else
                goto label_10;
            }
            if (!tile.inActive())
              return true;
          }
        }
      }
      catch
      {
      }
label_10:
      return false;
    }

    public static bool TopEdgeCanBeAttachedTo(int i, int j)
    {
      try
      {
        Tile tile = Main.tile[i, j];
        if (tile == null)
          return true;
        if (tile.active())
        {
          if (!Main.tileSolid[(int) tile.type])
          {
            if (!Main.tileSolidTop[(int) tile.type])
              goto label_12;
          }
          if (tile.topSlope())
          {
            if (TileID.Sets.Platforms[(int) tile.type])
            {
              if (!WorldGen.PlatformProperTopFrame(tile.frameX))
                goto label_12;
            }
            else
              goto label_12;
          }
          if (!tile.halfBrick())
          {
            if (!tile.inActive())
              return true;
          }
        }
      }
      catch
      {
      }
label_12:
      return false;
    }

    public static bool RightEdgeCanBeAttachedTo(int i, int j)
    {
      try
      {
        Tile tile = Main.tile[i, j];
        if (tile == null)
          return true;
        if (tile.active())
        {
          if (Main.tileSolid[(int) tile.type])
          {
            if (!Main.tileSolidTop[(int) tile.type])
            {
              if (!tile.rightSlope())
              {
                if (!tile.halfBrick())
                {
                  if (!tile.inActive())
                  {
                    if (!Main.tileNoAttach[(int) tile.type])
                      return true;
                  }
                }
              }
            }
          }
        }
      }
      catch
      {
      }
      return false;
    }

    public static bool LeftEdgeCanBeAttachedTo(int i, int j)
    {
      try
      {
        Tile tile = Main.tile[i, j];
        if (tile == null)
          return true;
        if (tile.active())
        {
          if (Main.tileSolid[(int) tile.type])
          {
            if (!Main.tileSolidTop[(int) tile.type])
            {
              if (!tile.leftSlope())
              {
                if (!tile.halfBrick())
                {
                  if (!tile.inActive())
                  {
                    if (!Main.tileNoAttach[(int) tile.type])
                      return true;
                  }
                }
              }
            }
          }
        }
      }
      catch
      {
      }
      return false;
    }

    public static bool BottomEdgeCanBeAttachedTo(int i, int j)
    {
      try
      {
        Tile tile = Main.tile[i, j];
        if (tile == null)
          return true;
        if (tile.active())
        {
          if (Main.tileSolid[(int) tile.type])
          {
            if (!Main.tileSolidTop[(int) tile.type])
            {
              if (!tile.bottomSlope())
              {
                if (!tile.inActive())
                {
                  if (!Main.tileNoAttach[(int) tile.type])
                    return true;
                }
              }
            }
          }
        }
      }
      catch
      {
      }
      return false;
    }

    public static bool SolidTile3(int i, int j)
    {
      return WorldGen.InWorld(i, j, 1) && WorldGen.SolidTile3(Main.tile[i, j]);
    }

    public static bool SolidTile3(Tile t)
    {
      return t != null && t.active() && (!t.inActive() && Main.tileSolid[(int) t.type]) && !Main.tileSolidTop[(int) t.type];
    }

    public static bool SolidTile2(int i, int j)
    {
      try
      {
        if (Main.tile[i, j] == null)
          return true;
        if (Main.tile[i, j].active())
        {
          if (Main.tileSolid[(int) Main.tile[i, j].type])
          {
            if (!TileID.Sets.Platforms[(int) Main.tile[i, j].type] || !Main.tile[i, j].halfBrick() && !Main.tile[i, j].topSlope())
            {
              if (Main.tile[i, j].slope() != (byte) 0)
                goto label_10;
            }
            if (!Main.tile[i, j].halfBrick())
            {
              if (!Main.tile[i, j].inActive())
                return true;
            }
          }
        }
      }
      catch
      {
      }
label_10:
      return false;
    }

    public static bool SolidTileNoAttach(int i, int j)
    {
      try
      {
        if (Main.tile[i, j] == null)
          return true;
        if (Main.tile[i, j].active())
        {
          if (Main.tileSolid[(int) Main.tile[i, j].type])
          {
            if (!Main.tileNoAttach[(int) Main.tile[i, j].type])
            {
              if (Main.tile[i, j].slope() == (byte) 0)
              {
                if (!Main.tile[i, j].halfBrick())
                {
                  if (!Main.tile[i, j].inActive())
                    return true;
                }
              }
            }
          }
        }
      }
      catch
      {
      }
      return false;
    }

    public static void MineHouse(int i, int j)
    {
      if (i < 50 || i > Main.maxTilesX - 50 || (j < 50 || j > Main.maxTilesY - 50))
        return;
      int num1 = WorldGen.genRand.Next(6, 12);
      int num2 = WorldGen.genRand.Next(3, 6);
      int num3 = WorldGen.genRand.Next(15, 30);
      int num4 = WorldGen.genRand.Next(15, 30);
      if (WorldGen.SolidTile(i, j, false) || Main.tile[i, j].wall > (ushort) 0)
        return;
      int num5 = j - num1;
      int num6 = j + num2;
      for (int index1 = 0; index1 < 2; ++index1)
      {
        bool flag1 = true;
        int i1 = i;
        int j1 = j;
        int num7 = -1;
        int num8 = num3;
        if (index1 == 1)
        {
          num7 = 1;
          num8 = num4;
          ++i1;
        }
        while (flag1)
        {
          if (j1 - num1 < num5)
            num5 = j1 - num1;
          if (j1 + num2 > num6)
            num6 = j1 + num2;
          for (int index2 = 0; index2 < 2; ++index2)
          {
            int j2 = j1;
            bool flag2 = true;
            int num9 = num1;
            int num10 = -1;
            if (index2 == 1)
            {
              ++j2;
              num9 = num2;
              num10 = 1;
            }
            while (flag2)
            {
              if (i1 != i && Main.tile[i1 - num7, j2].wall != (ushort) 27 && (WorldGen.SolidTile(i1 - num7, j2, false) || !Main.tile[i1 - num7, j2].active() || (Main.tile[i1 - num7, j2].halfBrick() || Main.tile[i1 - num7, j2].slope() != (byte) 0)))
              {
                Main.tile[i1 - num7, j2].active(true);
                Main.tile[i1 - num7, j2].type = (ushort) 30;
              }
              if (WorldGen.SolidTile(i1 - 1, j2, false) || Main.tile[i1 - 1, j2].halfBrick() || Main.tile[i1 - 1, j2].slope() != (byte) 0)
                Main.tile[i1 - 1, j2].type = (ushort) 30;
              if (WorldGen.SolidTile(i1 + 1, j2, false) || Main.tile[i1 + 1, j2].halfBrick() || Main.tile[i1 + 1, j2].slope() != (byte) 0)
                Main.tile[i1 + 1, j2].type = (ushort) 30;
              if (WorldGen.SolidTile(i1, j2, false) || Main.tile[i1, j2].halfBrick() || Main.tile[i1, j2].slope() != (byte) 0)
              {
                int num11 = 0;
                if (WorldGen.SolidTile(i1 - 1, j2, false))
                  ++num11;
                if (WorldGen.SolidTile(i1 + 1, j2, false))
                  ++num11;
                if (WorldGen.SolidTile(i1, j2 - 1, false))
                  ++num11;
                if (WorldGen.SolidTile(i1, j2 + 1, false))
                  ++num11;
                if (num11 < 2)
                {
                  Main.tile[i1, j2].active(false);
                }
                else
                {
                  flag2 = false;
                  Main.tile[i1, j2].type = (ushort) 30;
                }
              }
              else
              {
                Main.tile[i1, j2].wall = (ushort) 27;
                Main.tile[i1, j2].liquid = (byte) 0;
                Main.tile[i1, j2].lava(false);
              }
              j2 += num10;
              --num9;
              if (num9 <= 0)
              {
                if (!Main.tile[i1, j2].active())
                {
                  Main.tile[i1, j2].active(true);
                  Main.tile[i1, j2].type = (ushort) 30;
                }
                flag2 = false;
              }
            }
          }
          --num8;
          i1 += num7;
          if (WorldGen.SolidTile(i1, j1, false))
          {
            int num9 = 0;
            int num10 = 0;
            int j2 = j1;
            bool flag2 = true;
            while (flag2)
            {
              --j2;
              ++num9;
              if (WorldGen.SolidTile(i1 - num7, j2, false))
              {
                num9 = 999;
                flag2 = false;
              }
              else if (!WorldGen.SolidTile(i1, j2, false))
                flag2 = false;
            }
            int j3 = j1;
            bool flag3 = true;
            while (flag3)
            {
              ++j3;
              ++num10;
              if (WorldGen.SolidTile(i1 - num7, j3, false))
              {
                num10 = 999;
                flag3 = false;
              }
              else if (!WorldGen.SolidTile(i1, j3, false))
                flag3 = false;
            }
            if (num10 <= num9)
            {
              if (num10 > num2)
                num8 = 0;
              else
                j1 += num10 + 1;
            }
            else if (num9 > num1)
              num8 = 0;
            else
              j1 -= num9 + 1;
          }
          if (num8 <= 0)
            flag1 = false;
        }
      }
      int minValue1 = i - num3 - 1;
      int maxValue1 = i + num4 + 2;
      int minValue2 = num5 - 1;
      int maxValue2 = num6 + 2;
      for (int i1 = minValue1; i1 < maxValue1; ++i1)
      {
        for (int j1 = minValue2; j1 < maxValue2; ++j1)
        {
          if (Main.tile[i1, j1].wall == (ushort) 27 && !Main.tile[i1, j1].active())
          {
            if (Main.tile[i1 - 1, j1].wall != (ushort) 27 && i1 < i && !WorldGen.SolidTile(i1 - 1, j1, false))
            {
              WorldGen.PlaceTile(i1, j1, 30, true, false, -1, 0);
              Main.tile[i1, j1].wall = (ushort) 0;
            }
            if (Main.tile[i1 + 1, j1].wall != (ushort) 27 && i1 > i && !WorldGen.SolidTile(i1 + 1, j1, false))
            {
              WorldGen.PlaceTile(i1, j1, 30, true, false, -1, 0);
              Main.tile[i1, j1].wall = (ushort) 0;
            }
            for (int i2 = i1 - 1; i2 <= i1 + 1; ++i2)
            {
              for (int j2 = j1 - 1; j2 <= j1 + 1; ++j2)
              {
                if (WorldGen.SolidTile(i2, j2, false))
                  Main.tile[i2, j2].type = (ushort) 30;
              }
            }
          }
          if (Main.tile[i1, j1].type == (ushort) 30 && Main.tile[i1 - 1, j1].wall == (ushort) 27 && Main.tile[i1 + 1, j1].wall == (ushort) 27 && ((Main.tile[i1, j1 - 1].wall == (ushort) 27 || Main.tile[i1, j1 - 1].active()) && (Main.tile[i1, j1 + 1].wall == (ushort) 27 || Main.tile[i1, j1 + 1].active())))
          {
            Main.tile[i1, j1].active(false);
            Main.tile[i1, j1].wall = (ushort) 27;
          }
        }
      }
      for (int index1 = minValue1; index1 < maxValue1; ++index1)
      {
        for (int index2 = minValue2; index2 < maxValue2; ++index2)
        {
          if (Main.tile[index1, index2].type == (ushort) 30)
          {
            if (Main.tile[index1 - 1, index2].wall == (ushort) 27 && Main.tile[index1 + 1, index2].wall == (ushort) 27 && (!Main.tile[index1 - 1, index2].active() && !Main.tile[index1 + 1, index2].active()))
            {
              Main.tile[index1, index2].active(false);
              Main.tile[index1, index2].wall = (ushort) 27;
            }
            if (!TileID.Sets.BasicChest[(int) Main.tile[index1, index2 - 1].type] && Main.tile[index1 - 1, index2].wall == (ushort) 27 && (Main.tile[index1 + 1, index2].type == (ushort) 30 && Main.tile[index1 + 2, index2].wall == (ushort) 27) && (!Main.tile[index1 - 1, index2].active() && !Main.tile[index1 + 2, index2].active()))
            {
              Main.tile[index1, index2].active(false);
              Main.tile[index1, index2].wall = (ushort) 27;
              Main.tile[index1 + 1, index2].active(false);
              Main.tile[index1 + 1, index2].wall = (ushort) 27;
            }
            if (Main.tile[index1, index2 - 1].wall == (ushort) 27 && Main.tile[index1, index2 + 1].wall == (ushort) 27 && (!Main.tile[index1, index2 - 1].active() && !Main.tile[index1, index2 + 1].active()))
            {
              Main.tile[index1, index2].active(false);
              Main.tile[index1, index2].wall = (ushort) 27;
            }
          }
        }
      }
      for (int i1 = minValue1; i1 < maxValue1; ++i1)
      {
        for (int j1 = maxValue2; j1 > minValue2; --j1)
        {
          bool flag1 = false;
          if (Main.tile[i1, j1].active() && Main.tile[i1, j1].type == (ushort) 30)
          {
            int num7 = -1;
            for (int index1 = 0; index1 < 2; ++index1)
            {
              if (!WorldGen.SolidTile(i1 + num7, j1, false) && Main.tile[i1 + num7, j1].wall == (ushort) 0)
              {
                int num8 = 0;
                int j2 = j1;
                int num9 = j1;
                while (Main.tile[i1, j2].active() && Main.tile[i1, j2].type == (ushort) 30 && (!WorldGen.SolidTile(i1 + num7, j2, false) && Main.tile[i1 + num7, j2].wall == (ushort) 0))
                {
                  --j2;
                  ++num8;
                }
                int num10 = j2 + 1 + 1;
                if (num8 > 4)
                {
                  if (WorldGen.genRand.Next(2) == 0)
                  {
                    int j3 = num9 - 1;
                    bool flag2 = true;
                    for (int index2 = i1 - 2; index2 <= i1 + 2; ++index2)
                    {
                      for (int index3 = j3 - 2; index3 <= j3; ++index3)
                      {
                        if (index2 != i1 && Main.tile[index2, index3].active())
                          flag2 = false;
                      }
                    }
                    if (flag2)
                    {
                      Main.tile[i1, j3].active(false);
                      Main.tile[i1, j3 - 1].active(false);
                      Main.tile[i1, j3 - 2].active(false);
                      WorldGen.PlaceTile(i1, j3, 10, true, false, -1, 0);
                      flag1 = true;
                    }
                  }
                  if (!flag1)
                  {
                    for (int index2 = num10; index2 < num9; ++index2)
                      Main.tile[i1, index2].type = (ushort) 124;
                  }
                }
              }
              num7 = 1;
            }
          }
          if (flag1)
            break;
        }
      }
      int num12 = WorldGen.genRand.Next(1, 2);
      if (WorldGen.genRand.Next(4) == 0)
        num12 = 0;
      if (WorldGen.genRand.Next(6) == 0)
        ++num12;
      if (WorldGen.genRand.Next(10) == 0)
        ++num12;
      for (int index1 = 0; index1 < num12; ++index1)
      {
        int num7 = 0;
        int index2 = WorldGen.genRand.Next(minValue1, maxValue1);
        int index3;
        for (index3 = WorldGen.genRand.Next(minValue2, maxValue2); !Main.wallHouse[(int) Main.tile[index2, index3].wall] || Main.tile[index2, index3].active(); index3 = WorldGen.genRand.Next(minValue2, maxValue2))
        {
          ++num7;
          if (num7 <= 1000)
            index2 = WorldGen.genRand.Next(minValue1, maxValue1);
          else
            break;
        }
        if (num7 <= 1000)
        {
          for (int index4 = 0; index4 < 2; ++index4)
          {
            int index5 = index2;
            int index6 = index2;
            while (!Main.tile[index5, index3].active() && Main.wallHouse[(int) Main.tile[index5, index3].wall])
              --index5;
            int num8 = index5 + 1;
            while (!Main.tile[index6, index3].active() && Main.wallHouse[(int) Main.tile[index6, index3].wall])
              ++index6;
            int num9 = index6 - 1;
            i = (num8 + num9) / 2;
            int index7 = index3;
            int index8 = index3;
            while (!Main.tile[index2, index7].active() && Main.wallHouse[(int) Main.tile[index2, index7].wall])
              --index7;
            int num10 = index7 + 1;
            while (!Main.tile[index2, index8].active() && Main.wallHouse[(int) Main.tile[index2, index8].wall])
              ++index8;
            int num11 = index8 - 1;
            index3 = (num10 + num11) / 2;
          }
          int index9 = index2;
          int index10 = index2;
          while (!Main.tile[index9, index3].active() && !Main.tile[index9, index3 - 1].active() && !Main.tile[index9, index3 + 1].active())
            --index9;
          int num13 = index9 + 1;
          while (!Main.tile[index10, index3].active() && !Main.tile[index10, index3 - 1].active() && !Main.tile[index10, index3 + 1].active())
            ++index10;
          int num14 = index10 - 1;
          int index11 = index3;
          int index12 = index3;
          while (!Main.tile[index2, index11].active() && !Main.tile[index2 - 1, index11].active() && !Main.tile[index2 + 1, index11].active())
            --index11;
          int num15 = index11 + 1;
          while (!Main.tile[index2, index12].active() && !Main.tile[index2 - 1, index12].active() && !Main.tile[index2 + 1, index12].active())
            ++index12;
          int num16 = index12 - 1;
          int num17 = (num13 + num14) / 2;
          int num18 = (num15 + num16) / 2;
          int num19 = num14 - num13;
          int num20 = num16 - num15;
          if (num19 > 7 && num20 > 5)
          {
            int num8 = 0;
            if (WorldGen.nearPicture2(i, num18))
              num8 = -1;
            if (num8 == 0)
            {
              Vector2 vector2 = WorldGen.randHousePicture();
              int x = (int) vector2.X;
              int y = (int) vector2.Y;
              if (!WorldGen.nearPicture(num17, num18))
                WorldGen.PlaceTile(num17, num18, x, true, false, -1, y);
            }
          }
        }
        else
          break;
      }
      for (int i1 = minValue1; i1 < maxValue1; i1 = i1 + WorldGen.genRand.Next(4) + 1)
      {
        bool flag = true;
        for (int j1 = minValue2; j1 < maxValue2; ++j1)
        {
          for (int i2 = i1 - 3; i2 <= i1 + 3; ++i2)
          {
            if (Main.tile[i2, j1].active() && (!WorldGen.SolidTile(i2, j1, false) || Main.tile[i2, j1].type == (ushort) 10))
              flag = false;
          }
        }
        if (flag)
        {
          for (int j1 = minValue2; j1 < maxValue2; ++j1)
          {
            if (Main.tile[i1, j1].wall == (ushort) 27 && !Main.tile[i1, j1].active())
              WorldGen.PlaceTile(i1, j1, 124, true, false, -1, 0);
          }
        }
      }
      for (int index1 = 0; index1 < 4; ++index1)
      {
        int i1 = WorldGen.genRand.Next(minValue1 + 2, maxValue1 - 1);
        int index2;
        for (index2 = WorldGen.genRand.Next(minValue2 + 2, maxValue2 - 1); Main.tile[i1, index2].wall != (ushort) 27; index2 = WorldGen.genRand.Next(minValue2 + 2, maxValue2 - 1))
          i1 = WorldGen.genRand.Next(minValue1 + 2, maxValue1 - 1);
        while (Main.tile[i1, index2].active())
          --index2;
        while (!Main.tile[i1, index2].active())
          ++index2;
        int j1 = index2 - 1;
        if (Main.tile[i1, j1].wall == (ushort) 27)
        {
          if (WorldGen.genRand.Next(3) == 0)
          {
            int Type = WorldGen.genRand.Next(9);
            if (Type == 0)
              Type = 14;
            if (Type == 1)
              Type = 16;
            if (Type == 2)
              Type = 18;
            if (Type == 3)
              Type = 86;
            if (Type == 4)
              Type = 87;
            if (Type == 5)
              Type = 94;
            if (Type == 6)
              Type = 101;
            if (Type == 7)
              Type = 104;
            if (Type == 8)
              Type = 106;
            WorldGen.PlaceTile(i1, j1, Type, true, false, -1, 0);
          }
          else if (WorldGen.statueList != null)
          {
            int index3 = WorldGen.genRand.Next(2, WorldGen.statueList.Length);
            WorldGen.PlaceTile(i1, j1, (int) WorldGen.statueList[index3].X, true, true, -1, (int) WorldGen.statueList[index3].Y);
          }
        }
      }
      for (int index1 = 0; index1 < 40; ++index1)
      {
        int i1 = WorldGen.genRand.Next(minValue1 + 2, maxValue1 - 1);
        int index2;
        for (index2 = WorldGen.genRand.Next(minValue2 + 2, maxValue2 - 1); Main.tile[i1, index2].wall != (ushort) 27; index2 = WorldGen.genRand.Next(minValue2 + 2, maxValue2 - 1))
          i1 = WorldGen.genRand.Next(minValue1 + 2, maxValue1 - 1);
        while (Main.tile[i1, index2].active())
          --index2;
        while (!Main.tile[i1, index2].active())
          ++index2;
        int j1 = index2 - 1;
        if (Main.tile[i1, j1].wall == (ushort) 27 && WorldGen.genRand.Next(2) == 0)
        {
          int style = WorldGen.genRand.Next(22, 26);
          WorldGen.PlaceTile(i1, j1, 186, true, false, -1, style);
        }
      }
      for (int index1 = 0; index1 < 20; ++index1)
      {
        int i1 = WorldGen.genRand.Next(minValue1 + 2, maxValue1 - 1);
        int index2;
        for (index2 = WorldGen.genRand.Next(minValue2 + 2, maxValue2 - 1); Main.tile[i1, index2].wall != (ushort) 27; index2 = WorldGen.genRand.Next(minValue2 + 2, maxValue2 - 1))
          i1 = WorldGen.genRand.Next(minValue1 + 2, maxValue1 - 1);
        while (Main.tile[i1, index2].active())
          --index2;
        while (!Main.tile[i1, index2].active())
          ++index2;
        int j1 = index2 - 1;
        if (Main.tile[i1, j1].wall == (ushort) 27 && WorldGen.genRand.Next(2) == 0)
        {
          int X = WorldGen.genRand.Next(31, 34);
          WorldGen.PlaceSmallPile(i1, j1, X, 1, (ushort) 185);
        }
      }
      for (int index1 = 0; index1 < 15; ++index1)
      {
        int i1 = WorldGen.genRand.Next(minValue1 + 2, maxValue1 - 1);
        int j1;
        for (j1 = WorldGen.genRand.Next(minValue2 + 2, maxValue2 - 1); Main.tile[i1, j1].wall != (ushort) 27; j1 = WorldGen.genRand.Next(minValue2 + 2, maxValue2 - 1))
          i1 = WorldGen.genRand.Next(minValue1 + 2, maxValue1 - 1);
        while (Main.tile[i1, j1].active())
          --j1;
        while (j1 > 0 && !Main.tile[i1, j1 - 1].active())
          --j1;
        if (Main.tile[i1, j1].wall == (ushort) 27)
        {
          int style = 0;
          int Type;
          if (WorldGen.genRand.Next(10) < 9)
          {
            Type = -1;
          }
          else
          {
            Type = 34;
            style = WorldGen.genRand.Next(6);
          }
          if (Type > 0)
          {
            WorldGen.PlaceTile(i1, j1, Type, true, false, -1, style);
            if ((int) Main.tile[i1, j1].type == Type)
            {
              if (Type == 4)
              {
                Main.tile[i1, j1].frameX += (short) 54;
              }
              else
              {
                int index2 = i1;
                int index3 = j1;
                int index4 = index3 - (int) Main.tile[index2, index3].frameY % 54 / 18;
                int num7 = (int) Main.tile[index2, index3].frameX / 18;
                if (num7 > 2)
                  num7 -= 3;
                int index5 = index2 - num7;
                short num8 = 54;
                if (Main.tile[index5, index4].frameX > (short) 0)
                  num8 = (short) -54;
                for (int index6 = index5; index6 < index5 + 3; ++index6)
                {
                  for (int index7 = index4; index7 < index4 + 3; ++index7)
                    Main.tile[index6, index7].frameX += num8;
                }
              }
            }
          }
        }
      }
    }

    public static void CountTiles(int X)
    {
      if (X == 0)
      {
        WorldGen.totalEvil = WorldGen.totalEvil2;
        WorldGen.totalBlood = WorldGen.totalBlood2;
        WorldGen.totalSolid = WorldGen.totalSolid2;
        WorldGen.totalGood = WorldGen.totalGood2;
        WorldGen.tGood = (byte) Math.Round((double) WorldGen.totalGood / (double) WorldGen.totalSolid * 100.0);
        WorldGen.tEvil = (byte) Math.Round((double) WorldGen.totalEvil / (double) WorldGen.totalSolid * 100.0);
        WorldGen.tBlood = (byte) Math.Round((double) WorldGen.totalBlood / (double) WorldGen.totalSolid * 100.0);
        if (WorldGen.tGood == (byte) 0 && WorldGen.totalGood > 0)
          WorldGen.tGood = (byte) 1;
        if (WorldGen.tEvil == (byte) 0 && WorldGen.totalEvil > 0)
          WorldGen.tEvil = (byte) 1;
        if (WorldGen.tBlood == (byte) 0 && WorldGen.totalBlood > 0)
          WorldGen.tBlood = (byte) 1;
        if (Main.netMode == 2)
          NetMessage.SendData(57, -1, -1, (NetworkText) null, 0, 0.0f, 0.0f, 0.0f, 0, 0, 0);
        WorldGen.totalEvil2 = 0;
        WorldGen.totalSolid2 = 0;
        WorldGen.totalGood2 = 0;
        WorldGen.totalBlood2 = 0;
      }
      ushort num1 = 0;
      int num2 = 0;
      int num3 = 0;
      int num4 = 0;
      do
      {
        int num5;
        int num6;
        if (num3 == 0)
        {
          num5 = 0;
          num4 = (int) (Main.worldSurface + 1.0);
          num6 = 5;
        }
        else
        {
          num5 = num4;
          num4 = Main.maxTilesY;
          num6 = 1;
        }
        for (int index = num5; index < num4; ++index)
        {
          Tile tile = Main.tile[X, index] ?? (Main.tile[X, index] = new Tile());
          ushort type = tile.type;
          if (type != (ushort) 0 || tile.active())
          {
            if ((int) type == (int) num1)
            {
              num2 += num6;
            }
            else
            {
              WorldGen.tileCounts[(int) num1] += num2;
              num1 = type;
              num2 = num6;
            }
          }
        }
        WorldGen.tileCounts[(int) num1] += num2;
        num2 = 0;
        ++num3;
      }
      while (num3 < 2);
      WorldGen.AddUpAlignmentCounts(false);
    }

    public static void AddUpAlignmentCounts(bool clearCounts = false)
    {
      if (clearCounts)
      {
        WorldGen.totalEvil2 = 0;
        WorldGen.totalSolid2 = 0;
        WorldGen.totalGood2 = 0;
        WorldGen.totalBlood2 = 0;
      }
      WorldGen.totalGood2 += WorldGen.tileCounts[164] + WorldGen.tileCounts[109] + WorldGen.tileCounts[117] + WorldGen.tileCounts[116];
      WorldGen.totalEvil2 += WorldGen.tileCounts[23] + WorldGen.tileCounts[163] + WorldGen.tileCounts[112] + WorldGen.tileCounts[25];
      WorldGen.totalBlood2 += WorldGen.tileCounts[199] + WorldGen.tileCounts[234] + WorldGen.tileCounts[203] + WorldGen.tileCounts[200];
      WorldGen.totalSolid2 += WorldGen.tileCounts[2] + WorldGen.tileCounts[477] + WorldGen.tileCounts[1] + WorldGen.tileCounts[60] + WorldGen.tileCounts[53] + WorldGen.tileCounts[161];
      WorldGen.totalSolid2 += WorldGen.tileCounts[164] + WorldGen.tileCounts[109] + WorldGen.tileCounts[492] + WorldGen.tileCounts[117] + WorldGen.tileCounts[116];
      WorldGen.totalSolid2 += WorldGen.tileCounts[23] + WorldGen.tileCounts[163] + WorldGen.tileCounts[112] + WorldGen.tileCounts[25];
      WorldGen.totalSolid2 += WorldGen.tileCounts[199] + WorldGen.tileCounts[234] + WorldGen.tileCounts[203] + WorldGen.tileCounts[200];
      Array.Clear((Array) WorldGen.tileCounts, 0, WorldGen.tileCounts.Length);
    }

    public static void plantDye(int i, int j, bool exoticPlant = false)
    {
      UnifiedRandom unifiedRandom = WorldGen.gen ? WorldGen.genRand : Main.rand;
      if (!Main.tile[i, j].active() || i < 95 || (i > Main.maxTilesX - 95 || j < 95) || j > Main.maxTilesY - 95)
        return;
      int num1 = 90;
      if (exoticPlant)
        num1 = 240;
      if ((double) j < Main.worldSurface)
      {
        if (Main.tile[i, j - 1].active() && Main.tile[i, j - 1].type != (ushort) 3 && (Main.tile[i, j - 1].type != (ushort) 51 && Main.tile[i, j - 1].type != (ushort) 61) && (Main.tile[i, j - 1].type != (ushort) 73 && Main.tile[i, j - 1].type != (ushort) 74 && Main.tile[i, j - 1].type != (ushort) 184))
          return;
        int num2 = Utils.Clamp<int>(i - num1, 1, Main.maxTilesX - 1 - 1);
        int num3 = Utils.Clamp<int>(i + num1, 1, Main.maxTilesX - 1 - 1);
        int num4 = Utils.Clamp<int>(j - num1, 1, Main.maxTilesY - 1 - 1);
        int num5 = Utils.Clamp<int>(j + num1, 1, Main.maxTilesY - 1 - 1);
        for (int index1 = num2; index1 < num3; ++index1)
        {
          for (int index2 = num4; index2 < num5; ++index2)
          {
            if (Main.tile[index1, index2].active() && Main.tile[index1, index2].type == (ushort) 227 && (!exoticPlant || Main.tile[index1, index2].frameX >= (short) 272) && (exoticPlant || Main.tile[index1, index2].frameX < (short) 272))
              return;
          }
        }
        if (exoticPlant)
        {
          int type = (int) Main.tile[i, j].type;
          bool flag = TileID.Sets.Conversion.Grass[type] || TileID.Sets.Conversion.Moss[type] || type == 0;
          if (Main.tile[i, j - 1].liquid > (byte) 0 && Main.tile[i, j - 1].lava())
            flag = false;
          if (!flag)
            return;
          WorldGen.PlaceTile(i, j - 1, 227, true, false, -1, WorldGen.genRand.Next(8, 12));
        }
        else if (Main.tile[i, j].type == (ushort) 2 || Main.tile[i, j].type == (ushort) 109)
        {
          if (unifiedRandom.Next(4) == 0)
            WorldGen.PlaceTile(i, j - 1, 227, true, false, -1, 4);
          else
            WorldGen.PlaceTile(i, j - 1, 227, true, false, -1, 3);
        }
        else if (Main.tile[i, j].type == (ushort) 60)
        {
          if (unifiedRandom.Next(2) == 0)
            WorldGen.PlaceTile(i, j - 1, 227, true, false, -1, 2);
          else
            WorldGen.PlaceTile(i, j - 1, 227, true, false, -1, 4);
        }
        else if (Main.tile[i, j].type == (ushort) 53 && Main.tile[i, j - 1].liquid == byte.MaxValue && Main.tile[i, j - 2].liquid == byte.MaxValue)
        {
          WorldGen.PlaceTile(i, j - 1, 227, true, false, -1, 2);
        }
        else
        {
          if (Main.tile[i, j].type != (ushort) 80 || Main.tile[i - 1, j - 1].active())
            return;
          if (Main.tile[i + 1, j - 1].active())
            return;
          try
          {
            bool flag = true;
            for (int index1 = i - 5; index1 <= i + 5; ++index1)
            {
              for (int index2 = j - 5; index2 <= j + 15; ++index2)
              {
                if (Main.tile[index1, index2].active() && (Main.tile[index1, index2].type == (ushort) 112 || Main.tile[index1, index2].type == (ushort) 234))
                  flag = false;
              }
            }
            if (!flag)
              return;
            WorldGen.PlaceTile(i, j - 1, 227, true, false, -1, 6);
          }
          catch
          {
          }
        }
      }
      else
      {
        if (j >= Main.UnderworldLayer)
          return;
        if (!Main.tile[i, j - 1].active() || Main.tile[i, j - 1].type == (ushort) 3 || (Main.tile[i, j - 1].type == (ushort) 51 || Main.tile[i, j - 1].type == (ushort) 61) || (Main.tile[i, j - 1].type == (ushort) 73 || Main.tile[i, j - 1].type == (ushort) 74 || Main.tile[i, j - 1].type == (ushort) 184))
        {
          int num2 = Utils.Clamp<int>(i - num1, 1, Main.maxTilesX - 1 - 1);
          int num3 = Utils.Clamp<int>(i + num1, 1, Main.maxTilesX - 1 - 1);
          int num4 = Utils.Clamp<int>(j - num1, 1, Main.maxTilesY - 1 - 1);
          int num5 = Utils.Clamp<int>(j + num1, 1, Main.maxTilesY - 1 - 1);
          for (int index1 = num2; index1 < num3; ++index1)
          {
            for (int index2 = num4; index2 < num5; ++index2)
            {
              if (Main.tile[index1, index2].active() && Main.tile[index1, index2].type == (ushort) 227 && (!exoticPlant || Main.tile[index1, index2].frameX >= (short) 272) && (exoticPlant || Main.tile[index1, index2].frameX < (short) 272))
                return;
            }
          }
          if (exoticPlant)
          {
            int type = (int) Main.tile[i, j].type;
            if ((TileID.Sets.Conversion.Grass[type] || TileID.Sets.Conversion.Moss[type] ? 1 : (type == 0 ? 1 : 0)) != 0)
              WorldGen.PlaceTile(i, j - 1, 227, true, false, -1, WorldGen.genRand.Next(8, 12));
          }
          else if (Main.tile[i, j].type == (ushort) 60)
          {
            if (unifiedRandom.Next(2) == 0)
              WorldGen.PlaceTile(i, j - 1, 227, true, false, -1, 2);
            else if (unifiedRandom.Next(2) == 0)
              WorldGen.PlaceTile(i, j - 1, 227, true, false, -1, 0);
            else
              WorldGen.PlaceTile(i, j - 1, 227, true, false, -1, 1);
          }
          else if (Main.tile[i, j].type == (ushort) 0 || Main.tile[i, j].type == (ushort) 1 || Main.tile[i, j].type == (ushort) 59)
          {
            if (unifiedRandom.Next(2) == 0)
              WorldGen.PlaceTile(i, j - 1, 227, true, false, -1, 0);
            else
              WorldGen.PlaceTile(i, j - 1, 227, true, false, -1, 1);
          }
          else if (Main.tile[i, j - 1].liquid == byte.MaxValue && Main.tile[i, j - 2].liquid == byte.MaxValue)
            WorldGen.PlaceTile(i, j - 1, 227, true, false, -1, 5);
        }
        if (Main.tile[i, j + 1].active() || exoticPlant)
          return;
        for (int index1 = i - num1; index1 < i + num1; ++index1)
        {
          for (int index2 = j - num1; index2 < j + num1; ++index2)
          {
            if (Main.tile[index1, index2].active() && Main.tile[index1, index2].type == (ushort) 227)
              return;
          }
        }
        if (Main.tile[i, j].type != (ushort) 0)
          return;
        WorldGen.PlaceTile(i, j + 1, 227, true, false, -1, 7);
      }
    }

    private static int MossConversion(int thisType, int otherType)
    {
      if (TileID.Sets.tileMossBrick[thisType] && otherType == 38 || Main.tileMoss[thisType] && otherType == 1)
        return thisType;
      switch (thisType)
      {
        case 179:
          return 512;
        case 180:
          return 513;
        case 181:
          return 514;
        case 182:
          return 515;
        case 183:
          return 516;
        case 381:
          return 517;
        case 512:
          return 179;
        case 513:
          return 180;
        case 514:
          return 181;
        case 515:
          return 182;
        case 516:
          return 183;
        case 517:
          return 381;
        case 534:
          return 535;
        case 535:
          return 534;
        case 536:
          return 537;
        case 537:
          return 536;
        case 539:
          return 540;
        case 540:
          return 539;
        default:
          return 0;
      }
    }

    public static void UpdateWorld()
    {
      if (WorldGen.gen)
        return;
      WorldGen.AllowedToSpreadInfections = true;
      CreativePowers.StopBiomeSpreadPower power = CreativePowerManager.Instance.GetPower<CreativePowers.StopBiomeSpreadPower>();
      if (power != null && power.GetIsUnlocked())
        WorldGen.AllowedToSpreadInfections = !power.Enabled;
      int wallDist = 3;
      Wiring.UpdateMech();
      TileEntity.UpdateStart();
      foreach (TileEntity tileEntity in TileEntity.ByID.Values)
        tileEntity.Update();
      TileEntity.UpdateEnd();
      WorldGen.UpdateLunarApocalypse();
      if (Main.netMode != 1)
      {
        ++WorldGen.totalD;
        if (WorldGen.totalD >= 30)
        {
          WorldGen.totalD = 0;
          WorldGen.CountTiles(WorldGen.totalX);
          ++WorldGen.totalX;
          if (WorldGen.totalX >= Main.maxTilesX)
            WorldGen.totalX = 0;
        }
      }
      ++Liquid.skipCount;
      if (Liquid.skipCount > 1)
      {
        Liquid.UpdateLiquid();
        Liquid.skipCount = 0;
      }
      int worldUpdateRate = WorldGen.GetWorldUpdateRate();
      if (worldUpdateRate == 0)
        return;
      float num1 = 3E-05f * (float) worldUpdateRate;
      float num2 = 1.5E-05f * (float) worldUpdateRate;
      bool checkNPCSpawns = false;
      ++WorldGen.spawnDelay;
      if (Main.invasionType > 0 || Main.eclipse)
        WorldGen.spawnDelay = 0;
      if (WorldGen.spawnDelay >= 20)
      {
        checkNPCSpawns = true;
        WorldGen.spawnDelay = 0;
        if (WorldGen.prioritizedTownNPCType != 37)
        {
          for (int index = 0; index < 200; ++index)
          {
            if (Main.npc[index].active && Main.npc[index].homeless && (Main.npc[index].townNPC && Main.npc[index].type != 368))
            {
              WorldGen.prioritizedTownNPCType = Main.npc[index].type;
              break;
            }
          }
        }
      }
      float num3 = (float) (Main.maxTilesX * Main.maxTilesY) * num1;
      int num4 = 151;
      int num5 = (int) MathHelper.Lerp((float) num4, (float) num4 * 2.8f, MathHelper.Clamp((float) ((double) Main.maxTilesX / 4200.0 - 1.0), 0.0f, 1f));
      for (int index = 0; (double) index < (double) num3; ++index)
      {
        if (Main.rand.Next(num5 * 100) == 0)
          WorldGen.PlantAlch();
        WorldGen.UpdateWorld_OvergroundTile(WorldGen.genRand.Next(10, Main.maxTilesX - 10), WorldGen.genRand.Next(10, (int) Main.worldSurface - 1), checkNPCSpawns, wallDist);
      }
      for (int index = 0; (double) index < (double) (Main.maxTilesX * Main.maxTilesY) * (double) num2; ++index)
        WorldGen.UpdateWorld_UndergroundTile(WorldGen.genRand.Next(10, Main.maxTilesX - 10), WorldGen.genRand.Next((int) Main.worldSurface - 1, Main.maxTilesY - 20), checkNPCSpawns, wallDist);
      if (Main.dayTime)
        return;
      for (int index = 0; index < Main.dayRate; ++index)
      {
        float num6 = (float) (Main.maxTilesX / 4200) * Star.starfallBoost;
        if ((double) Main.rand.Next(8000) < 10.0 * (double) num6)
        {
          int num7 = 12;
          Vector2 Position = new Vector2((float) ((Main.rand.Next(Main.maxTilesX - 50) + 100) * 16), (float) (Main.rand.Next((int) ((double) Main.maxTilesY * 0.05)) * 16));
          int num8 = -1;
          if (Main.expertMode && Main.rand.Next(15) == 0)
          {
            int closest = (int) Player.FindClosest(Position, 1, 1);
            if ((double) Main.player[closest].position.Y < Main.worldSurface * 16.0 && Main.player[closest].afkCounter < 3600)
            {
              int num9 = Main.rand.Next(1, 640);
              Position.X = Main.player[closest].position.X + (float) Main.rand.Next(-num9, num9 + 1);
              num8 = closest;
            }
          }
          if (!Collision.SolidCollision(Position, 16, 16))
          {
            float num9 = (float) Main.rand.Next(-100, 101);
            float num10 = (float) (Main.rand.Next(200) + 100);
            float num11 = (float) Math.Sqrt((double) num9 * (double) num9 + (double) num10 * (double) num10);
            float num12 = (float) num7 / num11;
            float SpeedX = num9 * num12;
            float SpeedY = num10 * num12;
            Projectile.NewProjectile(Position.X, Position.Y, SpeedX, SpeedY, 720, 0, 0.0f, Main.myPlayer, 0.0f, (float) num8);
          }
        }
      }
    }

    public static int GetWorldUpdateRate()
    {
      int num = Math.Min(Main.desiredWorldTilesUpdateRate, 24);
      if (CreativePowerManager.Instance.GetPower<CreativePowers.FreezeTime>().Enabled)
        num = 0;
      return num;
    }

    private static void UpdateWorld_OvergroundTile(
      int i,
      int j,
      bool checkNPCSpawns,
      int wallDist)
    {
      int minI = i - 1;
      int maxI = i + 2;
      int index1 = j - 1;
      int maxJ = j + 2;
      if (minI < 10)
        minI = 10;
      if (maxI > Main.maxTilesX - 10)
        maxI = Main.maxTilesX - 10;
      if (index1 < 10)
        index1 = 10;
      if (maxJ > Main.maxTilesY - 10)
        maxJ = Main.maxTilesY - 10;
      if (Main.tile[i, j] == null)
        return;
      if (Main.tileAlch[(int) Main.tile[i, j].type])
        WorldGen.GrowAlch(i, j);
      else if ((double) j < Main.worldSurface + 10.0 && (i < WorldGen.beachDistance || i > Main.maxTilesX - WorldGen.beachDistance) && !Main.tile[i, j].nactive())
      {
        int maxValue = 3000 - (int) ((double) Math.Abs(Main.windSpeedCurrent) * 1250.0);
        if (Main.raining)
          maxValue -= (int) (1250.0 * (double) Main.maxRaining);
        if (maxValue < 300)
          maxValue = 300;
        if (WorldGen.genRand.Next(maxValue) == 0)
        {
          int j1 = j;
          while ((double) j1 < Main.worldSurface + 10.0 && !Main.tile[i, j1].nactive() && j1 - j < 15)
            ++j1;
          if (Main.tile[i, j1].nactive() && Main.tile[i, j1].type == (ushort) 53 && WorldGen.SolidTileAllowBottomSlope(i, j1))
          {
            int index2 = j1 - 1;
            int num1 = WorldGen.genRand.Next(2, 5);
            int num2 = WorldGen.genRand.Next(8, 11);
            int num3 = 0;
            for (int index3 = i - num2; index3 <= i + num2; ++index3)
            {
              for (int index4 = index2 - num2; index4 <= index2 + num2; ++index4)
              {
                if (Main.tile[index3, index4].active() && (Main.tile[index3, index4].type == (ushort) 324 || Main.tile[index3, index4].type == (ushort) 81))
                  ++num3;
              }
            }
            if (num3 < num1)
            {
              if (WorldGen.genRand.Next(2) == 0 && Main.tile[i, index2].liquid >= (byte) 230)
              {
                WorldGen.PlaceTile(i, index2, 81, false, false, -1, 0);
                if (Main.netMode == 2 && Main.tile[i, index2].active())
                  NetMessage.SendTileSquare(-1, i, index2, 3, TileChangeType.None);
              }
              else
              {
                WorldGen.PlaceTile(i, index2, 324, false, false, -1, WorldGen.RollRandomSeaShellStyle());
                if (Main.netMode == 2 && Main.tile[i, index2].active())
                  NetMessage.SendTileSquare(-1, i, index2, 3, TileChangeType.None);
              }
            }
          }
        }
      }
      if ((Main.tile[i, j].type == (ushort) 596 || Main.tile[i, j].type == (ushort) 616 || (Main.tile[i, j].type == (ushort) 595 || Main.tile[i, j].type == (ushort) 615)) && (Main.tile[i, j + 1].type == (ushort) 199 || Main.tile[i, j + 1].type == (ushort) 23))
      {
        WorldGen.KillTile(i, j, false, false, false);
        if (Main.netMode == 2)
          NetMessage.SendTileSquare(-1, i, j, 4, TileChangeType.None);
      }
      if ((Main.tile[i, j].type == (ushort) 571 || Main.tile[i, j].type == (ushort) 60 && Main.tile[i, j - 1].liquid > (byte) 0) && WorldGen.genRand.Next(5) == 0 && ((!Main.tile[i, j - 1].active() || Main.tile[i, j - 1].type == (ushort) 61 || (Main.tile[i, j - 1].type == (ushort) 74 || Main.tile[i, j - 1].type == (ushort) 518)) && ((Main.tile[i, j].type != (ushort) 60 || WorldGen.genRand.Next(30) == 0) && WorldGen.PlaceBamboo(i, j - 1))))
        NetMessage.SendTileSquare(-1, i, j, 3, TileChangeType.None);
      if (Main.tile[i, j].type == (ushort) 518)
      {
        if (Main.tile[i, j].liquid == (byte) 0 || (int) Main.tile[i, j].liquid / 16 >= 9 && WorldGen.SolidTile(i, j - 1, false) || Main.tile[i, j - 1].liquid > (byte) 0 && Main.tile[i, j - 1].active())
        {
          WorldGen.KillTile(i, j, false, false, false);
          if (Main.netMode == 2)
            NetMessage.SendData(17, -1, -1, (NetworkText) null, 0, (float) i, (float) j, 0.0f, 0, 0, 0);
        }
        else
          WorldGen.CheckLilyPad(i, j);
      }
      else if (Main.tile[i, j].type == (ushort) 519)
      {
        WorldGen.CheckCatTail(i, j);
        if (Main.tile[i, j].active() && WorldGen.genRand.Next(8) == 0)
        {
          WorldGen.GrowCatTail(i, j);
          WorldGen.CheckCatTail(i, j);
        }
      }
      else if (Main.tile[i, j].liquid > (byte) 32)
      {
        if (Main.tile[i, j].active())
        {
          if (TileID.Sets.SlowlyDiesInWater[(int) Main.tile[i, j].type])
          {
            WorldGen.KillTile(i, j, false, false, false);
            if (Main.netMode == 2)
              NetMessage.SendData(17, -1, -1, (NetworkText) null, 0, (float) i, (float) j, 0.0f, 0, 0, 0);
          }
          else if (Main.tile[i, j].type == (ushort) 60)
            WorldGen.UpdateWorld_GrassGrowth(i, j, minI, maxI, index1, maxJ, false);
        }
        else if (WorldGen.genRand.Next(600) == 0)
        {
          WorldGen.PlaceTile(i, j, 518, true, false, -1, 0);
          if (Main.netMode == 2)
            NetMessage.SendTileSquare(-1, i, j, 3, TileChangeType.None);
        }
        else if (WorldGen.genRand.Next(600) == 0)
        {
          WorldGen.PlaceTile(i, j, 519, true, false, -1, 0);
          if (Main.netMode == 2)
            NetMessage.SendTileSquare(-1, i, j, 3, TileChangeType.None);
        }
      }
      else if (Main.tile[i, j].nactive())
      {
        WorldGen.hardUpdateWorld(i, j);
        if (Main.rand.Next(3000) == 0)
          WorldGen.plantDye(i, j, false);
        else if (Main.hardMode && ((double) i < (double) Main.maxTilesX * 0.4 || (double) i > (double) Main.maxTilesX * 0.6) && Main.rand.Next(15000) == 0)
          WorldGen.plantDye(i, j, true);
        if (Main.tile[i, j].type == (ushort) 80)
        {
          if (WorldGen.genRand.Next(15) == 0)
            WorldGen.GrowCactus(i, j);
        }
        else if (Main.tile[i, j].type == (ushort) 529)
        {
          if (WorldGen.CheckSeaOat(i, j) && WorldGen.genRand.Next(20) == 0)
            WorldGen.GrowSeaOat(i, j);
        }
        else if (TileID.Sets.Conversion.Sand[(int) Main.tile[i, j].type])
        {
          if (!Main.tile[i, index1].active())
          {
            if (WorldGen.genRand.Next(25) == 0)
            {
              WorldGen.PlaceOasisPlant(i, index1, (ushort) 530);
              if (Main.tile[i, index1].type == (ushort) 530 && Main.netMode == 2)
                NetMessage.SendTileSquare(-1, i, index1, 4, TileChangeType.None);
            }
            if (WorldGen.genRand.Next(20) != 0 || !WorldGen.PlantSeaOat(i, index1))
            {
              if (i < WorldGen.oceanDistance || i > Main.maxTilesX - WorldGen.oceanDistance)
              {
                if (WorldGen.genRand.Next(500) == 0)
                {
                  int num1 = 7;
                  int num2 = 6;
                  int num3 = 0;
                  for (int index2 = i - num1; index2 <= i + num1; ++index2)
                  {
                    for (int index3 = index1 - num1; index3 <= index1 + num1; ++index3)
                    {
                      if (Main.tile[index2, index3].active() && Main.tile[index2, index3].type == (ushort) 81)
                        ++num3;
                    }
                  }
                  if (num3 < num2 && Main.tile[i, index1].liquid == byte.MaxValue && (Main.tile[i, index1 - 1].liquid == byte.MaxValue && Main.tile[i, index1 - 2].liquid == byte.MaxValue) && (Main.tile[i, index1 - 3].liquid == byte.MaxValue && Main.tile[i, index1 - 4].liquid == byte.MaxValue))
                  {
                    WorldGen.PlaceTile(i, index1, 81, true, false, -1, 0);
                    if (Main.netMode == 2 && Main.tile[i, index1].active())
                      NetMessage.SendTileSquare(-1, i, index1, 1, TileChangeType.None);
                  }
                }
              }
              else if (i > WorldGen.beachDistance + 20 && i < Main.maxTilesX - WorldGen.beachDistance - 20 && WorldGen.genRand.Next(300) == 0)
                WorldGen.GrowCactus(i, j);
            }
          }
        }
        else if (Main.tile[i, j].type == (ushort) 530)
        {
          if (!WorldGen.OasisPlantWaterCheck(i, j, true))
          {
            WorldGen.KillTile(i, j, false, false, false);
            if (Main.netMode == 2)
              NetMessage.SendData(17, -1, -1, (NetworkText) null, 0, (float) i, (float) j, 0.0f, 0, 0, 0);
          }
        }
        else if (Main.tile[i, j].type == (ushort) 147 || Main.tile[i, j].type == (ushort) 161 || (Main.tile[i, j].type == (ushort) 163 || Main.tile[i, j].type == (ushort) 164) || Main.tile[i, j].type == (ushort) 200)
        {
          if (Main.rand.Next(10) == 0 && !Main.tile[i, j + 1].active() && !Main.tile[i, j + 2].active())
          {
            int num1 = i - 3;
            int num2 = i + 4;
            int num3 = 0;
            for (int index2 = num1; index2 < num2; ++index2)
            {
              if (Main.tile[index2, j].type == (ushort) 165 && Main.tile[index2, j].active())
                ++num3;
              if (Main.tile[index2, j + 1].type == (ushort) 165 && Main.tile[index2, j + 1].active())
                ++num3;
              if (Main.tile[index2, j + 2].type == (ushort) 165 && Main.tile[index2, j + 2].active())
                ++num3;
              if (Main.tile[index2, j + 3].type == (ushort) 165 && Main.tile[index2, j + 3].active())
                ++num3;
            }
            if (num3 < 2)
            {
              WorldGen.PlaceTight(i, j + 1, false);
              WorldGen.SquareTileFrame(i, j + 1, true);
              if (Main.netMode == 2 && Main.tile[i, j + 1].active())
                NetMessage.SendTileSquare(-1, i, j + 1, 3, TileChangeType.None);
            }
          }
        }
        else if (Main.tile[i, j].type == (ushort) 254)
        {
          if (Main.rand.Next(((int) Main.tile[i, j].frameX + 10) / 10) == 0)
            WorldGen.GrowPumpkin(i, j, 254);
        }
        else if (Main.tile[i, j].type == (ushort) 78 || Main.tile[i, j].type == (ushort) 380 || Main.tile[i, j].type == (ushort) 579)
        {
          if (!Main.tile[i, index1].active() && WorldGen.genRand.Next(2) == 0)
          {
            WorldGen.PlaceTile(i, index1, 3, true, false, -1, 0);
            if (Main.netMode == 2 && Main.tile[i, index1].active())
              NetMessage.SendTileSquare(-1, i, index1, 1, TileChangeType.None);
          }
        }
        else if (TileID.Sets.SpreadOverground[(int) Main.tile[i, j].type])
          WorldGen.UpdateWorld_GrassGrowth(i, j, minI, maxI, index1, maxJ, false);
        else if (Main.tileMoss[(int) Main.tile[i, j].type] || TileID.Sets.tileMossBrick[(int) Main.tile[i, j].type])
        {
          if ((double) WorldGen.genRand.NextFloat() < 0.5)
          {
            int type1 = (int) Main.tile[i, j].type;
            bool flag = false;
            for (int i1 = minI; i1 < maxI; ++i1)
            {
              for (int j1 = index1; j1 < maxJ; ++j1)
              {
                if ((i != i1 || j != j1) && Main.tile[i1, j1].active() && (Main.tile[i1, j1].type == (ushort) 1 || Main.tile[i1, j1].type == (ushort) 38))
                {
                  int type2 = (int) Main.tile[i1, j1].type;
                  WorldGen.SpreadGrass(i1, j1, (int) Main.tile[i1, j1].type, WorldGen.MossConversion(type1, type2), false, Main.tile[i, j].color());
                  if ((int) Main.tile[i1, j1].type == type1)
                  {
                    WorldGen.SquareTileFrame(i1, j1, true);
                    flag = true;
                  }
                }
              }
            }
            if (Main.netMode == 2 & flag)
              NetMessage.SendTileSquare(-1, i, j, 3, TileChangeType.None);
            if (WorldGen.genRand.Next(6) == 0)
            {
              int index2 = i;
              int index3 = j;
              switch (WorldGen.genRand.Next(4))
              {
                case 0:
                  --index2;
                  break;
                case 1:
                  ++index2;
                  break;
                case 2:
                  --index3;
                  break;
                default:
                  ++index3;
                  break;
              }
              if (!Main.tile[index2, index3].active())
              {
                if (WorldGen.PlaceTile(index2, index3, 184, true, false, -1, 0))
                  Main.tile[index2, index3].color(Main.tile[i, j].color());
                if (Main.netMode == 2 && Main.tile[index2, index3].active())
                  NetMessage.SendTileSquare(-1, index2, index3, 1, TileChangeType.None);
              }
            }
          }
        }
        else if (Main.tile[i, j].type == (ushort) 20)
        {
          if (WorldGen.genRand.Next(20) == 0)
          {
            bool flag = WorldGen.PlayerLOS(i, j);
            if ((Main.tile[i, j].frameX < (short) 324 || Main.tile[i, j].frameX >= (short) 540 ? WorldGen.GrowTree(i, j) : WorldGen.GrowPalmTree(i, j)) & flag)
              WorldGen.TreeGrowFXCheck(i, j);
          }
        }
        else if (Main.tile[i, j].type == (ushort) 595)
        {
          if (WorldGen.genRand.Next(5) == 0)
          {
            int num = (int) Main.tile[i, j].frameX / 54;
            int treeTileType = 596;
            if (num == 0)
              treeTileType = 596;
            if (WorldGen.TryGrowingTreeByType(treeTileType, i, j) && WorldGen.PlayerLOS(i, j))
              WorldGen.TreeGrowFXCheck(i, j);
          }
        }
        else if (Main.tile[i, j].type == (ushort) 615)
        {
          if (WorldGen.genRand.Next(5) == 0)
          {
            int num = (int) Main.tile[i, j].frameX / 54;
            int treeTileType = 616;
            if (num == 0)
              treeTileType = 616;
            if (WorldGen.TryGrowingTreeByType(treeTileType, i, j) && WorldGen.PlayerLOS(i, j))
              WorldGen.TreeGrowFXCheck(i, j);
          }
        }
        else if (Main.tile[i, j].type == (ushort) 3 && WorldGen.genRand.Next(20) == 0)
        {
          if (Main.tile[i, j].frameX != (short) 144)
          {
            Main.tile[i, j].type = (ushort) 73;
            if (Main.netMode == 2)
              NetMessage.SendTileSquare(-1, i, j, 3, TileChangeType.None);
          }
        }
        else if (Main.tile[i, j].type == (ushort) 110 && WorldGen.genRand.Next(20) == 0)
        {
          if (Main.tile[i, j].frameX < (short) 144)
          {
            Main.tile[i, j].type = (ushort) 113;
            if (Main.netMode == 2)
              NetMessage.SendTileSquare(-1, i, j, 3, TileChangeType.None);
          }
        }
        else if (Main.tile[i, j].type == (ushort) 32 && WorldGen.genRand.Next(3) == 0)
          WorldGen.GrowSpike(i, j, (ushort) 32, (ushort) 23);
        else if (Main.tile[i, j].type == (ushort) 352 && WorldGen.genRand.Next(3) == 0)
          WorldGen.GrowSpike(i, j, (ushort) 352, (ushort) 199);
      }
      else if (checkNPCSpawns)
        WorldGen.TrySpawningTownNPC(i, j);
      if (WorldGen.AllowedToSpreadInfections)
      {
        if (Main.tile[i, j].wall == (ushort) 81 || Main.tile[i, j].wall == (ushort) 83 || Main.tile[i, j].type == (ushort) 199 && Main.tile[i, j].active())
        {
          int tileX = i + WorldGen.genRand.Next(-2, 3);
          int tileY = j + WorldGen.genRand.Next(-2, 3);
          if (Main.tile[tileX, tileY].wall >= (ushort) 63 && Main.tile[tileX, tileY].wall <= (ushort) 68)
          {
            bool flag = false;
label_187:
            for (int index2 = i - wallDist; index2 < i + wallDist; ++index2)
            {
              for (int index3 = j - wallDist; index3 < j + wallDist; ++index3)
              {
                if (Main.tile[i, j].active())
                {
                  switch (Main.tile[i, j].type)
                  {
                    case 199:
                    case 200:
                    case 201:
                    case 203:
                    case 205:
                    case 234:
                    case 352:
                      flag = true;
                      goto label_187;
                    default:
                      continue;
                  }
                }
              }
            }
            if (flag)
            {
              Main.tile[tileX, tileY].wall = (ushort) 81;
              if (Main.netMode == 2)
                NetMessage.SendTileSquare(-1, tileX, tileY, 3, TileChangeType.None);
            }
          }
        }
        else if (Main.tile[i, j].wall == (ushort) 69 || Main.tile[i, j].wall == (ushort) 3 || Main.tile[i, j].type == (ushort) 23 && Main.tile[i, j].active())
        {
          int tileX = i + WorldGen.genRand.Next(-2, 3);
          int tileY = j + WorldGen.genRand.Next(-2, 3);
          if (Main.tile[tileX, tileY].wall >= (ushort) 63 && Main.tile[tileX, tileY].wall <= (ushort) 68)
          {
            bool flag = false;
label_201:
            for (int index2 = i - wallDist; index2 < i + wallDist; ++index2)
            {
              for (int index3 = j - wallDist; index3 < j + wallDist; ++index3)
              {
                if (Main.tile[index2, index3].active())
                {
                  switch (Main.tile[index2, index3].type)
                  {
                    case 22:
                    case 23:
                    case 24:
                    case 25:
                    case 32:
                    case 112:
                    case 163:
                      flag = true;
                      goto label_201;
                    default:
                      continue;
                  }
                }
              }
            }
            if (flag)
            {
              Main.tile[tileX, tileY].wall = (ushort) 69;
              if (Main.netMode == 2)
                NetMessage.SendTileSquare(-1, tileX, tileY, 3, TileChangeType.None);
            }
          }
        }
        else if (Main.tile[i, j].wall == (ushort) 70 || Main.tile[i, j].type == (ushort) 109 && Main.tile[i, j].active())
        {
          int tileX = i + WorldGen.genRand.Next(-2, 3);
          int tileY = j + WorldGen.genRand.Next(-2, 3);
          if (Main.tile[tileX, tileY].wall == (ushort) 63 || Main.tile[tileX, tileY].wall == (ushort) 65 || (Main.tile[tileX, tileY].wall == (ushort) 66 || Main.tile[tileX, tileY].wall == (ushort) 68))
          {
            bool flag = false;
label_215:
            for (int index2 = i - wallDist; index2 < i + wallDist; ++index2)
            {
              for (int index3 = j - wallDist; index3 < j + wallDist; ++index3)
              {
                if (Main.tile[index2, index3].active())
                {
                  switch (Main.tile[index2, index3].type)
                  {
                    case 109:
                    case 110:
                    case 113:
                    case 115:
                    case 116:
                    case 117:
                    case 164:
                      flag = true;
                      goto label_215;
                    default:
                      continue;
                  }
                }
              }
            }
            if (flag)
            {
              Main.tile[tileX, tileY].wall = (ushort) 70;
              if (Main.netMode == 2)
                NetMessage.SendTileSquare(-1, tileX, tileY, 3, TileChangeType.None);
            }
          }
        }
        WorldGen.SpreadDesertWalls(wallDist, i, j);
      }
      if (!Main.tile[i, j].nactive())
        return;
      if ((Main.tile[i, j].type == (ushort) 2 || Main.tile[i, j].type == (ushort) 52 || Main.tile[i, j].type == (ushort) 382 || Main.tile[i, j].type == (ushort) 192 && WorldGen.genRand.Next(10) == 0) && WorldGen.GrowMoreVines(i, j))
      {
        int maxValue = 60;
        if (Main.tile[i, j].type == (ushort) 52 || Main.tile[i, j].type == (ushort) 382)
          maxValue = 20;
        if (WorldGen.genRand.Next(maxValue) == 0 && !Main.tile[i, j + 1].active() && !Main.tile[i, j + 1].lava())
        {
          bool flag = false;
          ushort num = 52;
          if (Main.tile[i, j].type == (ushort) 382)
            num = (ushort) 382;
          else if (Main.tile[i, j].type != (ushort) 52)
          {
            if (Main.tile[i, j].wall == (ushort) 68 || Main.tile[i, j].wall == (ushort) 65 || (Main.tile[i, j].wall == (ushort) 66 || Main.tile[i, j].wall == (ushort) 63))
              num = (ushort) 382;
            else if (Main.tile[i, j + 1].wall == (ushort) 68 || Main.tile[i, j + 1].wall == (ushort) 65 || (Main.tile[i, j + 1].wall == (ushort) 66 || Main.tile[i, j + 1].wall == (ushort) 63))
              num = (ushort) 382;
          }
          for (int index2 = j; index2 > j - 10; --index2)
          {
            if (Main.tile[i, index2].bottomSlope())
            {
              flag = false;
              break;
            }
            if (Main.tile[i, index2].active() && Main.tile[i, index2].type == (ushort) 2 && !Main.tile[i, index2].bottomSlope())
            {
              flag = true;
              break;
            }
          }
          if (flag)
          {
            int index2 = i;
            int index3 = j + 1;
            Main.tile[index2, index3].type = num;
            Main.tile[index2, index3].active(true);
            Main.tile[index2, index3].color(Main.tile[i, j].color());
            WorldGen.SquareTileFrame(index2, index3, true);
            if (Main.netMode == 2)
              NetMessage.SendTileSquare(-1, index2, index3, 3, TileChangeType.None);
          }
        }
      }
      else if (Main.tile[i, j].type == (ushort) 61 && WorldGen.genRand.Next(3) == 0 && Main.tile[i, j].frameX < (short) 144)
      {
        if (Main.rand.Next(4) == 0)
          Main.tile[i, j].frameX = (short) (162 + WorldGen.genRand.Next(8) * 18);
        Main.tile[i, j].type = (ushort) 74;
        if (Main.netMode == 2)
          NetMessage.SendTileSquare(-1, i, j, 3, TileChangeType.None);
      }
      if ((Main.tile[i, j].type == (ushort) 60 || Main.tile[i, j].type == (ushort) 62) && WorldGen.GrowMoreVines(i, j))
      {
        int maxValue = 30;
        if (Main.tile[i, j].type == (ushort) 62)
          maxValue = 10;
        if (WorldGen.genRand.Next(maxValue) != 0 || Main.tile[i, j + 1].active() || Main.tile[i, j + 1].lava())
          return;
        bool flag = false;
        for (int index2 = j; index2 > j - 10; --index2)
        {
          if (Main.tile[i, index2].bottomSlope())
          {
            flag = false;
            break;
          }
          if (Main.tile[i, index2].active() && Main.tile[i, index2].type == (ushort) 60 && !Main.tile[i, index2].bottomSlope())
          {
            flag = true;
            break;
          }
        }
        if (!flag)
          return;
        int index3 = i;
        int index4 = j + 1;
        Main.tile[index3, index4].type = (ushort) 62;
        Main.tile[index3, index4].active(true);
        WorldGen.SquareTileFrame(index3, index4, true);
        if (Main.netMode != 2)
          return;
        NetMessage.SendTileSquare(-1, index3, index4, 3, TileChangeType.None);
      }
      else if ((Main.tile[i, j].type == (ushort) 70 || Main.tile[i, j].type == (ushort) 528) && WorldGen.GrowMoreVines(i, j))
      {
        int maxValue = 70;
        if (Main.tile[i, j].type == (ushort) 528)
          maxValue = 7;
        if (WorldGen.genRand.Next(maxValue) != 0 || Main.tile[i, j + 1].active() || Main.tile[i, j + 1].lava())
          return;
        bool flag = false;
        for (int index2 = j; index2 > j - 10; --index2)
        {
          if (Main.tile[i, index2].bottomSlope())
          {
            flag = false;
            break;
          }
          if (Main.tile[i, index2].active() && Main.tile[i, index2].type == (ushort) 70 && !Main.tile[i, index2].bottomSlope())
          {
            flag = true;
            break;
          }
        }
        if (!flag)
          return;
        int index3 = i;
        int index4 = j + 1;
        Main.tile[index3, index4].type = (ushort) 528;
        Main.tile[index3, index4].active(true);
        WorldGen.SquareTileFrame(index3, index4, true);
        if (Main.netMode != 2)
          return;
        NetMessage.SendTileSquare(-1, index3, index4, 3, TileChangeType.None);
      }
      else if ((Main.tile[i, j].type == (ushort) 109 || Main.tile[i, j].type == (ushort) 115) && WorldGen.GrowMoreVines(i, j))
      {
        int maxValue = 60;
        if (Main.tile[i, j].type == (ushort) 115)
          maxValue = 20;
        if (WorldGen.genRand.Next(maxValue) != 0 || Main.tile[i, j + 1].active() || Main.tile[i, j + 1].lava())
          return;
        bool flag = false;
        for (int index2 = j; index2 > j - 10; --index2)
        {
          if (Main.tile[i, index2].bottomSlope())
          {
            flag = false;
            break;
          }
          if (Main.tile[i, index2].active() && Main.tile[i, index2].type == (ushort) 109 && !Main.tile[i, index2].bottomSlope())
          {
            flag = true;
            break;
          }
        }
        if (!flag)
          return;
        int index3 = i;
        int index4 = j + 1;
        Main.tile[index3, index4].type = (ushort) 115;
        Main.tile[index3, index4].active(true);
        WorldGen.SquareTileFrame(index3, index4, true);
        if (Main.netMode != 2)
          return;
        NetMessage.SendTileSquare(-1, index3, index4, 3, TileChangeType.None);
      }
      else
      {
        if (Main.tile[i, j].type != (ushort) 199 && Main.tile[i, j].type != (ushort) 205 || !WorldGen.GrowMoreVines(i, j))
          return;
        int maxValue = 60;
        if (Main.tile[i, j].type == (ushort) 205)
          maxValue = 20;
        if (WorldGen.genRand.Next(maxValue) != 0 || Main.tile[i, j + 1].active() || Main.tile[i, j + 1].lava())
          return;
        bool flag = false;
        for (int index2 = j; index2 > j - 10; --index2)
        {
          if (Main.tile[i, index2].bottomSlope())
          {
            flag = false;
            break;
          }
          if (Main.tile[i, index2].active() && Main.tile[i, index2].type == (ushort) 199 && !Main.tile[i, index2].bottomSlope())
          {
            flag = true;
            break;
          }
        }
        if (!flag)
          return;
        int index3 = i;
        int index4 = j + 1;
        Main.tile[index3, index4].type = (ushort) 205;
        Main.tile[index3, index4].active(true);
        WorldGen.SquareTileFrame(index3, index4, true);
        if (Main.netMode != 2)
          return;
        NetMessage.SendTileSquare(-1, index3, index4, 3, TileChangeType.None);
      }
    }

    private static void UpdateWorld_UndergroundTile(
      int i,
      int j,
      bool checkNPCSpawns,
      int wallDist)
    {
      int minI = i - 1;
      int maxI = i + 2;
      int minJ = j - 1;
      int maxJ = j + 2;
      if (minI < 10)
        minI = 10;
      if (maxI > Main.maxTilesX - 10)
        maxI = Main.maxTilesX - 10;
      if (minJ < 10)
        minJ = 10;
      if (maxJ > Main.maxTilesY - 10)
        maxJ = Main.maxTilesY - 10;
      if (Main.tile[i, j] == null)
        return;
      if (Main.tileAlch[(int) Main.tile[i, j].type])
        WorldGen.GrowAlch(i, j);
      else if (Main.tile[i, j].nactive())
      {
        WorldGen.hardUpdateWorld(i, j);
        if (Main.rand.Next(2500) == 0)
          WorldGen.plantDye(i, j, false);
        else if (Main.hardMode && Main.rand.Next(10000) == 0)
          WorldGen.plantDye(i, j, true);
        if (Main.tile[i, j].type == (ushort) 519)
        {
          WorldGen.CheckCatTail(i, j);
          if (Main.tile[i, j].active() && WorldGen.genRand.Next(2) == 0)
          {
            WorldGen.GrowCatTail(i, j);
            WorldGen.CheckCatTail(i, j);
          }
        }
        if (Main.tile[i, j].type == (ushort) 549)
          WorldGen.GrowCheckSeaweed(i, j);
        else if (Main.tile[i, j].type == (ushort) 53 && !Main.tile[i, j].topSlope() && (!Main.tile[i, j].halfBrick() && !Main.tile[i, j - 1].active()) && WorldGen.genRand.Next(20) == 0)
          WorldGen.GrowCheckSeaweed(i, j);
        else if (TileID.Sets.SpreadUnderground[(int) Main.tile[i, j].type])
          WorldGen.UpdateWorld_GrassGrowth(i, j, minI, maxI, minJ, maxJ, true);
        else if (Main.tile[i, j].type == (ushort) 32)
          WorldGen.GrowSpike(i, j, (ushort) 32, (ushort) 23);
        else if (Main.tile[i, j].type == (ushort) 352 && WorldGen.genRand.Next(3) == 0)
          WorldGen.GrowSpike(i, j, (ushort) 352, (ushort) 199);
        else if (Main.tile[i, j].type == (ushort) 61 && WorldGen.genRand.Next(3) == 0)
        {
          if (Main.tile[i, j].frameX < (short) 144)
          {
            if (Main.rand.Next(4) == 0)
              Main.tile[i, j].frameX = (short) (162 + WorldGen.genRand.Next(8) * 18);
            Main.tile[i, j].type = (ushort) 74;
            if (Main.netMode == 2)
              NetMessage.SendTileSquare(-1, i, j, 3, TileChangeType.None);
          }
        }
        else if ((Main.tile[i, j].type == (ushort) 60 || Main.tile[i, j].type == (ushort) 62) && (WorldGen.genRand.Next(5) == 0 && WorldGen.GrowMoreVines(i, j)))
        {
          if (!Main.tile[i, j + 1].active() && !Main.tile[i, j + 1].lava())
          {
            bool flag = false;
            for (int index = j; index > j - 10; --index)
            {
              if (Main.tile[i, index].bottomSlope())
              {
                flag = false;
                break;
              }
              if (Main.tile[i, index].active() && Main.tile[i, index].type == (ushort) 60 && !Main.tile[i, index].bottomSlope())
              {
                flag = true;
                break;
              }
            }
            if (flag)
            {
              int index1 = i;
              int index2 = j + 1;
              Main.tile[index1, index2].type = (ushort) 62;
              Main.tile[index1, index2].active(true);
              WorldGen.SquareTileFrame(index1, index2, true);
              Main.tile[index1, index2].color(Main.tile[index1, index2 - 1].color());
              if (Main.netMode == 2)
                NetMessage.SendTileSquare(-1, index1, index2, 3, TileChangeType.None);
            }
          }
        }
        else if ((Main.tile[i, j].type == (ushort) 70 || Main.tile[i, j].type == (ushort) 528) && WorldGen.GrowMoreVines(i, j))
        {
          if (!Main.tile[i, j + 1].active() && !Main.tile[i, j + 1].lava())
          {
            int maxValue = 70;
            if (Main.tile[i, j].type == (ushort) 528)
              maxValue = 7;
            if (WorldGen.genRand.Next(maxValue) == 0)
            {
              bool flag = false;
              for (int index = j; index > j - 10; --index)
              {
                if (Main.tile[i, index].bottomSlope())
                {
                  flag = false;
                  break;
                }
                if (Main.tile[i, index].active() && Main.tile[i, index].type == (ushort) 70 && !Main.tile[i, index].bottomSlope())
                {
                  flag = true;
                  break;
                }
              }
              if (flag)
              {
                int index1 = i;
                int index2 = j + 1;
                Main.tile[index1, index2].type = (ushort) 528;
                Main.tile[index1, index2].active(true);
                Main.tile[index1, index2].color(Main.tile[index1, index2 - 1].color());
                WorldGen.SquareTileFrame(index1, index2, true);
                if (Main.netMode == 2)
                  NetMessage.SendTileSquare(-1, index1, index2, 3, TileChangeType.None);
              }
            }
          }
        }
        else if ((Main.tile[i, j].type == (ushort) 60 || Main.tile[i, j].type == (ushort) 62) && (WorldGen.genRand.Next(80) == 0 && !WorldGen.PlayerLOS(i, j)))
        {
          bool flag = true;
          int tileY = j;
          if (Main.tile[i, j].type == (ushort) 60)
            ++tileY;
          for (int i1 = i; i1 < i + 2; ++i1)
          {
            int j1 = tileY - 1;
            if (!WorldGen.AnchorValid(Framing.GetTileSafely(i1, j1), AnchorType.SolidTile) || Main.tile[i1, j1].bottomSlope())
              flag = false;
            if (Main.tile[i1, j1].liquid > (byte) 0 || Main.wallHouse[(int) Main.tile[i1, j1].wall])
              flag = false;
            if (flag)
            {
              for (int index = tileY; index < tileY + 2; ++index)
              {
                if ((!Main.tile[i1, index].active() || Main.tileCut[(int) Main.tile[i1, index].type] && Main.tile[i1, index].type != (ushort) 444 ? (!Main.tile[i1, index].lava() ? 1 : 0) : 0) == 0)
                  flag = false;
                if (!flag)
                  break;
              }
              if (!flag)
                break;
            }
            else
              break;
          }
          if (flag)
          {
            if (WorldGen.CountNearBlocksTypes(i, j, 20, 1, 444) > 0)
              flag = false;
          }
          if (flag)
          {
            for (int i1 = i; i1 < i + 2; ++i1)
            {
              Main.tile[i1, tileY - 1].slope((byte) 0);
              Main.tile[i1, tileY - 1].halfBrick(false);
              for (int j1 = tileY; j1 < tileY + 2; ++j1)
              {
                if (Main.tile[i1, j1].active())
                  WorldGen.KillTile(i1, j1, false, false, false);
              }
            }
            for (int index1 = i; index1 < i + 2; ++index1)
            {
              for (int index2 = tileY; index2 < tileY + 2; ++index2)
              {
                Main.tile[index1, index2].active(true);
                Main.tile[index1, index2].type = (ushort) 444;
                Main.tile[index1, index2].frameX = (short) ((index1 - i) * 18);
                Main.tile[index1, index2].frameY = (short) ((index2 - tileY) * 18);
              }
            }
            if (Main.netMode == 2)
              NetMessage.SendTileSquare(-1, i, tileY, 3, TileChangeType.None);
          }
        }
        else if (Main.tile[i, j].type == (ushort) 69)
          WorldGen.GrowSpike(i, j, (ushort) 69, (ushort) 60);
        else if (Main.tile[i, j].type == (ushort) 147 || Main.tile[i, j].type == (ushort) 161 || (Main.tile[i, j].type == (ushort) 163 || Main.tile[i, j].type == (ushort) 164) || Main.tile[i, j].type == (ushort) 200)
        {
          if (Main.rand.Next(10) == 0 && !Main.tile[i, j + 1].active() && !Main.tile[i, j + 2].active())
          {
            int num1 = i - 3;
            int num2 = i + 4;
            int num3 = 0;
            for (int index = num1; index < num2; ++index)
            {
              if (Main.tile[index, j].type == (ushort) 165 && Main.tile[index, j].active())
                ++num3;
              if (Main.tile[index, j + 1].type == (ushort) 165 && Main.tile[index, j + 1].active())
                ++num3;
              if (Main.tile[index, j + 2].type == (ushort) 165 && Main.tile[index, j + 2].active())
                ++num3;
              if (Main.tile[index, j + 3].type == (ushort) 165 && Main.tile[index, j + 3].active())
                ++num3;
            }
            if (num3 < 2)
            {
              WorldGen.PlaceTight(i, j + 1, false);
              WorldGen.SquareTileFrame(i, j + 1, true);
              if (Main.netMode == 2 && Main.tile[i, j + 1].active())
                NetMessage.SendTileSquare(-1, i, j + 1, 3, TileChangeType.None);
            }
          }
        }
        else if (Main.tileMoss[(int) Main.tile[i, j].type] || TileID.Sets.tileMossBrick[(int) Main.tile[i, j].type])
        {
          int type1 = (int) Main.tile[i, j].type;
          bool flag = false;
          for (int i1 = minI; i1 < maxI; ++i1)
          {
            for (int j1 = minJ; j1 < maxJ; ++j1)
            {
              if ((i != i1 || j != j1) && Main.tile[i1, j1].active() && (Main.tile[i1, j1].type == (ushort) 1 || Main.tile[i1, j1].type == (ushort) 38))
              {
                int type2 = (int) Main.tile[i1, j1].type;
                WorldGen.SpreadGrass(i1, j1, (int) Main.tile[i1, j1].type, WorldGen.MossConversion(type1, type2), false, Main.tile[i, j].color());
                if ((int) Main.tile[i1, j1].type == type1)
                {
                  WorldGen.SquareTileFrame(i1, j1, true);
                  flag = true;
                }
              }
            }
          }
          if (Main.netMode == 2 & flag)
            NetMessage.SendTileSquare(-1, i, j, 3, TileChangeType.None);
          if (WorldGen.genRand.Next(6) == 0)
          {
            int index1 = i;
            int index2 = j;
            switch (WorldGen.genRand.Next(4))
            {
              case 0:
                --index1;
                break;
              case 1:
                ++index1;
                break;
              case 2:
                --index2;
                break;
              default:
                ++index2;
                break;
            }
            if (!Main.tile[index1, index2].active())
            {
              if (WorldGen.PlaceTile(index1, index2, 184, true, false, -1, 0))
                Main.tile[index1, index2].color(Main.tile[i, j].color());
              if (Main.netMode == 2 && Main.tile[index1, index2].active())
                NetMessage.SendTileSquare(-1, index1, index2, 1, TileChangeType.None);
            }
          }
        }
        else if (Main.tile[i, j].type == (ushort) 590)
        {
          if (WorldGen.genRand.Next(5) == 0)
          {
            int num = (int) Main.tile[i, j].frameX / 54;
            int treeTileType = 587;
            switch (num)
            {
              case 0:
                treeTileType = 583;
                break;
              case 1:
                treeTileType = 584;
                break;
              case 2:
                treeTileType = 585;
                break;
              case 3:
                treeTileType = 586;
                break;
              case 4:
                treeTileType = 587;
                break;
              case 5:
                treeTileType = 588;
                break;
              case 6:
                treeTileType = 589;
                break;
            }
            if (WorldGen.TryGrowingTreeByType(treeTileType, i, j) && WorldGen.PlayerLOS(i, j))
              WorldGen.TreeGrowFXCheck(i, j);
          }
        }
        else if (Main.tile[i, j].type == (ushort) 595)
        {
          if (WorldGen.genRand.Next(5) == 0)
          {
            int num = (int) Main.tile[i, j].frameX / 54;
            int treeTileType = 596;
            if (num == 0)
              treeTileType = 596;
            if (WorldGen.TryGrowingTreeByType(treeTileType, i, j) && WorldGen.PlayerLOS(i, j))
              WorldGen.TreeGrowFXCheck(i, j);
          }
        }
        else if (Main.tile[i, j].type == (ushort) 615 && WorldGen.genRand.Next(5) == 0)
        {
          int num = (int) Main.tile[i, j].frameX / 54;
          int treeTileType = 616;
          if (num == 0)
            treeTileType = 616;
          if (WorldGen.TryGrowingTreeByType(treeTileType, i, j) && WorldGen.PlayerLOS(i, j))
            WorldGen.TreeGrowFXCheck(i, j);
        }
      }
      else
      {
        if (Main.tile[i, j].wall == (ushort) 62 && Main.tile[i, j].liquid == (byte) 0 && WorldGen.genRand.Next(10) == 0)
        {
          int num1 = WorldGen.genRand.Next(2, 4);
          int num2 = i - num1;
          int num3 = i + num1;
          int num4 = j - num1;
          int num5 = j + num1;
          bool flag = false;
          for (int i1 = num2; i1 <= num3; ++i1)
          {
            for (int j1 = num4; j1 <= num5; ++j1)
            {
              if (WorldGen.SolidTile(i1, j1, false))
              {
                flag = true;
                break;
              }
            }
          }
          if (flag && !Main.tile[i, j].active())
          {
            WorldGen.PlaceTile(i, j, 51, true, false, -1, 0);
            WorldGen.TileFrame(i, j, true, false);
            if (Main.netMode == 2)
              NetMessage.SendTileSquare(-1, i, j, 3, TileChangeType.None);
          }
        }
        if (checkNPCSpawns)
          WorldGen.TrySpawningTownNPC(i, j);
      }
      if (!WorldGen.AllowedToSpreadInfections)
        return;
      if (Main.tile[i, j].wall == (ushort) 81 || Main.tile[i, j].wall == (ushort) 83 || Main.tile[i, j].type == (ushort) 199 && Main.tile[i, j].active())
      {
        int tileX = i + WorldGen.genRand.Next(-2, 3);
        int tileY = j + WorldGen.genRand.Next(-2, 3);
        if (Main.tile[tileX, tileY].wall >= (ushort) 63 && Main.tile[tileX, tileY].wall <= (ushort) 68)
        {
          bool flag = false;
label_190:
          for (int index1 = i - wallDist; index1 < i + wallDist; ++index1)
          {
            for (int index2 = j - wallDist; index2 < j + wallDist; ++index2)
            {
              if (Main.tile[index1, index2].active())
              {
                switch (Main.tile[index1, index2].type)
                {
                  case 199:
                  case 200:
                  case 201:
                  case 203:
                  case 205:
                  case 234:
                  case 352:
                    flag = true;
                    goto label_190;
                  default:
                    continue;
                }
              }
            }
          }
          if (flag)
          {
            Main.tile[tileX, tileY].wall = (ushort) 81;
            if (Main.netMode == 2)
              NetMessage.SendTileSquare(-1, tileX, tileY, 3, TileChangeType.None);
          }
        }
      }
      else if (Main.tile[i, j].wall == (ushort) 69 || Main.tile[i, j].wall == (ushort) 3 || Main.tile[i, j].type == (ushort) 23 && Main.tile[i, j].active())
      {
        int tileX = i + WorldGen.genRand.Next(-2, 3);
        int tileY = j + WorldGen.genRand.Next(-2, 3);
        if (Main.tile[tileX, tileY].wall >= (ushort) 63 && Main.tile[tileX, tileY].wall <= (ushort) 68)
        {
          bool flag = false;
label_204:
          for (int index1 = i - wallDist; index1 < i + wallDist; ++index1)
          {
            for (int index2 = j - wallDist; index2 < j + wallDist; ++index2)
            {
              if (Main.tile[index1, index2].active())
              {
                switch (Main.tile[index1, index2].type)
                {
                  case 22:
                  case 23:
                  case 24:
                  case 25:
                  case 32:
                  case 112:
                  case 163:
                    flag = true;
                    goto label_204;
                  default:
                    continue;
                }
              }
            }
          }
          if (flag)
          {
            Main.tile[tileX, tileY].wall = (ushort) 69;
            if (Main.netMode == 2)
              NetMessage.SendTileSquare(-1, tileX, tileY, 3, TileChangeType.None);
          }
        }
      }
      else if (Main.tile[i, j].wall == (ushort) 70 || Main.tile[i, j].type == (ushort) 109 && Main.tile[i, j].active())
      {
        int tileX = i + WorldGen.genRand.Next(-2, 3);
        int tileY = j + WorldGen.genRand.Next(-2, 3);
        if (Main.tile[tileX, tileY].wall == (ushort) 63 || Main.tile[tileX, tileY].wall == (ushort) 65 || (Main.tile[tileX, tileY].wall == (ushort) 66 || Main.tile[tileX, tileY].wall == (ushort) 68))
        {
          bool flag = false;
label_218:
          for (int index1 = i - wallDist; index1 < i + wallDist; ++index1)
          {
            for (int index2 = j - wallDist; index2 < j + wallDist; ++index2)
            {
              if (Main.tile[index1, index2].active())
              {
                switch (Main.tile[index1, index2].type)
                {
                  case 109:
                  case 110:
                  case 113:
                  case 115:
                  case 116:
                  case 117:
                  case 164:
                    flag = true;
                    goto label_218;
                  default:
                    continue;
                }
              }
            }
          }
          if (flag)
          {
            Main.tile[tileX, tileY].wall = (ushort) 70;
            if (Main.netMode == 2)
              NetMessage.SendTileSquare(-1, tileX, tileY, 3, TileChangeType.None);
          }
        }
      }
      WorldGen.SpreadDesertWalls(wallDist, i, j);
    }

    private static void UpdateWorld_GrassGrowth(
      int i,
      int j,
      int minI,
      int maxI,
      int minJ,
      int maxJ,
      bool underground)
    {
      if (underground)
      {
        int type = (int) Main.tile[i, j].type;
        int dirt = -1;
        int Type = -1;
        int maxValue1 = 1;
        switch (type)
        {
          case 23:
            dirt = 0;
            Type = 24;
            maxValue1 = 2;
            if (!WorldGen.AllowedToSpreadInfections)
              return;
            break;
          case 60:
            dirt = 59;
            Type = 61;
            maxValue1 = 10;
            break;
          case 70:
            dirt = 59;
            Type = 71;
            maxValue1 = 10;
            break;
          case 199:
            dirt = 0;
            Type = 201;
            maxValue1 = 2;
            if (!WorldGen.AllowedToSpreadInfections)
              return;
            break;
        }
        bool flag1 = false;
        if (Type != -1 && !Main.tile[i, minJ].active() && WorldGen.genRand.Next(maxValue1) == 0)
        {
          flag1 = true;
          if (WorldGen.PlaceTile(i, minJ, Type, true, false, -1, 0))
            Main.tile[i, minJ].color(Main.tile[i, j].color());
          if (Main.netMode == 2 && Main.tile[i, minJ].active())
            NetMessage.SendTileSquare(-1, i, minJ, 1, TileChangeType.None);
        }
        if (dirt != -1)
        {
          bool flag2 = false;
          for (int i1 = minI; i1 < maxI; ++i1)
          {
            for (int j1 = minJ; j1 < maxJ; ++j1)
            {
              if ((i != i1 || j != j1) && (Main.tile[i1, j1].active() && (int) Main.tile[i1, j1].type == dirt))
              {
                WorldGen.SpreadGrass(i1, j1, dirt, type, false, Main.tile[i, j].color());
                if ((int) Main.tile[i1, j1].type == type)
                {
                  WorldGen.SquareTileFrame(i1, j1, true);
                  flag2 = true;
                }
              }
            }
          }
          if (Main.netMode == 2 & flag2)
            NetMessage.SendTileSquare(-1, i, j, 3, TileChangeType.None);
        }
        switch (type)
        {
          case 60:
            if (flag1 || WorldGen.genRand.Next(25) != 0 || Main.tile[i, minJ].liquid != (byte) 0)
              break;
            if (Main.hardMode && NPC.downedMechBoss1 && (NPC.downedMechBoss2 && NPC.downedMechBoss3) && WorldGen.genRand.Next(60) == 0)
            {
              bool flag2 = true;
              int num = 150;
              for (int index1 = i - num; index1 < i + num; index1 += 2)
              {
                for (int index2 = j - num; index2 < j + num; index2 += 2)
                {
                  if (index1 > 1 && index1 < Main.maxTilesX - 2 && (index2 > 1 && index2 < Main.maxTilesY - 2) && (Main.tile[index1, index2].active() && Main.tile[index1, index2].type == (ushort) 238))
                  {
                    flag2 = false;
                    break;
                  }
                }
              }
              if (flag2)
              {
                WorldGen.PlaceJunglePlant(i, minJ, (ushort) 238, 0, 0);
                WorldGen.SquareTileFrame(i, minJ, true);
                WorldGen.SquareTileFrame(i + 2, minJ, true);
                WorldGen.SquareTileFrame(i - 1, minJ, true);
                if (Main.tile[i, minJ].type == (ushort) 238 && Main.netMode == 2)
                  NetMessage.SendTileSquare(-1, i, minJ, 5, TileChangeType.None);
              }
            }
            int maxValue2 = Main.expertMode ? 30 : 40;
            if (Main.hardMode && NPC.downedMechBossAny && WorldGen.genRand.Next(maxValue2) == 0)
            {
              bool flag2 = true;
              int num = 60;
              if (Main.expertMode)
                num -= 10;
              for (int index1 = i - num; index1 < i + num; index1 += 2)
              {
                for (int index2 = j - num; index2 < j + num; index2 += 2)
                {
                  if (index1 > 1 && index1 < Main.maxTilesX - 2 && (index2 > 1 && index2 < Main.maxTilesY - 2) && (Main.tile[index1, index2].active() && Main.tile[index1, index2].type == (ushort) 236))
                  {
                    flag2 = false;
                    break;
                  }
                }
              }
              if (!flag2)
                break;
              WorldGen.PlaceJunglePlant(i, minJ, (ushort) 236, WorldGen.genRand.Next(3), 0);
              WorldGen.SquareTileFrame(i, minJ, true);
              WorldGen.SquareTileFrame(i + 1, minJ + 1, true);
              if (Main.tile[i, minJ].type != (ushort) 236 || Main.netMode != 2)
                break;
              NetMessage.SendTileSquare(-1, i, minJ, 4, TileChangeType.None);
              break;
            }
            WorldGen.PlaceJunglePlant(i, minJ, (ushort) 233, WorldGen.genRand.Next(8), 0);
            if (Main.tile[i, minJ].type != (ushort) 233)
              break;
            if (Main.netMode == 2)
            {
              NetMessage.SendTileSquare(-1, i, minJ, 4, TileChangeType.None);
              break;
            }
            WorldGen.PlaceJunglePlant(i, minJ, (ushort) 233, WorldGen.genRand.Next(12), 1);
            if (Main.tile[i, minJ].type != (ushort) 233 || Main.netMode != 2)
              break;
            NetMessage.SendTileSquare(-1, i, minJ, 3, TileChangeType.None);
            break;
          case 70:
            if (Main.tile[i, j - 1].liquid > (byte) 0)
              WorldGen.PlaceCatTail(i, j - 1);
            if (WorldGen.genRand.Next(300) != 0 || !WorldGen.GrowShroom(i, j) || !WorldGen.PlayerLOS(i, j))
              break;
            WorldGen.TreeGrowFXCheck(i, j - 1);
            break;
        }
      }
      else
      {
        int grass = (int) Main.tile[i, j].type;
        switch (grass)
        {
          case 2:
          case 23:
          case 32:
          case 109:
          case 199:
          case 352:
          case 477:
          case 492:
            if (Main.halloween && WorldGen.genRand.Next(75) == 0 && (grass == 2 || grass == 109))
            {
              int num1 = 100;
              int num2 = 0;
              for (int index1 = i - num1; index1 < i + num1; index1 += 2)
              {
                for (int index2 = j - num1; index2 < j + num1; index2 += 2)
                {
                  if (index1 > 1 && index1 < Main.maxTilesX - 2 && (index2 > 1 && index2 < Main.maxTilesY - 2) && (Main.tile[index1, index2].active() && Main.tile[index1, index2].type == (ushort) 254))
                    ++num2;
                }
              }
              if (num2 < 6)
              {
                WorldGen.PlacePumpkin(i, minJ);
                if (Main.netMode == 2 && Main.tile[i, minJ].type == (ushort) 254)
                  NetMessage.SendTileSquare(-1, i, minJ, 4, TileChangeType.None);
              }
            }
            if (!Main.tile[i, minJ].active() && Main.tile[i, minJ].liquid == (byte) 0)
            {
              int Type = -1;
              if (grass == 2 && WorldGen.genRand.Next(12) == 0)
                Type = 3;
              else if (grass == 23 && WorldGen.genRand.Next(10) == 0)
                Type = 24;
              else if (grass == 109 && WorldGen.genRand.Next(10) == 0)
                Type = 110;
              else if (grass == 199 && WorldGen.genRand.Next(10) == 0)
                Type = 201;
              if (Type != -1 && WorldGen.PlaceTile(i, minJ, Type, true, false, -1, 0))
              {
                Main.tile[i, minJ].color(Main.tile[i, j].color());
                if (Main.netMode == 2)
                  NetMessage.SendTileSquare(-1, i, minJ, 1, TileChangeType.None);
              }
            }
            bool flag1 = false;
            switch (grass)
            {
              case 32:
                grass = 23;
                if (!WorldGen.AllowedToSpreadInfections)
                  return;
                break;
              case 352:
                grass = 199;
                if (!WorldGen.AllowedToSpreadInfections)
                  return;
                break;
              case 477:
                grass = 2;
                break;
              case 492:
                grass = 109;
                break;
            }
            bool flag2 = WorldGen.AllowedToSpreadInfections && (grass == 23 || grass == 199 || grass == 109 || grass == 492);
            for (int i1 = minI; i1 < maxI; ++i1)
            {
              for (int j1 = minJ; j1 < maxJ; ++j1)
              {
                if ((i != i1 || j != j1) && Main.tile[i1, j1].active())
                {
                  int type = (int) Main.tile[i1, j1].type;
                  if (flag2 || type == 0)
                  {
                    if (type == 0 || (grass == 23 || grass == 199) && (type == 2 || type == 109 || (type == 477 || type == 492)))
                    {
                      WorldGen.SpreadGrass(i1, j1, 0, grass, false, Main.tile[i, j].color());
                      if (grass == 23 || grass == 199)
                      {
                        if (WorldGen.AllowedToSpreadInfections)
                        {
                          WorldGen.SpreadGrass(i1, j1, 2, grass, false, Main.tile[i, j].color());
                          WorldGen.SpreadGrass(i1, j1, 109, grass, false, Main.tile[i, j].color());
                          WorldGen.SpreadGrass(i1, j1, 477, grass, false, Main.tile[i, j].color());
                          WorldGen.SpreadGrass(i1, j1, 492, grass, false, Main.tile[i, j].color());
                        }
                        else
                          continue;
                      }
                      if ((int) Main.tile[i1, j1].type == grass)
                      {
                        WorldGen.SquareTileFrame(i1, j1, true);
                        flag1 = true;
                      }
                    }
                    if (type == 0 || (grass == 109 || grass == 492) && (type == 2 || type == 477 || (type == 23 || type == 199)))
                    {
                      WorldGen.SpreadGrass(i1, j1, 0, grass, false, Main.tile[i, j].color());
                      if (grass == 109)
                        WorldGen.SpreadGrass(i1, j1, 2, grass, false, Main.tile[i, j].color());
                      if (grass == 492)
                        WorldGen.SpreadGrass(i1, j1, 477, grass, false, Main.tile[i, j].color());
                      else if (grass == 109)
                        WorldGen.SpreadGrass(i1, j1, 477, 492, false, Main.tile[i, j].color());
                      if ((grass == 492 || grass == 109) && WorldGen.AllowedToSpreadInfections)
                        WorldGen.SpreadGrass(i1, j1, 23, 109, false, Main.tile[i, j].color());
                      if ((grass == 492 || grass == 109) && WorldGen.AllowedToSpreadInfections)
                        WorldGen.SpreadGrass(i1, j1, 199, 109, false, Main.tile[i, j].color());
                      if ((int) Main.tile[i1, j1].type == grass)
                      {
                        WorldGen.SquareTileFrame(i1, j1, true);
                        flag1 = true;
                      }
                    }
                  }
                }
              }
            }
            if (!(Main.netMode == 2 & flag1))
              break;
            NetMessage.SendTileSquare(-1, i, j, 3, TileChangeType.None);
            break;
          case 60:
            if (!Main.tile[i, minJ].active() && WorldGen.genRand.Next(7) == 0)
            {
              WorldGen.PlaceTile(i, minJ, 61, true, false, -1, 0);
              if (Main.tile[i, minJ].active())
                Main.tile[i, minJ].color(Main.tile[i, j].color());
              if (Main.netMode == 2 && Main.tile[i, minJ].active())
                NetMessage.SendTileSquare(-1, i, minJ, 1, TileChangeType.None);
            }
            else if (WorldGen.genRand.Next(500) == 0 && (!Main.tile[i, minJ].active() || Main.tile[i, minJ].type == (ushort) 61 || (Main.tile[i, minJ].type == (ushort) 74 || Main.tile[i, minJ].type == (ushort) 69)))
            {
              if (WorldGen.GrowTree(i, j) && WorldGen.PlayerLOS(i, j))
                WorldGen.TreeGrowFXCheck(i, j - 1);
            }
            else if (WorldGen.genRand.Next(25) == 0 && Main.tile[i, minJ].liquid == (byte) 0)
            {
              WorldGen.PlaceJunglePlant(i, minJ, (ushort) 233, WorldGen.genRand.Next(8), 0);
              if (Main.tile[i, minJ].type == (ushort) 233)
              {
                if (Main.netMode == 2)
                {
                  NetMessage.SendTileSquare(-1, i, minJ, 4, TileChangeType.None);
                }
                else
                {
                  WorldGen.PlaceJunglePlant(i, minJ, (ushort) 233, WorldGen.genRand.Next(12), 1);
                  if (Main.tile[i, minJ].type == (ushort) 233 && Main.netMode == 2)
                    NetMessage.SendTileSquare(-1, i, minJ, 3, TileChangeType.None);
                }
              }
            }
            bool flag3 = false;
            for (int i1 = minI; i1 < maxI; ++i1)
            {
              for (int j1 = minJ; j1 < maxJ; ++j1)
              {
                if ((i != i1 || j != j1) && (Main.tile[i1, j1].active() && Main.tile[i1, j1].type == (ushort) 59))
                {
                  WorldGen.SpreadGrass(i1, j1, 59, grass, false, Main.tile[i, j].color());
                  if ((int) Main.tile[i1, j1].type == grass)
                  {
                    WorldGen.SquareTileFrame(i1, j1, true);
                    flag3 = true;
                  }
                }
              }
            }
            if (!(Main.netMode == 2 & flag3))
              break;
            NetMessage.SendTileSquare(-1, i, j, 3, TileChangeType.None);
            break;
          case 70:
            if (!Main.tile[i, j].inActive())
            {
              if (!Main.tile[i, minJ].active() && WorldGen.genRand.Next(10) == 0)
              {
                WorldGen.PlaceTile(i, minJ, 71, true, false, -1, 0);
                if (Main.tile[i, minJ].active())
                  Main.tile[i, minJ].color(Main.tile[i, j].color());
                if (Main.netMode == 2 && Main.tile[i, minJ].active())
                  NetMessage.SendTileSquare(-1, i, minJ, 1, TileChangeType.None);
              }
              if (WorldGen.genRand.Next(300) == 0)
              {
                bool flag4 = WorldGen.PlayerLOS(i, j);
                if (WorldGen.GrowTree(i, j) & flag4)
                  WorldGen.TreeGrowFXCheck(i, j - 1);
              }
            }
            bool flag5 = false;
            for (int i1 = minI; i1 < maxI; ++i1)
            {
              for (int j1 = minJ; j1 < maxJ; ++j1)
              {
                if ((i != i1 || j != j1) && (Main.tile[i1, j1].active() && Main.tile[i1, j1].type == (ushort) 59))
                {
                  WorldGen.SpreadGrass(i1, j1, 59, grass, false, Main.tile[i, j].color());
                  if ((int) Main.tile[i1, j1].type == grass)
                  {
                    WorldGen.SquareTileFrame(i1, j1, true);
                    flag5 = true;
                  }
                }
              }
            }
            if (!(Main.netMode == 2 & flag5))
              break;
            NetMessage.SendTileSquare(-1, i, j, 3, TileChangeType.None);
            break;
        }
      }
    }

    private static void TrySpawningTownNPC(int x, int y)
    {
      bool flag = Main.tileSolid[379];
      Main.tileSolid[379] = true;
      if (WorldGen.prioritizedTownNPCType > 0)
      {
        if (Main.tile[x, y].wall == (ushort) 34)
        {
          if (Main.rand.Next(4) == 0)
          {
            int num1 = (int) WorldGen.SpawnTownNPC(x, y);
          }
        }
        else
        {
          int num2 = (int) WorldGen.SpawnTownNPC(x, y);
        }
      }
      Main.tileSolid[379] = flag;
    }

    public static void SpreadDesertWalls(int wallDist, int i, int j)
    {
      if (!WallID.Sets.Conversion.Sandstone[(int) Main.tile[i, j].wall] && (!Main.tile[i, j].active() || !TileID.Sets.Conversion.Sandstone[(int) Main.tile[i, j].type]) && !WallID.Sets.Conversion.HardenedSand[(int) Main.tile[i, j].wall])
        return;
      int num = 0;
      int wall = (int) Main.tile[i, j].wall;
      int type = (int) Main.tile[i, j].type;
      if (WallID.Sets.Corrupt[wall] || TileID.Sets.Corrupt[type])
        num = 1;
      if (WallID.Sets.Hallow[wall] || TileID.Sets.Hallow[type])
        num = 2;
      if (WallID.Sets.Crimson[wall] || TileID.Sets.Crimson[type])
        num = 3;
      if (num == 0)
        return;
      int tileX = i + WorldGen.genRand.Next(-2, 3);
      int tileY = j + WorldGen.genRand.Next(-2, 3);
      bool flag = false;
      if (WallID.Sets.Conversion.PureSand[(int) Main.tile[tileX, tileY].wall])
      {
        switch (num)
        {
          case 1:
            for (int index1 = i - wallDist; index1 < i + wallDist; ++index1)
            {
              for (int index2 = j - wallDist; index2 < j + wallDist; ++index2)
              {
                if (Main.tile[index1, index2].active() && TileID.Sets.Corrupt[(int) Main.tile[index1, index2].type])
                {
                  flag = true;
                  break;
                }
              }
              if (flag)
                break;
            }
            break;
          case 2:
            for (int index1 = i - wallDist; index1 < i + wallDist; ++index1)
            {
              for (int index2 = j - wallDist; index2 < j + wallDist; ++index2)
              {
                if (Main.tile[index1, index2].active() && TileID.Sets.Hallow[(int) Main.tile[index1, index2].type])
                {
                  flag = true;
                  break;
                }
              }
              if (flag)
                break;
            }
            break;
          case 3:
            for (int index1 = i - wallDist; index1 < i + wallDist; ++index1)
            {
              for (int index2 = j - wallDist; index2 < j + wallDist; ++index2)
              {
                if (Main.tile[index1, index2].active() && TileID.Sets.Crimson[(int) Main.tile[index1, index2].type])
                {
                  flag = true;
                  break;
                }
              }
              if (flag)
                break;
            }
            break;
        }
      }
      if (!flag)
        return;
      ushort? nullable = new ushort?();
      if (WallID.Sets.Conversion.Sandstone[(int) Main.tile[tileX, tileY].wall])
      {
        switch (num)
        {
          case 1:
            nullable = new ushort?((ushort) 220);
            break;
          case 2:
            nullable = new ushort?((ushort) 222);
            break;
          case 3:
            nullable = new ushort?((ushort) 221);
            break;
        }
      }
      if (WallID.Sets.Conversion.HardenedSand[(int) Main.tile[tileX, tileY].wall])
      {
        switch (num)
        {
          case 1:
            nullable = new ushort?((ushort) 217);
            break;
          case 2:
            nullable = new ushort?((ushort) 219);
            break;
          case 3:
            nullable = new ushort?((ushort) 218);
            break;
        }
      }
      if (!nullable.HasValue || (int) Main.tile[tileX, tileY].wall == (int) nullable.Value)
        return;
      Main.tile[tileX, tileY].wall = nullable.Value;
      if (Main.netMode != 2)
        return;
      NetMessage.SendTileSquare(-1, tileX, tileY, 3, TileChangeType.None);
    }

    public static void PlaceWall(int i, int j, int type, bool mute = false)
    {
      if (i <= 1 || j <= 1 || (i >= Main.maxTilesX - 2 || j >= Main.maxTilesY - 2))
        return;
      if (Main.tile[i, j] == null)
        Main.tile[i, j] = new Tile();
      if (Main.tile[i, j].wall != (ushort) 0)
        return;
      Main.tile[i, j].wall = (ushort) type;
      WorldGen.SquareWallFrame(i, j, true);
      if (mute)
        return;
      SoundEngine.PlaySound(0, i * 16, j * 16, 1, 1f, 0.0f);
    }

    public static void SpreadGrass(int i, int j, int dirt = 0, int grass = 2, bool repeat = true, byte color = 0)
    {
      try
      {
        if (!WorldGen.InWorld(i, j, 1))
          return;
        if (WorldGen.gen && (grass == 199 || grass == 23))
        {
          int beachDistance = WorldGen.beachDistance;
          if ((double) i > (double) Main.maxTilesX * 0.45 && (double) i <= (double) Main.maxTilesX * 0.55 || (i < beachDistance || i >= Main.maxTilesX - beachDistance))
            return;
        }
        else if ((WorldGen.gen || grass != 199 && grass != 23) && ((int) Main.tile[i, j].type != dirt || !Main.tile[i, j].active() || (double) j >= Main.worldSurface && dirt == 0))
          return;
        int num1 = i - 1;
        int num2 = i + 2;
        int num3 = j - 1;
        int num4 = j + 2;
        if (num1 < 0)
          num1 = 0;
        if (num2 > Main.maxTilesX)
          num2 = Main.maxTilesX;
        if (num3 < 0)
          num3 = 0;
        if (num4 > Main.maxTilesY)
          num4 = Main.maxTilesY;
        bool flag = true;
        for (int index1 = num1; index1 < num2; ++index1)
        {
          for (int index2 = num3; index2 < num4; ++index2)
          {
            if (!Main.tile[index1, index2].active() || !Main.tileSolid[(int) Main.tile[index1, index2].type])
              flag = false;
            if (Main.tile[index1, index2].lava() && Main.tile[index1, index2].liquid > (byte) 0)
            {
              flag = true;
              break;
            }
          }
        }
        if (flag || !TileID.Sets.CanBeClearedDuringGeneration[(int) Main.tile[i, j].type] || grass == 23 && Main.tile[i, j - 1].type == (ushort) 27 || (grass == 199 && Main.tile[i, j - 1].type == (ushort) 27 || grass == 109 && Main.tile[i, j - 1].type == (ushort) 27))
          return;
        Main.tile[i, j].type = (ushort) grass;
        Main.tile[i, j].color(color);
        for (int i1 = num1; i1 < num2; ++i1)
        {
          for (int j1 = num3; j1 < num4; ++j1)
          {
            if (Main.tile[i1, j1].active())
            {
              if ((int) Main.tile[i1, j1].type == dirt)
              {
                try
                {
                  if (repeat)
                  {
                    if (WorldGen.grassSpread < 1000)
                    {
                      ++WorldGen.grassSpread;
                      WorldGen.SpreadGrass(i1, j1, dirt, grass, true, (byte) 0);
                      --WorldGen.grassSpread;
                    }
                  }
                }
                catch
                {
                }
              }
            }
          }
        }
      }
      catch
      {
      }
    }

    public static void ChasmRunnerSideways(int i, int j, int direction, int steps)
    {
      float num1 = (float) steps;
      Vector2 vector2_1;
      vector2_1.X = (float) i;
      vector2_1.Y = (float) j;
      Vector2 vector2_2;
      vector2_2.X = (float) WorldGen.genRand.Next(10, 21) * 0.1f * (float) direction;
      vector2_2.Y = (float) WorldGen.genRand.Next(-10, 10) * 0.01f;
      double num2 = (double) (WorldGen.genRand.Next(5) + 7);
      while (num2 > 0.0)
      {
        if ((double) num1 > 0.0)
        {
          num2 = num2 + (double) WorldGen.genRand.Next(3) - (double) WorldGen.genRand.Next(3);
          if (num2 < 7.0)
            num2 = 7.0;
          if (num2 > 20.0)
            num2 = 20.0;
          if ((double) num1 == 1.0 && num2 < 10.0)
            num2 = 10.0;
        }
        else
          num2 -= (double) WorldGen.genRand.Next(4);
        if ((double) vector2_1.Y > Main.rockLayer && (double) num1 > 0.0)
          num1 = 0.0f;
        --num1;
        int num3 = (int) ((double) vector2_1.X - num2 * 0.5);
        int num4 = (int) ((double) vector2_1.X + num2 * 0.5);
        int num5 = (int) ((double) vector2_1.Y - num2 * 0.5);
        int num6 = (int) ((double) vector2_1.Y + num2 * 0.5);
        if (num3 < 0)
          num3 = 0;
        if (num4 > Main.maxTilesX - 1)
          num4 = Main.maxTilesX - 1;
        if (num5 < 0)
          num5 = 0;
        if (num6 > Main.maxTilesY)
          num6 = Main.maxTilesY;
        for (int index1 = num3; index1 < num4; ++index1)
        {
          for (int index2 = num5; index2 < num6; ++index2)
          {
            if ((double) Math.Abs((float) index1 - vector2_1.X) + (double) Math.Abs((float) index2 - vector2_1.Y) < num2 * 0.5 * (1.0 + (double) WorldGen.genRand.Next(-10, 11) * 0.015) && Main.tile[index1, index2].type != (ushort) 31 && Main.tile[index1, index2].type != (ushort) 22)
              Main.tile[index1, index2].active(false);
          }
        }
        vector2_1 += vector2_2;
        vector2_2.Y += (float) WorldGen.genRand.Next(-10, 10) * 0.1f;
        if ((double) vector2_1.Y < (double) (j - 20))
          vector2_2.Y += (float) WorldGen.genRand.Next(20) * 0.01f;
        if ((double) vector2_1.Y > (double) (j + 20))
          vector2_2.Y -= (float) WorldGen.genRand.Next(20) * 0.01f;
        if ((double) vector2_2.Y < -0.5)
          vector2_2.Y = -0.5f;
        if ((double) vector2_2.Y > 0.5)
          vector2_2.Y = 0.5f;
        vector2_2.X += (float) WorldGen.genRand.Next(-10, 11) * 0.01f;
        switch (direction)
        {
          case -1:
            if ((double) vector2_2.X > -0.5)
              vector2_2.X = -0.5f;
            if ((double) vector2_2.X < -2.0)
            {
              vector2_2.X = -2f;
              break;
            }
            break;
          case 1:
            if ((double) vector2_2.X < 0.5)
              vector2_2.X = 0.5f;
            if ((double) vector2_2.X > 2.0)
            {
              vector2_2.X = 2f;
              break;
            }
            break;
        }
        int num7 = (int) ((double) vector2_1.X - num2 * 1.1);
        int num8 = (int) ((double) vector2_1.X + num2 * 1.1);
        int num9 = (int) ((double) vector2_1.Y - num2 * 1.1);
        int num10 = (int) ((double) vector2_1.Y + num2 * 1.1);
        if (num7 < 1)
          num7 = 1;
        if (num8 > Main.maxTilesX - 1)
          num8 = Main.maxTilesX - 1;
        if (num9 < 0)
          num9 = 0;
        if (num10 > Main.maxTilesY)
          num10 = Main.maxTilesY;
        for (int index1 = num7; index1 < num8; ++index1)
        {
          for (int index2 = num9; index2 < num10; ++index2)
          {
            if ((double) Math.Abs((float) index1 - vector2_1.X) + (double) Math.Abs((float) index2 - vector2_1.Y) < num2 * 1.1 * (1.0 + (double) WorldGen.genRand.Next(-10, 11) * 0.015) && Main.tile[index1, index2].wall != (ushort) 3)
            {
              if (Main.tile[index1, index2].type != (ushort) 25 && index2 > j + WorldGen.genRand.Next(3, 20))
                Main.tile[index1, index2].active(true);
              Main.tile[index1, index2].active(true);
              if (Main.tile[index1, index2].type != (ushort) 31 && Main.tile[index1, index2].type != (ushort) 22)
                Main.tile[index1, index2].type = (ushort) 25;
              if (Main.tile[index1, index2].wall == (ushort) 2)
                Main.tile[index1, index2].wall = (ushort) 0;
            }
          }
        }
        for (int i1 = num7; i1 < num8; ++i1)
        {
          for (int j1 = num9; j1 < num10; ++j1)
          {
            if ((double) Math.Abs((float) i1 - vector2_1.X) + (double) Math.Abs((float) j1 - vector2_1.Y) < num2 * 1.1 * (1.0 + (double) WorldGen.genRand.Next(-10, 11) * 0.015) && Main.tile[i1, j1].wall != (ushort) 3)
            {
              if (Main.tile[i1, j1].type != (ushort) 31 && Main.tile[i1, j1].type != (ushort) 22)
                Main.tile[i1, j1].type = (ushort) 25;
              Main.tile[i1, j1].active(true);
              WorldGen.PlaceWall(i1, j1, 3, true);
            }
          }
        }
      }
      if (WorldGen.genRand.Next(3) != 0)
        return;
      int x = (int) vector2_1.X;
      int y = (int) vector2_1.Y;
      while (!Main.tile[x, y].active())
        ++y;
      WorldGen.TileRunner(x, y, (double) WorldGen.genRand.Next(2, 6), WorldGen.genRand.Next(3, 7), 22, false, 0.0f, 0.0f, false, true, -1);
    }

    public static void CrimStart(int i, int j)
    {
      int crimDir = 1;
      int i1 = i;
      int j1 = j;
      if ((double) j1 > Main.worldSurface)
        j1 = (int) Main.worldSurface;
      while (!WorldGen.SolidTile(i1, j1, false))
        ++j1;
      int num1 = i1;
      int num2 = j1;
      Vector2 position = new Vector2((float) i1, (float) j1);
      Vector2 vector2 = new Vector2((float) WorldGen.genRand.Next(-20, 21) * 0.1f, (float) WorldGen.genRand.Next(20, 201) * 0.01f);
      if ((double) vector2.X < 0.0)
        crimDir = -1;
      float num3 = (float) WorldGen.genRand.Next(15, 26);
      bool flag1 = true;
      int num4 = 0;
      while (flag1)
      {
        num3 += (float) WorldGen.genRand.Next(-50, 51) * 0.01f;
        if ((double) num3 < 15.0)
          num3 = 15f;
        if ((double) num3 > 25.0)
          num3 = 25f;
        for (int index1 = (int) ((double) position.X - (double) num3 / 2.0); (double) index1 < (double) position.X + (double) num3 / 2.0; ++index1)
        {
          for (int index2 = (int) ((double) position.Y - (double) num3 / 2.0); (double) index2 < (double) position.Y + (double) num3 / 2.0; ++index2)
          {
            if (index2 > num2)
            {
              if ((double) Math.Abs((float) index1 - position.X) + (double) Math.Abs((float) index2 - position.Y) < (double) num3 * 0.3)
              {
                Main.tile[index1, index2].active(false);
                Main.tile[index1, index2].wall = (ushort) 83;
              }
              else if ((double) Math.Abs((float) index1 - position.X) + (double) Math.Abs((float) index2 - position.Y) < (double) num3 * 0.8 && Main.tile[index1, index2].wall != (ushort) 83)
              {
                Main.tile[index1, index2].active(true);
                Main.tile[index1, index2].type = (ushort) 203;
                if ((double) Math.Abs((float) index1 - position.X) + (double) Math.Abs((float) index2 - position.Y) < (double) num3 * 0.6)
                  Main.tile[index1, index2].wall = (ushort) 83;
              }
            }
            else if ((double) Math.Abs((float) index1 - position.X) + (double) Math.Abs((float) index2 - position.Y) < (double) num3 * 0.3 && Main.tile[index1, index2].active())
            {
              Main.tile[index1, index2].active(false);
              Main.tile[index1, index2].wall = (ushort) 83;
            }
          }
        }
        if ((double) position.X > (double) (num1 + 50))
          num4 = -100;
        if ((double) position.X < (double) (num1 - 50))
          num4 = 100;
        if (num4 < 0)
          vector2.X -= (float) WorldGen.genRand.Next(20, 51) * 0.01f;
        else if (num4 > 0)
          vector2.X += (float) WorldGen.genRand.Next(20, 51) * 0.01f;
        else
          vector2.X += (float) WorldGen.genRand.Next(-50, 51) * 0.01f;
        vector2.Y += (float) WorldGen.genRand.Next(-50, 51) * 0.01f;
        if ((double) vector2.Y < 0.25)
          vector2.Y = 0.25f;
        if ((double) vector2.Y > 2.0)
          vector2.Y = 2f;
        if ((double) vector2.X < -2.0)
          vector2.X = -2f;
        if ((double) vector2.X > 2.0)
          vector2.X = 2f;
        position += vector2;
        if ((double) position.Y > Main.worldSurface + 100.0)
          flag1 = false;
      }
      float num5 = (float) WorldGen.genRand.Next(40, 55);
      for (int index1 = 0; index1 < 50; ++index1)
      {
        int num6 = (int) position.X + WorldGen.genRand.Next(-20, 21);
        int num7 = (int) position.Y + WorldGen.genRand.Next(-20, 21);
        for (int index2 = (int) ((double) num6 - (double) num5 / 2.0); (double) index2 < (double) num6 + (double) num5 / 2.0; ++index2)
        {
          for (int index3 = (int) ((double) num7 - (double) num5 / 2.0); (double) index3 < (double) num7 + (double) num5 / 2.0; ++index3)
          {
            double num8 = (double) Math.Abs(index2 - num6);
            float num9 = (float) Math.Abs(index3 - num7);
            float num10 = (float) (1.0 + (double) WorldGen.genRand.Next(-20, 21) * 0.00999999977648258);
            float num11 = (float) (1.0 + (double) WorldGen.genRand.Next(-20, 21) * 0.00999999977648258);
            double num12 = (double) num10;
            double num13 = num8 * num12;
            float num14 = num9 * num11;
            double num15 = Math.Sqrt(num13 * num13 + (double) num14 * (double) num14);
            if (num15 < (double) num5 * 0.25)
            {
              Main.tile[index2, index3].active(false);
              Main.tile[index2, index3].wall = (ushort) 83;
            }
            else if (num15 < (double) num5 * 0.4 && Main.tile[index2, index3].wall != (ushort) 83)
            {
              Main.tile[index2, index3].active(true);
              Main.tile[index2, index3].type = (ushort) 203;
              if (num15 < (double) num5 * 0.35)
                Main.tile[index2, index3].wall = (ushort) 83;
            }
          }
        }
      }
      int length = WorldGen.genRand.Next(5, 9);
      Vector2[] vector2Array = new Vector2[length];
      for (int index1 = 0; index1 < length; ++index1)
      {
        int x = (int) position.X;
        int y = (int) position.Y;
        int num6 = 0;
        bool flag2 = true;
        Vector2 velocity = new Vector2((float) WorldGen.genRand.Next(-20, 21) * 0.15f, (float) WorldGen.genRand.Next(0, 21) * 0.15f);
        while (flag2)
        {
          velocity = new Vector2((float) WorldGen.genRand.Next(-20, 21) * 0.15f, (float) WorldGen.genRand.Next(0, 21) * 0.15f);
          while ((double) Math.Abs(velocity.X) + (double) Math.Abs(velocity.Y) < 1.5)
            velocity = new Vector2((float) WorldGen.genRand.Next(-20, 21) * 0.15f, (float) WorldGen.genRand.Next(0, 21) * 0.15f);
          flag2 = false;
          for (int index2 = 0; index2 < index1; ++index2)
          {
            if ((double) vector2.X > (double) vector2Array[index2].X - 0.75 && (double) vector2.X < (double) vector2Array[index2].X + 0.75 && ((double) vector2.Y > (double) vector2Array[index2].Y - 0.75 && (double) vector2.Y < (double) vector2Array[index2].Y + 0.75))
            {
              flag2 = true;
              ++num6;
              break;
            }
          }
          if (num6 > 10000)
            break;
        }
        vector2Array[index1] = velocity;
        WorldGen.CrimVein(new Vector2((float) x, (float) y), velocity);
      }
      int num16 = Main.maxTilesX;
      int num17 = 0;
      position.X = (float) num1;
      position.Y = (float) num2;
      float num18 = (float) WorldGen.genRand.Next(25, 35);
      float num19 = (float) WorldGen.genRand.Next(0, 6);
      for (int index1 = 0; index1 < 50; ++index1)
      {
        if ((double) num19 > 0.0)
        {
          float num6 = (float) WorldGen.genRand.Next(10, 30) * 0.01f;
          num19 -= num6;
          position.Y -= num6;
        }
        int num7 = (int) position.X + WorldGen.genRand.Next(-2, 3);
        int num8 = (int) position.Y + WorldGen.genRand.Next(-2, 3);
        for (int index2 = (int) ((double) num7 - (double) num18 / 2.0); (double) index2 < (double) num7 + (double) num18 / 2.0; ++index2)
        {
          for (int index3 = (int) ((double) num8 - (double) num18 / 2.0); (double) index3 < (double) num8 + (double) num18 / 2.0; ++index3)
          {
            double num6 = (double) Math.Abs(index2 - num7);
            float num9 = (float) Math.Abs(index3 - num8);
            float num10 = (float) (1.0 + (double) WorldGen.genRand.Next(-20, 21) * 0.00499999988824129);
            float num11 = (float) (1.0 + (double) WorldGen.genRand.Next(-20, 21) * 0.00499999988824129);
            double num12 = (double) num10;
            double num13 = num6 * num12;
            float num14 = num9 * num11;
            double num15 = Math.Sqrt(num13 * num13 + (double) num14 * (double) num14);
            if (num15 < (double) num18 * 0.2 * ((double) WorldGen.genRand.Next(90, 111) * 0.01))
            {
              Main.tile[index2, index3].active(false);
              Main.tile[index2, index3].wall = (ushort) 83;
            }
            else if (num15 < (double) num18 * 0.45)
            {
              if (index2 < num16)
                num16 = index2;
              if (index2 > num17)
                num17 = index2;
              if (Main.tile[index2, index3].wall != (ushort) 83)
              {
                Main.tile[index2, index3].active(true);
                Main.tile[index2, index3].type = (ushort) 203;
                if (num15 < (double) num18 * 0.35)
                  Main.tile[index2, index3].wall = (ushort) 83;
              }
            }
          }
        }
      }
      for (int index1 = num16; index1 <= num17; ++index1)
      {
        int index2 = num2;
        while (Main.tile[index1, index2].type == (ushort) 203 && Main.tile[index1, index2].active() || Main.tile[index1, index2].wall == (ushort) 83)
          ++index2;
        for (int index3 = WorldGen.genRand.Next(15, 20); !Main.tile[index1, index2].active() && index3 > 0 && Main.tile[index1, index2].wall != (ushort) 83; ++index2)
        {
          --index3;
          Main.tile[index1, index2].type = (ushort) 203;
          Main.tile[index1, index2].active(true);
        }
      }
      WorldGen.CrimEnt(position, crimDir);
    }

    public static void CrimPlaceHearts()
    {
      for (int index1 = 0; index1 < WorldGen.heartCount; ++index1)
      {
        int num1 = WorldGen.genRand.Next(16, 21);
        int x = (int) WorldGen.heartPos[index1].X;
        int y = (int) WorldGen.heartPos[index1].Y;
        for (int index2 = x - num1 / 2; index2 < x + num1 / 2; ++index2)
        {
          for (int index3 = y - num1 / 2; index3 < y + num1 / 2; ++index3)
          {
            double num2 = (double) Math.Abs(index2 - x);
            float num3 = (float) Math.Abs(index3 - y);
            if (Math.Sqrt(num2 * num2 + (double) num3 * (double) num3) < (double) num1 * 0.4)
            {
              Main.tile[index2, index3].active(true);
              Main.tile[index2, index3].type = (ushort) 203;
              Main.tile[index2, index3].wall = (ushort) 83;
            }
          }
        }
      }
      for (int index1 = 0; index1 < WorldGen.heartCount; ++index1)
      {
        int num1 = WorldGen.genRand.Next(10, 14);
        int x = (int) WorldGen.heartPos[index1].X;
        int y = (int) WorldGen.heartPos[index1].Y;
        for (int index2 = x - num1 / 2; index2 < x + num1 / 2; ++index2)
        {
          for (int index3 = y - num1 / 2; index3 < y + num1 / 2; ++index3)
          {
            double num2 = (double) Math.Abs(index2 - x);
            float num3 = (float) Math.Abs(index3 - y);
            if (Math.Sqrt(num2 * num2 + (double) num3 * (double) num3) < (double) num1 * 0.3)
            {
              Main.tile[index2, index3].active(false);
              Main.tile[index2, index3].wall = (ushort) 83;
            }
          }
        }
      }
      for (int index = 0; index < WorldGen.heartCount; ++index)
        WorldGen.AddShadowOrb((int) WorldGen.heartPos[index].X, (int) WorldGen.heartPos[index].Y);
    }

    public static void CrimEnt(Vector2 position, int crimDir)
    {
      float num1 = 0.0f;
      float num2 = (float) WorldGen.genRand.Next(6, 11);
      bool flag = true;
      Vector2 vector2 = new Vector2(2f, (float) WorldGen.genRand.Next(-20, 0) * 0.01f);
      vector2.X *= (float) -crimDir;
      while (flag)
      {
        ++num1;
        if ((double) num1 >= 20.0)
          flag = false;
        num2 += (float) WorldGen.genRand.Next(-10, 11) * 0.02f;
        if ((double) num2 < 6.0)
          num2 = 6f;
        if ((double) num2 > 10.0)
          num2 = 10f;
        for (int index1 = (int) ((double) position.X - (double) num2 / 2.0); (double) index1 < (double) position.X + (double) num2 / 2.0; ++index1)
        {
          for (int index2 = (int) ((double) position.Y - (double) num2 / 2.0); (double) index2 < (double) position.Y + (double) num2 / 2.0; ++index2)
          {
            double num3 = (double) Math.Abs((float) index1 - position.X);
            float num4 = Math.Abs((float) index2 - position.Y);
            if (Math.Sqrt(num3 * num3 + (double) num4 * (double) num4) < (double) num2 * 0.5 && Main.tile[index1, index2].active() && Main.tile[index1, index2].type == (ushort) 203)
            {
              Main.tile[index1, index2].active(false);
              flag = true;
              num1 = 0.0f;
            }
          }
        }
        position += vector2;
      }
    }

    public static void CrimVein(Vector2 position, Vector2 velocity)
    {
      float num1 = (float) WorldGen.genRand.Next(15, 26);
      bool flag = true;
      Vector2 vector2_1 = velocity;
      Vector2 vector2_2 = position;
      int num2 = WorldGen.genRand.Next(100, 150);
      if ((double) velocity.Y < 0.0)
        num2 -= 25;
      while (flag)
      {
        num1 += (float) WorldGen.genRand.Next(-50, 51) * 0.02f;
        if ((double) num1 < 15.0)
          num1 = 15f;
        if ((double) num1 > 25.0)
          num1 = 25f;
        for (int index1 = (int) ((double) position.X - (double) num1 / 2.0); (double) index1 < (double) position.X + (double) num1 / 2.0; ++index1)
        {
          for (int index2 = (int) ((double) position.Y - (double) num1 / 2.0); (double) index2 < (double) position.Y + (double) num1 / 2.0; ++index2)
          {
            double num3 = (double) Math.Abs((float) index1 - position.X);
            float num4 = Math.Abs((float) index2 - position.Y);
            double num5 = Math.Sqrt(num3 * num3 + (double) num4 * (double) num4);
            if (num5 < (double) num1 * 0.2)
            {
              Main.tile[index1, index2].active(false);
              Main.tile[index1, index2].wall = (ushort) 83;
            }
            else if (num5 < (double) num1 * 0.5 && Main.tile[index1, index2].wall != (ushort) 83)
            {
              Main.tile[index1, index2].active(true);
              Main.tile[index1, index2].type = (ushort) 203;
              if (num5 < (double) num1 * 0.4)
                Main.tile[index1, index2].wall = (ushort) 83;
            }
          }
        }
        velocity.X += (float) WorldGen.genRand.Next(-50, 51) * 0.05f;
        velocity.Y += (float) WorldGen.genRand.Next(-50, 51) * 0.05f;
        if ((double) velocity.Y < (double) vector2_1.Y - 0.75)
          velocity.Y = vector2_1.Y - 0.75f;
        if ((double) velocity.Y > (double) vector2_1.Y + 0.75)
          velocity.Y = vector2_1.Y + 0.75f;
        if ((double) velocity.X < (double) vector2_1.X - 0.75)
          velocity.X = vector2_1.X - 0.75f;
        if ((double) velocity.X > (double) vector2_1.X + 0.75)
          velocity.X = vector2_1.X + 0.75f;
        position += velocity;
        if ((double) Math.Abs(position.X - vector2_2.X) + (double) Math.Abs(position.Y - vector2_2.Y) > (double) num2)
          flag = false;
      }
      WorldGen.heartPos[WorldGen.heartCount] = position;
      ++WorldGen.heartCount;
    }

    public static void ChasmRunner(int i, int j, int steps, bool makeOrb = false)
    {
      bool flag1 = false;
      bool flag2 = false;
      bool flag3 = false;
      if (!makeOrb)
        flag2 = true;
      float num1 = (float) steps;
      Vector2 vector2_1;
      vector2_1.X = (float) i;
      vector2_1.Y = (float) j;
      Vector2 vector2_2;
      vector2_2.X = (float) WorldGen.genRand.Next(-10, 11) * 0.1f;
      vector2_2.Y = (float) ((double) WorldGen.genRand.Next(11) * 0.200000002980232 + 0.5);
      int num2 = 5;
      double num3 = (double) (WorldGen.genRand.Next(5) + 7);
      while (num3 > 0.0)
      {
        if ((double) num1 > 0.0)
        {
          num3 = num3 + (double) WorldGen.genRand.Next(3) - (double) WorldGen.genRand.Next(3);
          if (num3 < 7.0)
            num3 = 7.0;
          if (num3 > 20.0)
            num3 = 20.0;
          if ((double) num1 == 1.0 && num3 < 10.0)
            num3 = 10.0;
        }
        else if ((double) vector2_1.Y > Main.worldSurface + 45.0)
          num3 -= (double) WorldGen.genRand.Next(4);
        if ((double) vector2_1.Y > Main.rockLayer && (double) num1 > 0.0)
          num1 = 0.0f;
        --num1;
        if (!flag1 && (double) vector2_1.Y > Main.worldSurface + 20.0)
        {
          flag1 = true;
          WorldGen.ChasmRunnerSideways((int) vector2_1.X, (int) vector2_1.Y, -1, WorldGen.genRand.Next(20, 40));
          WorldGen.ChasmRunnerSideways((int) vector2_1.X, (int) vector2_1.Y, 1, WorldGen.genRand.Next(20, 40));
        }
        if ((double) num1 > (double) num2)
        {
          int num4 = (int) ((double) vector2_1.X - num3 * 0.5);
          int num5 = (int) ((double) vector2_1.X + num3 * 0.5);
          int num6 = (int) ((double) vector2_1.Y - num3 * 0.5);
          int num7 = (int) ((double) vector2_1.Y + num3 * 0.5);
          if (num4 < 0)
            num4 = 0;
          if (num5 > Main.maxTilesX - 1)
            num5 = Main.maxTilesX - 1;
          if (num6 < 0)
            num6 = 0;
          if (num7 > Main.maxTilesY)
            num7 = Main.maxTilesY;
          for (int index1 = num4; index1 < num5; ++index1)
          {
            for (int index2 = num6; index2 < num7; ++index2)
            {
              if ((double) Math.Abs((float) index1 - vector2_1.X) + (double) Math.Abs((float) index2 - vector2_1.Y) < num3 * 0.5 * (1.0 + (double) WorldGen.genRand.Next(-10, 11) * 0.015) && Main.tile[index1, index2].type != (ushort) 31 && Main.tile[index1, index2].type != (ushort) 22)
                Main.tile[index1, index2].active(false);
            }
          }
        }
        if ((double) num1 <= 2.0 && (double) vector2_1.Y < Main.worldSurface + 45.0)
          num1 = 2f;
        if ((double) num1 <= 0.0)
        {
          if (!flag2)
          {
            flag2 = true;
            WorldGen.AddShadowOrb((int) vector2_1.X, (int) vector2_1.Y);
          }
          else if (!flag3)
          {
            flag3 = false;
            bool flag4 = false;
            int num4 = 0;
            while (!flag4)
            {
              int x = WorldGen.genRand.Next((int) vector2_1.X - 25, (int) vector2_1.X + 25);
              int y = WorldGen.genRand.Next((int) vector2_1.Y - 50, (int) vector2_1.Y);
              if (x < 5)
                x = 5;
              if (x > Main.maxTilesX - 5)
                x = Main.maxTilesX - 5;
              if (y < 5)
                y = 5;
              if (y > Main.maxTilesY - 5)
                y = Main.maxTilesY - 5;
              if ((double) y > Main.worldSurface)
              {
                if (!WorldGen.IsTileNearby(x, y, 26, 3))
                  WorldGen.Place3x2(x, y, (ushort) 26, 0);
                if (Main.tile[x, y].type == (ushort) 26)
                {
                  flag4 = true;
                }
                else
                {
                  ++num4;
                  if (num4 >= 10000)
                    flag4 = true;
                }
              }
              else
                flag4 = true;
            }
          }
        }
        vector2_1 += vector2_2;
        vector2_2.X += (float) WorldGen.genRand.Next(-10, 11) * 0.01f;
        if ((double) vector2_2.X > 0.3)
          vector2_2.X = 0.3f;
        if ((double) vector2_2.X < -0.3)
          vector2_2.X = -0.3f;
        int num8 = (int) ((double) vector2_1.X - num3 * 1.1);
        int num9 = (int) ((double) vector2_1.X + num3 * 1.1);
        int num10 = (int) ((double) vector2_1.Y - num3 * 1.1);
        int num11 = (int) ((double) vector2_1.Y + num3 * 1.1);
        if (num8 < 1)
          num8 = 1;
        if (num9 > Main.maxTilesX - 1)
          num9 = Main.maxTilesX - 1;
        if (num10 < 0)
          num10 = 0;
        if (num11 > Main.maxTilesY)
          num11 = Main.maxTilesY;
        for (int index1 = num8; index1 < num9; ++index1)
        {
          for (int index2 = num10; index2 < num11; ++index2)
          {
            if ((double) Math.Abs((float) index1 - vector2_1.X) + (double) Math.Abs((float) index2 - vector2_1.Y) < num3 * 1.1 * (1.0 + (double) WorldGen.genRand.Next(-10, 11) * 0.015))
            {
              if (Main.tile[index1, index2].type != (ushort) 25 && index2 > j + WorldGen.genRand.Next(3, 20))
                Main.tile[index1, index2].active(true);
              if (steps <= num2)
                Main.tile[index1, index2].active(true);
              if (Main.tile[index1, index2].type != (ushort) 31)
                Main.tile[index1, index2].type = (ushort) 25;
            }
          }
        }
        for (int index1 = num8; index1 < num9; ++index1)
        {
          for (int index2 = num10; index2 < num11; ++index2)
          {
            if ((double) Math.Abs((float) index1 - vector2_1.X) + (double) Math.Abs((float) index2 - vector2_1.Y) < num3 * 1.1 * (1.0 + (double) WorldGen.genRand.Next(-10, 11) * 0.015))
            {
              if (Main.tile[index1, index2].type != (ushort) 31)
                Main.tile[index1, index2].type = (ushort) 25;
              if (steps <= num2)
                Main.tile[index1, index2].active(true);
              if (index2 > j + WorldGen.genRand.Next(3, 20))
                Main.tile[index1, index2].wall = (ushort) 3;
            }
          }
        }
      }
    }

    public static void GERunner(int i, int j, float speedX = 0.0f, float speedY = 0.0f, bool good = true)
    {
      int num1 = 0;
      for (int index1 = 20; index1 < Main.maxTilesX - 20; ++index1)
      {
        for (int index2 = 20; index2 < Main.maxTilesY - 20; ++index2)
        {
          if (Main.tile[index1, index2].active() && Main.tile[index1, index2].type == (ushort) 225)
            ++num1;
        }
      }
      bool flag1 = false;
      if (num1 > 200000)
        flag1 = true;
      int num2 = (int) ((double) WorldGen.genRand.Next(200, 250) * (double) (Main.maxTilesX / 4200));
      double num3 = (double) num2;
      Vector2 vector2_1;
      vector2_1.X = (float) i;
      vector2_1.Y = (float) j;
      Vector2 vector2_2;
      vector2_2.X = (float) WorldGen.genRand.Next(-10, 11) * 0.1f;
      vector2_2.Y = (float) WorldGen.genRand.Next(-10, 11) * 0.1f;
      if ((double) speedX != 0.0 || (double) speedY != 0.0)
      {
        vector2_2.X = speedX;
        vector2_2.Y = speedY;
      }
      bool flag2 = true;
      while (flag2)
      {
        int num4 = (int) ((double) vector2_1.X - num3 * 0.5);
        int num5 = (int) ((double) vector2_1.X + num3 * 0.5);
        int num6 = (int) ((double) vector2_1.Y - num3 * 0.5);
        int num7 = (int) ((double) vector2_1.Y + num3 * 0.5);
        if (num4 < 0)
          num4 = 0;
        if (num5 > Main.maxTilesX)
          num5 = Main.maxTilesX;
        if (num6 < 0)
          num6 = 0;
        if (num7 > Main.maxTilesY - 5)
          num7 = Main.maxTilesY - 5;
        for (int i1 = num4; i1 < num5; ++i1)
        {
          for (int j1 = num6; j1 < num7; ++j1)
          {
            if ((double) Math.Abs((float) i1 - vector2_1.X) + (double) Math.Abs((float) j1 - vector2_1.Y) < (double) num2 * 0.5 * (1.0 + (double) WorldGen.genRand.Next(-10, 11) * 0.015))
            {
              if (good)
              {
                if (Main.tile[i1, j1].wall == (ushort) 63 || Main.tile[i1, j1].wall == (ushort) 65 || (Main.tile[i1, j1].wall == (ushort) 66 || Main.tile[i1, j1].wall == (ushort) 68) || (Main.tile[i1, j1].wall == (ushort) 69 || Main.tile[i1, j1].wall == (ushort) 81))
                  Main.tile[i1, j1].wall = (ushort) 70;
                else if (Main.tile[i1, j1].wall == (ushort) 216)
                  Main.tile[i1, j1].wall = (ushort) 219;
                else if (Main.tile[i1, j1].wall == (ushort) 187)
                  Main.tile[i1, j1].wall = (ushort) 222;
                if (Main.tile[i1, j1].wall == (ushort) 3 || Main.tile[i1, j1].wall == (ushort) 83)
                  Main.tile[i1, j1].wall = (ushort) 28;
                if (flag1 && Main.tile[i1, j1].type == (ushort) 225)
                {
                  Main.tile[i1, j1].type = (ushort) 117;
                  WorldGen.SquareTileFrame(i1, j1, true);
                }
                else if (flag1 && Main.tile[i1, j1].type == (ushort) 230)
                {
                  Main.tile[i1, j1].type = (ushort) 402;
                  WorldGen.SquareTileFrame(i1, j1, true);
                }
                else if (Main.tile[i1, j1].type == (ushort) 2)
                {
                  Main.tile[i1, j1].type = (ushort) 109;
                  WorldGen.SquareTileFrame(i1, j1, true);
                }
                else if (Main.tile[i1, j1].type == (ushort) 1)
                {
                  Main.tile[i1, j1].type = (ushort) 117;
                  WorldGen.SquareTileFrame(i1, j1, true);
                }
                else if (Main.tile[i1, j1].type == (ushort) 53 || Main.tile[i1, j1].type == (ushort) 123)
                {
                  Main.tile[i1, j1].type = (ushort) 116;
                  WorldGen.SquareTileFrame(i1, j1, true);
                }
                else if (Main.tile[i1, j1].type == (ushort) 23 || Main.tile[i1, j1].type == (ushort) 199)
                {
                  Main.tile[i1, j1].type = (ushort) 109;
                  WorldGen.SquareTileFrame(i1, j1, true);
                }
                else if (Main.tile[i1, j1].type == (ushort) 25 || Main.tile[i1, j1].type == (ushort) 203)
                {
                  Main.tile[i1, j1].type = (ushort) 117;
                  WorldGen.SquareTileFrame(i1, j1, true);
                }
                else if (Main.tile[i1, j1].type == (ushort) 112 || Main.tile[i1, j1].type == (ushort) 234)
                {
                  Main.tile[i1, j1].type = (ushort) 116;
                  WorldGen.SquareTileFrame(i1, j1, true);
                }
                else if (Main.tile[i1, j1].type == (ushort) 161 || Main.tile[i1, j1].type == (ushort) 163 || Main.tile[i1, j1].type == (ushort) 200)
                {
                  Main.tile[i1, j1].type = (ushort) 164;
                  WorldGen.SquareTileFrame(i1, j1, true);
                }
                else if (Main.tile[i1, j1].type == (ushort) 396)
                {
                  Main.tile[i1, j1].type = (ushort) 403;
                  WorldGen.SquareTileFrame(i1, j1, true);
                }
                else if (Main.tile[i1, j1].type == (ushort) 397)
                {
                  Main.tile[i1, j1].type = (ushort) 402;
                  WorldGen.SquareTileFrame(i1, j1, true);
                }
              }
              else if (WorldGen.crimson)
              {
                if (Main.tile[i1, j1].wall == (ushort) 63 || Main.tile[i1, j1].wall == (ushort) 65 || (Main.tile[i1, j1].wall == (ushort) 66 || Main.tile[i1, j1].wall == (ushort) 68))
                  Main.tile[i1, j1].wall = (ushort) 81;
                else if (Main.tile[i1, j1].wall == (ushort) 216)
                  Main.tile[i1, j1].wall = (ushort) 218;
                else if (Main.tile[i1, j1].wall == (ushort) 187)
                  Main.tile[i1, j1].wall = (ushort) 221;
                if (flag1 && Main.tile[i1, j1].type == (ushort) 225)
                {
                  Main.tile[i1, j1].type = (ushort) 203;
                  WorldGen.SquareTileFrame(i1, j1, true);
                }
                else if (flag1 && Main.tile[i1, j1].type == (ushort) 230)
                {
                  Main.tile[i1, j1].type = (ushort) 399;
                  WorldGen.SquareTileFrame(i1, j1, true);
                }
                else if (Main.tile[i1, j1].type == (ushort) 2)
                {
                  Main.tile[i1, j1].type = (ushort) 199;
                  WorldGen.SquareTileFrame(i1, j1, true);
                }
                else if (Main.tile[i1, j1].type == (ushort) 1)
                {
                  Main.tile[i1, j1].type = (ushort) 203;
                  WorldGen.SquareTileFrame(i1, j1, true);
                }
                else if (Main.tile[i1, j1].type == (ushort) 53 || Main.tile[i1, j1].type == (ushort) 123)
                {
                  Main.tile[i1, j1].type = (ushort) 234;
                  WorldGen.SquareTileFrame(i1, j1, true);
                }
                else if (Main.tile[i1, j1].type == (ushort) 109)
                {
                  Main.tile[i1, j1].type = (ushort) 199;
                  WorldGen.SquareTileFrame(i1, j1, true);
                }
                else if (Main.tile[i1, j1].type == (ushort) 117)
                {
                  Main.tile[i1, j1].type = (ushort) 203;
                  WorldGen.SquareTileFrame(i1, j1, true);
                }
                else if (Main.tile[i1, j1].type == (ushort) 116)
                {
                  Main.tile[i1, j1].type = (ushort) 234;
                  WorldGen.SquareTileFrame(i1, j1, true);
                }
                else if (Main.tile[i1, j1].type == (ushort) 161 || Main.tile[i1, j1].type == (ushort) 164)
                {
                  Main.tile[i1, j1].type = (ushort) 200;
                  WorldGen.SquareTileFrame(i1, j1, true);
                }
                else if (Main.tile[i1, j1].type == (ushort) 396)
                {
                  Main.tile[i1, j1].type = (ushort) 401;
                  WorldGen.SquareTileFrame(i1, j1, true);
                }
                else if (Main.tile[i1, j1].type == (ushort) 397)
                {
                  Main.tile[i1, j1].type = (ushort) 399;
                  WorldGen.SquareTileFrame(i1, j1, true);
                }
              }
              else
              {
                if (Main.tile[i1, j1].wall == (ushort) 63 || Main.tile[i1, j1].wall == (ushort) 65 || (Main.tile[i1, j1].wall == (ushort) 66 || Main.tile[i1, j1].wall == (ushort) 68))
                  Main.tile[i1, j1].wall = (ushort) 69;
                else if (Main.tile[i1, j1].wall == (ushort) 216)
                  Main.tile[i1, j1].wall = (ushort) 217;
                else if (Main.tile[i1, j1].wall == (ushort) 187)
                  Main.tile[i1, j1].wall = (ushort) 220;
                if (flag1 && Main.tile[i1, j1].type == (ushort) 225)
                {
                  Main.tile[i1, j1].type = (ushort) 25;
                  WorldGen.SquareTileFrame(i1, j1, true);
                }
                else if (flag1 && Main.tile[i1, j1].type == (ushort) 230)
                {
                  Main.tile[i1, j1].type = (ushort) 398;
                  WorldGen.SquareTileFrame(i1, j1, true);
                }
                else if (Main.tile[i1, j1].type == (ushort) 2)
                {
                  Main.tile[i1, j1].type = (ushort) 23;
                  WorldGen.SquareTileFrame(i1, j1, true);
                }
                else if (Main.tile[i1, j1].type == (ushort) 1)
                {
                  Main.tile[i1, j1].type = (ushort) 25;
                  WorldGen.SquareTileFrame(i1, j1, true);
                }
                else if (Main.tile[i1, j1].type == (ushort) 53 || Main.tile[i1, j1].type == (ushort) 123)
                {
                  Main.tile[i1, j1].type = (ushort) 112;
                  WorldGen.SquareTileFrame(i1, j1, true);
                }
                else if (Main.tile[i1, j1].type == (ushort) 109)
                {
                  Main.tile[i1, j1].type = (ushort) 23;
                  WorldGen.SquareTileFrame(i1, j1, true);
                }
                else if (Main.tile[i1, j1].type == (ushort) 117)
                {
                  Main.tile[i1, j1].type = (ushort) 25;
                  WorldGen.SquareTileFrame(i1, j1, true);
                }
                else if (Main.tile[i1, j1].type == (ushort) 116)
                {
                  Main.tile[i1, j1].type = (ushort) 112;
                  WorldGen.SquareTileFrame(i1, j1, true);
                }
                else if (Main.tile[i1, j1].type == (ushort) 161 || Main.tile[i1, j1].type == (ushort) 164)
                {
                  Main.tile[i1, j1].type = (ushort) 163;
                  WorldGen.SquareTileFrame(i1, j1, true);
                }
                else if (Main.tile[i1, j1].type == (ushort) 396)
                {
                  Main.tile[i1, j1].type = (ushort) 400;
                  WorldGen.SquareTileFrame(i1, j1, true);
                }
                else if (Main.tile[i1, j1].type == (ushort) 397)
                {
                  Main.tile[i1, j1].type = (ushort) 398;
                  WorldGen.SquareTileFrame(i1, j1, true);
                }
              }
            }
          }
        }
        vector2_1 += vector2_2;
        vector2_2.X += (float) WorldGen.genRand.Next(-10, 11) * 0.05f;
        if ((double) vector2_2.X > (double) speedX + 1.0)
          vector2_2.X = speedX + 1f;
        if ((double) vector2_2.X < (double) speedX - 1.0)
          vector2_2.X = speedX - 1f;
        if ((double) vector2_1.X < (double) -num2 || (double) vector2_1.Y < (double) -num2 || ((double) vector2_1.X > (double) (Main.maxTilesX + num2) || (double) vector2_1.Y > (double) (Main.maxTilesY + num2)))
          flag2 = false;
      }
    }

    private static bool badOceanCaveTiles(int x, int y)
    {
      return Main.tile[x, y].wall == (ushort) 83 || Main.tile[x, y].wall == (ushort) 3 || (Main.wallDungeon[(int) Main.tile[x, y].wall] || Main.tile[x, y].type == (ushort) 203) || (Main.tile[x, y].type == (ushort) 25 || Main.tileDungeon[(int) Main.tile[x, y].type] || (Main.tile[x, y].type == (ushort) 26 || Main.tile[x, y].type == (ushort) 31));
    }

    public static void oceanCave(int i, int j)
    {
      if (WorldGen.numOceanCaveTreasure >= WorldGen.maxOceanCaveTreasure)
        WorldGen.numOceanCaveTreasure = 0;
      Vector2 vector2_1;
      vector2_1.X = (float) i;
      vector2_1.Y = (float) j;
      Vector2 vector2_2;
      vector2_2.X = i >= Main.maxTilesX / 2 ? (float) (-0.349999994039536 - (double) WorldGen.genRand.NextFloat() * 0.5) : (float) (0.25 + (double) WorldGen.genRand.NextFloat() * 0.25);
      vector2_2.Y = (float) (0.400000005960464 + (double) WorldGen.genRand.NextFloat() * 0.25);
      ushort num1 = 264;
      ushort num2 = 53;
      ushort num3 = 397;
      double num4 = (double) WorldGen.genRand.Next(17, 25);
      double num5 = (double) WorldGen.genRand.Next(600, 800);
      double num6 = 4.0;
      bool flag1 = true;
      while (num4 > num6 && num5 > 0.0)
      {
        bool flag2 = true;
        bool flag3 = true;
        bool flag4 = true;
        if ((double) vector2_1.X > (double) (WorldGen.beachDistance - 50) && (double) vector2_1.X < (double) (Main.maxTilesX - WorldGen.beachDistance + 50))
        {
          num4 *= 0.959999978542328;
          num5 *= 0.959999978542328;
        }
        if (num4 < num6 + 2.0 || num5 < 20.0)
          flag4 = false;
        if (flag1)
        {
          num4 -= 0.01 + (double) WorldGen.genRand.NextFloat() * 0.01;
          num5 -= 0.5;
        }
        else
        {
          num4 -= 0.02 + (double) WorldGen.genRand.NextFloat() * 0.02;
          --num5;
        }
        if (flag4)
        {
          WorldGen.oceanCaveTreasure[WorldGen.numOceanCaveTreasure].X = (int) vector2_1.X;
          WorldGen.oceanCaveTreasure[WorldGen.numOceanCaveTreasure].Y = (int) vector2_1.Y;
        }
        int num7 = (int) ((double) vector2_1.X - num4 * 3.0);
        int num8 = (int) ((double) vector2_1.X + num4 * 3.0);
        int num9 = (int) ((double) vector2_1.Y - num4 * 3.0);
        int num10 = (int) ((double) vector2_1.Y + num4 * 3.0);
        if (num7 < 1)
          num7 = 1;
        if (num8 > Main.maxTilesX - 1)
          num8 = Main.maxTilesX - 1;
        if (num9 < 1)
          num9 = 1;
        if (num10 > Main.maxTilesY - 1)
          num10 = Main.maxTilesY - 1;
        for (int x1 = num7; x1 < num8; ++x1)
        {
          for (int y1 = num9; y1 < num10; ++y1)
          {
            if (!WorldGen.badOceanCaveTiles(x1, y1))
            {
              float num11 = new Vector2(Math.Abs((float) x1 - vector2_1.X), Math.Abs((float) y1 - vector2_1.Y)).Length();
              if (flag4 && (double) num11 < num4 * 0.5 + 1.0)
              {
                Main.tile[x1, y1].type = num1;
                Main.tile[x1, y1].active(false);
              }
              else if ((double) num11 < num4 * 1.5 + 1.0 && (int) Main.tile[x1, y1].type != (int) num1)
              {
                if ((double) y1 < (double) vector2_1.Y)
                {
                  if ((double) vector2_2.X < 0.0 && (double) x1 < (double) vector2_1.X || (double) vector2_2.X > 0.0 && (double) x1 > (double) vector2_1.X)
                  {
                    if ((double) num11 < num4 * 1.1 + 1.0)
                    {
                      Main.tile[x1, y1].type = num3;
                      if (Main.tile[x1, y1].liquid == byte.MaxValue)
                        Main.tile[x1, y1].wall = (ushort) 0;
                    }
                    else if ((int) Main.tile[x1, y1].type != (int) num3)
                      Main.tile[x1, y1].type = num2;
                  }
                }
                else if ((double) vector2_2.X < 0.0 && x1 < i || (double) vector2_2.X > 0.0 && x1 > i)
                {
                  if (Main.tile[x1, y1].liquid == byte.MaxValue)
                    Main.tile[x1, y1].wall = (ushort) 0;
                  Main.tile[x1, y1].type = num2;
                  Main.tile[x1, y1].active(true);
                  if (x1 == (int) vector2_1.X & flag2)
                  {
                    flag2 = false;
                    int num12 = 50 + WorldGen.genRand.Next(3);
                    int num13 = 43 + WorldGen.genRand.Next(3);
                    int num14 = 20 + WorldGen.genRand.Next(3);
                    int num15 = x1;
                    int num16 = x1 + num14;
                    if ((double) vector2_2.X < 0.0)
                    {
                      num15 = x1 - num14;
                      num16 = x1;
                    }
                    if (num5 < 100.0)
                    {
                      num12 = (int) ((double) num12 * (num5 / 100.0));
                      num13 = (int) ((double) num13 * (num5 / 100.0));
                      num14 = (int) ((double) num14 * (num5 / 100.0));
                    }
                    if (num4 < num6 + 5.0)
                    {
                      double num17 = (num4 - num6) / 5.0;
                      num12 = (int) ((double) num12 * num17);
                      num13 = (int) ((double) num13 * num17);
                      int num18 = (int) ((double) num14 * num17);
                    }
                    for (int index1 = num15; index1 <= num16; ++index1)
                    {
                      for (int index2 = y1; index2 < y1 + num12 && !WorldGen.badOceanCaveTiles(index1, index2); ++index2)
                      {
                        if (index2 > y1 + num13)
                        {
                          if (!WorldGen.SolidTile(index1, index2, false) || (int) Main.tile[index1, index2].type == (int) num2)
                            Main.tile[index1, index2].type = num3;
                          else
                            break;
                        }
                        else
                          Main.tile[index1, index2].type = num2;
                        Main.tile[index1, index2].active(true);
                        if (WorldGen.genRand.Next(3) == 0)
                        {
                          Main.tile[index1 - 1, index2].type = num2;
                          Main.tile[index1 - 1, index2].active(true);
                        }
                        if (WorldGen.genRand.Next(3) == 0)
                        {
                          Main.tile[index1 + 1, index2].type = num2;
                          Main.tile[index1 + 1, index2].active(true);
                        }
                      }
                    }
                  }
                }
              }
              if ((double) num11 < num4 * 1.3 + 1.0 && y1 > j - 10)
                Main.tile[x1, y1].liquid = byte.MaxValue;
              if (flag3 && x1 == (int) vector2_1.X && (double) y1 > (double) vector2_1.Y)
              {
                flag3 = false;
                int num12 = 100;
                int num13 = 2;
                for (int x2 = x1 - num13; x2 <= x1 + num13; ++x2)
                {
                  for (int y2 = y1; y2 < y1 + num12; ++y2)
                  {
                    if (!WorldGen.badOceanCaveTiles(x2, y2))
                      Main.tile[x2, y2].liquid = byte.MaxValue;
                  }
                }
              }
            }
          }
        }
        vector2_1 += vector2_2;
        vector2_2.X += (float) ((double) WorldGen.genRand.NextFloat() * 0.100000001490116 - 0.0500000007450581);
        vector2_2.Y += (float) ((double) WorldGen.genRand.NextFloat() * 0.100000001490116 - 0.0500000007450581);
        if (flag1)
        {
          if ((double) vector2_1.Y > (Main.worldSurface * 2.0 + Main.rockLayer) / 3.0 && (double) vector2_1.Y > (double) (j + 30))
            flag1 = false;
          vector2_2.Y = MathHelper.Clamp(vector2_2.Y, 0.35f, 1f);
        }
        else
        {
          if ((double) vector2_1.X < (double) (Main.maxTilesX / 2))
          {
            if ((double) vector2_2.X < 0.5)
              vector2_2.X += 0.02f;
          }
          else if ((double) vector2_2.X > -0.5)
            vector2_2.X -= 0.02f;
          if (!flag4)
          {
            if ((double) vector2_2.Y < 0.0)
              vector2_2.Y *= 0.95f;
            vector2_2.Y += 0.04f;
          }
          else if ((double) vector2_1.Y < (Main.worldSurface * 4.0 + Main.rockLayer) / 5.0)
          {
            if ((double) vector2_2.Y < 0.0)
              vector2_2.Y *= 0.97f;
            vector2_2.Y += 0.02f;
          }
          else if ((double) vector2_2.Y > -0.100000001490116)
          {
            vector2_2.Y *= 0.99f;
            vector2_2.Y -= 0.01f;
          }
          vector2_2.Y = MathHelper.Clamp(vector2_2.Y, -1f, 1f);
        }
        vector2_2.X = (double) vector2_1.X >= (double) (Main.maxTilesX / 2) ? MathHelper.Clamp(vector2_2.X, -1f, -0.1f) : MathHelper.Clamp(vector2_2.X, 0.1f, 1f);
      }
      ++WorldGen.numOceanCaveTreasure;
    }

    public static void TileRunner(
      int i,
      int j,
      double strength,
      int steps,
      int type,
      bool addTile = false,
      float speedX = 0.0f,
      float speedY = 0.0f,
      bool noYChange = false,
      bool overRide = true,
      int ignoreTileType = -1)
    {
      if (WorldGen.drunkWorldGen)
      {
        strength *= 1.0 + (double) WorldGen.genRand.Next(-80, 81) * 0.00999999977648258;
        steps = (int) ((double) steps * (1.0 + (double) WorldGen.genRand.Next(-80, 81) * 0.00999999977648258));
      }
      if (WorldGen.getGoodWorldGen && type != 57)
      {
        strength *= 1.0 + (double) WorldGen.genRand.Next(-80, 81) * 0.0149999996647239;
        steps += WorldGen.genRand.Next(3);
      }
      double num1 = strength;
      float num2 = (float) steps;
      Vector2 vector2_1;
      vector2_1.X = (float) i;
      vector2_1.Y = (float) j;
      Vector2 vector2_2;
      vector2_2.X = (float) WorldGen.genRand.Next(-10, 11) * 0.1f;
      vector2_2.Y = (float) WorldGen.genRand.Next(-10, 11) * 0.1f;
      if ((double) speedX != 0.0 || (double) speedY != 0.0)
      {
        vector2_2.X = speedX;
        vector2_2.Y = speedY;
      }
      bool flag1 = type == 368;
      bool flag2 = type == 367;
      bool lava = false;
      if (WorldGen.getGoodWorldGen && WorldGen.genRand.Next(4) == 0)
        lava = true;
      while (num1 > 0.0 && (double) num2 > 0.0)
      {
        if (WorldGen.drunkWorldGen && WorldGen.genRand.Next(30) == 0)
        {
          vector2_1.X += (float) WorldGen.genRand.Next(-100, 101) * 0.05f;
          vector2_1.Y += (float) WorldGen.genRand.Next(-100, 101) * 0.05f;
        }
        if ((double) vector2_1.Y < 0.0 && (double) num2 > 0.0 && type == 59)
          num2 = 0.0f;
        num1 = strength * ((double) num2 / (double) steps);
        --num2;
        int num3 = (int) ((double) vector2_1.X - num1 * 0.5);
        int num4 = (int) ((double) vector2_1.X + num1 * 0.5);
        int num5 = (int) ((double) vector2_1.Y - num1 * 0.5);
        int num6 = (int) ((double) vector2_1.Y + num1 * 0.5);
        if (num3 < 1)
          num3 = 1;
        if (num4 > Main.maxTilesX - 1)
          num4 = Main.maxTilesX - 1;
        if (num5 < 1)
          num5 = 1;
        if (num6 > Main.maxTilesY - 1)
          num6 = Main.maxTilesY - 1;
        for (int index1 = num3; index1 < num4; ++index1)
        {
          if (index1 < WorldGen.beachDistance + 50 || index1 >= Main.maxTilesX - WorldGen.beachDistance - 50)
            lava = false;
          for (int index2 = num5; index2 < num6; ++index2)
          {
            if ((!WorldGen.drunkWorldGen || index2 >= Main.maxTilesY - 300 || type != 57) && (ignoreTileType < 0 || !Main.tile[index1, index2].active() || (int) Main.tile[index1, index2].type != ignoreTileType) && (double) Math.Abs((float) index1 - vector2_1.X) + (double) Math.Abs((float) index2 - vector2_1.Y) < strength * 0.5 * (1.0 + (double) WorldGen.genRand.Next(-10, 11) * 0.015))
            {
              if (WorldGen.mudWall && (double) index2 > Main.worldSurface && (Main.tile[index1, index2 - 1].wall != (ushort) 2 && index2 < Main.maxTilesY - 210 - WorldGen.genRand.Next(3)) && (double) Math.Abs((float) index1 - vector2_1.X) + (double) Math.Abs((float) index2 - vector2_1.Y) < strength * 0.45 * (1.0 + (double) WorldGen.genRand.Next(-10, 11) * 0.01))
              {
                if (index2 > WorldGen.lavaLine - WorldGen.genRand.Next(0, 4) - 50)
                {
                  if (Main.tile[index1, index2 - 1].wall != (ushort) 64 && Main.tile[index1, index2 + 1].wall != (ushort) 64 && (Main.tile[index1 - 1, index2].wall != (ushort) 64 && Main.tile[index1, index2 + 1].wall != (ushort) 64))
                    WorldGen.PlaceWall(index1, index2, 15, true);
                }
                else if (Main.tile[index1, index2 - 1].wall != (ushort) 15 && Main.tile[index1, index2 + 1].wall != (ushort) 15 && (Main.tile[index1 - 1, index2].wall != (ushort) 15 && Main.tile[index1, index2 + 1].wall != (ushort) 15))
                  WorldGen.PlaceWall(index1, index2, 64, true);
              }
              if (type < 0)
              {
                if (Main.tile[index1, index2].type != (ushort) 53)
                {
                  if (type == -2 && Main.tile[index1, index2].active() && (index2 < WorldGen.waterLine || index2 > WorldGen.lavaLine))
                  {
                    Main.tile[index1, index2].liquid = byte.MaxValue;
                    Main.tile[index1, index2].lava(lava);
                    if (index2 > WorldGen.lavaLine)
                      Main.tile[index1, index2].lava(true);
                  }
                  Main.tile[index1, index2].active(false);
                }
              }
              else
              {
                if (flag1 && (double) Math.Abs((float) index1 - vector2_1.X) + (double) Math.Abs((float) index2 - vector2_1.Y) < strength * 0.3 * (1.0 + (double) WorldGen.genRand.Next(-10, 11) * 0.01))
                  WorldGen.PlaceWall(index1, index2, 180, true);
                if (flag2 && (double) Math.Abs((float) index1 - vector2_1.X) + (double) Math.Abs((float) index2 - vector2_1.Y) < strength * 0.3 * (1.0 + (double) WorldGen.genRand.Next(-10, 11) * 0.01))
                  WorldGen.PlaceWall(index1, index2, 178, true);
                if (overRide || !Main.tile[index1, index2].active())
                {
                  Tile tile = Main.tile[index1, index2];
                  bool flag3 = Main.tileStone[type] && tile.type != (ushort) 1;
                  if (!TileID.Sets.CanBeClearedDuringGeneration[(int) tile.type])
                    flag3 = true;
                  switch (tile.type)
                  {
                    case 1:
                      if (type == 59 && (double) index2 < Main.worldSurface + (double) WorldGen.genRand.Next(-50, 50))
                      {
                        flag3 = true;
                        break;
                      }
                      break;
                    case 45:
                    case 147:
                    case 189:
                    case 190:
                    case 196:
                    case 460:
                      flag3 = true;
                      break;
                    case 53:
                      if (type == 59 && WorldGen.UndergroundDesertLocation.Contains(index1, index2))
                        flag3 = true;
                      if (type == 40)
                        flag3 = true;
                      if ((double) index2 < Main.worldSurface && type != 59)
                      {
                        flag3 = true;
                        break;
                      }
                      break;
                    case 367:
                    case 368:
                      if (type == 59)
                      {
                        flag3 = true;
                        break;
                      }
                      break;
                    case 396:
                    case 397:
                      flag3 = !TileID.Sets.Ore[type];
                      break;
                  }
                  if (!flag3)
                    tile.type = (ushort) type;
                }
                if (addTile)
                {
                  Main.tile[index1, index2].active(true);
                  Main.tile[index1, index2].liquid = (byte) 0;
                  Main.tile[index1, index2].lava(false);
                }
                if (noYChange && (double) index2 < Main.worldSurface && type != 59)
                  Main.tile[index1, index2].wall = (ushort) 2;
                if (type == 59 && index2 > WorldGen.waterLine && Main.tile[index1, index2].liquid > (byte) 0)
                {
                  Main.tile[index1, index2].lava(false);
                  Main.tile[index1, index2].liquid = (byte) 0;
                }
              }
            }
          }
        }
        vector2_1 += vector2_2;
        if ((!WorldGen.drunkWorldGen || WorldGen.genRand.Next(3) != 0) && num1 > 50.0)
        {
          vector2_1 += vector2_2;
          --num2;
          vector2_2.Y += (float) WorldGen.genRand.Next(-10, 11) * 0.05f;
          vector2_2.X += (float) WorldGen.genRand.Next(-10, 11) * 0.05f;
          if (num1 > 100.0)
          {
            vector2_1 += vector2_2;
            --num2;
            vector2_2.Y += (float) WorldGen.genRand.Next(-10, 11) * 0.05f;
            vector2_2.X += (float) WorldGen.genRand.Next(-10, 11) * 0.05f;
            if (num1 > 150.0)
            {
              vector2_1 += vector2_2;
              --num2;
              vector2_2.Y += (float) WorldGen.genRand.Next(-10, 11) * 0.05f;
              vector2_2.X += (float) WorldGen.genRand.Next(-10, 11) * 0.05f;
              if (num1 > 200.0)
              {
                vector2_1 += vector2_2;
                --num2;
                vector2_2.Y += (float) WorldGen.genRand.Next(-10, 11) * 0.05f;
                vector2_2.X += (float) WorldGen.genRand.Next(-10, 11) * 0.05f;
                if (num1 > 250.0)
                {
                  vector2_1 += vector2_2;
                  --num2;
                  vector2_2.Y += (float) WorldGen.genRand.Next(-10, 11) * 0.05f;
                  vector2_2.X += (float) WorldGen.genRand.Next(-10, 11) * 0.05f;
                  if (num1 > 300.0)
                  {
                    vector2_1 += vector2_2;
                    --num2;
                    vector2_2.Y += (float) WorldGen.genRand.Next(-10, 11) * 0.05f;
                    vector2_2.X += (float) WorldGen.genRand.Next(-10, 11) * 0.05f;
                    if (num1 > 400.0)
                    {
                      vector2_1 += vector2_2;
                      --num2;
                      vector2_2.Y += (float) WorldGen.genRand.Next(-10, 11) * 0.05f;
                      vector2_2.X += (float) WorldGen.genRand.Next(-10, 11) * 0.05f;
                      if (num1 > 500.0)
                      {
                        vector2_1 += vector2_2;
                        --num2;
                        vector2_2.Y += (float) WorldGen.genRand.Next(-10, 11) * 0.05f;
                        vector2_2.X += (float) WorldGen.genRand.Next(-10, 11) * 0.05f;
                        if (num1 > 600.0)
                        {
                          vector2_1 += vector2_2;
                          --num2;
                          vector2_2.Y += (float) WorldGen.genRand.Next(-10, 11) * 0.05f;
                          vector2_2.X += (float) WorldGen.genRand.Next(-10, 11) * 0.05f;
                          if (num1 > 700.0)
                          {
                            vector2_1 += vector2_2;
                            --num2;
                            vector2_2.Y += (float) WorldGen.genRand.Next(-10, 11) * 0.05f;
                            vector2_2.X += (float) WorldGen.genRand.Next(-10, 11) * 0.05f;
                            if (num1 > 800.0)
                            {
                              vector2_1 += vector2_2;
                              --num2;
                              vector2_2.Y += (float) WorldGen.genRand.Next(-10, 11) * 0.05f;
                              vector2_2.X += (float) WorldGen.genRand.Next(-10, 11) * 0.05f;
                              if (num1 > 900.0)
                              {
                                vector2_1 += vector2_2;
                                --num2;
                                vector2_2.Y += (float) WorldGen.genRand.Next(-10, 11) * 0.05f;
                                vector2_2.X += (float) WorldGen.genRand.Next(-10, 11) * 0.05f;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        vector2_2.X += (float) WorldGen.genRand.Next(-10, 11) * 0.05f;
        if (WorldGen.drunkWorldGen)
          vector2_2.X += (float) WorldGen.genRand.Next(-10, 11) * 0.25f;
        if ((double) vector2_2.X > 1.0)
          vector2_2.X = 1f;
        if ((double) vector2_2.X < -1.0)
          vector2_2.X = -1f;
        if (!noYChange)
        {
          vector2_2.Y += (float) WorldGen.genRand.Next(-10, 11) * 0.05f;
          if ((double) vector2_2.Y > 1.0)
            vector2_2.Y = 1f;
          if ((double) vector2_2.Y < -1.0)
            vector2_2.Y = -1f;
        }
        else if (type != 59 && num1 < 3.0)
        {
          if ((double) vector2_2.Y > 1.0)
            vector2_2.Y = 1f;
          if ((double) vector2_2.Y < -1.0)
            vector2_2.Y = -1f;
        }
        if (type == 59 && !noYChange)
        {
          if ((double) vector2_2.Y > 0.5)
            vector2_2.Y = 0.5f;
          if ((double) vector2_2.Y < -0.5)
            vector2_2.Y = -0.5f;
          if ((double) vector2_1.Y < Main.rockLayer + 100.0)
            vector2_2.Y = 1f;
          if ((double) vector2_1.Y > (double) (Main.maxTilesY - 300))
            vector2_2.Y = -1f;
        }
      }
    }

    public static void DirtyRockRunner(int i, int j)
    {
      double num1 = (double) WorldGen.genRand.Next(2, 6);
      float num2 = (float) WorldGen.genRand.Next(5, 50);
      float num3 = num2;
      Vector2 vector2_1;
      vector2_1.X = (float) i;
      vector2_1.Y = (float) j;
      Vector2 vector2_2;
      vector2_2.X = (float) WorldGen.genRand.Next(-10, 11) * 0.1f;
      vector2_2.Y = (float) WorldGen.genRand.Next(-10, 11) * 0.1f;
      while (num1 > 0.0 && (double) num3 > 0.0)
      {
        double num4 = num1 * ((double) num3 / (double) num2);
        --num3;
        int num5 = (int) ((double) vector2_1.X - num4 * 0.5);
        int num6 = (int) ((double) vector2_1.X + num4 * 0.5);
        int num7 = (int) ((double) vector2_1.Y - num4 * 0.5);
        int num8 = (int) ((double) vector2_1.Y + num4 * 0.5);
        if (num5 < 0)
          num5 = 0;
        if (num6 > Main.maxTilesX)
          num6 = Main.maxTilesX;
        if (num7 < 0)
          num7 = 0;
        if (num8 > Main.maxTilesY)
          num8 = Main.maxTilesY;
        for (int index1 = num5; index1 < num6; ++index1)
        {
          for (int index2 = num7; index2 < num8; ++index2)
          {
            if ((double) Math.Abs((float) index1 - vector2_1.X) + (double) Math.Abs((float) index2 - vector2_1.Y) < num1 * 0.5 * (1.0 + (double) WorldGen.genRand.Next(-10, 11) * 0.015) && Main.tile[index1, index2].wall == (ushort) 2)
              Main.tile[index1, index2].wall = (ushort) 59;
          }
        }
        vector2_1 += vector2_2;
        vector2_2.X += (float) WorldGen.genRand.Next(-10, 11) * 0.05f;
        if ((double) vector2_2.X > 1.0)
          vector2_2.X = 1f;
        if ((double) vector2_2.X < -1.0)
          vector2_2.X = -1f;
        vector2_2.Y += (float) WorldGen.genRand.Next(-10, 11) * 0.05f;
        if ((double) vector2_2.Y > 1.0)
          vector2_2.Y = 1f;
        if ((double) vector2_2.Y < -1.0)
          vector2_2.Y = -1f;
      }
    }

    public static void MudWallRunner(int i, int j)
    {
      double num1 = (double) WorldGen.genRand.Next(8, 21);
      float num2 = (float) WorldGen.genRand.Next(8, 33);
      float num3 = num2;
      Vector2 vector2_1;
      vector2_1.X = (float) i;
      vector2_1.Y = (float) j;
      Vector2 vector2_2;
      vector2_2.X = (float) WorldGen.genRand.Next(-10, 11) * 0.1f;
      vector2_2.Y = (float) WorldGen.genRand.Next(-10, 11) * 0.1f;
      while (num1 > 0.0 && (double) num3 > 0.0)
      {
        double num4 = num1 * ((double) num3 / (double) num2);
        --num3;
        int num5 = (int) ((double) vector2_1.X - num4 * 0.5);
        int num6 = (int) ((double) vector2_1.X + num4 * 0.5);
        int num7 = (int) ((double) vector2_1.Y - num4 * 0.5);
        int num8 = (int) ((double) vector2_1.Y + num4 * 0.5);
        if (num5 < 0)
          num5 = 0;
        if (num6 > Main.maxTilesX)
          num6 = Main.maxTilesX;
        if (num7 < 0)
          num7 = 0;
        if (num8 > Main.maxTilesY)
          num8 = Main.maxTilesY;
        for (int index1 = num5; index1 < num6; ++index1)
        {
          for (int index2 = num7; index2 < num8; ++index2)
          {
            if ((double) Math.Abs((float) index1 - vector2_1.X) + (double) Math.Abs((float) index2 - vector2_1.Y) < num1 * 0.5 * (1.0 + (double) WorldGen.genRand.Next(-10, 11) * 0.015) && (double) index2 > Main.worldSurface)
              Main.tile[index1, index2].wall = (ushort) 0;
          }
        }
        vector2_1 += vector2_2;
        vector2_2.X += (float) WorldGen.genRand.Next(-10, 11) * 0.05f;
        if ((double) vector2_2.X > 1.0)
          vector2_2.X = 1f;
        if ((double) vector2_2.X < -1.0)
          vector2_2.X = -1f;
        vector2_2.Y += (float) WorldGen.genRand.Next(-10, 11) * 0.05f;
        if ((double) vector2_2.Y > 1.0)
          vector2_2.Y = 1f;
        if ((double) vector2_2.Y < -1.0)
          vector2_2.Y = -1f;
      }
    }

    public static void SnowCloudIsland(int i, int j)
    {
      double num1 = (double) WorldGen.genRand.Next(100, 150);
      double num2 = num1;
      float num3 = (float) WorldGen.genRand.Next(20, 30);
      int num4 = i;
      int num5 = i;
      int num6 = i;
      int num7 = j;
      Vector2 vector2_1;
      vector2_1.X = (float) i;
      vector2_1.Y = (float) j;
      Vector2 vector2_2;
      vector2_2.X = (float) WorldGen.genRand.Next(-20, 21) * 0.2f;
      while ((double) vector2_2.X > -2.0 && (double) vector2_2.X < 2.0)
        vector2_2.X = (float) WorldGen.genRand.Next(-20, 21) * 0.2f;
      vector2_2.Y = (float) WorldGen.genRand.Next(-20, -10) * 0.02f;
      while (num1 > 0.0 && (double) num3 > 0.0)
      {
        num1 -= (double) WorldGen.genRand.Next(4);
        --num3;
        int num8 = (int) ((double) vector2_1.X - num1 * 0.5);
        int num9 = (int) ((double) vector2_1.X + num1 * 0.5);
        int num10 = (int) ((double) vector2_1.Y - num1 * 0.5);
        int num11 = (int) ((double) vector2_1.Y + num1 * 0.5);
        if (num8 < 0)
          num8 = 0;
        if (num9 > Main.maxTilesX)
          num9 = Main.maxTilesX;
        if (num10 < 0)
          num10 = 0;
        if (num11 > Main.maxTilesY)
          num11 = Main.maxTilesY;
        double num12 = num1 * (double) WorldGen.genRand.Next(80, 120) * 0.01;
        float num13 = vector2_1.Y + 1f;
        for (int i1 = num8; i1 < num9; ++i1)
        {
          if (WorldGen.genRand.Next(2) == 0)
            num13 += (float) WorldGen.genRand.Next(-1, 2);
          if ((double) num13 < (double) vector2_1.Y)
            num13 = vector2_1.Y;
          if ((double) num13 > (double) vector2_1.Y + 2.0)
            num13 = vector2_1.Y + 2f;
          for (int j1 = num10; j1 < num11; ++j1)
          {
            if ((double) j1 > (double) num13)
            {
              double num14 = (double) Math.Abs((float) i1 - vector2_1.X);
              float num15 = Math.Abs((float) j1 - vector2_1.Y) * 3f;
              if (Math.Sqrt(num14 * num14 + (double) num15 * (double) num15) < num12 * 0.4)
              {
                if (i1 < num4)
                  num4 = i1;
                if (i1 > num5)
                  num5 = i1;
                if (j1 < num6)
                  num6 = j1;
                if (j1 > num7)
                  num7 = j1;
                Main.tile[i1, j1].active(true);
                Main.tile[i1, j1].type = (ushort) 189;
                WorldGen.SquareTileFrame(i1, j1, true);
              }
            }
          }
        }
        vector2_1 += vector2_2;
        vector2_2.X += (float) WorldGen.genRand.Next(-20, 21) * 0.05f;
        if ((double) vector2_2.X > 1.0)
          vector2_2.X = 1f;
        if ((double) vector2_2.X < -1.0)
          vector2_2.X = -1f;
        if ((double) vector2_2.Y > 0.2)
          vector2_2.Y = -0.2f;
        if ((double) vector2_2.Y < -0.2)
          vector2_2.Y = -0.2f;
      }
      int minValue1;
      for (int index1 = num4 + WorldGen.genRand.Next(5); index1 < num5; index1 += WorldGen.genRand.Next(minValue1, (int) ((double) minValue1 * 1.5)))
      {
        int index2 = num7;
        while (!Main.tile[index1, index2].active())
          --index2;
        int num8 = index2 + WorldGen.genRand.Next(-3, 4);
        minValue1 = WorldGen.genRand.Next(4, 8);
        int num9 = 189;
        if (WorldGen.genRand.Next(4) == 0)
          num9 = 460;
        for (int i1 = index1 - minValue1; i1 <= index1 + minValue1; ++i1)
        {
          for (int j1 = num8 - minValue1; j1 <= num8 + minValue1; ++j1)
          {
            if (j1 > num6)
            {
              double num10 = (double) Math.Abs(i1 - index1);
              float num11 = (float) (Math.Abs(j1 - num8) * 2);
              if (Math.Sqrt(num10 * num10 + (double) num11 * (double) num11) < (double) (minValue1 + WorldGen.genRand.Next(2)))
              {
                Main.tile[i1, j1].active(true);
                Main.tile[i1, j1].type = (ushort) num9;
                WorldGen.SquareTileFrame(i1, j1, true);
              }
            }
          }
        }
      }
      double num16 = (double) WorldGen.genRand.Next(80, 95);
      num2 = num16;
      float num17 = (float) WorldGen.genRand.Next(10, 15);
      vector2_1.X = (float) i;
      vector2_1.Y = (float) num6;
      vector2_2.X = (float) WorldGen.genRand.Next(-20, 21) * 0.2f;
      while ((double) vector2_2.X > -2.0 && (double) vector2_2.X < 2.0)
        vector2_2.X = (float) WorldGen.genRand.Next(-20, 21) * 0.2f;
      vector2_2.Y = (float) WorldGen.genRand.Next(-20, -10) * 0.02f;
      while (num16 > 0.0 && (double) num17 > 0.0)
      {
        num16 -= (double) WorldGen.genRand.Next(4);
        --num17;
        int num8 = (int) ((double) vector2_1.X - num16 * 0.5);
        int num9 = (int) ((double) vector2_1.X + num16 * 0.5);
        int num10 = num6 - 1;
        int num11 = (int) ((double) vector2_1.Y + num16 * 0.5);
        if (num8 < 0)
          num8 = 0;
        if (num9 > Main.maxTilesX)
          num9 = Main.maxTilesX;
        if (num10 < 0)
          num10 = 0;
        if (num11 > Main.maxTilesY)
          num11 = Main.maxTilesY;
        double num12 = num16 * (double) WorldGen.genRand.Next(80, 120) * 0.01;
        float num13 = vector2_1.Y + 1f;
        for (int i1 = num8; i1 < num9; ++i1)
        {
          if (WorldGen.genRand.Next(2) == 0)
            num13 += (float) WorldGen.genRand.Next(-1, 2);
          if ((double) num13 < (double) vector2_1.Y)
            num13 = vector2_1.Y;
          if ((double) num13 > (double) vector2_1.Y + 2.0)
            num13 = vector2_1.Y + 2f;
          for (int j1 = num10; j1 < num11; ++j1)
          {
            if ((double) j1 > (double) num13)
            {
              double num14 = (double) Math.Abs((float) i1 - vector2_1.X);
              float num15 = Math.Abs((float) j1 - vector2_1.Y) * 3f;
              if (Math.Sqrt(num14 * num14 + (double) num15 * (double) num15) < num12 * 0.4 && Main.tile[i1, j1].type == (ushort) 189)
              {
                Main.tile[i1, j1].type = (ushort) 147;
                WorldGen.SquareTileFrame(i1, j1, true);
              }
            }
          }
        }
        vector2_1 += vector2_2;
        vector2_2.X += (float) WorldGen.genRand.Next(-20, 21) * 0.05f;
        if ((double) vector2_2.X > 1.0)
          vector2_2.X = 1f;
        if ((double) vector2_2.X < -1.0)
          vector2_2.X = -1f;
        if ((double) vector2_2.Y > 0.2)
          vector2_2.Y = -0.2f;
        if ((double) vector2_2.Y < -0.2)
          vector2_2.Y = -0.2f;
      }
      int index3 = num4 + WorldGen.genRand.Next(5);
      while (index3 < num5)
      {
        int index1 = num7;
        while ((!Main.tile[index3, index1].active() || Main.tile[index3, index1].type != (ushort) 0) && index3 < num5)
        {
          --index1;
          if (index1 < num6)
          {
            index1 = num7;
            index3 += WorldGen.genRand.Next(1, 4);
          }
        }
        if (index3 < num5)
        {
          int num8 = index1 + WorldGen.genRand.Next(0, 4);
          int minValue2 = WorldGen.genRand.Next(2, 5);
          int num9 = 189;
          for (int i1 = index3 - minValue2; i1 <= index3 + minValue2; ++i1)
          {
            for (int j1 = num8 - minValue2; j1 <= num8 + minValue2; ++j1)
            {
              if (j1 > num6)
              {
                double num10 = (double) Math.Abs(i1 - index3);
                float num11 = (float) (Math.Abs(j1 - num8) * 2);
                if (Math.Sqrt(num10 * num10 + (double) num11 * (double) num11) < (double) minValue2)
                {
                  Main.tile[i1, j1].type = (ushort) num9;
                  WorldGen.SquareTileFrame(i1, j1, true);
                }
              }
            }
          }
          index3 += WorldGen.genRand.Next(minValue2, (int) ((double) minValue2 * 1.5));
        }
      }
      for (int i1 = num4 - 20; i1 <= num5 + 20; ++i1)
      {
        for (int j1 = num6 - 20; j1 <= num7 + 20; ++j1)
        {
          bool flag = true;
          for (int index1 = i1 - 1; index1 <= i1 + 1; ++index1)
          {
            for (int index2 = j1 - 1; index2 <= j1 + 1; ++index2)
            {
              if (!Main.tile[index1, index2].active())
                flag = false;
            }
          }
          if (flag)
          {
            Main.tile[i1, j1].wall = (ushort) 73;
            WorldGen.SquareWallFrame(i1, j1, true);
          }
        }
      }
      for (int index1 = num4; index1 <= num5; ++index1)
      {
        int index2 = num6 - 10;
        while (!Main.tile[index1, index2 + 1].active())
          ++index2;
        if (index2 < num7 && Main.tile[index1, index2 + 1].type == (ushort) 189)
        {
          if (WorldGen.genRand.Next(10) == 0)
          {
            int num8 = WorldGen.genRand.Next(1, 3);
            for (int x = index1 - num8; x <= index1 + num8; ++x)
            {
              if (Main.tile[x, index2].type == (ushort) 189 && WorldGen.WillWaterPlacedHereStayPut(x, index2))
              {
                Main.tile[x, index2].active(false);
                Main.tile[x, index2].liquid = byte.MaxValue;
                Main.tile[x, index2].lava(false);
                WorldGen.SquareTileFrame(index1, index2, true);
              }
              if (Main.tile[x, index2 + 1].type == (ushort) 189 && WorldGen.WillWaterPlacedHereStayPut(x, index2 + 1))
              {
                Main.tile[x, index2 + 1].active(false);
                Main.tile[x, index2 + 1].liquid = byte.MaxValue;
                Main.tile[x, index2 + 1].lava(false);
                WorldGen.SquareTileFrame(index1, index2 + 1, true);
              }
              if (x > index1 - num8 && x < index1 + 2 && (Main.tile[x, index2 + 2].type == (ushort) 189 && WorldGen.WillWaterPlacedHereStayPut(x, index2 + 2)))
              {
                Main.tile[x, index2 + 2].active(false);
                Main.tile[x, index2 + 2].liquid = byte.MaxValue;
                Main.tile[x, index2 + 2].lava(false);
                WorldGen.SquareTileFrame(index1, index2 + 2, true);
              }
            }
          }
          if (WorldGen.genRand.Next(5) == 0 && WorldGen.WillWaterPlacedHereStayPut(index1, index2))
            Main.tile[index1, index2].liquid = byte.MaxValue;
          Main.tile[index1, index2].lava(false);
          WorldGen.SquareTileFrame(index1, index2, true);
        }
      }
      int num18 = WorldGen.genRand.Next(4);
      for (int index1 = 0; index1 <= num18; ++index1)
      {
        int num8 = WorldGen.genRand.Next(num4 - 5, num5 + 5);
        int num9 = num6 - WorldGen.genRand.Next(20, 40);
        int num10 = WorldGen.genRand.Next(4, 8);
        int num11 = 189;
        if (WorldGen.genRand.Next(2) == 0)
          num11 = 460;
        for (int i1 = num8 - num10; i1 <= num8 + num10; ++i1)
        {
          for (int j1 = num9 - num10; j1 <= num9 + num10; ++j1)
          {
            double num12 = (double) Math.Abs(i1 - num8);
            float num13 = (float) (Math.Abs(j1 - num9) * 2);
            if (Math.Sqrt(num12 * num12 + (double) num13 * (double) num13) < (double) (num10 + WorldGen.genRand.Next(-1, 2)))
            {
              Main.tile[i1, j1].active(true);
              Main.tile[i1, j1].type = (ushort) num11;
              WorldGen.SquareTileFrame(i1, j1, true);
            }
          }
        }
        for (int index2 = num8 - num10 + 2; index2 <= num8 + num10 - 2; ++index2)
        {
          int index4 = num9 - num10;
          while (!Main.tile[index2, index4].active())
            ++index4;
          if (WorldGen.WillWaterPlacedHereStayPut(index2, index4))
          {
            Main.tile[index2, index4].active(false);
            Main.tile[index2, index4].liquid = byte.MaxValue;
            WorldGen.SquareTileFrame(index2, index4, true);
          }
        }
      }
    }

    public static void DesertCloudIsland(int i, int j)
    {
      double num1 = (double) WorldGen.genRand.Next(100, 150);
      double num2 = num1;
      float num3 = (float) WorldGen.genRand.Next(20, 30);
      int num4 = i;
      int num5 = i;
      int num6 = i;
      int num7 = j;
      Vector2 vector2_1;
      vector2_1.X = (float) i;
      vector2_1.Y = (float) j;
      Vector2 vector2_2;
      vector2_2.X = (float) WorldGen.genRand.Next(-20, 21) * 0.2f;
      while ((double) vector2_2.X > -2.0 && (double) vector2_2.X < 2.0)
        vector2_2.X = (float) WorldGen.genRand.Next(-20, 21) * 0.2f;
      vector2_2.Y = (float) WorldGen.genRand.Next(-20, -10) * 0.02f;
      while (num1 > 0.0 && (double) num3 > 0.0)
      {
        num1 -= (double) WorldGen.genRand.Next(4);
        --num3;
        int num8 = (int) ((double) vector2_1.X - num1 * 0.5);
        int num9 = (int) ((double) vector2_1.X + num1 * 0.5);
        int num10 = (int) ((double) vector2_1.Y - num1 * 0.5);
        int num11 = (int) ((double) vector2_1.Y + num1 * 0.5);
        if (num8 < 0)
          num8 = 0;
        if (num9 > Main.maxTilesX)
          num9 = Main.maxTilesX;
        if (num10 < 0)
          num10 = 0;
        if (num11 > Main.maxTilesY)
          num11 = Main.maxTilesY;
        double num12 = num1 * (double) WorldGen.genRand.Next(80, 120) * 0.01;
        float num13 = vector2_1.Y + 1f;
        for (int i1 = num8; i1 < num9; ++i1)
        {
          if (WorldGen.genRand.Next(2) == 0)
            num13 += (float) WorldGen.genRand.Next(-1, 2);
          if ((double) num13 < (double) vector2_1.Y)
            num13 = vector2_1.Y;
          if ((double) num13 > (double) vector2_1.Y + 2.0)
            num13 = vector2_1.Y + 2f;
          for (int j1 = num10; j1 < num11; ++j1)
          {
            if ((double) j1 > (double) num13)
            {
              double num14 = (double) Math.Abs((float) i1 - vector2_1.X);
              float num15 = Math.Abs((float) j1 - vector2_1.Y) * 3f;
              if (Math.Sqrt(num14 * num14 + (double) num15 * (double) num15) < num12 * 0.4)
              {
                if (i1 < num4)
                  num4 = i1;
                if (i1 > num5)
                  num5 = i1;
                if (j1 < num6)
                  num6 = j1;
                if (j1 > num7)
                  num7 = j1;
                Main.tile[i1, j1].active(true);
                Main.tile[i1, j1].type = (ushort) 189;
                WorldGen.SquareTileFrame(i1, j1, true);
              }
            }
          }
        }
        vector2_1 += vector2_2;
        vector2_2.X += (float) WorldGen.genRand.Next(-20, 21) * 0.05f;
        if ((double) vector2_2.X > 1.0)
          vector2_2.X = 1f;
        if ((double) vector2_2.X < -1.0)
          vector2_2.X = -1f;
        if ((double) vector2_2.Y > 0.2)
          vector2_2.Y = -0.2f;
        if ((double) vector2_2.Y < -0.2)
          vector2_2.Y = -0.2f;
      }
      int minValue1;
      for (int index1 = num4 + WorldGen.genRand.Next(5); index1 < num5; index1 += WorldGen.genRand.Next(minValue1, (int) ((double) minValue1 * 1.5)))
      {
        int index2 = num7;
        while (!Main.tile[index1, index2].active())
          --index2;
        int num8 = index2 + WorldGen.genRand.Next(-3, 4);
        minValue1 = WorldGen.genRand.Next(4, 8);
        int num9 = 189;
        if (WorldGen.genRand.Next(4) == 0)
          num9 = 196;
        for (int i1 = index1 - minValue1; i1 <= index1 + minValue1; ++i1)
        {
          for (int j1 = num8 - minValue1; j1 <= num8 + minValue1; ++j1)
          {
            if (j1 > num6)
            {
              double num10 = (double) Math.Abs(i1 - index1);
              float num11 = (float) (Math.Abs(j1 - num8) * 2);
              if (Math.Sqrt(num10 * num10 + (double) num11 * (double) num11) < (double) (minValue1 + WorldGen.genRand.Next(2)))
              {
                Main.tile[i1, j1].active(true);
                Main.tile[i1, j1].type = (ushort) num9;
                WorldGen.SquareTileFrame(i1, j1, true);
              }
            }
          }
        }
      }
      double num16 = (double) WorldGen.genRand.Next(80, 95);
      num2 = num16;
      float num17 = (float) WorldGen.genRand.Next(10, 15);
      vector2_1.X = (float) i;
      vector2_1.Y = (float) num6;
      vector2_2.X = (float) WorldGen.genRand.Next(-20, 21) * 0.2f;
      while ((double) vector2_2.X > -2.0 && (double) vector2_2.X < 2.0)
        vector2_2.X = (float) WorldGen.genRand.Next(-20, 21) * 0.2f;
      vector2_2.Y = (float) WorldGen.genRand.Next(-20, -10) * 0.02f;
      while (num16 > 0.0 && (double) num17 > 0.0)
      {
        num16 -= (double) WorldGen.genRand.Next(4);
        --num17;
        int num8 = (int) ((double) vector2_1.X - num16 * 0.5);
        int num9 = (int) ((double) vector2_1.X + num16 * 0.5);
        int num10 = num6 - 1;
        int num11 = (int) ((double) vector2_1.Y + num16 * 0.5);
        if (num8 < 0)
          num8 = 0;
        if (num9 > Main.maxTilesX)
          num9 = Main.maxTilesX;
        if (num10 < 0)
          num10 = 0;
        if (num11 > Main.maxTilesY)
          num11 = Main.maxTilesY;
        double num12 = num16 * (double) WorldGen.genRand.Next(80, 120) * 0.01;
        float num13 = vector2_1.Y + 1f;
        for (int i1 = num8; i1 < num9; ++i1)
        {
          if (WorldGen.genRand.Next(2) == 0)
            num13 += (float) WorldGen.genRand.Next(-1, 2);
          if ((double) num13 < (double) vector2_1.Y)
            num13 = vector2_1.Y;
          if ((double) num13 > (double) vector2_1.Y + 2.0)
            num13 = vector2_1.Y + 2f;
          for (int j1 = num10; j1 < num11; ++j1)
          {
            if ((double) j1 > (double) num13)
            {
              double num14 = (double) Math.Abs((float) i1 - vector2_1.X);
              float num15 = Math.Abs((float) j1 - vector2_1.Y) * 3f;
              if (Math.Sqrt(num14 * num14 + (double) num15 * (double) num15) < num12 * 0.4 && Main.tile[i1, j1].type == (ushort) 189)
              {
                Main.tile[i1, j1].type = (ushort) 53;
                WorldGen.SquareTileFrame(i1, j1, true);
              }
            }
          }
        }
        vector2_1 += vector2_2;
        vector2_2.X += (float) WorldGen.genRand.Next(-20, 21) * 0.05f;
        if ((double) vector2_2.X > 1.0)
          vector2_2.X = 1f;
        if ((double) vector2_2.X < -1.0)
          vector2_2.X = -1f;
        if ((double) vector2_2.Y > 0.2)
          vector2_2.Y = -0.2f;
        if ((double) vector2_2.Y < -0.2)
          vector2_2.Y = -0.2f;
      }
      int index3 = num4 + WorldGen.genRand.Next(5);
      while (index3 < num5)
      {
        int index1 = num7;
        while ((!Main.tile[index3, index1].active() || Main.tile[index3, index1].type != (ushort) 0) && index3 < num5)
        {
          --index1;
          if (index1 < num6)
          {
            index1 = num7;
            index3 += WorldGen.genRand.Next(1, 4);
          }
        }
        if (index3 < num5)
        {
          int num8 = index1 + WorldGen.genRand.Next(0, 4);
          int minValue2 = WorldGen.genRand.Next(2, 5);
          int num9 = 189;
          for (int i1 = index3 - minValue2; i1 <= index3 + minValue2; ++i1)
          {
            for (int j1 = num8 - minValue2; j1 <= num8 + minValue2; ++j1)
            {
              if (j1 > num6)
              {
                double num10 = (double) Math.Abs(i1 - index3);
                float num11 = (float) (Math.Abs(j1 - num8) * 2);
                if (Math.Sqrt(num10 * num10 + (double) num11 * (double) num11) < (double) minValue2)
                {
                  Main.tile[i1, j1].type = (ushort) num9;
                  WorldGen.SquareTileFrame(i1, j1, true);
                }
              }
            }
          }
          index3 += WorldGen.genRand.Next(minValue2, (int) ((double) minValue2 * 1.5));
        }
      }
      for (int i1 = num4 - 20; i1 <= num5 + 20; ++i1)
      {
        for (int j1 = num6 - 20; j1 <= num7 + 20; ++j1)
        {
          bool flag = true;
          for (int index1 = i1 - 1; index1 <= i1 + 1; ++index1)
          {
            for (int index2 = j1 - 1; index2 <= j1 + 1; ++index2)
            {
              if (!Main.tile[index1, index2].active())
                flag = false;
            }
          }
          if (flag)
          {
            Main.tile[i1, j1].wall = (ushort) 73;
            WorldGen.SquareWallFrame(i1, j1, true);
          }
        }
      }
      for (int index1 = num4; index1 <= num5; ++index1)
      {
        int index2 = num6 - 10;
        while (!Main.tile[index1, index2 + 1].active())
          ++index2;
        if (index2 < num7 && Main.tile[index1, index2 + 1].type == (ushort) 189)
        {
          if (WorldGen.genRand.Next(10) == 0)
          {
            int num8 = WorldGen.genRand.Next(1, 3);
            for (int x = index1 - num8; x <= index1 + num8; ++x)
            {
              if (Main.tile[x, index2].type == (ushort) 189 && WorldGen.WillWaterPlacedHereStayPut(x, index2))
              {
                Main.tile[x, index2].active(false);
                Main.tile[x, index2].liquid = byte.MaxValue;
                Main.tile[x, index2].lava(false);
                WorldGen.SquareTileFrame(index1, index2, true);
              }
              if (Main.tile[x, index2 + 1].type == (ushort) 189 && WorldGen.WillWaterPlacedHereStayPut(x, index2 + 1))
              {
                Main.tile[x, index2 + 1].active(false);
                Main.tile[x, index2 + 1].liquid = byte.MaxValue;
                Main.tile[x, index2 + 1].lava(false);
                WorldGen.SquareTileFrame(index1, index2 + 1, true);
              }
              if (x > index1 - num8 && x < index1 + 2 && (Main.tile[x, index2 + 2].type == (ushort) 189 && WorldGen.WillWaterPlacedHereStayPut(x, index2 + 2)))
              {
                Main.tile[x, index2 + 2].active(false);
                Main.tile[x, index2 + 2].liquid = byte.MaxValue;
                Main.tile[x, index2 + 2].lava(false);
                WorldGen.SquareTileFrame(index1, index2 + 2, true);
              }
            }
          }
          if (WorldGen.genRand.Next(5) == 0 && WorldGen.WillWaterPlacedHereStayPut(index1, index2))
            Main.tile[index1, index2].liquid = byte.MaxValue;
          Main.tile[index1, index2].lava(false);
          WorldGen.SquareTileFrame(index1, index2, true);
        }
      }
      int num18 = WorldGen.genRand.Next(4);
      for (int index1 = 0; index1 <= num18; ++index1)
      {
        int num8 = WorldGen.genRand.Next(num4 - 5, num5 + 5);
        int num9 = num6 - WorldGen.genRand.Next(20, 40);
        int num10 = WorldGen.genRand.Next(4, 8);
        int num11 = 189;
        if (WorldGen.genRand.Next(2) == 0)
          num11 = 196;
        for (int i1 = num8 - num10; i1 <= num8 + num10; ++i1)
        {
          for (int j1 = num9 - num10; j1 <= num9 + num10; ++j1)
          {
            double num12 = (double) Math.Abs(i1 - num8);
            float num13 = (float) (Math.Abs(j1 - num9) * 2);
            if (Math.Sqrt(num12 * num12 + (double) num13 * (double) num13) < (double) (num10 + WorldGen.genRand.Next(-1, 2)))
            {
              Main.tile[i1, j1].active(true);
              Main.tile[i1, j1].type = (ushort) num11;
              WorldGen.SquareTileFrame(i1, j1, true);
            }
          }
        }
        for (int index2 = num8 - num10 + 2; index2 <= num8 + num10 - 2; ++index2)
        {
          int index4 = num9 - num10;
          while (!Main.tile[index2, index4].active())
            ++index4;
          if (WorldGen.WillWaterPlacedHereStayPut(index2, index4))
          {
            Main.tile[index2, index4].active(false);
            Main.tile[index2, index4].liquid = byte.MaxValue;
            WorldGen.SquareTileFrame(index2, index4, true);
          }
        }
      }
    }

    public static void CloudIsland(int i, int j)
    {
      double num1 = (double) WorldGen.genRand.Next(100, 150);
      double num2 = num1;
      float num3 = (float) WorldGen.genRand.Next(20, 30);
      int num4 = i;
      int num5 = i;
      int num6 = i;
      int num7 = j;
      Vector2 vector2_1;
      vector2_1.X = (float) i;
      vector2_1.Y = (float) j;
      Vector2 vector2_2;
      vector2_2.X = (float) WorldGen.genRand.Next(-20, 21) * 0.2f;
      while ((double) vector2_2.X > -2.0 && (double) vector2_2.X < 2.0)
        vector2_2.X = (float) WorldGen.genRand.Next(-20, 21) * 0.2f;
      vector2_2.Y = (float) WorldGen.genRand.Next(-20, -10) * 0.02f;
      while (num1 > 0.0 && (double) num3 > 0.0)
      {
        num1 -= (double) WorldGen.genRand.Next(4);
        --num3;
        int num8 = (int) ((double) vector2_1.X - num1 * 0.5);
        int num9 = (int) ((double) vector2_1.X + num1 * 0.5);
        int num10 = (int) ((double) vector2_1.Y - num1 * 0.5);
        int num11 = (int) ((double) vector2_1.Y + num1 * 0.5);
        if (num8 < 0)
          num8 = 0;
        if (num9 > Main.maxTilesX)
          num9 = Main.maxTilesX;
        if (num10 < 0)
          num10 = 0;
        if (num11 > Main.maxTilesY)
          num11 = Main.maxTilesY;
        double num12 = num1 * (double) WorldGen.genRand.Next(80, 120) * 0.01;
        float num13 = vector2_1.Y + 1f;
        for (int i1 = num8; i1 < num9; ++i1)
        {
          if (WorldGen.genRand.Next(2) == 0)
            num13 += (float) WorldGen.genRand.Next(-1, 2);
          if ((double) num13 < (double) vector2_1.Y)
            num13 = vector2_1.Y;
          if ((double) num13 > (double) vector2_1.Y + 2.0)
            num13 = vector2_1.Y + 2f;
          for (int j1 = num10; j1 < num11; ++j1)
          {
            if ((double) j1 > (double) num13)
            {
              double num14 = (double) Math.Abs((float) i1 - vector2_1.X);
              float num15 = Math.Abs((float) j1 - vector2_1.Y) * 3f;
              if (Math.Sqrt(num14 * num14 + (double) num15 * (double) num15) < num12 * 0.4)
              {
                if (i1 < num4)
                  num4 = i1;
                if (i1 > num5)
                  num5 = i1;
                if (j1 < num6)
                  num6 = j1;
                if (j1 > num7)
                  num7 = j1;
                Main.tile[i1, j1].active(true);
                Main.tile[i1, j1].type = (ushort) 189;
                WorldGen.SquareTileFrame(i1, j1, true);
              }
            }
          }
        }
        vector2_1 += vector2_2;
        vector2_2.X += (float) WorldGen.genRand.Next(-20, 21) * 0.05f;
        if ((double) vector2_2.X > 1.0)
          vector2_2.X = 1f;
        if ((double) vector2_2.X < -1.0)
          vector2_2.X = -1f;
        if ((double) vector2_2.Y > 0.2)
          vector2_2.Y = -0.2f;
        if ((double) vector2_2.Y < -0.2)
          vector2_2.Y = -0.2f;
      }
      int minValue1;
      for (int index1 = num4 + WorldGen.genRand.Next(5); index1 < num5; index1 += WorldGen.genRand.Next(minValue1, (int) ((double) minValue1 * 1.5)))
      {
        int index2 = num7;
        while (!Main.tile[index1, index2].active())
          --index2;
        int num8 = index2 + WorldGen.genRand.Next(-3, 4);
        minValue1 = WorldGen.genRand.Next(4, 8);
        int num9 = 189;
        if (WorldGen.genRand.Next(4) == 0)
          num9 = 196;
        for (int i1 = index1 - minValue1; i1 <= index1 + minValue1; ++i1)
        {
          for (int j1 = num8 - minValue1; j1 <= num8 + minValue1; ++j1)
          {
            if (j1 > num6)
            {
              double num10 = (double) Math.Abs(i1 - index1);
              float num11 = (float) (Math.Abs(j1 - num8) * 2);
              if (Math.Sqrt(num10 * num10 + (double) num11 * (double) num11) < (double) (minValue1 + WorldGen.genRand.Next(2)))
              {
                Main.tile[i1, j1].active(true);
                Main.tile[i1, j1].type = (ushort) num9;
                WorldGen.SquareTileFrame(i1, j1, true);
              }
            }
          }
        }
      }
      double num16 = (double) WorldGen.genRand.Next(80, 95);
      num2 = num16;
      float num17 = (float) WorldGen.genRand.Next(10, 15);
      vector2_1.X = (float) i;
      vector2_1.Y = (float) num6;
      vector2_2.X = (float) WorldGen.genRand.Next(-20, 21) * 0.2f;
      while ((double) vector2_2.X > -2.0 && (double) vector2_2.X < 2.0)
        vector2_2.X = (float) WorldGen.genRand.Next(-20, 21) * 0.2f;
      vector2_2.Y = (float) WorldGen.genRand.Next(-20, -10) * 0.02f;
      while (num16 > 0.0 && (double) num17 > 0.0)
      {
        num16 -= (double) WorldGen.genRand.Next(4);
        --num17;
        int num8 = (int) ((double) vector2_1.X - num16 * 0.5);
        int num9 = (int) ((double) vector2_1.X + num16 * 0.5);
        int num10 = num6 - 1;
        int num11 = (int) ((double) vector2_1.Y + num16 * 0.5);
        if (num8 < 0)
          num8 = 0;
        if (num9 > Main.maxTilesX)
          num9 = Main.maxTilesX;
        if (num10 < 0)
          num10 = 0;
        if (num11 > Main.maxTilesY)
          num11 = Main.maxTilesY;
        double num12 = num16 * (double) WorldGen.genRand.Next(80, 120) * 0.01;
        float num13 = vector2_1.Y + 1f;
        for (int i1 = num8; i1 < num9; ++i1)
        {
          if (WorldGen.genRand.Next(2) == 0)
            num13 += (float) WorldGen.genRand.Next(-1, 2);
          if ((double) num13 < (double) vector2_1.Y)
            num13 = vector2_1.Y;
          if ((double) num13 > (double) vector2_1.Y + 2.0)
            num13 = vector2_1.Y + 2f;
          for (int j1 = num10; j1 < num11; ++j1)
          {
            if ((double) j1 > (double) num13)
            {
              double num14 = (double) Math.Abs((float) i1 - vector2_1.X);
              float num15 = Math.Abs((float) j1 - vector2_1.Y) * 3f;
              if (Math.Sqrt(num14 * num14 + (double) num15 * (double) num15) < num12 * 0.4 && Main.tile[i1, j1].type == (ushort) 189)
              {
                Main.tile[i1, j1].type = (ushort) 0;
                WorldGen.SquareTileFrame(i1, j1, true);
              }
            }
          }
        }
        vector2_1 += vector2_2;
        vector2_2.X += (float) WorldGen.genRand.Next(-20, 21) * 0.05f;
        if ((double) vector2_2.X > 1.0)
          vector2_2.X = 1f;
        if ((double) vector2_2.X < -1.0)
          vector2_2.X = -1f;
        if ((double) vector2_2.Y > 0.2)
          vector2_2.Y = -0.2f;
        if ((double) vector2_2.Y < -0.2)
          vector2_2.Y = -0.2f;
      }
      int index3 = num4 + WorldGen.genRand.Next(5);
      while (index3 < num5)
      {
        int index1 = num7;
        while ((!Main.tile[index3, index1].active() || Main.tile[index3, index1].type != (ushort) 0) && index3 < num5)
        {
          --index1;
          if (index1 < num6)
          {
            index1 = num7;
            index3 += WorldGen.genRand.Next(1, 4);
          }
        }
        if (index3 < num5)
        {
          int num8 = index1 + WorldGen.genRand.Next(0, 4);
          int minValue2 = WorldGen.genRand.Next(2, 5);
          int num9 = 189;
          for (int i1 = index3 - minValue2; i1 <= index3 + minValue2; ++i1)
          {
            for (int j1 = num8 - minValue2; j1 <= num8 + minValue2; ++j1)
            {
              if (j1 > num6)
              {
                double num10 = (double) Math.Abs(i1 - index3);
                float num11 = (float) (Math.Abs(j1 - num8) * 2);
                if (Math.Sqrt(num10 * num10 + (double) num11 * (double) num11) < (double) minValue2)
                {
                  Main.tile[i1, j1].type = (ushort) num9;
                  WorldGen.SquareTileFrame(i1, j1, true);
                }
              }
            }
          }
          index3 += WorldGen.genRand.Next(minValue2, (int) ((double) minValue2 * 1.5));
        }
      }
      for (int i1 = num4 - 20; i1 <= num5 + 20; ++i1)
      {
        for (int j1 = num6 - 20; j1 <= num7 + 20; ++j1)
        {
          bool flag = true;
          for (int index1 = i1 - 1; index1 <= i1 + 1; ++index1)
          {
            for (int index2 = j1 - 1; index2 <= j1 + 1; ++index2)
            {
              if (!Main.tile[index1, index2].active())
                flag = false;
            }
          }
          if (flag)
          {
            Main.tile[i1, j1].wall = (ushort) 73;
            WorldGen.SquareWallFrame(i1, j1, true);
          }
        }
      }
      for (int index1 = num4; index1 <= num5; ++index1)
      {
        int index2 = num6 - 10;
        while (!Main.tile[index1, index2 + 1].active())
          ++index2;
        if (index2 < num7 && Main.tile[index1, index2 + 1].type == (ushort) 189)
        {
          if (WorldGen.genRand.Next(10) == 0)
          {
            int num8 = WorldGen.genRand.Next(1, 3);
            for (int x = index1 - num8; x <= index1 + num8; ++x)
            {
              if (Main.tile[x, index2].type == (ushort) 189 && WorldGen.WillWaterPlacedHereStayPut(x, index2))
              {
                Main.tile[x, index2].active(false);
                Main.tile[x, index2].liquid = byte.MaxValue;
                Main.tile[x, index2].lava(false);
                WorldGen.SquareTileFrame(index1, index2, true);
              }
              if (Main.tile[x, index2 + 1].type == (ushort) 189 && WorldGen.WillWaterPlacedHereStayPut(x, index2 + 1))
              {
                Main.tile[x, index2 + 1].active(false);
                Main.tile[x, index2 + 1].liquid = byte.MaxValue;
                Main.tile[x, index2 + 1].lava(false);
                WorldGen.SquareTileFrame(index1, index2 + 1, true);
              }
              if (x > index1 - num8 && x < index1 + 2 && (Main.tile[x, index2 + 2].type == (ushort) 189 && WorldGen.WillWaterPlacedHereStayPut(x, index2 + 2)))
              {
                Main.tile[x, index2 + 2].active(false);
                Main.tile[x, index2 + 2].liquid = byte.MaxValue;
                Main.tile[x, index2 + 2].lava(false);
                WorldGen.SquareTileFrame(index1, index2 + 2, true);
              }
            }
          }
          if (WorldGen.genRand.Next(5) == 0 && WorldGen.WillWaterPlacedHereStayPut(index1, index2))
            Main.tile[index1, index2].liquid = byte.MaxValue;
          Main.tile[index1, index2].lava(false);
          WorldGen.SquareTileFrame(index1, index2, true);
        }
      }
      int num18 = WorldGen.genRand.Next(4);
      for (int index1 = 0; index1 <= num18; ++index1)
      {
        int num8 = WorldGen.genRand.Next(num4 - 5, num5 + 5);
        int num9 = num6 - WorldGen.genRand.Next(20, 40);
        int num10 = WorldGen.genRand.Next(4, 8);
        int num11 = 189;
        if (WorldGen.genRand.Next(2) == 0)
          num11 = 196;
        for (int i1 = num8 - num10; i1 <= num8 + num10; ++i1)
        {
          for (int j1 = num9 - num10; j1 <= num9 + num10; ++j1)
          {
            double num12 = (double) Math.Abs(i1 - num8);
            float num13 = (float) (Math.Abs(j1 - num9) * 2);
            if (Math.Sqrt(num12 * num12 + (double) num13 * (double) num13) < (double) (num10 + WorldGen.genRand.Next(-1, 2)))
            {
              Main.tile[i1, j1].active(true);
              Main.tile[i1, j1].type = (ushort) num11;
              WorldGen.SquareTileFrame(i1, j1, true);
            }
          }
        }
        for (int index2 = num8 - num10 + 2; index2 <= num8 + num10 - 2; ++index2)
        {
          int index4 = num9 - num10;
          while (!Main.tile[index2, index4].active())
            ++index4;
          if (WorldGen.WillWaterPlacedHereStayPut(index2, index4))
          {
            Main.tile[index2, index4].active(false);
            Main.tile[index2, index4].liquid = byte.MaxValue;
            WorldGen.SquareTileFrame(index2, index4, true);
          }
        }
      }
    }

    public static bool WillWaterPlacedHereStayPut(int x, int y)
    {
      return (Main.tile[x, y + 1].active() && Main.tileSolid[(int) Main.tile[x, y + 1].type] && !Main.tileSolidTop[(int) Main.tile[x, y + 1].type] || Main.tile[x, y + 1].liquid == byte.MaxValue) && (Main.tile[x - 1, y].active() && Main.tileSolid[(int) Main.tile[x - 1, y].type] && !Main.tileSolidTop[(int) Main.tile[x - 1, y].type] || Main.tile[x - 1, y].liquid == byte.MaxValue) && (Main.tile[x + 1, y].active() && Main.tileSolid[(int) Main.tile[x + 1, y].type] && !Main.tileSolidTop[(int) Main.tile[x + 1, y].type] || Main.tile[x + 1, y].liquid == byte.MaxValue);
    }

    public static void CloudLake(int i, int j)
    {
      double num1 = (double) WorldGen.genRand.Next(100, 150);
      double num2 = num1;
      float num3 = (float) WorldGen.genRand.Next(20, 30);
      int num4 = i;
      int num5 = i;
      int num6 = i;
      int num7 = j;
      Vector2 vector2_1;
      vector2_1.X = (float) i;
      vector2_1.Y = (float) j;
      Vector2 vector2_2;
      vector2_2.X = (float) WorldGen.genRand.Next(-20, 21) * 0.2f;
      while ((double) vector2_2.X > -2.0 && (double) vector2_2.X < 2.0)
        vector2_2.X = (float) WorldGen.genRand.Next(-20, 21) * 0.2f;
      vector2_2.Y = (float) WorldGen.genRand.Next(-20, -10) * 0.02f;
      while (num1 > 0.0 && (double) num3 > 0.0)
      {
        num1 -= (double) WorldGen.genRand.Next(4);
        --num3;
        int num8 = (int) ((double) vector2_1.X - num1 * 0.5);
        int num9 = (int) ((double) vector2_1.X + num1 * 0.5);
        int num10 = (int) ((double) vector2_1.Y - num1 * 0.5);
        int num11 = (int) ((double) vector2_1.Y + num1 * 0.5);
        if (num8 < 0)
          num8 = 0;
        if (num9 > Main.maxTilesX)
          num9 = Main.maxTilesX;
        if (num10 < 0)
          num10 = 0;
        if (num11 > Main.maxTilesY)
          num11 = Main.maxTilesY;
        double num12 = num1 * (double) WorldGen.genRand.Next(80, 120) * 0.01;
        float num13 = vector2_1.Y + 1f;
        for (int i1 = num8; i1 < num9; ++i1)
        {
          if (WorldGen.genRand.Next(2) == 0)
            num13 += (float) WorldGen.genRand.Next(-1, 2);
          if ((double) num13 < (double) vector2_1.Y)
            num13 = vector2_1.Y;
          if ((double) num13 > (double) vector2_1.Y + 2.0)
            num13 = vector2_1.Y + 2f;
          for (int j1 = num10; j1 < num11; ++j1)
          {
            if ((double) j1 > (double) num13)
            {
              double num14 = (double) Math.Abs((float) i1 - vector2_1.X);
              float num15 = Math.Abs((float) j1 - vector2_1.Y) * 3f;
              if (Math.Sqrt(num14 * num14 + (double) num15 * (double) num15) < num12 * 0.4)
              {
                if (i1 < num4)
                  num4 = i1;
                if (i1 > num5)
                  num5 = i1;
                if (j1 < num6)
                  num6 = j1;
                if (j1 > num7)
                  num7 = j1;
                Main.tile[i1, j1].active(true);
                Main.tile[i1, j1].type = (ushort) 189;
                WorldGen.SquareTileFrame(i1, j1, true);
              }
            }
          }
        }
        vector2_1 += vector2_2;
        vector2_2.X += (float) WorldGen.genRand.Next(-20, 21) * 0.05f;
        if ((double) vector2_2.X > 1.0)
          vector2_2.X = 1f;
        if ((double) vector2_2.X < -1.0)
          vector2_2.X = -1f;
        if ((double) vector2_2.Y > 0.2)
          vector2_2.Y = -0.2f;
        if ((double) vector2_2.Y < -0.2)
          vector2_2.Y = -0.2f;
      }
      int minValue;
      for (int index1 = num4 + WorldGen.genRand.Next(5); index1 < num5; index1 += WorldGen.genRand.Next(minValue, (int) ((double) minValue * 1.5)))
      {
        int index2 = num7;
        while (!Main.tile[index1, index2].active())
          --index2;
        int num8 = index2 + WorldGen.genRand.Next(-3, 4);
        minValue = WorldGen.genRand.Next(4, 8);
        int num9 = 189;
        if (WorldGen.genRand.Next(4) == 0)
          num9 = 196;
        for (int i1 = index1 - minValue; i1 <= index1 + minValue; ++i1)
        {
          for (int j1 = num8 - minValue; j1 <= num8 + minValue; ++j1)
          {
            if (j1 > num6)
            {
              double num10 = (double) Math.Abs(i1 - index1);
              float num11 = (float) (Math.Abs(j1 - num8) * 2);
              if (Math.Sqrt(num10 * num10 + (double) num11 * (double) num11) < (double) (minValue + WorldGen.genRand.Next(2)))
              {
                Main.tile[i1, j1].active(true);
                Main.tile[i1, j1].type = (ushort) num9;
                WorldGen.SquareTileFrame(i1, j1, true);
              }
            }
          }
        }
      }
      double num16 = (double) WorldGen.genRand.Next(80, 95);
      num2 = num16;
      float num17 = (float) WorldGen.genRand.Next(10, 15);
      vector2_1.X = (float) i;
      vector2_1.Y = (float) num6;
      vector2_2.X = (float) WorldGen.genRand.Next(-20, 21) * 0.2f;
      while ((double) vector2_2.X > -2.0 && (double) vector2_2.X < 2.0)
        vector2_2.X = (float) WorldGen.genRand.Next(-20, 21) * 0.2f;
      vector2_2.Y = (float) WorldGen.genRand.Next(-20, -10) * 0.02f;
      while (num16 > 0.0 && (double) num17 > 0.0)
      {
        num16 -= (double) WorldGen.genRand.Next(4);
        --num17;
        int num8 = (int) ((double) vector2_1.X - num16 * 0.5);
        int num9 = (int) ((double) vector2_1.X + num16 * 0.5);
        int num10 = num6 - 1;
        int num11 = (int) ((double) vector2_1.Y + num16 * 0.5);
        if (num8 < 0)
          num8 = 0;
        if (num9 > Main.maxTilesX)
          num9 = Main.maxTilesX;
        if (num10 < 0)
          num10 = 0;
        if (num11 > Main.maxTilesY)
          num11 = Main.maxTilesY;
        double num12 = num16 * (double) WorldGen.genRand.Next(80, 120) * 0.01;
        float num13 = vector2_1.Y + 1f;
        for (int x = num8; x < num9; ++x)
        {
          if (WorldGen.genRand.Next(2) == 0)
            num13 += (float) WorldGen.genRand.Next(-1, 2);
          if ((double) num13 < (double) vector2_1.Y)
            num13 = vector2_1.Y;
          if ((double) num13 > (double) vector2_1.Y + 2.0)
            num13 = vector2_1.Y + 2f;
          for (int y = num10; y < num11; ++y)
          {
            if ((double) y > (double) num13 - 2.0)
            {
              double num14 = (double) Math.Abs((float) x - vector2_1.X);
              float num15 = Math.Abs((float) y - vector2_1.Y) * 3f;
              if (Math.Sqrt(num14 * num14 + (double) num15 * (double) num15) < num12 * 0.4 && Main.tile[x, y].type == (ushort) 189)
              {
                Main.tile[x, y].active(false);
                if ((double) y > (double) num13 + 1.0)
                {
                  if (WorldGen.WillWaterPlacedHereStayPut(x, y))
                    Main.tile[x, y].liquid = byte.MaxValue;
                  Main.tile[x, y].honey(false);
                  Main.tile[x, y].lava(false);
                }
              }
            }
          }
        }
        vector2_1 += vector2_2;
        vector2_2.X += (float) WorldGen.genRand.Next(-20, 21) * 0.05f;
        if ((double) vector2_2.X > 1.0)
          vector2_2.X = 1f;
        if ((double) vector2_2.X < -1.0)
          vector2_2.X = -1f;
        if ((double) vector2_2.Y > 0.2)
          vector2_2.Y = -0.2f;
        if ((double) vector2_2.Y < 0.0)
          vector2_2.Y = 0.0f;
      }
      for (int index1 = num4 - 20; index1 <= num5 + 20; ++index1)
      {
        for (int index2 = num6 - 20; index2 <= num7 + 20; ++index2)
        {
          bool flag = true;
          for (int index3 = index1 - 1; index3 <= index1 + 1; ++index3)
          {
            for (int index4 = index2 - 1; index4 <= index2 + 1; ++index4)
            {
              if (!Main.tile[index3, index4].active())
                flag = false;
            }
          }
          if (flag)
            Main.tile[index1, index2].wall = (ushort) 73;
        }
      }
      for (int index1 = num4; index1 <= num5; ++index1)
      {
        int index2 = num6 - 10;
        while (!Main.tile[index1, index2 + 1].active())
          ++index2;
        if (index2 < num7 && Main.tile[index1, index2 + 1].type == (ushort) 189)
        {
          if (WorldGen.genRand.Next(10) == 0)
          {
            int num8 = WorldGen.genRand.Next(1, 3);
            for (int x = index1 - num8; x <= index1 + num8; ++x)
            {
              if (Main.tile[x, index2].type == (ushort) 189 && WorldGen.WillWaterPlacedHereStayPut(x, index2))
              {
                Main.tile[x, index2].active(false);
                Main.tile[x, index2].liquid = byte.MaxValue;
                Main.tile[x, index2].lava(false);
                WorldGen.SquareTileFrame(index1, index2, true);
              }
              if (Main.tile[x, index2 + 1].type == (ushort) 189 && WorldGen.WillWaterPlacedHereStayPut(x, index2 + 1))
              {
                Main.tile[x, index2 + 1].active(false);
                Main.tile[x, index2 + 1].liquid = byte.MaxValue;
                Main.tile[x, index2 + 1].lava(false);
                WorldGen.SquareTileFrame(index1, index2 + 1, true);
              }
              if (x > index1 - num8 && x < index1 + 2 && (Main.tile[x, index2 + 2].type == (ushort) 189 && WorldGen.WillWaterPlacedHereStayPut(x, index2 + 2)))
              {
                Main.tile[x, index2 + 2].active(false);
                Main.tile[x, index2 + 2].liquid = byte.MaxValue;
                Main.tile[x, index2 + 2].lava(false);
                WorldGen.SquareTileFrame(index1, index2 + 2, true);
              }
            }
          }
          if (WorldGen.genRand.Next(5) == 0 && WorldGen.WillWaterPlacedHereStayPut(index1, index2))
            Main.tile[index1, index2].liquid = byte.MaxValue;
          Main.tile[index1, index2].lava(false);
          WorldGen.SquareTileFrame(index1, index2, true);
        }
      }
      int num18 = WorldGen.genRand.Next(1, 4);
      for (int index1 = 0; index1 <= num18; ++index1)
      {
        int num8 = WorldGen.genRand.Next(num4 - 5, num5 + 5);
        int num9 = num6 - WorldGen.genRand.Next(20, 40);
        int num10 = WorldGen.genRand.Next(4, 8);
        int num11 = 189;
        if (WorldGen.genRand.Next(4) != 0)
          num11 = 196;
        for (int i1 = num8 - num10; i1 <= num8 + num10; ++i1)
        {
          for (int j1 = num9 - num10; j1 <= num9 + num10; ++j1)
          {
            double num12 = (double) Math.Abs(i1 - num8);
            float num13 = (float) (Math.Abs(j1 - num9) * 2);
            if (Math.Sqrt(num12 * num12 + (double) num13 * (double) num13) < (double) (num10 + WorldGen.genRand.Next(-1, 2)))
            {
              Main.tile[i1, j1].active(true);
              Main.tile[i1, j1].type = (ushort) num11;
              WorldGen.SquareTileFrame(i1, j1, true);
            }
          }
        }
        for (int index2 = num8 - num10 + 2; index2 <= num8 + num10 - 2; ++index2)
        {
          int index3 = num9 - num10;
          while (!Main.tile[index2, index3].active())
            ++index3;
          if (WorldGen.WillWaterPlacedHereStayPut(index2, index3))
          {
            Main.tile[index2, index3].active(false);
            Main.tile[index2, index3].liquid = byte.MaxValue;
            WorldGen.SquareTileFrame(index2, index3, true);
          }
        }
      }
    }

    public static void FloatingIsland(int i, int j)
    {
      double num1 = (double) WorldGen.genRand.Next(80, 120);
      float num2 = (float) WorldGen.genRand.Next(20, 25);
      Vector2 vector2_1;
      vector2_1.X = (float) i;
      vector2_1.Y = (float) j;
      Vector2 vector2_2;
      vector2_2.X = (float) WorldGen.genRand.Next(-20, 21) * 0.2f;
      while ((double) vector2_2.X > -2.0 && (double) vector2_2.X < 2.0)
        vector2_2.X = (float) WorldGen.genRand.Next(-20, 21) * 0.2f;
      vector2_2.Y = (float) WorldGen.genRand.Next(-20, -10) * 0.02f;
      while (num1 > 0.0 && (double) num2 > 0.0)
      {
        num1 -= (double) WorldGen.genRand.Next(4);
        --num2;
        int num3 = (int) ((double) vector2_1.X - num1 * 0.5);
        int num4 = (int) ((double) vector2_1.X + num1 * 0.5);
        int num5 = (int) ((double) vector2_1.Y - num1 * 0.5);
        int num6 = (int) ((double) vector2_1.Y + num1 * 0.5);
        if (num3 < 0)
          num3 = 0;
        if (num4 > Main.maxTilesX)
          num4 = Main.maxTilesX;
        if (num5 < 0)
          num5 = 0;
        if (num6 > Main.maxTilesY)
          num6 = Main.maxTilesY;
        double num7 = num1 * (double) WorldGen.genRand.Next(80, 120) * 0.01;
        float num8 = vector2_1.Y + 1f;
        for (int index1 = num3; index1 < num4; ++index1)
        {
          if (WorldGen.genRand.Next(2) == 0)
            num8 += (float) WorldGen.genRand.Next(-1, 2);
          if ((double) num8 < (double) vector2_1.Y)
            num8 = vector2_1.Y;
          if ((double) num8 > (double) vector2_1.Y + 2.0)
            num8 = vector2_1.Y + 2f;
          for (int index2 = num5; index2 < num6; ++index2)
          {
            if ((double) index2 > (double) num8)
            {
              double num9 = (double) Math.Abs((float) index1 - vector2_1.X);
              float num10 = Math.Abs((float) index2 - vector2_1.Y) * 2f;
              if (Math.Sqrt(num9 * num9 + (double) num10 * (double) num10) < num7 * 0.4)
              {
                Main.tile[index1, index2].active(true);
                if (Main.tile[index1, index2].type == (ushort) 59)
                  Main.tile[index1, index2].type = (ushort) 0;
              }
            }
          }
        }
        int num11 = (int) ((double) vector2_1.X - num1 * 0.4);
        int num12 = (int) ((double) vector2_1.X + num1 * 0.4);
        int num13 = (int) ((double) vector2_1.Y - num1 * 0.4);
        int num14 = (int) ((double) vector2_1.Y + num1 * 0.4);
        if (num11 < 0)
          num11 = 0;
        if (num12 > Main.maxTilesX)
          num12 = Main.maxTilesX;
        if (num13 < 0)
          num13 = 0;
        if (num14 > Main.maxTilesY)
          num14 = Main.maxTilesY;
        double num15 = num1 * (double) WorldGen.genRand.Next(80, 120) * 0.01;
        for (int index1 = num11; index1 < num12; ++index1)
        {
          for (int index2 = num13; index2 < num14; ++index2)
          {
            if ((double) index2 > (double) vector2_1.Y + 2.0)
            {
              double num9 = (double) Math.Abs((float) index1 - vector2_1.X);
              float num10 = Math.Abs((float) index2 - vector2_1.Y) * 2f;
              if (Math.Sqrt(num9 * num9 + (double) num10 * (double) num10) < num15 * 0.4)
                Main.tile[index1, index2].wall = (ushort) 2;
            }
          }
        }
        vector2_1 += vector2_2;
        vector2_2.Y += (float) WorldGen.genRand.Next(-10, 11) * 0.05f;
        if ((double) vector2_2.X > 1.0)
          vector2_2.X = 1f;
        if ((double) vector2_2.X < -1.0)
          vector2_2.X = -1f;
        if ((double) vector2_2.Y > 0.2)
          vector2_2.Y = -0.2f;
        if ((double) vector2_2.Y < -0.2)
          vector2_2.Y = -0.2f;
      }
    }

    public static void Caverer(int X, int Y)
    {
      switch (WorldGen.genRand.Next(2))
      {
        case 0:
          int num1 = WorldGen.genRand.Next(7, 9);
          float xDir1 = (float) WorldGen.genRand.Next(100) * 0.01f;
          float yDir1 = 1f - xDir1;
          if (WorldGen.genRand.Next(2) == 0)
            xDir1 = -xDir1;
          if (WorldGen.genRand.Next(2) == 0)
            yDir1 = -yDir1;
          Vector2 vector2_1 = new Vector2((float) X, (float) Y);
          for (int index = 0; index < num1; ++index)
          {
            vector2_1 = WorldGen.digTunnel(vector2_1.X, vector2_1.Y, xDir1, yDir1, WorldGen.genRand.Next(6, 20), WorldGen.genRand.Next(4, 9), false);
            xDir1 += (float) WorldGen.genRand.Next(-20, 21) * 0.1f;
            yDir1 += (float) WorldGen.genRand.Next(-20, 21) * 0.1f;
            if ((double) xDir1 < -1.5)
              xDir1 = -1.5f;
            if ((double) xDir1 > 1.5)
              xDir1 = 1.5f;
            if ((double) yDir1 < -1.5)
              yDir1 = -1.5f;
            if ((double) yDir1 > 1.5)
              yDir1 = 1.5f;
            float xDir2 = (float) WorldGen.genRand.Next(100) * 0.01f;
            float yDir2 = 1f - xDir2;
            if (WorldGen.genRand.Next(2) == 0)
              xDir2 = -xDir2;
            if (WorldGen.genRand.Next(2) == 0)
              yDir2 = -yDir2;
            Vector2 vector2_2 = WorldGen.digTunnel(vector2_1.X, vector2_1.Y, xDir2, yDir2, WorldGen.genRand.Next(30, 50), WorldGen.genRand.Next(3, 6), false);
            WorldGen.TileRunner((int) vector2_2.X, (int) vector2_2.Y, (double) WorldGen.genRand.Next(10, 20), WorldGen.genRand.Next(5, 10), -1, false, 0.0f, 0.0f, false, true, -1);
          }
          break;
        case 1:
          int num2 = WorldGen.genRand.Next(15, 30);
          float xDir3 = (float) WorldGen.genRand.Next(100) * 0.01f;
          float yDir3 = 1f - xDir3;
          if (WorldGen.genRand.Next(2) == 0)
            xDir3 = -xDir3;
          if (WorldGen.genRand.Next(2) == 0)
            yDir3 = -yDir3;
          Vector2 vector2_3 = new Vector2((float) X, (float) Y);
          for (int index = 0; index < num2; ++index)
          {
            vector2_3 = WorldGen.digTunnel(vector2_3.X, vector2_3.Y, xDir3, yDir3, WorldGen.genRand.Next(5, 15), WorldGen.genRand.Next(2, 6), true);
            xDir3 += (float) WorldGen.genRand.Next(-20, 21) * 0.1f;
            yDir3 += (float) WorldGen.genRand.Next(-20, 21) * 0.1f;
            if ((double) xDir3 < -1.5)
              xDir3 = -1.5f;
            if ((double) xDir3 > 1.5)
              xDir3 = 1.5f;
            if ((double) yDir3 < -1.5)
              yDir3 = -1.5f;
            if ((double) yDir3 > 1.5)
              yDir3 = 1.5f;
          }
          break;
      }
    }

    public static Vector2 digTunnel(
      float X,
      float Y,
      float xDir,
      float yDir,
      int Steps,
      int Size,
      bool Wet = false)
    {
      float x = X;
      float y = Y;
      try
      {
        float num1 = 0.0f;
        float num2 = 0.0f;
        int num3 = Steps;
        float num4 = (float) Size;
        x = MathHelper.Clamp(x, num4 + 1f, (float) ((double) Main.maxTilesX - (double) num4 - 1.0));
        y = MathHelper.Clamp(y, num4 + 1f, (float) ((double) Main.maxTilesY - (double) num4 - 1.0));
        for (int index1 = 0; index1 < num3; ++index1)
        {
          for (int index2 = (int) ((double) x - (double) num4); (double) index2 <= (double) x + (double) num4; ++index2)
          {
            for (int index3 = (int) ((double) y - (double) num4); (double) index3 <= (double) y + (double) num4; ++index3)
            {
              if ((double) Math.Abs((float) index2 - x) + (double) Math.Abs((float) index3 - y) < (double) num4 * (1.0 + (double) WorldGen.genRand.Next(-10, 11) * 0.005) && index2 >= 0 && (index2 < Main.maxTilesX && index3 >= 0) && index3 < Main.maxTilesY)
              {
                Main.tile[index2, index3].active(false);
                if (Wet)
                  Main.tile[index2, index3].liquid = byte.MaxValue;
              }
            }
          }
          num4 += (float) WorldGen.genRand.Next(-50, 51) * 0.03f;
          if ((double) num4 < (double) Size * 0.6)
            num4 = (float) Size * 0.6f;
          if ((double) num4 > (double) (Size * 2))
            num4 = (float) Size * 2f;
          num1 += (float) WorldGen.genRand.Next(-20, 21) * 0.01f;
          num2 += (float) WorldGen.genRand.Next(-20, 21) * 0.01f;
          if ((double) num1 < -1.0)
            num1 = -1f;
          if ((double) num1 > 1.0)
            num1 = 1f;
          if ((double) num2 < -1.0)
            num2 = -1f;
          if ((double) num2 > 1.0)
            num2 = 1f;
          x += (float) (((double) xDir + (double) num1) * 0.600000023841858);
          y += (float) (((double) yDir + (double) num2) * 0.600000023841858);
        }
      }
      catch
      {
      }
      return new Vector2(x, y);
    }

    public static void IslandHouse(int i, int j, int islandStyle)
    {
      byte num1 = 202;
      byte num2 = 82;
      Vector2 vector2 = new Vector2((float) i, (float) j);
      int num3 = 1;
      if (WorldGen.genRand.Next(2) == 0)
        num3 = -1;
      int num4 = WorldGen.genRand.Next(7, 12);
      int num5 = WorldGen.genRand.Next(5, 7);
      vector2.X = (float) (i + (num4 + 2) * num3);
      for (int index = j - 15; index < j + 30; ++index)
      {
        if (Main.tile[(int) vector2.X, index].active())
        {
          vector2.Y = (float) (index - 1);
          break;
        }
      }
      vector2.X = (float) i;
      int num6 = (int) ((double) vector2.X - (double) num4 - 1.0);
      int num7 = (int) ((double) vector2.X + (double) num4 + 1.0);
      int num8 = (int) ((double) vector2.Y - (double) num5 - 1.0);
      int num9 = (int) ((double) vector2.Y + 2.0);
      if (num6 < 0)
        num6 = 0;
      if (num7 > Main.maxTilesX)
        num7 = Main.maxTilesX;
      if (num8 < 0)
        num8 = 0;
      if (num9 > Main.maxTilesY)
        num9 = Main.maxTilesY;
      for (int index1 = num6; index1 <= num7; ++index1)
      {
        for (int index2 = num8 - 1; index2 < num9 + 1; ++index2)
        {
          if (index2 != num8 - 1 || index1 != num6 && index1 != num7)
          {
            Main.tile[index1, index2].active(true);
            Main.tile[index1, index2].liquid = (byte) 0;
            Main.tile[index1, index2].type = (ushort) num1;
            Main.tile[index1, index2].wall = (ushort) 0;
            Main.tile[index1, index2].halfBrick(false);
            Main.tile[index1, index2].slope((byte) 0);
          }
        }
      }
      int num10 = (int) ((double) vector2.X - (double) num4);
      int num11 = (int) ((double) vector2.X + (double) num4);
      int j1 = (int) ((double) vector2.Y - (double) num5);
      int num12 = (int) ((double) vector2.Y + 1.0);
      if (num10 < 0)
        num10 = 0;
      if (num11 > Main.maxTilesX)
        num11 = Main.maxTilesX;
      if (j1 < 0)
        j1 = 0;
      if (num12 > Main.maxTilesY)
        num12 = Main.maxTilesY;
      for (int index1 = num10; index1 <= num11; ++index1)
      {
        for (int index2 = j1; index2 < num12; ++index2)
        {
          if ((index2 != j1 || index1 != num10 && index1 != num11) && Main.tile[index1, index2].wall == (ushort) 0)
          {
            Main.tile[index1, index2].active(false);
            Main.tile[index1, index2].wall = (ushort) num2;
          }
        }
      }
      int i1 = i + (num4 + 1) * num3;
      int y = (int) vector2.Y;
      for (int index = i1 - 2; index <= i1 + 2; ++index)
      {
        Main.tile[index, y].active(false);
        Main.tile[index, y - 1].active(false);
        Main.tile[index, y - 2].active(false);
      }
      WorldGen.PlaceTile(i1, y, 10, true, false, -1, 9);
      int index3 = i + (num4 + 1) * -num3 - num3;
      for (int index1 = j1; index1 <= num12 + 1; ++index1)
      {
        Main.tile[index3, index1].active(true);
        Main.tile[index3, index1].liquid = (byte) 0;
        Main.tile[index3, index1].type = (ushort) num1;
        Main.tile[index3, index1].wall = (ushort) 0;
        Main.tile[index3, index1].halfBrick(false);
        Main.tile[index3, index1].slope((byte) 0);
      }
      int contain = 0;
      int num13 = WorldGen.houseCount;
      if (num13 > 2)
        num13 = WorldGen.genRand.Next(3);
      switch (num13)
      {
        case 0:
          contain = 159;
          break;
        case 1:
          contain = 65;
          break;
        case 2:
          contain = 158;
          break;
      }
      if (WorldGen.getGoodWorldGen)
        WorldGen.AddBuriedChest(i, y - 3, contain, false, 2, false, (ushort) 0);
      else
        WorldGen.AddBuriedChest(i, y - 3, contain, false, 13, false, (ushort) 0);
      if (islandStyle > 0)
      {
        for (int index1 = 0; index1 < 100000; ++index1)
        {
          int index2 = i + WorldGen.genRand.Next(-50, 51);
          int index4 = y + WorldGen.genRand.Next(21);
          if ((index1 >= 50000 || Main.tile[index2, index4].type != (ushort) 202) && !Main.tile[index2, index4].active())
          {
            WorldGen.Place2xX(index2, index4, (ushort) 207, islandStyle);
            if (Main.tile[index2, index4].active())
            {
              WorldGen.SwitchFountain(index2, index4);
              break;
            }
          }
        }
      }
      ++WorldGen.houseCount;
      int num14 = i - num4 / 2 + 1;
      int num15 = i + num4 / 2 - 1;
      int num16 = 1;
      if (num4 > 10)
        num16 = 2;
      int num17 = (j1 + num12) / 2 - 1;
      for (int index1 = num14 - num16; index1 <= num14 + num16; ++index1)
      {
        for (int index2 = num17 - 1; index2 <= num17 + 1; ++index2)
          Main.tile[index1, index2].wall = (ushort) 21;
      }
      for (int index1 = num15 - num16; index1 <= num15 + num16; ++index1)
      {
        for (int index2 = num17 - 1; index2 <= num17 + 1; ++index2)
          Main.tile[index1, index2].wall = (ushort) 21;
      }
      int i2 = i + (num4 / 2 + 1) * -num3;
      WorldGen.PlaceTile(i2, num12 - 1, 14, true, false, -1, 7);
      WorldGen.PlaceTile(i2 - 2, num12 - 1, 15, true, false, 0, 10);
      Main.tile[i2 - 2, num12 - 1].frameX += (short) 18;
      Main.tile[i2 - 2, num12 - 2].frameX += (short) 18;
      WorldGen.PlaceTile(i2 + 2, num12 - 1, 15, true, false, 0, 10);
      WorldGen.PlaceTile(num10 + 1, j1, 91, true, false, -1, WorldGen.genRand.Next(7, 10));
      WorldGen.PlaceTile(num11 - 1, j1, 91, true, false, -1, WorldGen.genRand.Next(7, 10));
      int i3;
      int j2;
      if (num3 > 0)
      {
        i3 = num10;
        j2 = j1 + 1;
      }
      else
      {
        i3 = num11;
        j2 = j1 + 1;
      }
      WorldGen.PlaceTile(i3, j2, 91, true, false, -1, WorldGen.genRand.Next(7, 10));
      if (islandStyle != 1)
        return;
      int num18 = WorldGen.genRand.Next(3, 6);
      for (int index1 = 0; index1 < 100000; ++index1)
      {
        int i4 = i + WorldGen.genRand.Next(-50, 51);
        int index2 = y + WorldGen.genRand.Next(-10, 21);
        if (!Main.tile[i4, index2].active())
        {
          WorldGen.GrowPalmTree(i4, index2 + 1);
          if (Main.tile[i4, index2].active())
            --num18;
        }
        if (num18 <= 0)
          break;
      }
    }

    public static void Mountinater(int i, int j)
    {
      double num1 = (double) WorldGen.genRand.Next(80, 120);
      float num2 = (float) WorldGen.genRand.Next(40, 55);
      Vector2 vector2_1;
      vector2_1.X = (float) i;
      vector2_1.Y = (float) j + num2 / 2f;
      Vector2 vector2_2;
      vector2_2.X = (float) WorldGen.genRand.Next(-10, 11) * 0.1f;
      vector2_2.Y = (float) WorldGen.genRand.Next(-20, -10) * 0.1f;
      while (num1 > 0.0 && (double) num2 > 0.0)
      {
        num1 -= (double) WorldGen.genRand.Next(4);
        --num2;
        int num3 = (int) ((double) vector2_1.X - num1 * 0.5);
        int num4 = (int) ((double) vector2_1.X + num1 * 0.5);
        int num5 = (int) ((double) vector2_1.Y - num1 * 0.5);
        int num6 = (int) ((double) vector2_1.Y + num1 * 0.5);
        if (num3 < 0)
          num3 = 0;
        if (num4 > Main.maxTilesX)
          num4 = Main.maxTilesX;
        if (num5 < 0)
          num5 = 0;
        if (num6 > Main.maxTilesY)
          num6 = Main.maxTilesY;
        double num7 = num1 * (double) WorldGen.genRand.Next(80, 120) * 0.01;
        for (int index1 = num3; index1 < num4; ++index1)
        {
          for (int index2 = num5; index2 < num6; ++index2)
          {
            double num8 = (double) Math.Abs((float) index1 - vector2_1.X);
            float num9 = Math.Abs((float) index2 - vector2_1.Y);
            if (Math.Sqrt(num8 * num8 + (double) num9 * (double) num9) < num7 * 0.4 && !Main.tile[index1, index2].active())
            {
              Main.tile[index1, index2].active(true);
              Main.tile[index1, index2].type = (ushort) 0;
            }
          }
        }
        vector2_1 += vector2_2;
        vector2_2.X += (float) WorldGen.genRand.Next(-10, 11) * 0.05f;
        vector2_2.Y += (float) WorldGen.genRand.Next(-10, 11) * 0.05f;
        if ((double) vector2_2.X > 0.5)
          vector2_2.X = 0.5f;
        if ((double) vector2_2.X < -0.5)
          vector2_2.X = -0.5f;
        if ((double) vector2_2.Y > -0.5)
          vector2_2.Y = -0.5f;
        if ((double) vector2_2.Y < -1.5)
          vector2_2.Y = -1.5f;
      }
    }

    public static void MakeWateryIceThing(int i, int j)
    {
      if (Main.tile[i, j].liquid <= (byte) 0 || Main.tile[i, j].active() || Main.tile[i, j].lava())
        return;
      int index1 = j;
      while (!Main.tile[i, index1].active() && Main.tile[i, index1].liquid > (byte) 0)
      {
        ++index1;
        if (index1 > Main.maxTilesY - 50)
          return;
      }
      if (Main.tile[i, index1].type != (ushort) 147 && Main.tile[i, index1].type != (ushort) 161)
        return;
      int index2 = index1 - 1;
      while (Main.tile[i, index2].liquid > (byte) 0)
      {
        --index2;
        if (index2 < 10)
          return;
      }
      if (Main.tile[i, index2].active())
        return;
      int j1 = index2 + 1;
      if (Main.tile[i, j1].active())
        return;
      for (int i1 = i; !Main.tile[i1, j1].active() && Main.tile[i1, j1].liquid > (byte) 0 && (Main.tile[i1, j1 - 1].liquid == (byte) 0 && !Main.tile[i1, j1 - 1].active()) && !Main.tile[i1 - 1, j1].halfBrick(); --i1)
        WorldGen.PlaceTile(i1, j1, 162, true, false, -1, 0);
      for (int i1 = i + 1; !Main.tile[i1, j1].active() && Main.tile[i1, j1].liquid > (byte) 0 && (Main.tile[i1, j1 - 1].liquid == (byte) 0 && !Main.tile[i1, j1 - 1].active()) && !Main.tile[i1 + 1, j1].halfBrick(); ++i1)
        WorldGen.PlaceTile(i1, j1, 162, true, false, -1, 0);
    }

    public static void Lakinater(int i, int j, float strengthMultiplier = 1f)
    {
      double num1 = (double) WorldGen.genRand.Next(25, 50) * (double) strengthMultiplier;
      double num2 = num1;
      float num3 = (float) WorldGen.genRand.Next(30, 80);
      if (WorldGen.genRand.Next(5) == 0)
      {
        num1 *= 1.5;
        num2 *= 1.5;
        num3 *= 1.2f;
      }
      Vector2 vector2_1;
      vector2_1.X = (float) i;
      vector2_1.Y = (float) j - num3 * 0.3f;
      Vector2 vector2_2;
      vector2_2.X = (float) WorldGen.genRand.Next(-10, 11) * 0.1f;
      vector2_2.Y = (float) WorldGen.genRand.Next(-20, -10) * 0.1f;
      while (num1 > 0.0 && (double) num3 > 0.0)
      {
        if ((double) vector2_1.Y + num2 * 0.5 > Main.worldSurface)
          num3 = 0.0f;
        num1 -= (double) WorldGen.genRand.Next(3);
        --num3;
        int num4 = (int) ((double) vector2_1.X - num1 * 0.5);
        int num5 = (int) ((double) vector2_1.X + num1 * 0.5);
        int num6 = (int) ((double) vector2_1.Y - num1 * 0.5);
        int num7 = (int) ((double) vector2_1.Y + num1 * 0.5);
        if (num4 < 0)
          num4 = 0;
        if (num5 > Main.maxTilesX)
          num5 = Main.maxTilesX;
        if (num6 < 0)
          num6 = 0;
        if (num7 > Main.maxTilesY)
          num7 = Main.maxTilesY;
        num2 = num1 * (double) WorldGen.genRand.Next(80, 120) * 0.01;
        for (int index1 = num4; index1 < num5; ++index1)
        {
          for (int index2 = num6; index2 < num7; ++index2)
          {
            double num8 = (double) Math.Abs((float) index1 - vector2_1.X);
            float num9 = Math.Abs((float) index2 - vector2_1.Y);
            if (Math.Sqrt(num8 * num8 + (double) num9 * (double) num9) < num2 * 0.4)
            {
              if (Main.tile[index1, index2].active())
                Main.tile[index1, index2].liquid = byte.MaxValue;
              Main.tile[index1, index2].active(false);
            }
          }
        }
        vector2_1 += vector2_2;
        vector2_2.X += (float) WorldGen.genRand.Next(-10, 11) * 0.05f;
        vector2_2.Y += (float) WorldGen.genRand.Next(-10, 11) * 0.05f;
        if ((double) vector2_2.X > 0.5)
          vector2_2.X = 0.5f;
        if ((double) vector2_2.X < -0.5)
          vector2_2.X = -0.5f;
        if ((double) vector2_2.Y > 1.5)
          vector2_2.Y = 1.5f;
        if ((double) vector2_2.Y < 0.5)
          vector2_2.Y = 0.5f;
      }
    }

    public static void SonOfLakinater(int i, int j, float strengthMultiplier = 1f)
    {
      bool lava = false;
      if (WorldGen.getGoodWorldGen && WorldGen.genRand.Next(3) == 0)
        lava = true;
      double num1 = (double) WorldGen.genRand.Next(15, 31) * (double) strengthMultiplier;
      float num2 = (float) WorldGen.genRand.Next(30, 61);
      if (WorldGen.genRand.Next(5) == 0)
      {
        num1 *= 1.29999995231628;
        num2 *= 1.3f;
      }
      if (WorldGen.drunkWorldGen)
      {
        num1 *= 1.29999995231628;
        num2 *= 1.3f;
      }
      Vector2 vector2_1;
      vector2_1.X = (float) i;
      vector2_1.Y = (float) j;
      float num3 = WorldGen.genRand.NextFloat() * (1f / 500f);
      Vector2 vector2_2;
      if (WorldGen.genRand.Next(4) != 0)
      {
        vector2_2.X = (float) WorldGen.genRand.Next(-15, 16) * 0.01f;
      }
      else
      {
        vector2_2.X = (float) WorldGen.genRand.Next(-50, 51) * 0.01f;
        num3 = (float) ((double) WorldGen.genRand.NextFloat() * 0.00400000018998981 + 1.0 / 1000.0);
      }
      vector2_2.Y = (float) WorldGen.genRand.Next(101) * 0.01f;
      float num4 = num2;
      while (num1 > 3.0 && (double) num2 > 0.0)
      {
        num1 -= (double) WorldGen.genRand.Next(11) * 0.100000001490116;
        --num2;
        int num5 = (int) ((double) vector2_1.X - num1 * 4.0);
        int num6 = (int) ((double) vector2_1.X + num1 * 4.0);
        int num7 = (int) ((double) vector2_1.Y - num1 * 3.0);
        int num8 = (int) ((double) vector2_1.Y + num1 * 2.0);
        if (num5 < 0)
          num5 = 0;
        if (num6 > Main.maxTilesX)
          num6 = Main.maxTilesX;
        if (num7 < 0)
          num7 = 0;
        if (num8 > Main.maxTilesY)
          num8 = Main.maxTilesY;
        double num9 = num1;
        for (int index1 = num5; index1 < num6; ++index1)
        {
          for (int index2 = num7; index2 < num8; ++index2)
          {
            float num10 = Math.Abs((float) index1 - vector2_1.X) * 0.6f;
            float num11 = Math.Abs((float) index2 - vector2_1.Y) * 1.4f;
            float num12 = Math.Abs((float) index1 - vector2_1.X) * 0.3f;
            float num13 = Math.Abs((float) index2 - vector2_1.Y) * 5f;
            float num14 = MathHelper.Lerp(num10, num12, num2 / num4);
            float num15 = MathHelper.Lerp(num11, num13, num2 / num4);
            double num16 = Math.Sqrt((double) num14 * (double) num14 + (double) num15 * (double) num15);
            int num17 = j + 5;
            if (num16 < num9 * 0.4)
            {
              if (index2 >= j)
              {
                if (index2 <= j + 1)
                {
                  if (WorldGen.WillWaterPlacedHereStayPut(index1, index2))
                  {
                    Main.tile[index1, index2].liquid = byte.MaxValue;
                    Main.tile[index1, index2].lava(lava);
                  }
                }
                else
                {
                  Main.tile[index1, index2].liquid = byte.MaxValue;
                  Main.tile[index1, index2].lava(lava);
                }
              }
              Main.tile[index1, index2].active(false);
              if (!WorldGen.gen)
                WorldGen.SquareTileFrame(index1, index2, true);
              if (Main.tile[index1, index2].type == (ushort) 59 || Main.tile[index1, index2].type == (ushort) 60)
              {
                WorldGen.SpreadGrass(index1 - 1, index2, 59, 60, true, (byte) 0);
                WorldGen.SpreadGrass(index1 + 1, index2, 59, 60, true, (byte) 0);
                WorldGen.SpreadGrass(index1, index2 + 1, 59, 60, true, (byte) 0);
              }
            }
            else if (index2 > j + 1 && num16 < num9 && Main.tile[index1, index2].liquid == (byte) 0)
            {
              if ((double) Math.Abs((float) index1 - vector2_1.X) * 0.8 < num9 && Main.tile[index1, index2].wall > (ushort) 0 && (Main.tile[index1 - 1, index2].wall > (ushort) 0 && Main.tile[index1 + 1, index2].wall > (ushort) 0) && Main.tile[index1, index2 + 1].wall > (ushort) 0)
                Main.tile[index1, index2].active(true);
            }
            else if (index2 < j && (double) num2 == (double) num4 - 1.0 && ((double) index2 > WorldGen.worldSurfaceLow - 20.0 && !TileID.Sets.Clouds[(int) Main.tile[index1, index2].type]))
            {
              float num18 = (float) Math.Abs(index1 - i) * 0.7f;
              float num19 = (float) Math.Abs(index2 - num17) * 1.35f;
              Math.Sqrt((double) num18 * (double) num18 + (double) num19 * (double) num19);
              float num20 = (float) num9 * 0.4f;
              float num21 = (1f - (float) Math.Abs(index1 - i) / (float) (num6 - i)) * 2.3f;
              float num22 = num21 * num21;
              float num23 = num22 * num22;
              if (index2 < num17 && (double) num18 < (double) num20 + (double) Math.Abs(index2 - num17) * 0.5 * (double) num23)
              {
                Main.tile[index1, index2].active(false);
                if (Main.tile[index1, index2].type == (ushort) 59 || Main.tile[index1, index2].type == (ushort) 60)
                {
                  WorldGen.SpreadGrass(index1 - 1, index2, 59, 60, true, (byte) 0);
                  WorldGen.SpreadGrass(index1 + 1, index2, 59, 60, true, (byte) 0);
                  WorldGen.SpreadGrass(index1, index2 + 1, 59, 60, true, (byte) 0);
                }
              }
            }
          }
        }
        vector2_1 += vector2_2;
        vector2_2.X += (float) WorldGen.genRand.Next(-100, 101) * num3;
        vector2_2.Y += (float) WorldGen.genRand.Next(-100, 101) * 0.01f;
        if ((double) vector2_2.X > 1.0)
          vector2_2.X = 1f;
        if ((double) vector2_2.X < -1.0)
          vector2_2.X = -1f;
        if ((double) vector2_2.Y > 1.0)
          vector2_2.Y = 1f;
        float num24 = (float) (0.5 * (1.0 - (double) num2 / (double) num4));
        if ((double) vector2_2.Y < (double) num24)
          vector2_2.Y = num24;
      }
    }

    public static void ShroomPatch(int i, int j)
    {
      double num1 = (double) WorldGen.genRand.Next(80, 100);
      float num2 = (float) WorldGen.genRand.Next(20, 26);
      float num3 = (float) (Main.maxTilesX / 4200);
      if (WorldGen.getGoodWorldGen)
        num3 *= 2f;
      double num4 = num1 * (double) num3;
      float num5 = num2 * num3;
      float num6 = num5 - 1f;
      Vector2 vector2_1;
      vector2_1.X = (float) i;
      vector2_1.Y = (float) j - num5 * 0.3f;
      Vector2 vector2_2;
      vector2_2.X = (float) WorldGen.genRand.Next(-100, 101) * 0.005f;
      vector2_2.Y = (float) WorldGen.genRand.Next(-200, -100) * 0.005f;
      while (num4 > 0.0 && (double) num5 > 0.0)
      {
        num4 -= (double) WorldGen.genRand.Next(3);
        --num5;
        int num7 = (int) ((double) vector2_1.X - num4 * 0.5);
        int num8 = (int) ((double) vector2_1.X + num4 * 0.5);
        int num9 = (int) ((double) vector2_1.Y - num4 * 0.5);
        int num10 = (int) ((double) vector2_1.Y + num4 * 0.5);
        if (num7 < 0)
          num7 = 0;
        if (num8 > Main.maxTilesX)
          num8 = Main.maxTilesX;
        if (num9 < 0)
          num9 = 0;
        if (num10 > Main.maxTilesY)
          num10 = Main.maxTilesY;
        double num11 = num4 * (double) WorldGen.genRand.Next(80, 120) * 0.01;
        for (int index1 = num7; index1 < num8; ++index1)
        {
          for (int index2 = num9; index2 < num10; ++index2)
          {
            double num12 = (double) Math.Abs((float) index1 - vector2_1.X);
            float num13 = Math.Abs((float) (((double) index2 - (double) vector2_1.Y) * 2.29999995231628));
            double num14 = Math.Sqrt(num12 * num12 + (double) num13 * (double) num13);
            if (num14 < num11 * 0.8 && Main.tile[index1, index2].lava())
              Main.tile[index1, index2].liquid = (byte) 0;
            if (num14 < num11 * 0.2 && (double) index2 < (double) vector2_1.Y)
            {
              Main.tile[index1, index2].active(false);
              if (Main.tile[index1, index2].wall > (ushort) 0)
                Main.tile[index1, index2].wall = (ushort) 80;
            }
            else if (num14 < num11 * 0.4 * (0.95 + (double) WorldGen.genRand.NextFloat() * 0.1))
            {
              Main.tile[index1, index2].type = (ushort) 59;
              if ((double) num5 == (double) num6 && (double) index2 > (double) vector2_1.Y)
                Main.tile[index1, index2].active(true);
              if (Main.tile[index1, index2].wall > (ushort) 0)
                Main.tile[index1, index2].wall = (ushort) 80;
            }
          }
        }
        vector2_1 += vector2_2;
        vector2_1.X += vector2_2.X;
        vector2_2.X += (float) WorldGen.genRand.Next(-100, 110) * 0.005f;
        vector2_2.Y -= (float) WorldGen.genRand.Next(110) * 0.005f;
        if ((double) vector2_2.X > -0.5 && (double) vector2_2.X < 0.5)
          vector2_2.X = (double) vector2_2.X >= 0.0 ? 0.5f : -0.5f;
        if ((double) vector2_2.X > 0.5)
          vector2_2.X = 0.5f;
        if ((double) vector2_2.X < -0.5)
          vector2_2.X = -0.5f;
        if ((double) vector2_2.Y > 0.5)
          vector2_2.Y = 0.5f;
        if ((double) vector2_2.Y < -0.5)
          vector2_2.Y = -0.5f;
        for (int index = 0; index < 2; ++index)
        {
          int i1 = (int) vector2_1.X + WorldGen.genRand.Next(-20, 20);
          int j1;
          for (j1 = (int) vector2_1.Y + WorldGen.genRand.Next(0, 20); !Main.tile[i1, j1].active() && Main.tile[i1, j1].type != (ushort) 59; j1 = (int) vector2_1.Y + WorldGen.genRand.Next(0, 20))
            i1 = (int) vector2_1.X + WorldGen.genRand.Next(-20, 20);
          int num12 = WorldGen.genRand.Next(10, 20);
          int steps = WorldGen.genRand.Next(10, 20);
          WorldGen.TileRunner(i1, j1, (double) num12, steps, 59, false, 0.0f, 2f, true, true, -1);
        }
      }
    }

    public static void Cavinator(int i, int j, int steps)
    {
      double num1 = (double) WorldGen.genRand.Next(7, 15);
      int num2 = 1;
      if (WorldGen.genRand.Next(2) == 0)
        num2 = -1;
      Vector2 vector2_1;
      vector2_1.X = (float) i;
      vector2_1.Y = (float) j;
      int num3 = WorldGen.genRand.Next(20, 40);
      Vector2 vector2_2;
      vector2_2.Y = (float) WorldGen.genRand.Next(10, 20) * 0.01f;
      vector2_2.X = (float) num2;
      while (num3 > 0)
      {
        --num3;
        int num4 = (int) ((double) vector2_1.X - num1 * 0.5);
        int num5 = (int) ((double) vector2_1.X + num1 * 0.5);
        int num6 = (int) ((double) vector2_1.Y - num1 * 0.5);
        int num7 = (int) ((double) vector2_1.Y + num1 * 0.5);
        if (num4 < 0)
          num4 = 0;
        if (num5 > Main.maxTilesX)
          num5 = Main.maxTilesX;
        if (num6 < 0)
          num6 = 0;
        if (num7 > Main.maxTilesY)
          num7 = Main.maxTilesY;
        double num8 = num1 * (double) WorldGen.genRand.Next(80, 120) * 0.01;
        for (int index1 = num4; index1 < num5; ++index1)
        {
          for (int index2 = num6; index2 < num7; ++index2)
          {
            double num9 = (double) Math.Abs((float) index1 - vector2_1.X);
            float num10 = Math.Abs((float) index2 - vector2_1.Y);
            if (Math.Sqrt(num9 * num9 + (double) num10 * (double) num10) < num8 * 0.4 && TileID.Sets.CanBeClearedDuringGeneration[(int) Main.tile[index1, index2].type] && Main.tile[index1, index2].type != (ushort) 53)
              Main.tile[index1, index2].active(false);
          }
        }
        vector2_1 += vector2_2;
        vector2_2.X += (float) WorldGen.genRand.Next(-10, 11) * 0.05f;
        vector2_2.Y += (float) WorldGen.genRand.Next(-10, 11) * 0.05f;
        if ((double) vector2_2.X > (double) num2 + 0.5)
          vector2_2.X = (float) num2 + 0.5f;
        if ((double) vector2_2.X < (double) num2 - 0.5)
          vector2_2.X = (float) num2 - 0.5f;
        if ((double) vector2_2.Y > 2.0)
          vector2_2.Y = 2f;
        if ((double) vector2_2.Y < 0.0)
          vector2_2.Y = 0.0f;
      }
      if (steps <= 0 || (double) (int) vector2_1.Y >= Main.rockLayer + 50.0)
        return;
      WorldGen.Cavinator((int) vector2_1.X, (int) vector2_1.Y, steps - 1);
    }

    public static void CaveOpenater(int i, int j)
    {
      double num1 = (double) WorldGen.genRand.Next(7, 12);
      int num2 = 1;
      if (WorldGen.genRand.Next(2) == 0)
        num2 = -1;
      if (WorldGen.genRand.Next(10) != 0)
        num2 = i >= Main.maxTilesX / 2 ? -1 : 1;
      Vector2 vector2_1;
      vector2_1.X = (float) i;
      vector2_1.Y = (float) j;
      int num3 = 100;
      Vector2 vector2_2;
      vector2_2.Y = 0.0f;
      vector2_2.X = (float) num2;
      while (num3 > 0)
      {
        Tile tile = Main.tile[(int) vector2_1.X, (int) vector2_1.Y];
        if (tile.wall == (ushort) 0 || tile.active() && !TileID.Sets.CanBeClearedDuringGeneration[(int) tile.type])
          num3 = 0;
        --num3;
        int num4 = (int) ((double) vector2_1.X - num1 * 0.5);
        int num5 = (int) ((double) vector2_1.X + num1 * 0.5);
        int num6 = (int) ((double) vector2_1.Y - num1 * 0.5);
        int num7 = (int) ((double) vector2_1.Y + num1 * 0.5);
        if (num4 < 0)
          num4 = 0;
        if (num5 > Main.maxTilesX)
          num5 = Main.maxTilesX;
        if (num6 < 0)
          num6 = 0;
        if (num7 > Main.maxTilesY)
          num7 = Main.maxTilesY;
        double num8 = num1 * (double) WorldGen.genRand.Next(80, 120) * 0.01;
        for (int index1 = num4; index1 < num5; ++index1)
        {
          for (int index2 = num6; index2 < num7; ++index2)
          {
            double num9 = (double) Math.Abs((float) index1 - vector2_1.X);
            float num10 = Math.Abs((float) index2 - vector2_1.Y);
            if (Math.Sqrt(num9 * num9 + (double) num10 * (double) num10) < num8 * 0.4 && TileID.Sets.CanBeClearedDuringGeneration[(int) Main.tile[index1, index2].type])
              Main.tile[index1, index2].active(false);
          }
        }
        vector2_1 += vector2_2;
        vector2_2.X += (float) WorldGen.genRand.Next(-10, 11) * 0.05f;
        vector2_2.Y += (float) WorldGen.genRand.Next(-10, 11) * 0.05f;
        if ((double) vector2_2.X > (double) num2 + 0.5)
          vector2_2.X = (float) num2 + 0.5f;
        if ((double) vector2_2.X < (double) num2 - 0.5)
          vector2_2.X = (float) num2 - 0.5f;
        if ((double) vector2_2.Y > 0.0)
          vector2_2.Y = 0.0f;
        if ((double) vector2_2.Y < -0.5)
          vector2_2.Y = -0.5f;
      }
    }

    public static void DiamondTileFrame(int i, int j)
    {
      WorldGen.TileFrame(i - 1, j, false, false);
      WorldGen.TileFrame(i, j - 1, false, false);
      WorldGen.TileFrame(i, j + 1, false, false);
      WorldGen.TileFrame(i + 1, j, false, false);
    }

    public static void SquareTileFrame(int i, int j, bool resetFrame = true)
    {
      WorldGen.TileFrame(i - 1, j - 1, false, false);
      WorldGen.TileFrame(i - 1, j, false, false);
      WorldGen.TileFrame(i - 1, j + 1, false, false);
      WorldGen.TileFrame(i, j - 1, false, false);
      WorldGen.TileFrame(i, j, resetFrame, false);
      WorldGen.TileFrame(i, j + 1, false, false);
      WorldGen.TileFrame(i + 1, j - 1, false, false);
      WorldGen.TileFrame(i + 1, j, false, false);
      WorldGen.TileFrame(i + 1, j + 1, false, false);
    }

    public static void SquareWallFrame(int i, int j, bool resetFrame = true)
    {
      Framing.WallFrame(i - 1, j - 1, false);
      Framing.WallFrame(i - 1, j, false);
      Framing.WallFrame(i - 1, j + 1, false);
      Framing.WallFrame(i, j - 1, false);
      Framing.WallFrame(i, j, resetFrame);
      Framing.WallFrame(i, j + 1, false);
      Framing.WallFrame(i + 1, j - 1, false);
      Framing.WallFrame(i + 1, j, false);
      Framing.WallFrame(i + 1, j + 1, false);
    }

    public static void SectionTileFrameWithCheck(int startX, int startY, int endX, int endY)
    {
      int sectionX1 = Netplay.GetSectionX(startX);
      int sectionY1 = Netplay.GetSectionY(startY);
      int sectionX2 = Netplay.GetSectionX(endX);
      int sectionY2 = Netplay.GetSectionY(endY);
      for (int index1 = sectionX1; index1 <= sectionX2; ++index1)
      {
        for (int index2 = sectionY1; index2 <= sectionY2; ++index2)
        {
          if (Main.sectionManager.SectionLoaded(index1, index2) && !Main.sectionManager.SectionFramed(index1, index2))
          {
            WorldGen.SectionTileFrame(index1, index2, index1, index2);
            if (Main.sectionManager.FrameSectionsLeft == 0)
              return;
          }
        }
      }
    }

    public static void SectionTileFrame(int startX, int startY, int endX, int endY)
    {
      Main.mapTime = Main.mapTimeMax + 10;
      WorldGen.noMapUpdate = true;
      int num1 = startX * 200;
      int num2 = (endX + 1) * 200;
      int num3 = startY * 150;
      int num4 = (endY + 1) * 150;
      if (num1 < 1)
        num1 = 1;
      if (num3 < 1)
        num3 = 1;
      if (num1 > Main.maxTilesX - 2)
        num1 = Main.maxTilesX - 2;
      if (num3 > Main.maxTilesY - 2)
        num3 = Main.maxTilesY - 2;
      if (num2 > Main.maxTilesX - 2)
        num2 = Main.maxTilesX - 2;
      if (num4 > Main.maxTilesY - 2)
        num4 = Main.maxTilesY - 2;
      for (int i = num1 - 1; i < num2 + 1; ++i)
      {
        for (int j = num3 - 1; j < num4 + 1; ++j)
        {
          if (Main.tile[i, j] == null)
            Main.tile[i, j] = new Tile();
          WorldGen.TileFrame(i, j, true, true);
          Framing.WallFrame(i, j, true);
        }
      }
      for (int x = startX; x <= endX; ++x)
      {
        for (int y = startY; y <= endY; ++y)
          Main.sectionManager.SetSectionFramed(x, y);
      }
      WorldGen.noMapUpdate = false;
    }

    public static void RangeFrame(int startX, int startY, int endX, int endY)
    {
      int num1 = startX;
      int num2 = endX + 1;
      int num3 = startY;
      int num4 = endY + 1;
      for (int i = num1 - 1; i < num2 + 1; ++i)
      {
        for (int j = num3 - 1; j < num4 + 1; ++j)
        {
          WorldGen.TileFrame(i, j, false, false);
          Framing.WallFrame(i, j, false);
        }
      }
    }

    public static void WaterCheck()
    {
      Liquid.tilesIgnoreWater(true);
      Liquid.numLiquid = 0;
      LiquidBuffer.numLiquidBuffer = 0;
      for (int index1 = 1; index1 < Main.maxTilesX - 1; ++index1)
      {
        for (int index2 = Main.maxTilesY - 2; index2 > 0; --index2)
        {
          Tile checkTile = Main.tile[index1, index2];
          checkTile.checkingLiquid(false);
          if (checkTile.liquid > (byte) 0 && checkTile.nactive() && (Main.tileSolid[(int) checkTile.type] && !Main.tileSolidTop[(int) checkTile.type]))
            checkTile.liquid = (byte) 0;
          else if (checkTile.liquid > (byte) 0)
          {
            if (checkTile.active())
            {
              if (checkTile.lava())
              {
                if (TileObjectData.CheckLavaDeath(checkTile))
                  WorldGen.KillTile(index1, index2, false, false, false);
              }
              else if (TileObjectData.CheckWaterDeath(checkTile))
                WorldGen.KillTile(index1, index2, false, false, false);
            }
            Tile tile1 = Main.tile[index1, index2 + 1];
            if ((!tile1.nactive() || !Main.tileSolid[(int) tile1.type] || Main.tileSolidTop[(int) tile1.type]) && tile1.liquid < byte.MaxValue)
            {
              if (tile1.liquid > (byte) 250)
                tile1.liquid = byte.MaxValue;
              else
                Liquid.AddWater(index1, index2);
            }
            Tile tile2 = Main.tile[index1 - 1, index2];
            Tile tile3 = Main.tile[index1 + 1, index2];
            if ((!tile2.nactive() || !Main.tileSolid[(int) tile2.type] || Main.tileSolidTop[(int) tile2.type]) && (int) tile2.liquid != (int) checkTile.liquid)
              Liquid.AddWater(index1, index2);
            else if ((!tile3.nactive() || !Main.tileSolid[(int) tile3.type] || Main.tileSolidTop[(int) tile3.type]) && (int) tile3.liquid != (int) checkTile.liquid)
              Liquid.AddWater(index1, index2);
            if (checkTile.lava())
            {
              if (tile2.liquid > (byte) 0 && !tile2.lava())
                Liquid.AddWater(index1, index2);
              else if (tile3.liquid > (byte) 0 && !tile3.lava())
                Liquid.AddWater(index1, index2);
              else if (Main.tile[index1, index2 - 1].liquid > (byte) 0 && !Main.tile[index1, index2 - 1].lava())
                Liquid.AddWater(index1, index2);
              else if (tile1.liquid > (byte) 0 && !tile1.lava())
                Liquid.AddWater(index1, index2);
            }
          }
        }
      }
      Liquid.tilesIgnoreWater(false);
    }

    public static void EveryTileFrame()
    {
      Stopwatch stopwatch = new Stopwatch();
      stopwatch.Start();
      WorldGen.noLiquidCheck = true;
      WorldGen.noTileActions = true;
      for (int i = 0; i < Main.maxTilesX; ++i)
      {
        float num = (float) i / (float) Main.maxTilesX;
        Main.statusText = Lang.gen[55].Value + " " + (object) (int) ((double) num * 100.0 + 1.0) + "%";
        for (int j = 0; j < Main.maxTilesY; ++j)
        {
          if (Main.tile[i, j].active())
            WorldGen.TileFrame(i, j, true, false);
          if (Main.tile[i, j].wall > (ushort) 0)
            Framing.WallFrame(i, j, true);
        }
      }
      WorldGen.noLiquidCheck = false;
      WorldGen.noTileActions = false;
      long elapsedMilliseconds = stopwatch.ElapsedMilliseconds;
    }

    public static void PlantCheck(int x, int y)
    {
      x = Utils.Clamp<int>(x, 1, Main.maxTilesX - 2);
      y = Utils.Clamp<int>(y, 1, Main.maxTilesY - 2);
      for (int index1 = x - 1; index1 <= x + 1; ++index1)
      {
        for (int index2 = y - 1; index2 <= y + 1; ++index2)
        {
          if (Main.tile[index1, index2] == null)
            return;
        }
      }
      int num1 = -1;
      int num2 = (int) Main.tile[x, y].type;
      int num3 = x - 1;
      int num4 = x + 1;
      int maxTilesX = Main.maxTilesX;
      int num5 = y - 1;
      if (y + 1 >= Main.maxTilesY)
        num1 = num2;
      if (x - 1 >= 0 && Main.tile[x - 1, y] != null && Main.tile[x - 1, y].nactive())
      {
        int type1 = (int) Main.tile[x - 1, y].type;
      }
      if (x + 1 < Main.maxTilesX && Main.tile[x + 1, y] != null && Main.tile[x + 1, y].nactive())
      {
        int type2 = (int) Main.tile[x + 1, y].type;
      }
      if (y - 1 >= 0 && Main.tile[x, y - 1] != null && Main.tile[x, y - 1].nactive())
      {
        int type3 = (int) Main.tile[x, y - 1].type;
      }
      if (y + 1 < Main.maxTilesY && Main.tile[x, y + 1] != null && (Main.tile[x, y + 1].nactive() && !Main.tile[x, y + 1].halfBrick()) && Main.tile[x, y + 1].slope() == (byte) 0)
        num1 = (int) Main.tile[x, y + 1].type;
      if (x - 1 >= 0 && y - 1 >= 0 && (Main.tile[x - 1, y - 1] != null && Main.tile[x - 1, y - 1].nactive()))
      {
        int type4 = (int) Main.tile[x - 1, y - 1].type;
      }
      if (x + 1 < Main.maxTilesX && y - 1 >= 0 && (Main.tile[x + 1, y - 1] != null && Main.tile[x + 1, y - 1].nactive()))
      {
        int type5 = (int) Main.tile[x + 1, y - 1].type;
      }
      if (x - 1 >= 0 && y + 1 < Main.maxTilesY && (Main.tile[x - 1, y + 1] != null && Main.tile[x - 1, y + 1].nactive()))
      {
        int type6 = (int) Main.tile[x - 1, y + 1].type;
      }
      if (x + 1 < Main.maxTilesX && y + 1 < Main.maxTilesY && (Main.tile[x + 1, y + 1] != null && Main.tile[x + 1, y + 1].nactive()))
      {
        int type7 = (int) Main.tile[x + 1, y + 1].type;
      }
      if ((num2 != 3 || num1 == 2 || (num1 == 477 || num1 == 78) || (num1 == 380 || num1 == 579)) && (num2 != 73 || num1 == 2 || (num1 == 477 || num1 == 78) || (num1 == 380 || num1 == 579)) && ((num2 != 24 || num1 == 23) && (num2 != 61 || num1 == 60) && ((num2 != 74 || num1 == 60) && (num2 != 71 || num1 == 70)) && ((num2 != 110 || num1 == 109 || num1 == 492) && (num2 != 113 || num1 == 109 || num1 == 492))) && (num2 != 201 || num1 == 199))
        return;
      if ((num2 == 3 || num2 == 73) && (num1 != 2 && num1 != 477) && Main.tile[x, y].frameX >= (short) 162)
        Main.tile[x, y].frameX = (short) 126;
      if (num2 == 74 && num1 != 60 && Main.tile[x, y].frameX >= (short) 162)
        Main.tile[x, y].frameX = (short) 126;
      if (num1 == 23)
      {
        num2 = 24;
        if (Main.tile[x, y].frameX >= (short) 162)
          Main.tile[x, y].frameX = (short) 126;
      }
      else if (num1 == 2 || num1 == 477)
        num2 = num2 != 113 ? 3 : 73;
      else if (num1 == 109 || num1 == 492)
      {
        num2 = num2 != 73 ? 110 : 113;
      }
      else
      {
        switch (num1)
        {
          case 70:
            num2 = 71;
            while (Main.tile[x, y].frameX > (short) 72)
              Main.tile[x, y].frameX -= (short) 72;
            break;
          case 199:
            num2 = 201;
            break;
        }
      }
      if (num2 != (int) Main.tile[x, y].type)
        Main.tile[x, y].type = (ushort) num2;
      else
        WorldGen.KillTile(x, y, false, false, false);
    }

    public static bool CanPoundTile(int x, int y)
    {
      if (Main.tile[x, y] == null)
        Main.tile[x, y] = new Tile();
      if (Main.tile[x, y - 1] == null)
        Main.tile[x, y - 1] = new Tile();
      if (Main.tile[x, y + 1] == null)
        Main.tile[x, y + 1] = new Tile();
      switch (Main.tile[x, y].type)
      {
        case 10:
        case 48:
        case 137:
        case 138:
        case 232:
        case 380:
        case 387:
        case 388:
        case 476:
        case 484:
          return false;
        default:
          if (WorldGen.gen && (Main.tile[x, y].type == (ushort) 190 || Main.tile[x, y].type == (ushort) 30))
            return false;
          if (Main.tile[x, y - 1].active())
          {
            switch (Main.tile[x, y - 1].type)
            {
              case 21:
              case 26:
              case 77:
              case 88:
              case 235:
              case 237:
              case 441:
              case 467:
              case 468:
              case 470:
              case 475:
              case 488:
              case 597:
                return false;
            }
          }
          return WorldGen.CanKillTile(x, y);
      }
    }

    public static bool SlopeTile(int i, int j, int slope = 0, bool noEffects = false)
    {
      if (!WorldGen.CanPoundTile(i, j))
        return false;
      Main.tile[i, j].halfBrick(false);
      Main.tile[i, j].slope((byte) slope);
      if (!WorldGen.gen)
      {
        if (!noEffects)
          WorldGen.KillTile(i, j, true, true, false);
        SoundEngine.PlaySound(0, i * 16, j * 16, 1, 1f, 0.0f);
        WorldGen.SquareTileFrame(i, j, true);
        if (Main.tile[i, j].slope() == (byte) 0)
        {
          Microsoft.Xna.Framework.Rectangle rectangle = new Microsoft.Xna.Framework.Rectangle(i * 16, j * 16, 16, 16);
          for (int index = 0; index < (int) byte.MaxValue; ++index)
          {
            if (Main.player[index].active && !Main.player[index].dead && rectangle.Intersects(new Microsoft.Xna.Framework.Rectangle((int) Main.player[index].position.X, (int) Main.player[index].position.Y, Main.player[index].width, Main.player[index].height)))
            {
              Main.player[index].gfxOffY += Main.player[index].position.Y + (float) Main.player[index].height - (float) rectangle.Y;
              Main.player[index].position.Y = (float) (rectangle.Y - Main.player[index].height);
            }
          }
        }
      }
      return true;
    }

    public static bool PoundTile(int i, int j)
    {
      if (!WorldGen.CanPoundTile(i, j))
        return false;
      if (!Main.tile[i, j].halfBrick())
        Main.tile[i, j].halfBrick(true);
      else
        Main.tile[i, j].halfBrick(false);
      if (!WorldGen.gen)
      {
        WorldGen.KillTile(i, j, true, true, false);
        SoundEngine.PlaySound(0, i * 16, j * 16, 1, 1f, 0.0f);
        WorldGen.SquareTileFrame(i, j, true);
        if (!Main.tile[i, j].halfBrick())
        {
          Microsoft.Xna.Framework.Rectangle rectangle = new Microsoft.Xna.Framework.Rectangle(i * 16, j * 16, 16, 16);
          for (int index = 0; index < (int) byte.MaxValue; ++index)
          {
            if (Main.player[index].active && !Main.player[index].dead && rectangle.Intersects(new Microsoft.Xna.Framework.Rectangle((int) Main.player[index].position.X, (int) Main.player[index].position.Y, Main.player[index].width, Main.player[index].height)))
            {
              Main.player[index].gfxOffY += Main.player[index].position.Y + (float) Main.player[index].height - (float) rectangle.Y;
              Main.player[index].position.Y = (float) (rectangle.Y - Main.player[index].height);
            }
          }
        }
      }
      return true;
    }

    public static void PoundPlatform(int x, int y)
    {
      if (Main.tile[x, y].halfBrick())
      {
        WorldGen.PoundTile(x, y);
        if (Main.netMode != 1)
          return;
        NetMessage.SendData(17, -1, -1, (NetworkText) null, 7, (float) x, (float) y, 1f, 0, 0, 0);
      }
      else
      {
        int slope1 = 1;
        int slope2 = 2;
        if (TileID.Sets.Platforms[(int) Main.tile[x + 1, y - 1].type] || TileID.Sets.Platforms[(int) Main.tile[x - 1, y + 1].type] || WorldGen.SolidTile(x + 1, y, false) && !WorldGen.SolidTile(x - 1, y, false))
        {
          slope1 = 2;
          slope2 = 1;
        }
        if (Main.tile[x, y].slope() == (byte) 0)
        {
          WorldGen.SlopeTile(x, y, slope1, false);
          int num = (int) Main.tile[x, y].slope();
          if (Main.netMode != 1)
            return;
          NetMessage.SendData(17, -1, -1, (NetworkText) null, 14, (float) x, (float) y, (float) num, 0, 0, 0);
        }
        else if ((int) Main.tile[x, y].slope() == slope1)
        {
          WorldGen.SlopeTile(x, y, slope2, false);
          int num = (int) Main.tile[x, y].slope();
          if (Main.netMode != 1)
            return;
          NetMessage.SendData(17, -1, -1, (NetworkText) null, 14, (float) x, (float) y, (float) num, 0, 0, 0);
        }
        else
        {
          WorldGen.SlopeTile(x, y, 0, false);
          int num = (int) Main.tile[x, y].slope();
          if (Main.netMode == 1)
            NetMessage.SendData(17, -1, -1, (NetworkText) null, 14, (float) x, (float) y, (float) num, 0, 0, 0);
          WorldGen.PoundTile(x, y);
          if (Main.netMode != 1)
            return;
          NetMessage.SendData(17, -1, -1, (NetworkText) null, 7, (float) x, (float) y, 1f, 0, 0, 0);
        }
      }
    }

    public static int PlatformProperSides(int x, int y, bool acceptNonOpposing = false)
    {
      Tile tile = Main.tile[x, y];
      if (!tile.active() || !TileID.Sets.Platforms[(int) tile.type])
        return 0;
      int num1 = (int) tile.slope();
      int num2 = -1;
      if (num1 == 1)
        num2 = 2;
      if (num1 == 2)
        num2 = 1;
      int num3 = 0;
      int num4 = 1;
      int num5 = 0;
      if (num1 == 1)
        num5 = 1;
      if (num1 == 2)
        num5 = -1;
      if (acceptNonOpposing)
      {
        if (Main.tile[x + num4, y + num5].active() && TileID.Sets.Platforms[(int) Main.tile[x + num4, y + num5].type] && (int) Main.tile[x + num4, y + num5].slope() != num2)
          ++num3;
      }
      else if (Main.tile[x + num4, y + num5].active() && TileID.Sets.Platforms[(int) Main.tile[x + num4, y + num5].type] && (int) Main.tile[x + num4, y + num5].slope() == num1)
        ++num3;
      int num6 = num4 * -1;
      int num7 = num5 * -1;
      if (acceptNonOpposing)
      {
        if (Main.tile[x + num6, y + num7].active() && TileID.Sets.Platforms[(int) Main.tile[x + num6, y + num7].type] && (int) Main.tile[x + num6, y + num7].slope() != num2)
          ++num3;
      }
      else if (Main.tile[x + num6, y + num7].active() && TileID.Sets.Platforms[(int) Main.tile[x + num6, y + num7].type] && (int) Main.tile[x + num6, y + num7].slope() == num1)
        ++num3;
      return num3;
    }

    public static bool UpdateMapTile(int i, int j, bool addToList = true)
    {
      bool flag = false;
      if (Main.mapEnabled && !WorldGen.noMapUpdate && !WorldGen.gen && ((Main.Map[i, j].Light <= (byte) 0 ? 0 : (Main.Map.UpdateType(i, j) ? 1 : 0)) & (addToList ? 1 : 0)) != 0)
      {
        flag = true;
        if (MapHelper.numUpdateTile < MapHelper.maxUpdateTile - 1)
        {
          MapHelper.updateTileX[MapHelper.numUpdateTile] = (short) i;
          MapHelper.updateTileY[MapHelper.numUpdateTile] = (short) j;
          ++MapHelper.numUpdateTile;
        }
        else
          Main.refreshMap = true;
      }
      return flag;
    }

    public static void TileMergeAttemptFrametest(
      int i,
      int j,
      int myType,
      int lookfor,
      ref int up,
      ref int down,
      ref int left,
      ref int right,
      ref int upLeft,
      ref int upRight,
      ref int downLeft,
      ref int downRight)
    {
      if (up == lookfor)
      {
        WorldGen.TileFrame(i, j - 1, false, false);
        if (WorldGen.mergeDown)
          up = myType;
      }
      if (down == lookfor)
      {
        WorldGen.TileFrame(i, j + 1, false, false);
        if (WorldGen.mergeUp)
          down = myType;
      }
      if (left == lookfor)
      {
        WorldGen.TileFrame(i - 1, j, false, false);
        if (WorldGen.mergeRight)
          left = myType;
      }
      if (right == lookfor)
      {
        WorldGen.TileFrame(i + 1, j, false, false);
        if (WorldGen.mergeLeft)
          right = myType;
      }
      if (upLeft == lookfor)
        upLeft = myType;
      if (upRight == lookfor)
        upRight = myType;
      if (downLeft == lookfor)
        downLeft = myType;
      if (downRight != lookfor)
        return;
      downRight = myType;
    }

    public static void TileMergeAttemptFrametest(
      int i,
      int j,
      int myType,
      bool[] lookfor,
      ref int up,
      ref int down,
      ref int left,
      ref int right,
      ref int upLeft,
      ref int upRight,
      ref int downLeft,
      ref int downRight)
    {
      if (up > -1 && lookfor[up])
      {
        WorldGen.TileFrame(i, j - 1, false, false);
        if (WorldGen.mergeDown)
          up = myType;
      }
      if (down > -1 && lookfor[down])
      {
        WorldGen.TileFrame(i, j + 1, false, false);
        if (WorldGen.mergeUp)
          down = myType;
      }
      if (left > -1 && lookfor[left])
      {
        WorldGen.TileFrame(i - 1, j, false, false);
        if (WorldGen.mergeRight)
          left = myType;
      }
      if (right > -1 && lookfor[right])
      {
        WorldGen.TileFrame(i + 1, j, false, false);
        if (WorldGen.mergeLeft)
          right = myType;
      }
      if (upLeft > -1 && lookfor[upLeft])
        upLeft = myType;
      if (upRight > -1 && lookfor[upRight])
        upRight = myType;
      if (downLeft > -1 && lookfor[downLeft])
        downLeft = myType;
      if (downRight <= -1 || !lookfor[downRight])
        return;
      downRight = myType;
    }

    public static void TileMergeAttempt(
      int myType,
      int lookfor,
      ref int up,
      ref int down,
      ref int left,
      ref int right)
    {
      if (lookfor == up)
        up = myType;
      if (lookfor == down)
        down = myType;
      if (lookfor == left)
        left = myType;
      if (lookfor != right)
        return;
      right = myType;
    }

    public static void TileMergeAttempt(
      int myType,
      int lookfor,
      ref int up,
      ref int down,
      ref int left,
      ref int right,
      ref int upLeft,
      ref int upRight,
      ref int downLeft,
      ref int downRight)
    {
      if (lookfor == up)
        up = myType;
      if (lookfor == down)
        down = myType;
      if (lookfor == left)
        left = myType;
      if (lookfor == right)
        right = myType;
      if (lookfor == upLeft)
        upLeft = myType;
      if (lookfor == upRight)
        upRight = myType;
      if (lookfor == downLeft)
        downLeft = myType;
      if (lookfor != downRight)
        return;
      downRight = myType;
    }

    public static void TileMergeAttempt(
      int myType,
      bool[] lookfor,
      ref int up,
      ref int down,
      ref int left,
      ref int right,
      ref int upLeft,
      ref int upRight,
      ref int downLeft,
      ref int downRight)
    {
      if (up > -1 && lookfor[up])
        up = myType;
      if (down > -1 && lookfor[down])
        down = myType;
      if (left > -1 && lookfor[left])
        left = myType;
      if (right > -1 && lookfor[right])
        right = myType;
      if (upLeft > -1 && lookfor[upLeft])
        upLeft = myType;
      if (upRight > -1 && lookfor[upRight])
        upRight = myType;
      if (downLeft > -1 && lookfor[downLeft])
        downLeft = myType;
      if (downRight <= -1 || !lookfor[downRight])
        return;
      downRight = myType;
    }

    public static void TileMergeAttempt(
      int myType,
      bool[] lookfor,
      bool[] exclude,
      ref int up,
      ref int down,
      ref int left,
      ref int right,
      ref int upLeft,
      ref int upRight,
      ref int downLeft,
      ref int downRight)
    {
      if (up > -1 && !exclude[up] && lookfor[up])
        up = myType;
      if (down > -1 && !exclude[down] && lookfor[down])
        down = myType;
      if (left > -1 && !exclude[left] && lookfor[left])
        left = myType;
      if (right > -1 && !exclude[right] && lookfor[right])
        right = myType;
      if (upLeft > -1 && !exclude[upLeft] && lookfor[upLeft])
        upLeft = myType;
      if (upRight > -1 && !exclude[upRight] && lookfor[upRight])
        upRight = myType;
      if (downLeft > -1 && !exclude[downLeft] && lookfor[downLeft])
        downLeft = myType;
      if (downRight <= -1 || exclude[downRight] || !lookfor[downRight])
        return;
      downRight = myType;
    }

    public static void TileMergeAttemptWeird(
      int myType,
      int changeTo,
      bool[] exclude,
      ref int up,
      ref int down,
      ref int left,
      ref int right,
      ref int upLeft,
      ref int upRight,
      ref int downLeft,
      ref int downRight)
    {
      if (up > -1 && !exclude[up] && up != myType)
        up = changeTo;
      if (down > -1 && !exclude[down] && down != myType)
        down = changeTo;
      if (left > -1 && !exclude[left] && left != myType)
        left = changeTo;
      if (right > -1 && !exclude[right] && right != myType)
        right = changeTo;
      if (upLeft > -1 && !exclude[upLeft] && upLeft != myType)
        upLeft = changeTo;
      if (upRight > -1 && !exclude[upRight] && upRight != myType)
        upRight = changeTo;
      if (downLeft > -1 && !exclude[downLeft] && downLeft != myType)
        downLeft = changeTo;
      if (downRight <= -1 || exclude[downRight] || downRight == myType)
        return;
      downRight = changeTo;
    }

    public static int GetTileMossColor(int tileType)
    {
      switch (tileType)
      {
        case 179:
        case 512:
          return 0;
        case 180:
        case 513:
          return 1;
        case 181:
        case 514:
          return 2;
        case 182:
        case 515:
          return 3;
        case 183:
        case 516:
          return 4;
        case 381:
        case 517:
          return 5;
        case 534:
        case 535:
          return 6;
        case 536:
        case 537:
          return 7;
        case 539:
        case 540:
          return 8;
        default:
          return -1;
      }
    }

    public static void CheckFoodPlatter(int x, int y, int type)
    {
      if (Main.tile[x, y] == null || WorldGen.destroyObject || WorldGen.SolidTileAllowBottomSlope(x, y + 1))
        return;
      if (type == 520)
      {
        int index = TEFoodPlatter.Find(x, y);
        if (index != -1 && ((TEFoodPlatter) TileEntity.ByID[index]).item.stack > 0)
        {
          ((TEFoodPlatter) TileEntity.ByID[index]).DropItem();
          if (Main.netMode != 2)
            Main.LocalPlayer.InterruptItemUsageIfOverTile(520);
        }
      }
      WorldGen.destroyObject = true;
      if ((int) Main.tile[x, y].type == type)
        WorldGen.KillTile(x, y, false, false, false);
      if (type == 520)
        TEFoodPlatter.Kill(x, y);
      WorldGen.destroyObject = false;
    }

    public static bool SkipFramingBecauseOfGen
    {
      get
      {
        return WorldGen.generatingWorld && WorldGen.skipFramingDuringGen;
      }
    }

    public static void TileFrame(int i, int j, bool resetFrame = false, bool noBreak = false)
    {
      bool addToList = false;
      try
      {
        if (i > 5)
        {
          if (j > 5)
          {
            if (i < Main.maxTilesX - 5)
            {
              if (j < Main.maxTilesY - 5)
              {
                if (Main.tile[i, j] != null)
                {
                  if (WorldGen.SkipFramingBecauseOfGen && !Main.tileFrameImportant[(int) Main.tile[i, j].type])
                    return;
                  addToList = WorldGen.UpdateMapTile(i, j, true);
                  Tile tile1 = Main.tile[i, j];
                  if (!tile1.active())
                  {
                    tile1.halfBrick(false);
                    tile1.color((byte) 0);
                    tile1.slope((byte) 0);
                  }
                  if (tile1.liquid > (byte) 0 && Main.netMode != 1 && !WorldGen.noLiquidCheck)
                    Liquid.AddWater(i, j);
                  if (tile1.active())
                  {
                    if (noBreak && Main.tileFrameImportant[(int) tile1.type] && tile1.type != (ushort) 4)
                      return;
                    int index1 = (int) tile1.type;
                    if (Main.tileStone[index1])
                      index1 = 1;
                    int frameX = (int) tile1.frameX;
                    int frameY = (int) tile1.frameY;
                    Microsoft.Xna.Framework.Rectangle rectangle = new Microsoft.Xna.Framework.Rectangle(-1, -1, 0, 0);
                    if (Main.tileFrameImportant[(int) tile1.type])
                    {
                      switch (index1)
                      {
                        case 4:
                          WorldGen.CheckTorch(i, j);
                          return;
                        case 136:
                          Tile tile2 = Main.tile[i, j - 1];
                          Tile tile3 = Main.tile[i, j + 1];
                          Tile tile4 = Main.tile[i - 1, j];
                          Tile tile5 = Main.tile[i + 1, j];
                          Tile tile6 = Main.tile[i - 1, j + 1];
                          Tile tile7 = Main.tile[i + 1, j + 1];
                          Tile tile8 = Main.tile[i - 1, j - 1];
                          Tile tile9 = Main.tile[i + 1, j - 1];
                          int index2 = -1;
                          int tree1 = -1;
                          int tree2 = -1;
                          int tree3 = -1;
                          int tree4 = -1;
                          int tree5 = -1;
                          int tree6 = -1;
                          if (tile2 != null && tile2.nactive())
                          {
                            int type = (int) tile2.type;
                          }
                          if (tile3 != null && tile3.nactive() && (!tile3.halfBrick() && !tile3.topSlope()))
                            index2 = (int) tile3.type;
                          if (tile4 != null && tile4.nactive())
                            tree1 = (int) tile4.type;
                          if (tile5 != null && tile5.nactive())
                            tree2 = (int) tile5.type;
                          if (tile6 != null && tile6.nactive())
                            tree3 = (int) tile6.type;
                          if (tile7 != null && tile7.nactive())
                            tree4 = (int) tile7.type;
                          if (tile8 != null && tile8.nactive())
                            tree5 = (int) tile8.type;
                          if (tile9 != null && tile9.nactive())
                            tree6 = (int) tile9.type;
                          if (index2 >= 0 && Main.tileSolid[index2] && (!Main.tileNoAttach[index2] && !tile3.halfBrick()) && (tile3.slope() == (byte) 0 || tile3.bottomSlope()))
                          {
                            tile1.frameX = (short) 0;
                            return;
                          }
                          if (tree1 >= 0 && Main.tileSolid[tree1] && !Main.tileNoAttach[tree1] && ((tile4.leftSlope() || tile4.slope() == (byte) 0) && !tile4.halfBrick()) || (tree1 >= 0 && TileID.Sets.IsBeam[tree1] || WorldGen.IsTreeType(tree1) && WorldGen.IsTreeType(tree5) && WorldGen.IsTreeType(tree3)))
                          {
                            tile1.frameX = (short) 18;
                            return;
                          }
                          if (tree2 >= 0 && Main.tileSolid[tree2] && !Main.tileNoAttach[tree2] && ((tile5.rightSlope() || tile5.slope() == (byte) 0) && !tile5.halfBrick()) || (tree2 >= 0 && TileID.Sets.IsBeam[tree2] || WorldGen.IsTreeType(tree2) && WorldGen.IsTreeType(tree6) && WorldGen.IsTreeType(tree4)))
                          {
                            tile1.frameX = (short) 36;
                            return;
                          }
                          if (tile1.wall > (ushort) 0)
                          {
                            tile1.frameX = (short) 54;
                            return;
                          }
                          WorldGen.KillTile(i, j, false, false, false);
                          return;
                        case 442:
                          WorldGen.CheckProjectilePressurePad(i, j);
                          return;
                        case 518:
                          WorldGen.CheckLilyPad(i, j);
                          return;
                        case 519:
                          WorldGen.CheckCatTail(i, j);
                          return;
                        case 549:
                          WorldGen.CheckUnderwaterPlant((ushort) 549, i, j);
                          return;
                        case 571:
                          WorldGen.CheckBamboo(i, j);
                          return;
                        default:
                          if (index1 == 129 || index1 == 149)
                          {
                            Tile tile10 = Main.tile[i, j - 1];
                            Tile tile11 = Main.tile[i, j + 1];
                            Tile tile12 = Main.tile[i - 1, j];
                            Tile tile13 = Main.tile[i + 1, j];
                            int index3 = -1;
                            int index4 = -1;
                            int index5 = -1;
                            int index6 = -1;
                            if (tile10 != null && tile10.nactive() && !tile10.bottomSlope())
                              index4 = (int) tile10.type;
                            if (tile11 != null && tile11.nactive() && (!tile11.halfBrick() && !tile11.topSlope()))
                              index3 = (int) tile11.type;
                            if (tile12 != null && tile12.nactive())
                              index5 = (int) tile12.type;
                            if (tile13 != null && tile13.nactive())
                              index6 = (int) tile13.type;
                            if (index3 >= 0 && Main.tileSolid[index3] && !Main.tileSolidTop[index3])
                            {
                              tile1.frameY = (short) 0;
                              return;
                            }
                            if (index5 >= 0 && Main.tileSolid[index5] && !Main.tileSolidTop[index5])
                            {
                              tile1.frameY = (short) 54;
                              return;
                            }
                            if (index6 >= 0 && Main.tileSolid[index6] && !Main.tileSolidTop[index6])
                            {
                              tile1.frameY = (short) 36;
                              return;
                            }
                            if (index4 >= 0 && Main.tileSolid[index4] && !Main.tileSolidTop[index4])
                            {
                              tile1.frameY = (short) 18;
                              return;
                            }
                            WorldGen.KillTile(i, j, false, false, false);
                            return;
                          }
                          if (index1 >= 373 && index1 <= 375 || index1 == 461)
                          {
                            Tile tile10 = Main.tile[i, j - 1];
                            if (tile10 != null && tile10.active() && (!tile10.bottomSlope() && Main.tileSolid[(int) tile10.type]) && !Main.tileSolidTop[(int) tile10.type])
                              return;
                            WorldGen.KillTile(i, j, false, false, false);
                            return;
                          }
                          switch (index1)
                          {
                            case 178:
                              Tile tile14 = Main.tile[i, j - 1];
                              Tile tile15 = Main.tile[i, j + 1];
                              Tile tile16 = Main.tile[i - 1, j];
                              Tile tile17 = Main.tile[i + 1, j];
                              int index7 = -1;
                              int index8 = -1;
                              int index9 = -1;
                              int index10 = -1;
                              if (tile14 != null && tile14.nactive() && !tile14.bottomSlope())
                                index8 = (int) tile14.type;
                              if (tile15 != null && tile15.nactive() && (!tile15.halfBrick() && !tile15.topSlope()))
                                index7 = (int) tile15.type;
                              if (tile16 != null && tile16.nactive() && (!tile16.halfBrick() && !tile16.rightSlope()))
                                index9 = (int) tile16.type;
                              if (tile17 != null && tile17.nactive() && (!tile17.halfBrick() && !tile17.leftSlope()))
                                index10 = (int) tile17.type;
                              if (index9 == 10)
                                index9 = -1;
                              if (index10 == 10)
                                index10 = -1;
                              short num1 = (short) (WorldGen.genRand.Next(3) * 18);
                              if (index7 >= 0 && Main.tileSolid[index7] && !Main.tileSolidTop[index7])
                              {
                                if (tile1.frameY >= (short) 0 && tile1.frameY <= (short) 36)
                                  return;
                                tile1.frameY = num1;
                                return;
                              }
                              if (index9 >= 0 && Main.tileSolid[index9] && !Main.tileSolidTop[index9])
                              {
                                if (tile1.frameY >= (short) 108 && tile1.frameY <= (short) 54)
                                  return;
                                tile1.frameY = (short) (108 + (int) num1);
                                return;
                              }
                              if (index10 >= 0 && Main.tileSolid[index10] && !Main.tileSolidTop[index10])
                              {
                                if (tile1.frameY >= (short) 162 && tile1.frameY <= (short) 198)
                                  return;
                                tile1.frameY = (short) (162 + (int) num1);
                                return;
                              }
                              if (index8 >= 0 && Main.tileSolid[index8] && !Main.tileSolidTop[index8])
                              {
                                if (tile1.frameY >= (short) 54 && tile1.frameY <= (short) 90)
                                  return;
                                tile1.frameY = (short) (54 + (int) num1);
                                return;
                              }
                              WorldGen.KillTile(i, j, false, false, false);
                              return;
                            case 184:
                              Tile tile18 = Main.tile[i, j - 1];
                              Tile tile19 = Main.tile[i, j + 1];
                              Tile tile20 = Main.tile[i - 1, j];
                              Tile tile21 = Main.tile[i + 1, j];
                              int tileType1 = -1;
                              int tileType2 = -1;
                              int tileType3 = -1;
                              int tileType4 = -1;
                              if (tile18 != null && tile18.active() && !tile18.bottomSlope())
                                tileType2 = (int) tile18.type;
                              if (tile19 != null && tile19.active() && (!tile19.halfBrick() && !tile19.topSlope()))
                                tileType1 = (int) tile19.type;
                              if (tile20 != null && tile20.active())
                                tileType3 = (int) tile20.type;
                              if (tile21 != null && tile21.active())
                                tileType4 = (int) tile21.type;
                              short num2 = (short) (WorldGen.genRand.Next(3) * 18);
                              if (tileType1 >= 0 && WorldGen.GetTileMossColor(tileType1) != -1)
                              {
                                tile1.frameX = (short) (22 * WorldGen.GetTileMossColor(tileType1));
                                if (tile1.frameY >= (short) 0 && tile1.frameY <= (short) 36)
                                  return;
                                tile1.frameY = num2;
                                return;
                              }
                              if (tileType2 >= 0 && WorldGen.GetTileMossColor(tileType2) != -1)
                              {
                                tile1.frameX = (short) (22 * WorldGen.GetTileMossColor(tileType2));
                                if (tile1.frameY >= (short) 54 && tile1.frameY <= (short) 90)
                                  return;
                                tile1.frameY = (short) (54 + (int) num2);
                                return;
                              }
                              if (tileType3 >= 0 && WorldGen.GetTileMossColor(tileType3) != -1)
                              {
                                tile1.frameX = (short) (22 * WorldGen.GetTileMossColor(tileType3));
                                if (tile1.frameY >= (short) 108 && tile1.frameY <= (short) 54)
                                  return;
                                tile1.frameY = (short) (108 + (int) num2);
                                return;
                              }
                              if (tileType4 >= 0 && WorldGen.GetTileMossColor(tileType4) != -1)
                              {
                                tile1.frameX = (short) (22 * WorldGen.GetTileMossColor(tileType4));
                                if (tile1.frameY >= (short) 162 && tile1.frameY <= (short) 198)
                                  return;
                                tile1.frameY = (short) (162 + (int) num2);
                                return;
                              }
                              WorldGen.KillTile(i, j, false, false, false);
                              return;
                            case 529:
                              if (!WorldGen.SolidTileAllowBottomSlope(i, j + 1))
                              {
                                WorldGen.KillTile(i, j, false, false, false);
                                return;
                              }
                              int num3 = (int) Main.tile[i, j].frameY / 34;
                              if (TileID.Sets.Conversion.Sand[(int) Main.tile[i, j + 1].type])
                                return;
                              WorldGen.KillTile(i, j, false, false, false);
                              return;
                            default:
                              if (index1 == 3 || index1 == 24 || (index1 == 61 || index1 == 71) || (index1 == 73 || index1 == 74 || (index1 == 110 || index1 == 113)) || index1 == 201)
                              {
                                WorldGen.PlantCheck(i, j);
                                return;
                              }
                              if (index1 == 227)
                              {
                                WorldGen.CheckDye(i, j);
                                return;
                              }
                              if (index1 == 579)
                              {
                                WorldGen.CheckRockGolemHead(i, j);
                                return;
                              }
                              if (index1 == 12 || index1 == 31)
                              {
                                WorldGen.CheckOrb(i, j, index1);
                                return;
                              }
                              switch (index1)
                              {
                                case 165:
                                  WorldGen.CheckTight(i, j);
                                  return;
                                case 185:
                                  WorldGen.CheckPile(i, j);
                                  return;
                                case 235:
                                  WorldGen.Check3x1(i, j, index1);
                                  return;
                                case 324:
                                  if (WorldGen.SolidTileAllowBottomSlope(i, j + 1))
                                    return;
                                  WorldGen.KillTile(i, j, false, false, false);
                                  return;
                                default:
                                  if (index1 >= 275 && index1 <= 281 || (index1 == 296 || index1 == 297) || (index1 == 309 || index1 == 358 || (index1 == 359 || index1 == 413)) || (index1 == 414 || index1 == 542 || (index1 == 550 || index1 == 551) || (index1 == 553 || index1 == 554 || (index1 == 558 || index1 == 559))) || (index1 == 599 || index1 == 600 || (index1 == 601 || index1 == 602) || (index1 == 603 || index1 == 604 || (index1 == 605 || index1 == 606)) || (index1 == 607 || index1 == 608 || (index1 == 609 || index1 == 610) || (index1 == 611 || index1 == 612))))
                                  {
                                    WorldGen.Check6x3(i, j, index1);
                                    return;
                                  }
                                  switch (index1)
                                  {
                                    case 10:
                                      WorldGen.CheckDoorClosed(i, j, tile1, index1);
                                      return;
                                    case 11:
                                      WorldGen.CheckDoorOpen(i, j, tile1);
                                      return;
                                    case 314:
                                      Minecart.FrameTrack(i, j, false, false);
                                      return;
                                    case 380:
                                      Tile tile22 = Main.tile[i - 1, j];
                                      if (tile22 == null)
                                        return;
                                      Tile tile23 = Main.tile[i + 1, j];
                                      if (tile23 == null || Main.tile[i - 1, j + 1] == null || (Main.tile[i + 1, j + 1] == null || Main.tile[i - 1, j - 1] == null) || Main.tile[i + 1, j - 1] == null)
                                        return;
                                      int index11 = -1;
                                      int index12 = -1;
                                      if (tile22 != null && tile22.active())
                                        index12 = !Main.tileStone[(int) tile22.type] ? (int) tile22.type : 1;
                                      if (tile23 != null && tile23.active())
                                        index11 = !Main.tileStone[(int) tile23.type] ? (int) tile23.type : 1;
                                      if (index11 >= 0 && !Main.tileSolid[index11])
                                        index11 = -1;
                                      if (index12 >= 0 && !Main.tileSolid[index12])
                                        index12 = -1;
                                      rectangle.X = index12 != index1 || index11 != index1 ? (index12 != index1 || index11 == index1 ? (index12 == index1 || index11 != index1 ? 54 : 0) : 36) : 18;
                                      tile1.frameX = (short) rectangle.X;
                                      return;
                                    default:
                                      if (index1 >= 0 && TileID.Sets.Platforms[index1])
                                      {
                                        Tile tile10 = Main.tile[i - 1, j];
                                        if (tile10 == null)
                                          return;
                                        Tile tile11 = Main.tile[i + 1, j];
                                        if (tile11 == null)
                                          return;
                                        Tile tile12 = Main.tile[i - 1, j + 1];
                                        if (tile12 == null)
                                          return;
                                        Tile tile13 = Main.tile[i + 1, j + 1];
                                        if (tile13 == null)
                                          return;
                                        Tile tile24 = Main.tile[i - 1, j - 1];
                                        if (tile24 == null)
                                          return;
                                        Tile tile25 = Main.tile[i + 1, j - 1];
                                        if (tile25 == null)
                                          return;
                                        int index3 = -1;
                                        int index4 = -1;
                                        if (tile10 != null && tile10.active())
                                          index4 = !Main.tileStone[(int) tile10.type] ? (!TileID.Sets.Platforms[(int) tile10.type] ? (int) tile10.type : index1) : 1;
                                        if (tile11 != null && tile11.active())
                                          index3 = !Main.tileStone[(int) tile11.type] ? (!TileID.Sets.Platforms[(int) tile11.type] ? (int) tile11.type : index1) : 1;
                                        if (index3 >= 0 && !Main.tileSolid[index3])
                                          index3 = -1;
                                        if (index4 >= 0 && !Main.tileSolid[index4])
                                          index4 = -1;
                                        if (index4 == index1 && tile10.halfBrick() != tile1.halfBrick())
                                          index4 = -1;
                                        if (index3 == index1 && tile11.halfBrick() != tile1.halfBrick())
                                          index3 = -1;
                                        if (index4 != -1 && index4 != index1 && tile1.halfBrick())
                                          index4 = -1;
                                        if (index3 != -1 && index3 != index1 && tile1.halfBrick())
                                          index3 = -1;
                                        if (index4 == -1 && tile24.active() && ((int) tile24.type == index1 && tile24.slope() == (byte) 1))
                                          index4 = index1;
                                        if (index3 == -1 && tile25.active() && ((int) tile25.type == index1 && tile25.slope() == (byte) 2))
                                          index3 = index1;
                                        if (index4 == index1 && tile10.slope() == (byte) 2 && index3 != index1)
                                          index3 = -1;
                                        if (index3 == index1 && tile11.slope() == (byte) 1 && index4 != index1)
                                          index4 = -1;
                                        rectangle.X = tile1.slope() != (byte) 1 ? (tile1.slope() != (byte) 2 ? (index4 != index1 || index3 != index1 ? (index4 != index1 || index3 != -1 ? (index4 != -1 || index3 != index1 ? (index4 == index1 || index3 != index1 ? (index4 != index1 || index3 == index1 ? (index4 == index1 || index4 == -1 || index3 != -1 ? (index4 != -1 || index3 == index1 || index3 == -1 ? 90 : 126) : 108) : 72) : 54) : (tile11.slope() != (byte) 1 ? 36 : 288)) : (tile10.slope() != (byte) 2 ? 18 : 270)) : (tile10.slope() != (byte) 2 || tile11.slope() != (byte) 1 ? (tile10.slope() != (byte) 2 ? (tile11.slope() != (byte) 1 ? 0 : 234) : 216) : 252)) : (!TileID.Sets.Platforms[(int) tile10.type] || tile10.slope() != (byte) 0 || tile10.halfBrick() ? (tile12.active() || TileID.Sets.Platforms[(int) tile12.type] && tile12.slope() != (byte) 1 ? (tile11.active() || TileID.Sets.Platforms[(int) tile25.type] && tile25.slope() == (byte) 2 ? 144 : 378) : (tile11.active() || TileID.Sets.Platforms[(int) tile25.type] && tile25.slope() == (byte) 2 ? 342 : 414)) : 450)) : (!TileID.Sets.Platforms[(int) tile11.type] || tile11.slope() != (byte) 0 || tile11.halfBrick() ? (tile13.active() || TileID.Sets.Platforms[(int) tile13.type] && tile13.slope() != (byte) 2 ? (tile10.active() || TileID.Sets.Platforms[(int) tile24.type] && tile24.slope() == (byte) 1 ? 180 : 396) : (tile10.active() || TileID.Sets.Platforms[(int) tile24.type] && tile24.slope() == (byte) 1 ? 360 : 432)) : 468);
                                        tile1.frameX = (short) rectangle.X;
                                        return;
                                      }
                                      if (index1 == 233 || index1 == 236 || index1 == 238)
                                      {
                                        WorldGen.CheckJunglePlant(i, j, index1);
                                        return;
                                      }
                                      if (index1 == 530)
                                      {
                                        WorldGen.CheckOasisPlant(i, j, 530);
                                        return;
                                      }
                                      if (index1 == 240 || index1 == 440)
                                      {
                                        WorldGen.Check3x3Wall(i, j);
                                        return;
                                      }
                                      switch (index1)
                                      {
                                        case 241:
                                          WorldGen.Check4x3Wall(i, j);
                                          return;
                                        case 242:
                                          WorldGen.Check6x4Wall(i, j);
                                          return;
                                        case 245:
                                          WorldGen.Check2x3Wall(i, j);
                                          return;
                                        case 246:
                                          WorldGen.Check3x2Wall(i, j);
                                          return;
                                        default:
                                          if (index1 == 464 || index1 == 466)
                                          {
                                            WorldGen.Check5x4(i, j, index1);
                                            return;
                                          }
                                          if (index1 == 334)
                                          {
                                            WorldGen.CheckWeaponsRack(i, j);
                                            return;
                                          }
                                          if (index1 == 471)
                                          {
                                            TEWeaponsRack.Framing_CheckTile(i, j);
                                            return;
                                          }
                                          if (index1 == 34 || index1 == 454)
                                          {
                                            WorldGen.CheckChand(i, j, index1);
                                            return;
                                          }
                                          if (index1 == 547)
                                          {
                                            WorldGen.Check2x5(i, j, index1);
                                            return;
                                          }
                                          if (index1 == 548 || index1 == 614)
                                          {
                                            WorldGen.Check3x6(i, j, index1);
                                            return;
                                          }
                                          if (index1 == 613)
                                          {
                                            WorldGen.Check3x5(i, j, index1);
                                            return;
                                          }
                                          if (index1 == 106 || index1 == 212 || (index1 == 219 || index1 == 220) || (index1 == 228 || index1 == 231 || (index1 == 243 || index1 == 247)) || (index1 == 283 || index1 >= 300 && index1 <= 308 || (index1 == 354 || index1 == 406 || (index1 == 412 || index1 == 355))) || (index1 == 452 || index1 == 455 || (index1 == 491 || index1 == 499)))
                                          {
                                            WorldGen.Check3x3(i, j, (int) (ushort) index1);
                                            return;
                                          }
                                          if (index1 == 15 || index1 == 497 || (index1 == 20 || index1 == 590) || (index1 == 216 || index1 == 338 || (index1 == 390 || index1 == 493)) || (index1 == 595 || index1 == 615))
                                          {
                                            WorldGen.Check1x2(i, j, (ushort) index1);
                                            return;
                                          }
                                          if (index1 == 14 || index1 == 469 || (index1 == 17 || index1 == 26) || (index1 == 77 || index1 == 86 || (index1 == 87 || index1 == 377)) || (index1 == 88 || index1 == 89 || (index1 == 114 || index1 == 133) || (index1 == 186 || index1 == 187 || (index1 == 215 || index1 == 217))) || (index1 == 218 || index1 == 237 || (index1 == 244 || index1 == 285) || (index1 == 286 || index1 == 298 || (index1 == 299 || index1 == 310)) || (index1 == 339 || index1 == 538 || index1 >= 361 && index1 <= 364 || (index1 >= 391 && index1 <= 394 || (index1 == 405 || index1 == 486)))) || (index1 == 488 || index1 == 532 || (index1 == 544 || index1 == 533) || (index1 == 552 || index1 == 555 || (index1 == 556 || index1 == 582)) || index1 == 619))
                                          {
                                            WorldGen.Check3x2(i, j, (int) (ushort) index1);
                                            return;
                                          }
                                          if (index1 == 135 || index1 == 144 || (index1 == 141 || index1 == 210) || (index1 == 239 || index1 == 36 || (index1 == 428 || index1 == 593)))
                                          {
                                            WorldGen.Check1x1(i, j, index1);
                                            return;
                                          }
                                          if (index1 == 476)
                                          {
                                            WorldGen.CheckGolf1x1(i, j, index1);
                                            return;
                                          }
                                          if (index1 == 494)
                                          {
                                            WorldGen.CheckGolf1x1(i, j, index1);
                                            return;
                                          }
                                          if (index1 == 419 || index1 == 420 || (index1 == 423 || index1 == 424) || (index1 == 429 || index1 == 445))
                                          {
                                            WorldGen.CheckLogicTiles(i, j, index1);
                                            return;
                                          }
                                          if (index1 == 16 || index1 == 18 || (index1 == 29 || index1 == 103) || (index1 == 134 || index1 == 462))
                                          {
                                            WorldGen.Check2x1(i, j, (ushort) index1);
                                            return;
                                          }
                                          if (index1 == 13 || index1 == 33 || (index1 == 50 || index1 == 78) || (index1 == 174 || index1 == 372 || index1 == 49))
                                          {
                                            WorldGen.CheckOnTable1x1(i, j, index1);
                                            return;
                                          }
                                          if (TileID.Sets.BasicChest[index1])
                                          {
                                            WorldGen.CheckChest(i, j, index1);
                                            return;
                                          }
                                          switch (index1)
                                          {
                                            case 27:
                                              WorldGen.CheckSunflower(i, j, 27);
                                              return;
                                            case 28:
                                              WorldGen.CheckPot(i, j, 28);
                                              return;
                                            case 128:
                                              WorldGen.CheckMan(i, j);
                                              return;
                                            case 171:
                                              WorldGen.CheckXmasTree(i, j);
                                              return;
                                            case 254:
                                              WorldGen.Check2x2Style(i, j, index1);
                                              return;
                                            case 269:
                                              WorldGen.CheckWoman(i, j);
                                              return;
                                            case 470:
                                              TEDisplayDoll.Framing_CheckTile(i, j);
                                              return;
                                            case 475:
                                              TEHatRack.Framing_CheckTile(i, j);
                                              return;
                                            case 597:
                                              TETeleportationPylon.Framing_CheckTile(i, j);
                                              return;
                                            default:
                                              if (!TileID.Sets.BasicChestFake[index1] && index1 != 457)
                                              {
                                                if (index1 == 335 || index1 == 411 || (index1 == 490 || index1 == 564) || (index1 == 565 || index1 == 594))
                                                {
                                                  WorldGen.Check2x2(i, j, index1);
                                                  return;
                                                }
                                                if (index1 == 132 || index1 == 138 || (index1 == 484 || index1 == 142) || (index1 == 143 || index1 >= 288 && index1 <= 295) || (index1 >= 316 && index1 <= 318 || (index1 == 172 || index1 == 360) || (index1 == 505 || index1 == 521 || (index1 == 522 || index1 == 523))) || (index1 == 524 || index1 == 525 || (index1 == 526 || index1 == 527) || (index1 == 543 || index1 == 568 || (index1 == 569 || index1 == 570)) || (index1 == 580 || index1 == 598 || index1 == 620)))
                                                {
                                                  WorldGen.Check2x2(i, j, index1);
                                                  return;
                                                }
                                                if (index1 == 376 || index1 == 443 || (index1 == 444 || index1 == 485))
                                                {
                                                  WorldGen.CheckSuper(i, j, index1);
                                                  return;
                                                }
                                                if (index1 == 91)
                                                {
                                                  WorldGen.CheckBanner(i, j, (byte) index1);
                                                  return;
                                                }
                                                if (index1 == 139 || index1 == 35)
                                                {
                                                  WorldGen.CheckMB(i, j, (int) (byte) index1);
                                                  return;
                                                }
                                                if (index1 == 386 || index1 == 387)
                                                {
                                                  WorldGen.CheckTrapDoor(i, j, index1);
                                                  return;
                                                }
                                                if (index1 == 389 || index1 == 388)
                                                {
                                                  WorldGen.CheckTallGate(i, j, index1);
                                                  return;
                                                }
                                                if (index1 == 92 || index1 == 93 || index1 == 453)
                                                {
                                                  WorldGen.Check1xX(i, j, (short) index1);
                                                  return;
                                                }
                                                if (index1 == 104 || index1 == 105 || (index1 == 207 || index1 == 320) || (index1 == 337 || index1 == 349 || (index1 == 356 || index1 == 378)) || (index1 == 410 || index1 == 456 || (index1 == 465 || index1 == 480) || (index1 == 489 || index1 == 506 || (index1 == 509 || index1 == 531))) || (index1 == 545 || index1 == 560 || (index1 == 591 || index1 == 592)))
                                                {
                                                  WorldGen.Check2xX(i, j, (ushort) index1);
                                                  return;
                                                }
                                                if (index1 == 101 || index1 == 102 || (index1 == 463 || index1 == 617))
                                                {
                                                  WorldGen.Check3x4(i, j, index1);
                                                  return;
                                                }
                                                if (index1 == 42 || index1 == 270 || (index1 == 271 || index1 == 572) || index1 == 581)
                                                {
                                                  WorldGen.Check1x2Top(i, j, (ushort) index1);
                                                  return;
                                                }
                                                if (index1 == 55 || index1 == 85 || (index1 == 395 || index1 == 425) || (index1 == 510 || index1 == 511 || index1 == 573))
                                                {
                                                  WorldGen.CheckSign(i, j, (ushort) index1);
                                                  return;
                                                }
                                                if (index1 == 520)
                                                {
                                                  WorldGen.CheckFoodPlatter(i, j, (int) (ushort) index1);
                                                  return;
                                                }
                                                if (index1 == 209)
                                                {
                                                  WorldGen.CheckCannon(i, j, index1);
                                                  return;
                                                }
                                                if (index1 == 79 || index1 == 90 || index1 == 487)
                                                {
                                                  WorldGen.Check4x2(i, j, index1);
                                                  return;
                                                }
                                                if (index1 == 94 || index1 == 95 || (index1 == 97 || index1 == 319) || (index1 == 98 || index1 == 99 || (index1 == 100 || index1 == 125)) || (index1 == 126 || index1 == 173 || (index1 == 282 || index1 == 287) || (index1 == 621 || index1 == 622)))
                                                {
                                                  WorldGen.Check2x2(i, j, index1);
                                                  return;
                                                }
                                                switch (index1)
                                                {
                                                  case 81:
                                                    Tile tile10 = Main.tile[i, j - 1];
                                                    Tile tile11 = Main.tile[i, j + 1];
                                                    Tile tile12 = Main.tile[i - 1, j];
                                                    Tile tile13 = Main.tile[i + 1, j];
                                                    int index3 = -1;
                                                    int num4 = -1;
                                                    if (tile10 != null && tile10.active())
                                                      num4 = (int) tile10.type;
                                                    if (tile11 != null && tile11.active())
                                                      index3 = (int) tile11.type;
                                                    if (num4 != -1)
                                                    {
                                                      WorldGen.KillTile(i, j, false, false, false);
                                                      return;
                                                    }
                                                    if (index3 >= 0 && Main.tileSolid[index3] && (!tile11.halfBrick() && !tile11.topSlope()))
                                                      return;
                                                    WorldGen.KillTile(i, j, false, false, false);
                                                    return;
                                                  case 96:
                                                    WorldGen.Check2x2Style(i, j, index1);
                                                    return;
                                                  default:
                                                    if (Main.tileAlch[index1])
                                                    {
                                                      WorldGen.CheckAlch(i, j);
                                                      return;
                                                    }
                                                    switch (index1)
                                                    {
                                                      case 5:
                                                        WorldGen.CheckTree(i, j);
                                                        return;
                                                      case 72:
                                                        Tile tile24 = Main.tile[i, j - 1];
                                                        Tile tile25 = Main.tile[i, j + 1];
                                                        int num5 = -1;
                                                        int num6 = -1;
                                                        if (tile24 != null && tile24.active())
                                                          num6 = (int) tile24.type;
                                                        if (tile25 != null && tile25.active())
                                                          num5 = (int) tile25.type;
                                                        if (num5 != index1 && num5 != 70)
                                                        {
                                                          WorldGen.KillTile(i, j, false, false, false);
                                                          return;
                                                        }
                                                        if (num6 == index1 || tile1.frameX != (short) 0)
                                                          return;
                                                        tile1.frameNumber((byte) WorldGen.genRand.Next(3));
                                                        if (tile1.frameNumber() == (byte) 0)
                                                        {
                                                          tile1.frameX = (short) 18;
                                                          tile1.frameY = (short) 0;
                                                        }
                                                        if (tile1.frameNumber() == (byte) 1)
                                                        {
                                                          tile1.frameX = (short) 18;
                                                          tile1.frameY = (short) 18;
                                                        }
                                                        if (tile1.frameNumber() != (byte) 2)
                                                          return;
                                                        tile1.frameX = (short) 18;
                                                        tile1.frameY = (short) 36;
                                                        return;
                                                      case 323:
                                                        WorldGen.CheckPalmTree(i, j);
                                                        return;
                                                      case 567:
                                                        WorldGen.CheckGnome(i, j);
                                                        return;
                                                      case 583:
                                                      case 584:
                                                      case 585:
                                                      case 586:
                                                      case 587:
                                                      case 588:
                                                      case 589:
                                                        WorldGen.CheckTreeWithSettings(i, j, new WorldGen.CheckTreeSettings()
                                                        {
                                                          IsGroundValid = new WorldGen.CheckTreeSettings.GroundValidTest(WorldGen.GemTreeGroundTest)
                                                        });
                                                        return;
                                                      case 596:
                                                        WorldGen.CheckTreeWithSettings(i, j, new WorldGen.CheckTreeSettings()
                                                        {
                                                          IsGroundValid = new WorldGen.CheckTreeSettings.GroundValidTest(WorldGen.VanityTreeGroundTest)
                                                        });
                                                        return;
                                                      case 616:
                                                        WorldGen.CheckTreeWithSettings(i, j, new WorldGen.CheckTreeSettings()
                                                        {
                                                          IsGroundValid = new WorldGen.CheckTreeSettings.GroundValidTest(WorldGen.VanityTreeGroundTest)
                                                        });
                                                        return;
                                                      default:
                                                        return;
                                                    }
                                                }
                                              }
                                              else
                                                goto case 254;
                                          }
                                      }
                                  }
                              }
                          }
                      }
                    }
                    else
                    {
                      if (index1 >= (int) byte.MaxValue && index1 <= 268 || index1 == 385 || index1 >= 446 && index1 <= 448)
                      {
                        Framing.SelfFrame8Way(i, j, tile1, resetFrame);
                        return;
                      }
                      Tile tileTopCache = Main.tile[i, j - 1];
                      Tile tile10 = Main.tile[i, j + 1];
                      Tile tile11 = Main.tile[i - 1, j];
                      Tile tile12 = Main.tile[i + 1, j];
                      Tile tile13 = Main.tile[i - 1, j + 1];
                      Tile tile24 = Main.tile[i + 1, j + 1];
                      Tile tile25 = Main.tile[i - 1, j - 1];
                      Tile tile26 = Main.tile[i + 1, j - 1];
                      int upLeft = -1;
                      int up = -1;
                      int upRight = -1;
                      int left = -1;
                      int right = -1;
                      int downLeft = -1;
                      int down = -1;
                      int downRight = -1;
                      if (tile11 != null && tile11.active())
                      {
                        left = !Main.tileStone[(int) tile11.type] ? (int) tile11.type : 1;
                        if (tile11.slope() == (byte) 1 || tile11.slope() == (byte) 3)
                          left = -1;
                      }
                      if (tile12 != null && tile12.active())
                      {
                        right = !Main.tileStone[(int) tile12.type] ? (int) tile12.type : 1;
                        if (tile12.slope() == (byte) 2 || tile12.slope() == (byte) 4)
                          right = -1;
                      }
                      if (tileTopCache != null && tileTopCache.active())
                      {
                        up = !Main.tileStone[(int) tileTopCache.type] ? (int) tileTopCache.type : 1;
                        if (tileTopCache.slope() == (byte) 3 || tileTopCache.slope() == (byte) 4)
                          up = -1;
                      }
                      if (tile10 != null && tile10.active())
                      {
                        down = !Main.tileStone[(int) tile10.type] ? (int) tile10.type : 1;
                        if (tile10.slope() == (byte) 1 || tile10.slope() == (byte) 2)
                          down = -1;
                      }
                      if (tile25 != null && tile25.active())
                        upLeft = !Main.tileStone[(int) tile25.type] ? (int) tile25.type : 1;
                      if (tile26 != null && tile26.active())
                        upRight = !Main.tileStone[(int) tile26.type] ? (int) tile26.type : 1;
                      if (tile13 != null && tile13.active())
                        downLeft = !Main.tileStone[(int) tile13.type] ? (int) tile13.type : 1;
                      if (tile24 != null && tile24.active())
                        downRight = !Main.tileStone[(int) tile24.type] ? (int) tile24.type : 1;
                      if (tile1.slope() == (byte) 2)
                      {
                        up = -1;
                        left = -1;
                      }
                      if (tile1.slope() == (byte) 1)
                      {
                        up = -1;
                        right = -1;
                      }
                      if (tile1.slope() == (byte) 4)
                      {
                        down = -1;
                        left = -1;
                      }
                      if (tile1.slope() == (byte) 3)
                      {
                        down = -1;
                        right = -1;
                      }
                      switch (index1)
                      {
                        case 147:
                          WorldGen.TileMergeAttempt(index1, Main.tileBrick, TileID.Sets.Ices, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                          break;
                        case 161:
                        case 163:
                        case 164:
                        case 200:
                          WorldGen.TileMergeAttempt(index1, Main.tileBrick, TileID.Sets.Snow, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                          break;
                        case 162:
                          WorldGen.TileMergeAttempt(index1, Main.tileBrick, TileID.Sets.IcesSnow, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                          break;
                        default:
                          if (Main.tileBrick[index1])
                          {
                            if (index1 == 60 || index1 == 70)
                            {
                              WorldGen.TileMergeAttempt(index1, Main.tileBrick, TileID.Sets.Mud, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                              break;
                            }
                            WorldGen.TileMergeAttempt(index1, Main.tileBrick, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                            break;
                          }
                          if (Main.tilePile[index1])
                          {
                            WorldGen.TileMergeAttempt(index1, Main.tilePile, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                            break;
                          }
                          break;
                      }
                      if ((index1 == 1 || Main.tileMoss[index1] || (index1 == 117 || index1 == 25) || index1 == 203) && down == 165)
                      {
                        if (tile10.frameY == (short) 72)
                          down = index1;
                        else if (tile10.frameY == (short) 0)
                          down = index1;
                      }
                      if ((index1 == 1 || Main.tileMoss[index1] || (index1 == 117 || index1 == 25) || index1 == 203) && up == 165)
                      {
                        if (tileTopCache.frameY == (short) 90)
                          up = index1;
                        else if (tileTopCache.frameY == (short) 54)
                          up = index1;
                      }
                      if (index1 == 225)
                      {
                        if (down == 165)
                          down = index1;
                        if (up == 165)
                          up = index1;
                      }
                      if ((index1 == 200 || index1 == 161 || (index1 == 147 || index1 == 163) || index1 == 164) && down == 165)
                        down = index1;
                      if ((tile1.slope() == (byte) 1 || tile1.slope() == (byte) 2) && (down > -1 && !TileID.Sets.Platforms[down]))
                        down = index1;
                      if (up > -1 && (tileTopCache.slope() == (byte) 1 || tileTopCache.slope() == (byte) 2) && !TileID.Sets.Platforms[up])
                        up = index1;
                      if ((tile1.slope() == (byte) 3 || tile1.slope() == (byte) 4) && (up > -1 && !TileID.Sets.Platforms[up]))
                        up = index1;
                      if (down > -1 && (tile10.slope() == (byte) 3 || tile10.slope() == (byte) 4) && !TileID.Sets.Platforms[down])
                        down = index1;
                      if (index1 == 124)
                      {
                        if (up > -1 && Main.tileSolid[up] && !TileID.Sets.Platforms[up])
                          up = index1;
                        if (down > -1 && Main.tileSolid[down] && !TileID.Sets.Platforms[down])
                          down = index1;
                      }
                      if (up > -1 && tileTopCache.halfBrick() && !TileID.Sets.Platforms[up])
                        up = index1;
                      if (left > -1 && tile11.halfBrick())
                      {
                        if (tile1.halfBrick())
                          left = index1;
                        else if ((int) tile11.type != index1)
                          left = -1;
                      }
                      if (right > -1 && tile12.halfBrick())
                      {
                        if (tile1.halfBrick())
                          right = index1;
                        else if ((int) tile12.type != index1)
                          right = -1;
                      }
                      if (tile1.halfBrick())
                      {
                        if (left != index1)
                          left = -1;
                        if (right != index1)
                          right = -1;
                        up = -1;
                      }
                      if (tile10 != null && tile10.halfBrick())
                        down = -1;
                      if (!Main.tileSolid[index1])
                      {
                        if (index1 == 49)
                        {
                          WorldGen.CheckOnTable1x1(i, j, (int) (byte) index1);
                          return;
                        }
                        if (index1 == 80)
                        {
                          WorldGen.CactusFrame(i, j);
                          return;
                        }
                      }
                      WorldGen.mergeUp = false;
                      WorldGen.mergeDown = false;
                      WorldGen.mergeLeft = false;
                      WorldGen.mergeRight = false;
                      int num4;
                      if (resetFrame)
                      {
                        num4 = WorldGen.genRand.Next(0, 3);
                        tile1.frameNumber((byte) num4);
                      }
                      else
                        num4 = (int) tile1.frameNumber();
                      if (Main.tileLargeFrames[index1] == (byte) 1)
                        num4 = new int[4, 3]
                        {
                          {
                            2,
                            4,
                            2
                          },
                          {
                            1,
                            3,
                            1
                          },
                          {
                            2,
                            2,
                            4
                          },
                          {
                            1,
                            1,
                            3
                          }
                        }[j % 4, i % 3] - 1;
                      if (Main.tileLargeFrames[index1] == (byte) 2)
                        num4 = i % 2 + j % 2 * 2;
                      WorldGen.TileMergeAttempt(index1, Main.tileBlendAll, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                      if (Main.tileBlendAll[index1])
                      {
                        Main.tileSolid[10] = false;
                        Main.tileSolid[387] = false;
                        WorldGen.TileMergeAttempt(index1, Main.tileSolid, Main.tileSolidTop, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                        Main.tileSolid[10] = true;
                        Main.tileSolid[387] = true;
                      }
                      if (TileID.Sets.ForcedDirtMerging[index1])
                      {
                        if (up == 0)
                          up = index1;
                        if (down == 0)
                          down = index1;
                        if (left == 0)
                          left = index1;
                        if (right == 0)
                          right = index1;
                        if (upLeft == 0)
                          upLeft = index1;
                        if (upRight == 0)
                          upRight = index1;
                        if (downLeft == 0)
                          downLeft = index1;
                        if (downRight == 0)
                          downRight = index1;
                      }
                      switch (index1)
                      {
                        case 0:
                          if (up > -1 && Main.tileMergeDirt[up])
                          {
                            WorldGen.TileFrame(i, j - 1, false, false);
                            if (WorldGen.mergeDown)
                              up = index1;
                          }
                          else if (up == 147)
                          {
                            WorldGen.TileFrame(i, j - 1, false, false);
                            if (WorldGen.mergeDown)
                              up = index1;
                          }
                          if (down > -1 && Main.tileMergeDirt[down])
                          {
                            WorldGen.TileFrame(i, j + 1, false, false);
                            if (WorldGen.mergeUp)
                              down = index1;
                          }
                          else if (down == 147)
                          {
                            WorldGen.TileFrame(i, j + 1, false, false);
                            if (WorldGen.mergeUp)
                              down = index1;
                          }
                          if (left > -1 && Main.tileMergeDirt[left])
                          {
                            WorldGen.TileFrame(i - 1, j, false, false);
                            if (WorldGen.mergeRight)
                              left = index1;
                          }
                          else if (left == 147)
                          {
                            WorldGen.TileFrame(i - 1, j, false, false);
                            if (WorldGen.mergeRight)
                              left = index1;
                          }
                          if (right > -1 && Main.tileMergeDirt[right])
                          {
                            WorldGen.TileFrame(i + 1, j, false, false);
                            if (WorldGen.mergeLeft)
                              right = index1;
                          }
                          else if (right == 147)
                          {
                            WorldGen.TileFrame(i + 1, j, false, false);
                            if (WorldGen.mergeLeft)
                              right = index1;
                          }
                          bool[] dirtInAspecialWay = TileID.Sets.Conversion.MergesWithDirtInASpecialWay;
                          if (up > -1 && dirtInAspecialWay[up])
                            up = index1;
                          if (down > -1 && dirtInAspecialWay[down])
                            down = index1;
                          if (left > -1 && dirtInAspecialWay[left])
                            left = index1;
                          if (right > -1 && dirtInAspecialWay[right])
                            right = index1;
                          if (upLeft > -1 && Main.tileMergeDirt[upLeft])
                            upLeft = index1;
                          else if (upLeft > -1 && dirtInAspecialWay[upLeft])
                            upLeft = index1;
                          if (upRight > -1 && Main.tileMergeDirt[upRight])
                            upRight = index1;
                          else if (upRight > -1 && dirtInAspecialWay[upRight])
                            upRight = index1;
                          if (downLeft > -1 && Main.tileMergeDirt[downLeft])
                            downLeft = index1;
                          else if (downLeft > -1 && dirtInAspecialWay[downLeft])
                            downLeft = index1;
                          if (downRight > -1 && Main.tileMergeDirt[downRight])
                            downRight = index1;
                          else if (downRight > -1 && dirtInAspecialWay[downRight])
                            downRight = index1;
                          WorldGen.TileMergeAttempt(-2, 59, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                          WorldGen.TileMergeAttempt(index1, 191, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                          if (up > -1 && TileID.Sets.ForcedDirtMerging[up])
                            up = index1;
                          if (down > -1 && TileID.Sets.ForcedDirtMerging[down])
                            down = index1;
                          if (left > -1 && TileID.Sets.ForcedDirtMerging[left])
                            left = index1;
                          if (right > -1 && TileID.Sets.ForcedDirtMerging[right])
                            right = index1;
                          if (upLeft > -1 && TileID.Sets.ForcedDirtMerging[upLeft])
                            upLeft = index1;
                          if (upRight > -1 && TileID.Sets.ForcedDirtMerging[upRight])
                            upRight = index1;
                          if (downLeft > -1 && TileID.Sets.ForcedDirtMerging[downLeft])
                            downLeft = index1;
                          if (downRight > -1 && TileID.Sets.ForcedDirtMerging[downRight])
                          {
                            downRight = index1;
                            break;
                          }
                          break;
                        case 53:
                          WorldGen.TileMergeAttemptFrametest(i, j, index1, 397, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                          WorldGen.TileMergeAttemptFrametest(i, j, index1, 396, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                          break;
                        case 112:
                          WorldGen.TileMergeAttemptFrametest(i, j, index1, 398, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                          WorldGen.TileMergeAttemptFrametest(i, j, index1, 400, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                          break;
                        case 116:
                          WorldGen.TileMergeAttemptFrametest(i, j, index1, 402, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                          WorldGen.TileMergeAttemptFrametest(i, j, index1, 403, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                          break;
                        case 213:
                          if (up > -1 && Main.tileSolid[up] && !Main.tileSolidTop[up])
                            up = index1;
                          if (down > -1 && Main.tileSolid[down])
                            down = index1;
                          if (up != index1)
                          {
                            if (left > -1 && Main.tileSolid[left])
                              left = index1;
                            if (right > -1 && Main.tileSolid[right])
                            {
                              right = index1;
                              break;
                            }
                            break;
                          }
                          break;
                        case 234:
                          WorldGen.TileMergeAttemptFrametest(i, j, index1, 399, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                          WorldGen.TileMergeAttemptFrametest(i, j, index1, 401, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                          break;
                      }
                      if (Main.tileMergeDirt[index1])
                      {
                        WorldGen.TileMergeAttempt(-2, 0, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                        if (index1 == 1)
                        {
                          if ((double) j > Main.rockLayer)
                            WorldGen.TileMergeAttemptFrametest(i, j, index1, 59, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                          WorldGen.TileMergeAttemptFrametest(i, j, index1, 57, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                        }
                      }
                      else if (index1 == 58 || index1 == 76 || index1 == 75)
                      {
                        WorldGen.TileMergeAttempt(-2, 57, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                      }
                      else
                      {
                        switch (index1)
                        {
                          case 57:
                            WorldGen.TileMergeAttempt(-2, 1, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                            WorldGen.TileMergeAttemptFrametest(i, j, index1, TileID.Sets.HellSpecial, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                            break;
                          case 59:
                            if ((double) j > Main.rockLayer)
                              WorldGen.TileMergeAttempt(-2, 1, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                            WorldGen.TileMergeAttempt(index1, TileID.Sets.GrassSpecial, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                            WorldGen.TileMergeAttemptFrametest(i, j, index1, TileID.Sets.JungleSpecial, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                            if ((double) j < Main.rockLayer)
                            {
                              WorldGen.TileMergeAttemptFrametest(i, j, index1, 0, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                              break;
                            }
                            WorldGen.TileMergeAttempt(index1, 0, ref up, ref down, ref left, ref right);
                            break;
                          case 211:
                            WorldGen.TileMergeAttempt(59, 60, ref up, ref down, ref left, ref right);
                            WorldGen.TileMergeAttempt(-2, 59, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                            break;
                          default:
                            if (index1 == 225 || index1 == 226)
                            {
                              WorldGen.TileMergeAttempt(-2, 59, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                              break;
                            }
                            switch (index1)
                            {
                              case 60:
                                WorldGen.TileMergeAttempt(59, 211, ref up, ref down, ref left, ref right);
                                break;
                              case 147:
                                WorldGen.TileMergeAttemptFrametest(i, j, index1, TileID.Sets.IcesSlush, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                break;
                              case 189:
                                WorldGen.TileMergeAttemptFrametest(i, j, index1, TileID.Sets.MergesWithClouds, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                break;
                              case 196:
                                WorldGen.TileMergeAttempt(-2, 189, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                WorldGen.TileMergeAttempt(index1, 460, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                break;
                              case 460:
                                WorldGen.TileMergeAttempt(-2, 189, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                WorldGen.TileMergeAttempt(index1, 196, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                break;
                              default:
                                if (index1 == 161 || index1 == 163 || (index1 == 164 || index1 == 200) || index1 == 224)
                                {
                                  WorldGen.TileMergeAttempt(-2, 147, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                  break;
                                }
                                if (index1 == 162)
                                {
                                  WorldGen.TileMergeAttempt(-2, TileID.Sets.IcesSnow, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                  break;
                                }
                                if (index1 == 32)
                                {
                                  if (down == 23)
                                  {
                                    down = index1;
                                    break;
                                  }
                                  break;
                                }
                                if (index1 == 352)
                                {
                                  if (down == 199)
                                  {
                                    down = index1;
                                    break;
                                  }
                                  break;
                                }
                                if (index1 == 69)
                                {
                                  if (down == 60)
                                  {
                                    down = index1;
                                    break;
                                  }
                                  break;
                                }
                                if (index1 == 51)
                                {
                                  WorldGen.TileMergeAttempt(index1, TileID.Sets.AllTiles, Main.tileNoAttach, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                  break;
                                }
                                if (index1 == 192)
                                {
                                  WorldGen.TileMergeAttemptFrametest(i, j, index1, 191, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                  break;
                                }
                                if (index1 == 191)
                                {
                                  WorldGen.TileMergeAttempt(-2, 192, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                  WorldGen.TileMergeAttempt(index1, 0, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                  break;
                                }
                                if (index1 == 384)
                                {
                                  WorldGen.TileMergeAttemptFrametest(i, j, index1, 383, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                  break;
                                }
                                if (index1 == 383)
                                {
                                  WorldGen.TileMergeAttempt(-2, 384, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                  WorldGen.TileMergeAttempt(index1, 59, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                  break;
                                }
                                if (index1 == 407)
                                {
                                  WorldGen.TileMergeAttempt(-2, 404, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                  break;
                                }
                                if (index1 == 404)
                                {
                                  WorldGen.TileMergeAttempt(-2, 396, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                  WorldGen.TileMergeAttemptFrametest(i, j, index1, 407, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                  break;
                                }
                                if (index1 == 397)
                                {
                                  WorldGen.TileMergeAttempt(-2, 53, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                  WorldGen.TileMergeAttemptFrametest(i, j, index1, 396, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                  break;
                                }
                                if (index1 == 396)
                                {
                                  WorldGen.TileMergeAttempt(-2, 397, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                  WorldGen.TileMergeAttempt(-2, 53, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                  WorldGen.TileMergeAttemptFrametest(i, j, index1, 404, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                  break;
                                }
                                if (index1 == 398)
                                {
                                  WorldGen.TileMergeAttempt(-2, 112, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                  WorldGen.TileMergeAttemptFrametest(i, j, index1, 400, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                  break;
                                }
                                if (index1 == 400)
                                {
                                  WorldGen.TileMergeAttempt(-2, 398, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                  WorldGen.TileMergeAttempt(-2, 112, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                  break;
                                }
                                if (index1 == 399)
                                {
                                  WorldGen.TileMergeAttempt(-2, 234, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                  WorldGen.TileMergeAttemptFrametest(i, j, index1, 401, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                  break;
                                }
                                if (index1 == 401)
                                {
                                  WorldGen.TileMergeAttempt(-2, 399, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                  WorldGen.TileMergeAttempt(-2, 234, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                  break;
                                }
                                if (index1 == 402)
                                {
                                  WorldGen.TileMergeAttempt(-2, 116, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                  WorldGen.TileMergeAttemptFrametest(i, j, index1, 403, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                  break;
                                }
                                if (index1 == 403)
                                {
                                  WorldGen.TileMergeAttempt(-2, 402, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                  WorldGen.TileMergeAttempt(-2, 116, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                                  break;
                                }
                                break;
                            }
                            break;
                        }
                      }
                      if (index1 == 0)
                      {
                        WorldGen.TileMergeAttempt(index1, Main.tileMoss, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                        WorldGen.TileMergeAttempt(index1, TileID.Sets.tileMossBrick, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                      }
                      else if (Main.tileMoss[index1] || TileID.Sets.tileMossBrick[index1])
                      {
                        WorldGen.TileMergeAttempt(index1, 0, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                      }
                      else
                      {
                        if (!Main.tileStone[index1])
                        {
                          switch (index1)
                          {
                            case 1:
                              break;
                            case 38:
                              WorldGen.TileMergeAttempt(index1, TileID.Sets.tileMossBrick, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                              goto label_576;
                            default:
                              goto label_576;
                          }
                        }
                        WorldGen.TileMergeAttempt(index1, Main.tileMoss, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                      }
label_576:
                      if (TileID.Sets.Conversion.Grass[index1])
                        WorldGen.TileMergeAttempt(index1, TileID.Sets.Ore, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                      else if (TileID.Sets.Ore[index1])
                        WorldGen.TileMergeAttempt(index1, TileID.Sets.Conversion.Grass, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                      if (index1 == 59)
                        WorldGen.TileMergeAttempt(index1, TileID.Sets.OreMergesWithMud, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                      else if (TileID.Sets.OreMergesWithMud[index1])
                        WorldGen.TileMergeAttempt(index1, 59, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                      bool flag1 = false;
                      if (index1 == 2 || index1 == 23 || (index1 == 60 || index1 == 477) || (index1 == 492 || index1 == 70 || (index1 == 109 || index1 == 199)) || (Main.tileMoss[index1] || TileID.Sets.NeedsGrassFraming[index1] || TileID.Sets.tileMossBrick[index1]))
                      {
                        flag1 = true;
                        WorldGen.TileMergeAttemptWeird(index1, -1, Main.tileSolid, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                        int num5 = TileID.Sets.NeedsGrassFramingDirt[index1];
                        if (index1 == 60 || index1 == 70)
                          num5 = 59;
                        else if (Main.tileMoss[index1])
                          num5 = 1;
                        else if (TileID.Sets.tileMossBrick[index1])
                        {
                          num5 = 38;
                        }
                        else
                        {
                          switch (index1)
                          {
                            case 2:
                            case 477:
                              WorldGen.TileMergeAttempt(num5, 23, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                              break;
                            case 23:
                              WorldGen.TileMergeAttempt(num5, 2, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                              break;
                          }
                        }
                        if (up != index1 && up != num5 && (down == index1 || down == num5))
                        {
                          if (left == num5 && right == index1)
                          {
                            switch (num4)
                            {
                              case 0:
                                rectangle.X = 0;
                                rectangle.Y = 198;
                                break;
                              case 1:
                                rectangle.X = 18;
                                rectangle.Y = 198;
                                break;
                              default:
                                rectangle.X = 36;
                                rectangle.Y = 198;
                                break;
                            }
                          }
                          else if (left == index1 && right == num5)
                          {
                            switch (num4)
                            {
                              case 0:
                                rectangle.X = 54;
                                rectangle.Y = 198;
                                break;
                              case 1:
                                rectangle.X = 72;
                                rectangle.Y = 198;
                                break;
                              default:
                                rectangle.X = 90;
                                rectangle.Y = 198;
                                break;
                            }
                          }
                        }
                        else if (down != index1 && down != num5 && (up == index1 || up == num5))
                        {
                          if (left == num5 && right == index1)
                          {
                            switch (num4)
                            {
                              case 0:
                                rectangle.X = 0;
                                rectangle.Y = 216;
                                break;
                              case 1:
                                rectangle.X = 18;
                                rectangle.Y = 216;
                                break;
                              default:
                                rectangle.X = 36;
                                rectangle.Y = 216;
                                break;
                            }
                          }
                          else if (left == index1 && right == num5)
                          {
                            switch (num4)
                            {
                              case 0:
                                rectangle.X = 54;
                                rectangle.Y = 216;
                                break;
                              case 1:
                                rectangle.X = 72;
                                rectangle.Y = 216;
                                break;
                              default:
                                rectangle.X = 90;
                                rectangle.Y = 216;
                                break;
                            }
                          }
                        }
                        else if (left != index1 && left != num5 && (right == index1 || right == num5))
                        {
                          if (up == num5 && down == index1)
                          {
                            switch (num4)
                            {
                              case 0:
                                rectangle.X = 72;
                                rectangle.Y = 144;
                                break;
                              case 1:
                                rectangle.X = 72;
                                rectangle.Y = 162;
                                break;
                              default:
                                rectangle.X = 72;
                                rectangle.Y = 180;
                                break;
                            }
                          }
                          else if (down == index1 && up == num5)
                          {
                            switch (num4)
                            {
                              case 0:
                                rectangle.X = 72;
                                rectangle.Y = 90;
                                break;
                              case 1:
                                rectangle.X = 72;
                                rectangle.Y = 108;
                                break;
                              default:
                                rectangle.X = 72;
                                rectangle.Y = 126;
                                break;
                            }
                          }
                        }
                        else if (right != index1 && right != num5 && (left == index1 || left == num5))
                        {
                          if (up == num5 && down == index1)
                          {
                            switch (num4)
                            {
                              case 0:
                                rectangle.X = 90;
                                rectangle.Y = 144;
                                break;
                              case 1:
                                rectangle.X = 90;
                                rectangle.Y = 162;
                                break;
                              default:
                                rectangle.X = 90;
                                rectangle.Y = 180;
                                break;
                            }
                          }
                          else if (down == index1 && right == up)
                          {
                            switch (num4)
                            {
                              case 0:
                                rectangle.X = 90;
                                rectangle.Y = 90;
                                break;
                              case 1:
                                rectangle.X = 90;
                                rectangle.Y = 108;
                                break;
                              default:
                                rectangle.X = 90;
                                rectangle.Y = 126;
                                break;
                            }
                          }
                        }
                        else if (up == index1 && down == index1 && (left == index1 && right == index1))
                        {
                          if (upLeft != index1 && upRight != index1 && (downLeft != index1 && downRight != index1))
                          {
                            if (downRight == num5)
                            {
                              switch (num4)
                              {
                                case 0:
                                  rectangle.X = 108;
                                  rectangle.Y = 324;
                                  break;
                                case 1:
                                  rectangle.X = 126;
                                  rectangle.Y = 324;
                                  break;
                                default:
                                  rectangle.X = 144;
                                  rectangle.Y = 324;
                                  break;
                              }
                            }
                            else if (upRight == num5)
                            {
                              switch (num4)
                              {
                                case 0:
                                  rectangle.X = 108;
                                  rectangle.Y = 342;
                                  break;
                                case 1:
                                  rectangle.X = 126;
                                  rectangle.Y = 342;
                                  break;
                                default:
                                  rectangle.X = 144;
                                  rectangle.Y = 342;
                                  break;
                              }
                            }
                            else if (downLeft == num5)
                            {
                              switch (num4)
                              {
                                case 0:
                                  rectangle.X = 108;
                                  rectangle.Y = 360;
                                  break;
                                case 1:
                                  rectangle.X = 126;
                                  rectangle.Y = 360;
                                  break;
                                default:
                                  rectangle.X = 144;
                                  rectangle.Y = 360;
                                  break;
                              }
                            }
                            else if (upLeft == num5)
                            {
                              switch (num4)
                              {
                                case 0:
                                  rectangle.X = 108;
                                  rectangle.Y = 378;
                                  break;
                                case 1:
                                  rectangle.X = 126;
                                  rectangle.Y = 378;
                                  break;
                                default:
                                  rectangle.X = 144;
                                  rectangle.Y = 378;
                                  break;
                              }
                            }
                            else
                            {
                              switch (num4)
                              {
                                case 0:
                                  rectangle.X = 144;
                                  rectangle.Y = 234;
                                  break;
                                case 1:
                                  rectangle.X = 198;
                                  rectangle.Y = 234;
                                  break;
                                default:
                                  rectangle.X = 252;
                                  rectangle.Y = 234;
                                  break;
                              }
                            }
                          }
                          else if (upLeft != index1 && downRight != index1)
                          {
                            switch (num4)
                            {
                              case 0:
                                rectangle.X = 36;
                                rectangle.Y = 306;
                                break;
                              case 1:
                                rectangle.X = 54;
                                rectangle.Y = 306;
                                break;
                              default:
                                rectangle.X = 72;
                                rectangle.Y = 306;
                                break;
                            }
                          }
                          else if (upRight != index1 && downLeft != index1)
                          {
                            switch (num4)
                            {
                              case 0:
                                rectangle.X = 90;
                                rectangle.Y = 306;
                                break;
                              case 1:
                                rectangle.X = 108;
                                rectangle.Y = 306;
                                break;
                              default:
                                rectangle.X = 126;
                                rectangle.Y = 306;
                                break;
                            }
                          }
                          else if (upLeft != index1 && upRight == index1 && (downLeft == index1 && downRight == index1))
                          {
                            switch (num4)
                            {
                              case 0:
                                rectangle.X = 54;
                                rectangle.Y = 108;
                                break;
                              case 1:
                                rectangle.X = 54;
                                rectangle.Y = 144;
                                break;
                              default:
                                rectangle.X = 54;
                                rectangle.Y = 180;
                                break;
                            }
                          }
                          else if (upLeft == index1 && upRight != index1 && (downLeft == index1 && downRight == index1))
                          {
                            switch (num4)
                            {
                              case 0:
                                rectangle.X = 36;
                                rectangle.Y = 108;
                                break;
                              case 1:
                                rectangle.X = 36;
                                rectangle.Y = 144;
                                break;
                              default:
                                rectangle.X = 36;
                                rectangle.Y = 180;
                                break;
                            }
                          }
                          else if (upLeft == index1 && upRight == index1 && (downLeft != index1 && downRight == index1))
                          {
                            switch (num4)
                            {
                              case 0:
                                rectangle.X = 54;
                                rectangle.Y = 90;
                                break;
                              case 1:
                                rectangle.X = 54;
                                rectangle.Y = 126;
                                break;
                              default:
                                rectangle.X = 54;
                                rectangle.Y = 162;
                                break;
                            }
                          }
                          else if (upLeft == index1 && upRight == index1 && (downLeft == index1 && downRight != index1))
                          {
                            switch (num4)
                            {
                              case 0:
                                rectangle.X = 36;
                                rectangle.Y = 90;
                                break;
                              case 1:
                                rectangle.X = 36;
                                rectangle.Y = 126;
                                break;
                              default:
                                rectangle.X = 36;
                                rectangle.Y = 162;
                                break;
                            }
                          }
                        }
                        else if (up == index1 && down == num5 && (left == index1 && right == index1) && (upLeft == -1 && upRight == -1))
                        {
                          switch (num4)
                          {
                            case 0:
                              rectangle.X = 108;
                              rectangle.Y = 18;
                              break;
                            case 1:
                              rectangle.X = 126;
                              rectangle.Y = 18;
                              break;
                            default:
                              rectangle.X = 144;
                              rectangle.Y = 18;
                              break;
                          }
                        }
                        else if (up == num5 && down == index1 && (left == index1 && right == index1) && (downLeft == -1 && downRight == -1))
                        {
                          switch (num4)
                          {
                            case 0:
                              rectangle.X = 108;
                              rectangle.Y = 36;
                              break;
                            case 1:
                              rectangle.X = 126;
                              rectangle.Y = 36;
                              break;
                            default:
                              rectangle.X = 144;
                              rectangle.Y = 36;
                              break;
                          }
                        }
                        else if (up == index1 && down == index1 && (left == num5 && right == index1) && (upRight == -1 && downRight == -1))
                        {
                          switch (num4)
                          {
                            case 0:
                              rectangle.X = 198;
                              rectangle.Y = 0;
                              break;
                            case 1:
                              rectangle.X = 198;
                              rectangle.Y = 18;
                              break;
                            default:
                              rectangle.X = 198;
                              rectangle.Y = 36;
                              break;
                          }
                        }
                        else if (up == index1 && down == index1 && (left == index1 && right == num5) && (upLeft == -1 && downLeft == -1))
                        {
                          switch (num4)
                          {
                            case 0:
                              rectangle.X = 180;
                              rectangle.Y = 0;
                              break;
                            case 1:
                              rectangle.X = 180;
                              rectangle.Y = 18;
                              break;
                            default:
                              rectangle.X = 180;
                              rectangle.Y = 36;
                              break;
                          }
                        }
                        else if (up == index1 && down == num5 && (left == index1 && right == index1))
                        {
                          if (upRight != -1)
                          {
                            switch (num4)
                            {
                              case 0:
                                rectangle.X = 54;
                                rectangle.Y = 108;
                                break;
                              case 1:
                                rectangle.X = 54;
                                rectangle.Y = 144;
                                break;
                              default:
                                rectangle.X = 54;
                                rectangle.Y = 180;
                                break;
                            }
                          }
                          else if (upLeft != -1)
                          {
                            switch (num4)
                            {
                              case 0:
                                rectangle.X = 36;
                                rectangle.Y = 108;
                                break;
                              case 1:
                                rectangle.X = 36;
                                rectangle.Y = 144;
                                break;
                              default:
                                rectangle.X = 36;
                                rectangle.Y = 180;
                                break;
                            }
                          }
                        }
                        else if (up == num5 && down == index1 && (left == index1 && right == index1))
                        {
                          if (downRight != -1)
                          {
                            switch (num4)
                            {
                              case 0:
                                rectangle.X = 54;
                                rectangle.Y = 90;
                                break;
                              case 1:
                                rectangle.X = 54;
                                rectangle.Y = 126;
                                break;
                              default:
                                rectangle.X = 54;
                                rectangle.Y = 162;
                                break;
                            }
                          }
                          else if (downLeft != -1)
                          {
                            switch (num4)
                            {
                              case 0:
                                rectangle.X = 36;
                                rectangle.Y = 90;
                                break;
                              case 1:
                                rectangle.X = 36;
                                rectangle.Y = 126;
                                break;
                              default:
                                rectangle.X = 36;
                                rectangle.Y = 162;
                                break;
                            }
                          }
                        }
                        else if (up == index1 && down == index1 && (left == index1 && right == num5))
                        {
                          if (upLeft != -1)
                          {
                            switch (num4)
                            {
                              case 0:
                                rectangle.X = 54;
                                rectangle.Y = 90;
                                break;
                              case 1:
                                rectangle.X = 54;
                                rectangle.Y = 126;
                                break;
                              default:
                                rectangle.X = 54;
                                rectangle.Y = 162;
                                break;
                            }
                          }
                          else if (downLeft != -1)
                          {
                            switch (num4)
                            {
                              case 0:
                                rectangle.X = 54;
                                rectangle.Y = 108;
                                break;
                              case 1:
                                rectangle.X = 54;
                                rectangle.Y = 144;
                                break;
                              default:
                                rectangle.X = 54;
                                rectangle.Y = 180;
                                break;
                            }
                          }
                        }
                        else if (up == index1 && down == index1 && (left == num5 && right == index1))
                        {
                          if (upRight != -1)
                          {
                            switch (num4)
                            {
                              case 0:
                                rectangle.X = 36;
                                rectangle.Y = 90;
                                break;
                              case 1:
                                rectangle.X = 36;
                                rectangle.Y = 126;
                                break;
                              default:
                                rectangle.X = 36;
                                rectangle.Y = 162;
                                break;
                            }
                          }
                          else if (downRight != -1)
                          {
                            switch (num4)
                            {
                              case 0:
                                rectangle.X = 36;
                                rectangle.Y = 108;
                                break;
                              case 1:
                                rectangle.X = 36;
                                rectangle.Y = 144;
                                break;
                              default:
                                rectangle.X = 36;
                                rectangle.Y = 180;
                                break;
                            }
                          }
                        }
                        else if (up == num5 && down == index1 && (left == index1 && right == index1) || up == index1 && down == num5 && (left == index1 && right == index1) || (up == index1 && down == index1 && (left == num5 && right == index1) || up == index1 && down == index1 && (left == index1 && right == num5)))
                        {
                          switch (num4)
                          {
                            case 0:
                              rectangle.X = 18;
                              rectangle.Y = 18;
                              break;
                            case 1:
                              rectangle.X = 36;
                              rectangle.Y = 18;
                              break;
                            default:
                              rectangle.X = 54;
                              rectangle.Y = 18;
                              break;
                          }
                        }
                        if ((up == index1 || up == num5) && (down == index1 || down == num5) && ((left == index1 || left == num5) && (right == index1 || right == num5)))
                        {
                          if (upLeft != index1 && upLeft != num5 && (upRight == index1 || upRight == num5) && ((downLeft == index1 || downLeft == num5) && (downRight == index1 || downRight == num5)))
                          {
                            switch (num4)
                            {
                              case 0:
                                rectangle.X = 54;
                                rectangle.Y = 108;
                                break;
                              case 1:
                                rectangle.X = 54;
                                rectangle.Y = 144;
                                break;
                              default:
                                rectangle.X = 54;
                                rectangle.Y = 180;
                                break;
                            }
                          }
                          else if (upRight != index1 && upRight != num5 && (upLeft == index1 || upLeft == num5) && ((downLeft == index1 || downLeft == num5) && (downRight == index1 || downRight == num5)))
                          {
                            switch (num4)
                            {
                              case 0:
                                rectangle.X = 36;
                                rectangle.Y = 108;
                                break;
                              case 1:
                                rectangle.X = 36;
                                rectangle.Y = 144;
                                break;
                              default:
                                rectangle.X = 36;
                                rectangle.Y = 180;
                                break;
                            }
                          }
                          else if (downLeft != index1 && downLeft != num5 && (upLeft == index1 || upLeft == num5) && ((upRight == index1 || upRight == num5) && (downRight == index1 || downRight == num5)))
                          {
                            switch (num4)
                            {
                              case 0:
                                rectangle.X = 54;
                                rectangle.Y = 90;
                                break;
                              case 1:
                                rectangle.X = 54;
                                rectangle.Y = 126;
                                break;
                              default:
                                rectangle.X = 54;
                                rectangle.Y = 162;
                                break;
                            }
                          }
                          else if (downRight != index1 && downRight != num5 && (upLeft == index1 || upLeft == num5) && ((downLeft == index1 || downLeft == num5) && (upRight == index1 || upRight == num5)))
                          {
                            switch (num4)
                            {
                              case 0:
                                rectangle.X = 36;
                                rectangle.Y = 90;
                                break;
                              case 1:
                                rectangle.X = 36;
                                rectangle.Y = 126;
                                break;
                              default:
                                rectangle.X = 36;
                                rectangle.Y = 162;
                                break;
                            }
                          }
                        }
                        if (up != num5 && up != index1 && (down == index1 && left != num5) && (left != index1 && right == index1 && (downRight != num5 && downRight != index1)))
                        {
                          switch (num4)
                          {
                            case 0:
                              rectangle.X = 90;
                              rectangle.Y = 270;
                              break;
                            case 1:
                              rectangle.X = 108;
                              rectangle.Y = 270;
                              break;
                            default:
                              rectangle.X = 126;
                              rectangle.Y = 270;
                              break;
                          }
                        }
                        else if (up != num5 && up != index1 && (down == index1 && left == index1) && (right != num5 && right != index1 && (downLeft != num5 && downLeft != index1)))
                        {
                          switch (num4)
                          {
                            case 0:
                              rectangle.X = 144;
                              rectangle.Y = 270;
                              break;
                            case 1:
                              rectangle.X = 162;
                              rectangle.Y = 270;
                              break;
                            default:
                              rectangle.X = 180;
                              rectangle.Y = 270;
                              break;
                          }
                        }
                        else if (down != num5 && down != index1 && (up == index1 && left != num5) && (left != index1 && right == index1 && (upRight != num5 && upRight != index1)))
                        {
                          switch (num4)
                          {
                            case 0:
                              rectangle.X = 90;
                              rectangle.Y = 288;
                              break;
                            case 1:
                              rectangle.X = 108;
                              rectangle.Y = 288;
                              break;
                            default:
                              rectangle.X = 126;
                              rectangle.Y = 288;
                              break;
                          }
                        }
                        else if (down != num5 && down != index1 && (up == index1 && left == index1) && (right != num5 && right != index1 && (upLeft != num5 && upLeft != index1)))
                        {
                          switch (num4)
                          {
                            case 0:
                              rectangle.X = 144;
                              rectangle.Y = 288;
                              break;
                            case 1:
                              rectangle.X = 162;
                              rectangle.Y = 288;
                              break;
                            default:
                              rectangle.X = 180;
                              rectangle.Y = 288;
                              break;
                          }
                        }
                        else if (up != index1 && up != num5 && (down == index1 && left == index1) && (right == index1 && downLeft != index1 && (downLeft != num5 && downRight != index1)) && downRight != num5)
                        {
                          switch (num4)
                          {
                            case 0:
                              rectangle.X = 144;
                              rectangle.Y = 216;
                              break;
                            case 1:
                              rectangle.X = 198;
                              rectangle.Y = 216;
                              break;
                            default:
                              rectangle.X = 252;
                              rectangle.Y = 216;
                              break;
                          }
                        }
                        else if (down != index1 && down != num5 && (up == index1 && left == index1) && (right == index1 && upLeft != index1 && (upLeft != num5 && upRight != index1)) && upRight != num5)
                        {
                          switch (num4)
                          {
                            case 0:
                              rectangle.X = 144;
                              rectangle.Y = 252;
                              break;
                            case 1:
                              rectangle.X = 198;
                              rectangle.Y = 252;
                              break;
                            default:
                              rectangle.X = 252;
                              rectangle.Y = 252;
                              break;
                          }
                        }
                        else if (left != index1 && left != num5 && (down == index1 && up == index1) && (right == index1 && upRight != index1 && (upRight != num5 && downRight != index1)) && downRight != num5)
                        {
                          switch (num4)
                          {
                            case 0:
                              rectangle.X = 126;
                              rectangle.Y = 234;
                              break;
                            case 1:
                              rectangle.X = 180;
                              rectangle.Y = 234;
                              break;
                            default:
                              rectangle.X = 234;
                              rectangle.Y = 234;
                              break;
                          }
                        }
                        else if (right != index1 && right != num5 && (down == index1 && up == index1) && (left == index1 && upLeft != index1 && (upLeft != num5 && downLeft != index1)) && downLeft != num5)
                        {
                          switch (num4)
                          {
                            case 0:
                              rectangle.X = 162;
                              rectangle.Y = 234;
                              break;
                            case 1:
                              rectangle.X = 216;
                              rectangle.Y = 234;
                              break;
                            default:
                              rectangle.X = 270;
                              rectangle.Y = 234;
                              break;
                          }
                        }
                        else if (up != num5 && up != index1 && (down == num5 || down == index1) && (left == num5 && right == num5))
                        {
                          switch (num4)
                          {
                            case 0:
                              rectangle.X = 36;
                              rectangle.Y = 270;
                              break;
                            case 1:
                              rectangle.X = 54;
                              rectangle.Y = 270;
                              break;
                            default:
                              rectangle.X = 72;
                              rectangle.Y = 270;
                              break;
                          }
                        }
                        else if (down != num5 && down != index1 && (up == num5 || up == index1) && (left == num5 && right == num5))
                        {
                          switch (num4)
                          {
                            case 0:
                              rectangle.X = 36;
                              rectangle.Y = 288;
                              break;
                            case 1:
                              rectangle.X = 54;
                              rectangle.Y = 288;
                              break;
                            default:
                              rectangle.X = 72;
                              rectangle.Y = 288;
                              break;
                          }
                        }
                        else if (left != num5 && left != index1 && (right == num5 || right == index1) && (up == num5 && down == num5))
                        {
                          switch (num4)
                          {
                            case 0:
                              rectangle.X = 0;
                              rectangle.Y = 270;
                              break;
                            case 1:
                              rectangle.X = 0;
                              rectangle.Y = 288;
                              break;
                            default:
                              rectangle.X = 0;
                              rectangle.Y = 306;
                              break;
                          }
                        }
                        else if (right != num5 && right != index1 && (left == num5 || left == index1) && (up == num5 && down == num5))
                        {
                          switch (num4)
                          {
                            case 0:
                              rectangle.X = 18;
                              rectangle.Y = 270;
                              break;
                            case 1:
                              rectangle.X = 18;
                              rectangle.Y = 288;
                              break;
                            default:
                              rectangle.X = 18;
                              rectangle.Y = 306;
                              break;
                          }
                        }
                        else if (up == index1 && down == num5 && (left == num5 && right == num5))
                        {
                          switch (num4)
                          {
                            case 0:
                              rectangle.X = 198;
                              rectangle.Y = 288;
                              break;
                            case 1:
                              rectangle.X = 216;
                              rectangle.Y = 288;
                              break;
                            default:
                              rectangle.X = 234;
                              rectangle.Y = 288;
                              break;
                          }
                        }
                        else if (up == num5 && down == index1 && (left == num5 && right == num5))
                        {
                          switch (num4)
                          {
                            case 0:
                              rectangle.X = 198;
                              rectangle.Y = 270;
                              break;
                            case 1:
                              rectangle.X = 216;
                              rectangle.Y = 270;
                              break;
                            default:
                              rectangle.X = 234;
                              rectangle.Y = 270;
                              break;
                          }
                        }
                        else if (up == num5 && down == num5 && (left == index1 && right == num5))
                        {
                          switch (num4)
                          {
                            case 0:
                              rectangle.X = 198;
                              rectangle.Y = 306;
                              break;
                            case 1:
                              rectangle.X = 216;
                              rectangle.Y = 306;
                              break;
                            default:
                              rectangle.X = 234;
                              rectangle.Y = 306;
                              break;
                          }
                        }
                        else if (up == num5 && down == num5 && (left == num5 && right == index1))
                        {
                          switch (num4)
                          {
                            case 0:
                              rectangle.X = 144;
                              rectangle.Y = 306;
                              break;
                            case 1:
                              rectangle.X = 162;
                              rectangle.Y = 306;
                              break;
                            default:
                              rectangle.X = 180;
                              rectangle.Y = 306;
                              break;
                          }
                        }
                        if (up != index1 && up != num5 && (down == index1 && left == index1) && right == index1)
                        {
                          if ((downLeft == num5 || downLeft == index1) && (downRight != num5 && downRight != index1))
                          {
                            switch (num4)
                            {
                              case 0:
                                rectangle.X = 0;
                                rectangle.Y = 324;
                                break;
                              case 1:
                                rectangle.X = 18;
                                rectangle.Y = 324;
                                break;
                              default:
                                rectangle.X = 36;
                                rectangle.Y = 324;
                                break;
                            }
                          }
                          else if ((downRight == num5 || downRight == index1) && (downLeft != num5 && downLeft != index1))
                          {
                            switch (num4)
                            {
                              case 0:
                                rectangle.X = 54;
                                rectangle.Y = 324;
                                break;
                              case 1:
                                rectangle.X = 72;
                                rectangle.Y = 324;
                                break;
                              default:
                                rectangle.X = 90;
                                rectangle.Y = 324;
                                break;
                            }
                          }
                        }
                        else if (down != index1 && down != num5 && (up == index1 && left == index1) && right == index1)
                        {
                          if ((upLeft == num5 || upLeft == index1) && (upRight != num5 && upRight != index1))
                          {
                            switch (num4)
                            {
                              case 0:
                                rectangle.X = 0;
                                rectangle.Y = 342;
                                break;
                              case 1:
                                rectangle.X = 18;
                                rectangle.Y = 342;
                                break;
                              default:
                                rectangle.X = 36;
                                rectangle.Y = 342;
                                break;
                            }
                          }
                          else if ((upRight == num5 || upRight == index1) && (upLeft != num5 && upLeft != index1))
                          {
                            switch (num4)
                            {
                              case 0:
                                rectangle.X = 54;
                                rectangle.Y = 342;
                                break;
                              case 1:
                                rectangle.X = 72;
                                rectangle.Y = 342;
                                break;
                              default:
                                rectangle.X = 90;
                                rectangle.Y = 342;
                                break;
                            }
                          }
                        }
                        else if (left != index1 && left != num5 && (up == index1 && down == index1) && right == index1)
                        {
                          if ((upRight == num5 || upRight == index1) && (downRight != num5 && downRight != index1))
                          {
                            switch (num4)
                            {
                              case 0:
                                rectangle.X = 54;
                                rectangle.Y = 360;
                                break;
                              case 1:
                                rectangle.X = 72;
                                rectangle.Y = 360;
                                break;
                              default:
                                rectangle.X = 90;
                                rectangle.Y = 360;
                                break;
                            }
                          }
                          else if ((downRight == num5 || downRight == index1) && (upRight != num5 && upRight != index1))
                          {
                            switch (num4)
                            {
                              case 0:
                                rectangle.X = 0;
                                rectangle.Y = 360;
                                break;
                              case 1:
                                rectangle.X = 18;
                                rectangle.Y = 360;
                                break;
                              default:
                                rectangle.X = 36;
                                rectangle.Y = 360;
                                break;
                            }
                          }
                        }
                        else if (right != index1 && right != num5 && (up == index1 && down == index1) && left == index1)
                        {
                          if ((upLeft == num5 || upLeft == index1) && (downLeft != num5 && downLeft != index1))
                          {
                            switch (num4)
                            {
                              case 0:
                                rectangle.X = 0;
                                rectangle.Y = 378;
                                break;
                              case 1:
                                rectangle.X = 18;
                                rectangle.Y = 378;
                                break;
                              default:
                                rectangle.X = 36;
                                rectangle.Y = 378;
                                break;
                            }
                          }
                          else if ((downLeft == num5 || downLeft == index1) && (upLeft != num5 && upLeft != index1))
                          {
                            switch (num4)
                            {
                              case 0:
                                rectangle.X = 54;
                                rectangle.Y = 378;
                                break;
                              case 1:
                                rectangle.X = 72;
                                rectangle.Y = 378;
                                break;
                              default:
                                rectangle.X = 90;
                                rectangle.Y = 378;
                                break;
                            }
                          }
                        }
                        if ((up == index1 || up == num5) && (down == index1 || down == num5) && ((left == index1 || left == num5) && (right == index1 || right == num5)) && (upLeft != -1 && upRight != -1 && (downLeft != -1 && downRight != -1)))
                        {
                          if ((i + j) % 2 == 1)
                          {
                            switch (num4)
                            {
                              case 0:
                                rectangle.X = 108;
                                rectangle.Y = 198;
                                break;
                              case 1:
                                rectangle.X = 126;
                                rectangle.Y = 198;
                                break;
                              default:
                                rectangle.X = 144;
                                rectangle.Y = 198;
                                break;
                            }
                          }
                          else
                          {
                            switch (num4)
                            {
                              case 0:
                                rectangle.X = 18;
                                rectangle.Y = 18;
                                break;
                              case 1:
                                rectangle.X = 36;
                                rectangle.Y = 18;
                                break;
                              default:
                                rectangle.X = 54;
                                rectangle.Y = 18;
                                break;
                            }
                          }
                        }
                        WorldGen.TileMergeAttempt(-2, num5, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                      }
                      WorldGen.TileMergeAttempt(index1, Main.tileMerge[index1], ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                      if (rectangle.X == -1 && rectangle.Y == -1 && (Main.tileMergeDirt[index1] || index1 > -1 && TileID.Sets.ChecksForMerge[index1]))
                      {
                        if (!flag1)
                        {
                          flag1 = true;
                          WorldGen.TileMergeAttemptWeird(index1, -1, Main.tileSolid, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                        }
                        if (up > -1 && up != index1)
                          up = -1;
                        if (down > -1 && down != index1)
                          down = -1;
                        if (left > -1 && left != index1)
                          left = -1;
                        if (right > -1 && right != index1)
                          right = -1;
                        if (up != -1 && down != -1 && (left != -1 && right != -1))
                        {
                          if (up == -2 && down == index1 && (left == index1 && right == index1))
                          {
                            switch (num4)
                            {
                              case 0:
                                rectangle.X = 144;
                                rectangle.Y = 108;
                                break;
                              case 1:
                                rectangle.X = 162;
                                rectangle.Y = 108;
                                break;
                              default:
                                rectangle.X = 180;
                                rectangle.Y = 108;
                                break;
                            }
                            WorldGen.mergeUp = true;
                          }
                          else if (up == index1 && down == -2 && (left == index1 && right == index1))
                          {
                            switch (num4)
                            {
                              case 0:
                                rectangle.X = 144;
                                rectangle.Y = 90;
                                break;
                              case 1:
                                rectangle.X = 162;
                                rectangle.Y = 90;
                                break;
                              default:
                                rectangle.X = 180;
                                rectangle.Y = 90;
                                break;
                            }
                            WorldGen.mergeDown = true;
                          }
                          else if (up == index1 && down == index1 && (left == -2 && right == index1))
                          {
                            switch (num4)
                            {
                              case 0:
                                rectangle.X = 162;
                                rectangle.Y = 126;
                                break;
                              case 1:
                                rectangle.X = 162;
                                rectangle.Y = 144;
                                break;
                              default:
                                rectangle.X = 162;
                                rectangle.Y = 162;
                                break;
                            }
                            WorldGen.mergeLeft = true;
                          }
                          else if (up == index1 && down == index1 && (left == index1 && right == -2))
                          {
                            switch (num4)
                            {
                              case 0:
                                rectangle.X = 144;
                                rectangle.Y = 126;
                                break;
                              case 1:
                                rectangle.X = 144;
                                rectangle.Y = 144;
                                break;
                              default:
                                rectangle.X = 144;
                                rectangle.Y = 162;
                                break;
                            }
                            WorldGen.mergeRight = true;
                          }
                          else if (up == -2 && down == index1 && (left == -2 && right == index1))
                          {
                            switch (num4)
                            {
                              case 0:
                                rectangle.X = 36;
                                rectangle.Y = 90;
                                break;
                              case 1:
                                rectangle.X = 36;
                                rectangle.Y = 126;
                                break;
                              default:
                                rectangle.X = 36;
                                rectangle.Y = 162;
                                break;
                            }
                            WorldGen.mergeUp = true;
                            WorldGen.mergeLeft = true;
                          }
                          else if (up == -2 && down == index1 && (left == index1 && right == -2))
                          {
                            switch (num4)
                            {
                              case 0:
                                rectangle.X = 54;
                                rectangle.Y = 90;
                                break;
                              case 1:
                                rectangle.X = 54;
                                rectangle.Y = 126;
                                break;
                              default:
                                rectangle.X = 54;
                                rectangle.Y = 162;
                                break;
                            }
                            WorldGen.mergeUp = true;
                            WorldGen.mergeRight = true;
                          }
                          else if (up == index1 && down == -2 && (left == -2 && right == index1))
                          {
                            switch (num4)
                            {
                              case 0:
                                rectangle.X = 36;
                                rectangle.Y = 108;
                                break;
                              case 1:
                                rectangle.X = 36;
                                rectangle.Y = 144;
                                break;
                              default:
                                rectangle.X = 36;
                                rectangle.Y = 180;
                                break;
                            }
                            WorldGen.mergeDown = true;
                            WorldGen.mergeLeft = true;
                          }
                          else if (up == index1 && down == -2 && (left == index1 && right == -2))
                          {
                            switch (num4)
                            {
                              case 0:
                                rectangle.X = 54;
                                rectangle.Y = 108;
                                break;
                              case 1:
                                rectangle.X = 54;
                                rectangle.Y = 144;
                                break;
                              default:
                                rectangle.X = 54;
                                rectangle.Y = 180;
                                break;
                            }
                            WorldGen.mergeDown = true;
                            WorldGen.mergeRight = true;
                          }
                          else if (up == index1 && down == index1 && (left == -2 && right == -2))
                          {
                            switch (num4)
                            {
                              case 0:
                                rectangle.X = 180;
                                rectangle.Y = 126;
                                break;
                              case 1:
                                rectangle.X = 180;
                                rectangle.Y = 144;
                                break;
                              default:
                                rectangle.X = 180;
                                rectangle.Y = 162;
                                break;
                            }
                            WorldGen.mergeLeft = true;
                            WorldGen.mergeRight = true;
                          }
                          else if (up == -2 && down == -2 && (left == index1 && right == index1))
                          {
                            switch (num4)
                            {
                              case 0:
                                rectangle.X = 144;
                                rectangle.Y = 180;
                                break;
                              case 1:
                                rectangle.X = 162;
                                rectangle.Y = 180;
                                break;
                              default:
                                rectangle.X = 180;
                                rectangle.Y = 180;
                                break;
                            }
                            WorldGen.mergeUp = true;
                            WorldGen.mergeDown = true;
                          }
                          else if (up == -2 && down == index1 && (left == -2 && right == -2))
                          {
                            switch (num4)
                            {
                              case 0:
                                rectangle.X = 198;
                                rectangle.Y = 90;
                                break;
                              case 1:
                                rectangle.X = 198;
                                rectangle.Y = 108;
                                break;
                              default:
                                rectangle.X = 198;
                                rectangle.Y = 126;
                                break;
                            }
                            WorldGen.mergeUp = true;
                            WorldGen.mergeLeft = true;
                            WorldGen.mergeRight = true;
                          }
                          else if (up == index1 && down == -2 && (left == -2 && right == -2))
                          {
                            switch (num4)
                            {
                              case 0:
                                rectangle.X = 198;
                                rectangle.Y = 144;
                                break;
                              case 1:
                                rectangle.X = 198;
                                rectangle.Y = 162;
                                break;
                              default:
                                rectangle.X = 198;
                                rectangle.Y = 180;
                                break;
                            }
                            WorldGen.mergeDown = true;
                            WorldGen.mergeLeft = true;
                            WorldGen.mergeRight = true;
                          }
                          else if (up == -2 && down == -2 && (left == index1 && right == -2))
                          {
                            switch (num4)
                            {
                              case 0:
                                rectangle.X = 216;
                                rectangle.Y = 144;
                                break;
                              case 1:
                                rectangle.X = 216;
                                rectangle.Y = 162;
                                break;
                              default:
                                rectangle.X = 216;
                                rectangle.Y = 180;
                                break;
                            }
                            WorldGen.mergeUp = true;
                            WorldGen.mergeDown = true;
                            WorldGen.mergeRight = true;
                          }
                          else if (up == -2 && down == -2 && (left == -2 && right == index1))
                          {
                            switch (num4)
                            {
                              case 0:
                                rectangle.X = 216;
                                rectangle.Y = 90;
                                break;
                              case 1:
                                rectangle.X = 216;
                                rectangle.Y = 108;
                                break;
                              default:
                                rectangle.X = 216;
                                rectangle.Y = 126;
                                break;
                            }
                            WorldGen.mergeUp = true;
                            WorldGen.mergeDown = true;
                            WorldGen.mergeLeft = true;
                          }
                          else if (up == -2 && down == -2 && (left == -2 && right == -2))
                          {
                            switch (num4)
                            {
                              case 0:
                                rectangle.X = 108;
                                rectangle.Y = 198;
                                break;
                              case 1:
                                rectangle.X = 126;
                                rectangle.Y = 198;
                                break;
                              default:
                                rectangle.X = 144;
                                rectangle.Y = 198;
                                break;
                            }
                            WorldGen.mergeUp = true;
                            WorldGen.mergeDown = true;
                            WorldGen.mergeLeft = true;
                            WorldGen.mergeRight = true;
                          }
                          else if (up == index1 && down == index1 && (left == index1 && right == index1))
                          {
                            if (upLeft == -2)
                            {
                              switch (num4)
                              {
                                case 0:
                                  rectangle.X = 18;
                                  rectangle.Y = 108;
                                  break;
                                case 1:
                                  rectangle.X = 18;
                                  rectangle.Y = 144;
                                  break;
                                default:
                                  rectangle.X = 18;
                                  rectangle.Y = 180;
                                  break;
                              }
                            }
                            if (upRight == -2)
                            {
                              switch (num4)
                              {
                                case 0:
                                  rectangle.X = 0;
                                  rectangle.Y = 108;
                                  break;
                                case 1:
                                  rectangle.X = 0;
                                  rectangle.Y = 144;
                                  break;
                                default:
                                  rectangle.X = 0;
                                  rectangle.Y = 180;
                                  break;
                              }
                            }
                            if (downLeft == -2)
                            {
                              switch (num4)
                              {
                                case 0:
                                  rectangle.X = 18;
                                  rectangle.Y = 90;
                                  break;
                                case 1:
                                  rectangle.X = 18;
                                  rectangle.Y = 126;
                                  break;
                                default:
                                  rectangle.X = 18;
                                  rectangle.Y = 162;
                                  break;
                              }
                            }
                            if (downRight == -2)
                            {
                              switch (num4)
                              {
                                case 0:
                                  rectangle.X = 0;
                                  rectangle.Y = 90;
                                  break;
                                case 1:
                                  rectangle.X = 0;
                                  rectangle.Y = 126;
                                  break;
                                default:
                                  rectangle.X = 0;
                                  rectangle.Y = 162;
                                  break;
                              }
                            }
                          }
                        }
                        else
                        {
                          if (index1 != 2 && index1 != 23 && (index1 != 60 && index1 != 70) && (index1 != 109 && index1 != 199 && (index1 != 477 && index1 != 492)))
                          {
                            if (up == -1 && down == -2 && (left == index1 && right == index1))
                            {
                              switch (num4)
                              {
                                case 0:
                                  rectangle.X = 234;
                                  rectangle.Y = 0;
                                  break;
                                case 1:
                                  rectangle.X = 252;
                                  rectangle.Y = 0;
                                  break;
                                default:
                                  rectangle.X = 270;
                                  rectangle.Y = 0;
                                  break;
                              }
                              WorldGen.mergeDown = true;
                            }
                            else if (up == -2 && down == -1 && (left == index1 && right == index1))
                            {
                              switch (num4)
                              {
                                case 0:
                                  rectangle.X = 234;
                                  rectangle.Y = 18;
                                  break;
                                case 1:
                                  rectangle.X = 252;
                                  rectangle.Y = 18;
                                  break;
                                default:
                                  rectangle.X = 270;
                                  rectangle.Y = 18;
                                  break;
                              }
                              WorldGen.mergeUp = true;
                            }
                            else if (up == index1 && down == index1 && (left == -1 && right == -2))
                            {
                              switch (num4)
                              {
                                case 0:
                                  rectangle.X = 234;
                                  rectangle.Y = 36;
                                  break;
                                case 1:
                                  rectangle.X = 252;
                                  rectangle.Y = 36;
                                  break;
                                default:
                                  rectangle.X = 270;
                                  rectangle.Y = 36;
                                  break;
                              }
                              WorldGen.mergeRight = true;
                            }
                            else if (up == index1 && down == index1 && (left == -2 && right == -1))
                            {
                              switch (num4)
                              {
                                case 0:
                                  rectangle.X = 234;
                                  rectangle.Y = 54;
                                  break;
                                case 1:
                                  rectangle.X = 252;
                                  rectangle.Y = 54;
                                  break;
                                default:
                                  rectangle.X = 270;
                                  rectangle.Y = 54;
                                  break;
                              }
                              WorldGen.mergeLeft = true;
                            }
                          }
                          if (up != -1 && down != -1 && (left == -1 && right == index1))
                          {
                            if (up == -2 && down == index1)
                            {
                              switch (num4)
                              {
                                case 0:
                                  rectangle.X = 72;
                                  rectangle.Y = 144;
                                  break;
                                case 1:
                                  rectangle.X = 72;
                                  rectangle.Y = 162;
                                  break;
                                default:
                                  rectangle.X = 72;
                                  rectangle.Y = 180;
                                  break;
                              }
                              WorldGen.mergeUp = true;
                            }
                            else if (down == -2 && up == index1)
                            {
                              switch (num4)
                              {
                                case 0:
                                  rectangle.X = 72;
                                  rectangle.Y = 90;
                                  break;
                                case 1:
                                  rectangle.X = 72;
                                  rectangle.Y = 108;
                                  break;
                                default:
                                  rectangle.X = 72;
                                  rectangle.Y = 126;
                                  break;
                              }
                              WorldGen.mergeDown = true;
                            }
                          }
                          else if (up != -1 && down != -1 && (left == index1 && right == -1))
                          {
                            if (up == -2 && down == index1)
                            {
                              switch (num4)
                              {
                                case 0:
                                  rectangle.X = 90;
                                  rectangle.Y = 144;
                                  break;
                                case 1:
                                  rectangle.X = 90;
                                  rectangle.Y = 162;
                                  break;
                                default:
                                  rectangle.X = 90;
                                  rectangle.Y = 180;
                                  break;
                              }
                              WorldGen.mergeUp = true;
                            }
                            else if (down == -2 && up == index1)
                            {
                              switch (num4)
                              {
                                case 0:
                                  rectangle.X = 90;
                                  rectangle.Y = 90;
                                  break;
                                case 1:
                                  rectangle.X = 90;
                                  rectangle.Y = 108;
                                  break;
                                default:
                                  rectangle.X = 90;
                                  rectangle.Y = 126;
                                  break;
                              }
                              WorldGen.mergeDown = true;
                            }
                          }
                          else if (up == -1 && down == index1 && (left != -1 && right != -1))
                          {
                            if (left == -2 && right == index1)
                            {
                              switch (num4)
                              {
                                case 0:
                                  rectangle.X = 0;
                                  rectangle.Y = 198;
                                  break;
                                case 1:
                                  rectangle.X = 18;
                                  rectangle.Y = 198;
                                  break;
                                default:
                                  rectangle.X = 36;
                                  rectangle.Y = 198;
                                  break;
                              }
                              WorldGen.mergeLeft = true;
                            }
                            else if (right == -2 && left == index1)
                            {
                              switch (num4)
                              {
                                case 0:
                                  rectangle.X = 54;
                                  rectangle.Y = 198;
                                  break;
                                case 1:
                                  rectangle.X = 72;
                                  rectangle.Y = 198;
                                  break;
                                default:
                                  rectangle.X = 90;
                                  rectangle.Y = 198;
                                  break;
                              }
                              WorldGen.mergeRight = true;
                            }
                          }
                          else if (up == index1 && down == -1 && (left != -1 && right != -1))
                          {
                            if (left == -2 && right == index1)
                            {
                              switch (num4)
                              {
                                case 0:
                                  rectangle.X = 0;
                                  rectangle.Y = 216;
                                  break;
                                case 1:
                                  rectangle.X = 18;
                                  rectangle.Y = 216;
                                  break;
                                default:
                                  rectangle.X = 36;
                                  rectangle.Y = 216;
                                  break;
                              }
                              WorldGen.mergeLeft = true;
                            }
                            else if (right == -2 && left == index1)
                            {
                              switch (num4)
                              {
                                case 0:
                                  rectangle.X = 54;
                                  rectangle.Y = 216;
                                  break;
                                case 1:
                                  rectangle.X = 72;
                                  rectangle.Y = 216;
                                  break;
                                default:
                                  rectangle.X = 90;
                                  rectangle.Y = 216;
                                  break;
                              }
                              WorldGen.mergeRight = true;
                            }
                          }
                          else if (up != -1 && down != -1 && (left == -1 && right == -1))
                          {
                            if (up == -2 && down == -2)
                            {
                              switch (num4)
                              {
                                case 0:
                                  rectangle.X = 108;
                                  rectangle.Y = 216;
                                  break;
                                case 1:
                                  rectangle.X = 108;
                                  rectangle.Y = 234;
                                  break;
                                default:
                                  rectangle.X = 108;
                                  rectangle.Y = 252;
                                  break;
                              }
                              WorldGen.mergeUp = true;
                              WorldGen.mergeDown = true;
                            }
                            else if (up == -2)
                            {
                              switch (num4)
                              {
                                case 0:
                                  rectangle.X = 126;
                                  rectangle.Y = 144;
                                  break;
                                case 1:
                                  rectangle.X = 126;
                                  rectangle.Y = 162;
                                  break;
                                default:
                                  rectangle.X = 126;
                                  rectangle.Y = 180;
                                  break;
                              }
                              WorldGen.mergeUp = true;
                            }
                            else if (down == -2)
                            {
                              switch (num4)
                              {
                                case 0:
                                  rectangle.X = 126;
                                  rectangle.Y = 90;
                                  break;
                                case 1:
                                  rectangle.X = 126;
                                  rectangle.Y = 108;
                                  break;
                                default:
                                  rectangle.X = 126;
                                  rectangle.Y = 126;
                                  break;
                              }
                              WorldGen.mergeDown = true;
                            }
                          }
                          else if (up == -1 && down == -1 && (left != -1 && right != -1))
                          {
                            if (left == -2 && right == -2)
                            {
                              switch (num4)
                              {
                                case 0:
                                  rectangle.X = 162;
                                  rectangle.Y = 198;
                                  break;
                                case 1:
                                  rectangle.X = 180;
                                  rectangle.Y = 198;
                                  break;
                                default:
                                  rectangle.X = 198;
                                  rectangle.Y = 198;
                                  break;
                              }
                              WorldGen.mergeLeft = true;
                              WorldGen.mergeRight = true;
                            }
                            else if (left == -2)
                            {
                              switch (num4)
                              {
                                case 0:
                                  rectangle.X = 0;
                                  rectangle.Y = 252;
                                  break;
                                case 1:
                                  rectangle.X = 18;
                                  rectangle.Y = 252;
                                  break;
                                default:
                                  rectangle.X = 36;
                                  rectangle.Y = 252;
                                  break;
                              }
                              WorldGen.mergeLeft = true;
                            }
                            else if (right == -2)
                            {
                              switch (num4)
                              {
                                case 0:
                                  rectangle.X = 54;
                                  rectangle.Y = 252;
                                  break;
                                case 1:
                                  rectangle.X = 72;
                                  rectangle.Y = 252;
                                  break;
                                default:
                                  rectangle.X = 90;
                                  rectangle.Y = 252;
                                  break;
                              }
                              WorldGen.mergeRight = true;
                            }
                          }
                          else if (up == -2 && down == -1 && (left == -1 && right == -1))
                          {
                            switch (num4)
                            {
                              case 0:
                                rectangle.X = 108;
                                rectangle.Y = 144;
                                break;
                              case 1:
                                rectangle.X = 108;
                                rectangle.Y = 162;
                                break;
                              default:
                                rectangle.X = 108;
                                rectangle.Y = 180;
                                break;
                            }
                            WorldGen.mergeUp = true;
                          }
                          else if (up == -1 && down == -2 && (left == -1 && right == -1))
                          {
                            switch (num4)
                            {
                              case 0:
                                rectangle.X = 108;
                                rectangle.Y = 90;
                                break;
                              case 1:
                                rectangle.X = 108;
                                rectangle.Y = 108;
                                break;
                              default:
                                rectangle.X = 108;
                                rectangle.Y = 126;
                                break;
                            }
                            WorldGen.mergeDown = true;
                          }
                          else if (up == -1 && down == -1 && (left == -2 && right == -1))
                          {
                            switch (num4)
                            {
                              case 0:
                                rectangle.X = 0;
                                rectangle.Y = 234;
                                break;
                              case 1:
                                rectangle.X = 18;
                                rectangle.Y = 234;
                                break;
                              default:
                                rectangle.X = 36;
                                rectangle.Y = 234;
                                break;
                            }
                            WorldGen.mergeLeft = true;
                          }
                          else if (up == -1 && down == -1 && (left == -1 && right == -2))
                          {
                            switch (num4)
                            {
                              case 0:
                                rectangle.X = 54;
                                rectangle.Y = 234;
                                break;
                              case 1:
                                rectangle.X = 72;
                                rectangle.Y = 234;
                                break;
                              default:
                                rectangle.X = 90;
                                rectangle.Y = 234;
                                break;
                            }
                            WorldGen.mergeRight = true;
                          }
                        }
                      }
                      int num6 = tile1.blockType();
                      if (TileID.Sets.HasSlopeFrames[index1])
                      {
                        if (num6 == 0)
                        {
                          bool flag2 = index1 == up && tileTopCache.topSlope();
                          bool flag3 = index1 == left && tile11.leftSlope();
                          bool flag4 = index1 == right && tile12.rightSlope();
                          bool flag5 = index1 == down && tile10.bottomSlope();
                          int num5 = 0;
                          int num7 = 0;
                          if (flag2.ToInt() + flag3.ToInt() + flag4.ToInt() + flag5.ToInt() > 2)
                          {
                            int num8 = (tileTopCache.slope() == (byte) 1).ToInt() + (tile12.slope() == (byte) 1).ToInt() + (tile10.slope() == (byte) 4).ToInt() + (tile11.slope() == (byte) 4).ToInt();
                            int num9 = (tileTopCache.slope() == (byte) 2).ToInt() + (tile12.slope() == (byte) 3).ToInt() + (tile10.slope() == (byte) 3).ToInt() + (tile11.slope() == (byte) 2).ToInt();
                            if (num8 == num9)
                            {
                              num5 = 2;
                              num7 = 4;
                            }
                            else if (num8 > num9)
                            {
                              int num10 = index1 != upLeft ? 0 : (tile25.slope() == (byte) 0 ? 1 : 0);
                              bool flag6 = index1 == downRight && tile24.slope() == (byte) 0;
                              int num11 = flag6 ? 1 : 0;
                              if ((num10 & num11) != 0)
                                num7 = 4;
                              else if (flag6)
                              {
                                num5 = 6;
                              }
                              else
                              {
                                num5 = 7;
                                num7 = 1;
                              }
                            }
                            else
                            {
                              int num10 = index1 != upRight ? 0 : (tile26.slope() == (byte) 0 ? 1 : 0);
                              bool flag6 = index1 == downLeft && tile13.slope() == (byte) 0;
                              int num11 = flag6 ? 1 : 0;
                              if ((num10 & num11) != 0)
                              {
                                num7 = 4;
                                num5 = 1;
                              }
                              else if (flag6)
                              {
                                num5 = 7;
                              }
                              else
                              {
                                num5 = 6;
                                num7 = 1;
                              }
                            }
                            rectangle.X = (18 + num5) * 18;
                            rectangle.Y = num7 * 18;
                          }
                          else
                          {
                            if (flag2 & flag3 && index1 == down && index1 == right)
                              num7 = 2;
                            else if (flag2 & flag4 && index1 == down && index1 == left)
                            {
                              num5 = 1;
                              num7 = 2;
                            }
                            else if (flag4 & flag5 && index1 == up && index1 == left)
                            {
                              num5 = 1;
                              num7 = 3;
                            }
                            else if (flag5 & flag3 && index1 == up && index1 == right)
                              num7 = 3;
                            if (num5 != 0 || num7 != 0)
                            {
                              rectangle.X = (18 + num5) * 18;
                              rectangle.Y = num7 * 18;
                            }
                          }
                        }
                        if (num6 >= 2 && (rectangle.X < 0 || rectangle.Y < 0))
                        {
                          int num5 = -1;
                          int num7 = -1;
                          int num8 = -1;
                          int num9 = 0;
                          int num10 = 0;
                          switch (num6)
                          {
                            case 2:
                              num5 = left;
                              num7 = down;
                              num8 = downLeft;
                              ++num9;
                              break;
                            case 3:
                              num5 = right;
                              num7 = down;
                              num8 = downRight;
                              break;
                            case 4:
                              num5 = left;
                              num7 = up;
                              num8 = upLeft;
                              ++num9;
                              ++num10;
                              break;
                            case 5:
                              num5 = right;
                              num7 = up;
                              num8 = upRight;
                              ++num10;
                              break;
                          }
                          if (index1 != num5 || index1 != num7 || index1 != num8)
                          {
                            if (index1 == num5 && index1 == num7)
                              num9 += 2;
                            else if (index1 == num5)
                              num9 += 4;
                            else if (index1 == num7)
                            {
                              num9 += 4;
                              num10 += 2;
                            }
                            else
                            {
                              num9 += 2;
                              num10 += 2;
                            }
                          }
                          rectangle.X = (18 + num9) * 18;
                          rectangle.Y = num10 * 18;
                        }
                      }
                      if (rectangle.X < 0 || rectangle.Y < 0)
                      {
                        if (!flag1)
                          WorldGen.TileMergeAttemptWeird(index1, -1, Main.tileSolid, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                        if (index1 == 2 || index1 == 23 || (index1 == 60 || index1 == 70) || (index1 == 109 || index1 == 199 || (index1 == 477 || index1 == 492)) || (Main.tileMoss[index1] || TileID.Sets.tileMossBrick[index1]))
                          WorldGen.TileMergeAttempt(index1, -2, ref up, ref down, ref left, ref right, ref upLeft, ref upRight, ref downLeft, ref downRight);
                        if (up == index1 && down == index1 && (left == index1 && right == index1))
                        {
                          if (upLeft != index1 && upRight != index1)
                          {
                            switch (num4)
                            {
                              case 0:
                                rectangle.X = 108;
                                rectangle.Y = 18;
                                break;
                              case 1:
                                rectangle.X = 126;
                                rectangle.Y = 18;
                                break;
                              default:
                                rectangle.X = 144;
                                rectangle.Y = 18;
                                break;
                            }
                          }
                          else if (downLeft != index1 && downRight != index1)
                          {
                            switch (num4)
                            {
                              case 0:
                                rectangle.X = 108;
                                rectangle.Y = 36;
                                break;
                              case 1:
                                rectangle.X = 126;
                                rectangle.Y = 36;
                                break;
                              default:
                                rectangle.X = 144;
                                rectangle.Y = 36;
                                break;
                            }
                          }
                          else if (upLeft != index1 && downLeft != index1)
                          {
                            switch (num4)
                            {
                              case 0:
                                rectangle.X = 180;
                                rectangle.Y = 0;
                                break;
                              case 1:
                                rectangle.X = 180;
                                rectangle.Y = 18;
                                break;
                              default:
                                rectangle.X = 180;
                                rectangle.Y = 36;
                                break;
                            }
                          }
                          else if (upRight != index1 && downRight != index1)
                          {
                            switch (num4)
                            {
                              case 0:
                                rectangle.X = 198;
                                rectangle.Y = 0;
                                break;
                              case 1:
                                rectangle.X = 198;
                                rectangle.Y = 18;
                                break;
                              default:
                                rectangle.X = 198;
                                rectangle.Y = 36;
                                break;
                            }
                          }
                          else
                          {
                            switch (num4)
                            {
                              case 0:
                                rectangle.X = 18;
                                rectangle.Y = 18;
                                break;
                              case 1:
                                rectangle.X = 36;
                                rectangle.Y = 18;
                                break;
                              default:
                                rectangle.X = 54;
                                rectangle.Y = 18;
                                break;
                            }
                          }
                        }
                        else if (up != index1 && down == index1 && (left == index1 && right == index1))
                        {
                          switch (num4)
                          {
                            case 0:
                              rectangle.X = 18;
                              rectangle.Y = 0;
                              break;
                            case 1:
                              rectangle.X = 36;
                              rectangle.Y = 0;
                              break;
                            default:
                              rectangle.X = 54;
                              rectangle.Y = 0;
                              break;
                          }
                        }
                        else if (up == index1 && down != index1 && (left == index1 && right == index1))
                        {
                          switch (num4)
                          {
                            case 0:
                              rectangle.X = 18;
                              rectangle.Y = 36;
                              break;
                            case 1:
                              rectangle.X = 36;
                              rectangle.Y = 36;
                              break;
                            default:
                              rectangle.X = 54;
                              rectangle.Y = 36;
                              break;
                          }
                        }
                        else if (up == index1 && down == index1 && (left != index1 && right == index1))
                        {
                          switch (num4)
                          {
                            case 0:
                              rectangle.X = 0;
                              rectangle.Y = 0;
                              break;
                            case 1:
                              rectangle.X = 0;
                              rectangle.Y = 18;
                              break;
                            default:
                              rectangle.X = 0;
                              rectangle.Y = 36;
                              break;
                          }
                        }
                        else if (up == index1 && down == index1 && (left == index1 && right != index1))
                        {
                          switch (num4)
                          {
                            case 0:
                              rectangle.X = 72;
                              rectangle.Y = 0;
                              break;
                            case 1:
                              rectangle.X = 72;
                              rectangle.Y = 18;
                              break;
                            default:
                              rectangle.X = 72;
                              rectangle.Y = 36;
                              break;
                          }
                        }
                        else if (up != index1 && down == index1 && (left != index1 && right == index1))
                        {
                          switch (num4)
                          {
                            case 0:
                              rectangle.X = 0;
                              rectangle.Y = 54;
                              break;
                            case 1:
                              rectangle.X = 36;
                              rectangle.Y = 54;
                              break;
                            default:
                              rectangle.X = 72;
                              rectangle.Y = 54;
                              break;
                          }
                        }
                        else if (up != index1 && down == index1 && (left == index1 && right != index1))
                        {
                          switch (num4)
                          {
                            case 0:
                              rectangle.X = 18;
                              rectangle.Y = 54;
                              break;
                            case 1:
                              rectangle.X = 54;
                              rectangle.Y = 54;
                              break;
                            default:
                              rectangle.X = 90;
                              rectangle.Y = 54;
                              break;
                          }
                        }
                        else if (up == index1 && down != index1 && (left != index1 && right == index1))
                        {
                          switch (num4)
                          {
                            case 0:
                              rectangle.X = 0;
                              rectangle.Y = 72;
                              break;
                            case 1:
                              rectangle.X = 36;
                              rectangle.Y = 72;
                              break;
                            default:
                              rectangle.X = 72;
                              rectangle.Y = 72;
                              break;
                          }
                        }
                        else if (up == index1 && down != index1 && (left == index1 && right != index1))
                        {
                          switch (num4)
                          {
                            case 0:
                              rectangle.X = 18;
                              rectangle.Y = 72;
                              break;
                            case 1:
                              rectangle.X = 54;
                              rectangle.Y = 72;
                              break;
                            default:
                              rectangle.X = 90;
                              rectangle.Y = 72;
                              break;
                          }
                        }
                        else if (up == index1 && down == index1 && (left != index1 && right != index1))
                        {
                          switch (num4)
                          {
                            case 0:
                              rectangle.X = 90;
                              rectangle.Y = 0;
                              break;
                            case 1:
                              rectangle.X = 90;
                              rectangle.Y = 18;
                              break;
                            default:
                              rectangle.X = 90;
                              rectangle.Y = 36;
                              break;
                          }
                        }
                        else if (up != index1 && down != index1 && (left == index1 && right == index1))
                        {
                          switch (num4)
                          {
                            case 0:
                              rectangle.X = 108;
                              rectangle.Y = 72;
                              break;
                            case 1:
                              rectangle.X = 126;
                              rectangle.Y = 72;
                              break;
                            default:
                              rectangle.X = 144;
                              rectangle.Y = 72;
                              break;
                          }
                        }
                        else if (up != index1 && down == index1 && (left != index1 && right != index1))
                        {
                          switch (num4)
                          {
                            case 0:
                              rectangle.X = 108;
                              rectangle.Y = 0;
                              break;
                            case 1:
                              rectangle.X = 126;
                              rectangle.Y = 0;
                              break;
                            default:
                              rectangle.X = 144;
                              rectangle.Y = 0;
                              break;
                          }
                        }
                        else if (up == index1 && down != index1 && (left != index1 && right != index1))
                        {
                          switch (num4)
                          {
                            case 0:
                              rectangle.X = 108;
                              rectangle.Y = 54;
                              break;
                            case 1:
                              rectangle.X = 126;
                              rectangle.Y = 54;
                              break;
                            default:
                              rectangle.X = 144;
                              rectangle.Y = 54;
                              break;
                          }
                        }
                        else if (up != index1 && down != index1 && (left != index1 && right == index1))
                        {
                          switch (num4)
                          {
                            case 0:
                              rectangle.X = 162;
                              rectangle.Y = 0;
                              break;
                            case 1:
                              rectangle.X = 162;
                              rectangle.Y = 18;
                              break;
                            default:
                              rectangle.X = 162;
                              rectangle.Y = 36;
                              break;
                          }
                        }
                        else if (up != index1 && down != index1 && (left == index1 && right != index1))
                        {
                          switch (num4)
                          {
                            case 0:
                              rectangle.X = 216;
                              rectangle.Y = 0;
                              break;
                            case 1:
                              rectangle.X = 216;
                              rectangle.Y = 18;
                              break;
                            default:
                              rectangle.X = 216;
                              rectangle.Y = 36;
                              break;
                          }
                        }
                        else if (up != index1 && down != index1 && (left != index1 && right != index1))
                        {
                          switch (num4)
                          {
                            case 0:
                              rectangle.X = 162;
                              rectangle.Y = 54;
                              break;
                            case 1:
                              rectangle.X = 180;
                              rectangle.Y = 54;
                              break;
                            default:
                              rectangle.X = 198;
                              rectangle.Y = 54;
                              break;
                          }
                        }
                      }
                      if (rectangle.X <= -1 || rectangle.Y <= -1)
                      {
                        if (num4 <= 0)
                        {
                          rectangle.X = 18;
                          rectangle.Y = 18;
                        }
                        else if (num4 == 1)
                        {
                          rectangle.X = 36;
                          rectangle.Y = 18;
                        }
                        if (num4 >= 2)
                        {
                          rectangle.X = 54;
                          rectangle.Y = 18;
                        }
                      }
                      if (Main.tileLargeFrames[index1] == (byte) 1 && num4 == 3)
                        rectangle.Y += 90;
                      if (Main.tileLargeFrames[index1] == (byte) 2 && num4 == 3)
                        rectangle.Y += 90;
                      tile1.frameX = (short) rectangle.X;
                      tile1.frameY = (short) rectangle.Y;
                      if (TileID.Sets.IsVine[index1])
                      {
                        up = tileTopCache == null ? index1 : (tileTopCache.nactive() ? (!tileTopCache.bottomSlope() ? (int) tileTopCache.type : -1) : -1);
                        if (index1 != up)
                        {
                          int num5 = up == 109 ? 1 : (up == 115 ? 1 : 0);
                          bool flag2 = up == 199 || up == 205;
                          bool flag3 = up == 2 || up == 52;
                          bool flag4 = up == 382;
                          int num7 = up == 70 ? 1 : (up == 528 ? 1 : 0);
                          ushort num8 = 0;
                          if (num7 != 0)
                            num8 = (ushort) 528;
                          if (num5 != 0)
                            num8 = (ushort) 115;
                          if (flag2)
                            num8 = (ushort) 205;
                          if (flag3 && index1 != 382)
                            num8 = (ushort) 52;
                          if (flag4)
                            num8 = (ushort) 382;
                          if (num8 != (ushort) 0 && (int) num8 != index1)
                          {
                            tile1.type = num8;
                            WorldGen.SquareTileFrame(i, j, true);
                            return;
                          }
                        }
                        if (up != index1)
                        {
                          bool flag2 = false;
                          if (up == -1)
                            flag2 = true;
                          if (index1 == 52 && up != 2 && up != 192)
                            flag2 = true;
                          if (index1 == 382 && up != 2 && up != 192)
                            flag2 = true;
                          if (index1 == 62 && up != 60)
                            flag2 = true;
                          if (index1 == 115 && up != 109)
                            flag2 = true;
                          if (index1 == 528 && up != 70)
                            flag2 = true;
                          if (index1 == 205 && up != 199)
                            flag2 = true;
                          if (flag2)
                            WorldGen.KillTile(i, j, false, false, false);
                        }
                      }
                      if (!WorldGen.noTileActions && tile1.active() && (index1 == 53 || index1 == 112 || (index1 == 116 || index1 == 123) || (index1 == 234 || index1 == 224 || (index1 == 495 || index1 == 330)) || (index1 == 331 || index1 == 332 || index1 == 333)))
                      {
                        switch (Main.netMode)
                        {
                          case 0:
                            if (tile10 != null)
                            {
                              bool flag2 = false;
                              if (!Main.tile[i, j + 1].nactive())
                                flag2 = true;
                              else if (!Main.tile[i, j + 2].nactive() && (!Main.tile[i, j + 1].active() || !Main.tileSolid[(int) Main.tile[i, j + 1].type]))
                                flag2 = true;
                              if (flag2 && WorldGen.AllowsSandfall(tileTopCache))
                              {
                                int projType;
                                int dmg;
                                WorldGen.GetSandfallProjData(index1, out projType, out dmg);
                                tile1.ClearTile();
                                int index3 = Projectile.NewProjectile((float) (i * 16 + 8), (float) (j * 16 + 8), 0.0f, 0.41f, projType, dmg, 0.0f, Main.myPlayer, 0.0f, 0.0f);
                                Main.projectile[index3].ai[0] = 1f;
                                WorldGen.SquareTileFrame(i, j, true);
                                break;
                              }
                              break;
                            }
                            break;
                          case 2:
                            if (tile10 != null && !tile10.nactive() && WorldGen.AllowsSandfall(tileTopCache))
                            {
                              int projType;
                              int dmg;
                              WorldGen.GetSandfallProjData(index1, out projType, out dmg);
                              tile1.ClearTile();
                              bool flag2 = false;
                              for (int index3 = 0; index3 < 1000; ++index3)
                              {
                                if (Main.projectile[index3].active && Main.projectile[index3].owner == Main.myPlayer && (Main.projectile[index3].type == projType && Math.Abs(Main.projectile[index3].timeLeft - 3600) < 60) && (double) Main.projectile[index3].Distance(new Vector2((float) (i * 16 + 8), (float) (j * 16 + 10))) < 4.0)
                                {
                                  flag2 = true;
                                  break;
                                }
                              }
                              if (!flag2)
                              {
                                int index3 = Projectile.NewProjectile((float) (i * 16 + 8), (float) (j * 16 + 8), 0.0f, 2.5f, projType, dmg, 0.0f, Main.myPlayer, 0.0f, 0.0f);
                                Main.projectile[index3].velocity.Y = 0.5f;
                                Main.projectile[index3].position.Y += 2f;
                                Main.projectile[index3].netUpdate = true;
                              }
                              NetMessage.SendTileSquare(-1, i, j, 1, TileChangeType.None);
                              WorldGen.SquareTileFrame(i, j, true);
                              break;
                            }
                            break;
                        }
                      }
                      if (rectangle.X != frameX)
                      {
                        if (rectangle.Y != frameY)
                        {
                          if (frameX >= 0)
                          {
                            if (frameY >= 0)
                            {
                              ++WorldGen.tileReframeCount;
                              if (WorldGen.tileReframeCount < 25)
                              {
                                int num5 = WorldGen.mergeUp ? 1 : 0;
                                bool mergeDown = WorldGen.mergeDown;
                                bool mergeLeft = WorldGen.mergeLeft;
                                bool mergeRight = WorldGen.mergeRight;
                                WorldGen.TileFrame(i - 1, j, false, false);
                                WorldGen.TileFrame(i + 1, j, false, false);
                                WorldGen.TileFrame(i, j - 1, false, false);
                                WorldGen.TileFrame(i, j + 1, false, false);
                                WorldGen.mergeUp = num5 != 0;
                                WorldGen.mergeDown = mergeDown;
                                WorldGen.mergeLeft = mergeLeft;
                                WorldGen.mergeRight = mergeRight;
                              }
                              --WorldGen.tileReframeCount;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      catch
      {
      }
      if (i <= 0 || j <= 0)
        return;
      WorldGen.UpdateMapTile(i, j, addToList);
    }

    public static void CheckTorch(int x, int y)
    {
      for (int index1 = x - 1; index1 <= x + 1; ++index1)
      {
        for (int index2 = y - 1; index2 <= y + 1; ++index2)
        {
          if (Main.tile[index1, index2] == null)
            return;
        }
      }
      Tile tile1 = Main.tile[x, y];
      Tile tile2 = Main.tile[x, y - 1];
      Tile tile3 = Main.tile[x, y + 1];
      Tile tile4 = Main.tile[x - 1, y];
      Tile tile5 = Main.tile[x + 1, y];
      Tile tile6 = Main.tile[x - 1, y + 1];
      Tile tile7 = Main.tile[x + 1, y + 1];
      Tile tile8 = Main.tile[x - 1, y - 1];
      Tile tile9 = Main.tile[x + 1, y - 1];
      short num = 0;
      if (tile1.frameX >= (short) 66)
        num = (short) 66;
      int index = -1;
      int tree1 = -1;
      int tree2 = -1;
      int tree3 = -1;
      int tree4 = -1;
      int tree5 = -1;
      int tree6 = -1;
      if (tile2 != null && tile2.active() && !tile2.bottomSlope())
      {
        int type = (int) tile2.type;
      }
      if (tile3 != null && tile3.active() && (TileID.Sets.Platforms[(int) tile3.type] && WorldGen.TopEdgeCanBeAttachedTo(x, y + 1) || !tile3.halfBrick() && !tile3.topSlope()))
        index = (int) tile3.type;
      if (tile4 != null && tile4.active() && (tile4.slope() == (byte) 0 || (int) tile4.slope() % 2 != 1))
        tree1 = (int) tile4.type;
      if (tile5 != null && tile5.active() && (tile5.slope() == (byte) 0 || (int) tile5.slope() % 2 != 0))
        tree2 = (int) tile5.type;
      if (tile6 != null && tile6.active())
        tree3 = (int) tile6.type;
      if (tile7 != null && tile7.active())
        tree4 = (int) tile7.type;
      if (tile8 != null && tile8.active())
        tree5 = (int) tile8.type;
      if (tile9 != null && tile9.active())
        tree6 = (int) tile9.type;
      if (index >= 0 && Main.tileSolid[index] && (!Main.tileNoAttach[index] || TileID.Sets.Platforms[index]))
        tile1.frameX = num;
      else if (tree1 >= 0 && Main.tileSolid[tree1] && !Main.tileNoAttach[tree1] || tree1 >= 0 && TileID.Sets.IsBeam[tree1] || WorldGen.IsTreeType(tree1) && WorldGen.IsTreeType(tree5) && WorldGen.IsTreeType(tree3))
        tile1.frameX = (short) (22 + (int) num);
      else if (tree2 >= 0 && Main.tileSolid[tree2] && !Main.tileNoAttach[tree2] || tree2 >= 0 && TileID.Sets.IsBeam[tree2] || WorldGen.IsTreeType(tree2) && WorldGen.IsTreeType(tree6) && WorldGen.IsTreeType(tree4))
        tile1.frameX = (short) (44 + (int) num);
      else if (tile1.wall > (ushort) 0)
        tile1.frameX = num;
      else
        WorldGen.KillTile(x, y, false, false, false);
    }

    public static void CheckProjectilePressurePad(int i, int j)
    {
      bool canUp;
      bool canLeft;
      bool canRight;
      bool canDown;
      WorldGen.CheckProjectilePressurePad_GetPossiblePlacementDirections(i, j, out canUp, out canLeft, out canRight, out canDown);
      Tile tile = Main.tile[i, j];
      bool flag;
      switch ((int) tile.frameX / 22)
      {
        case 0:
          flag = !canDown;
          break;
        case 1:
          flag = !canUp;
          break;
        case 2:
          flag = !canLeft;
          break;
        case 3:
          flag = !canRight;
          break;
        default:
          flag = true;
          break;
      }
      if (!flag)
        return;
      if (canDown)
        tile.frameX = (short) 0;
      else if (canUp)
        tile.frameX = (short) 22;
      else if (canLeft)
        tile.frameX = (short) 44;
      else if (canRight)
        tile.frameX = (short) 66;
      else
        WorldGen.KillTile(i, j, false, false, false);
    }

    private static void CheckProjectilePressurePad_GetPossiblePlacementDirections(
      int i,
      int j,
      out bool canUp,
      out bool canLeft,
      out bool canRight,
      out bool canDown)
    {
      canUp = false;
      canLeft = false;
      canRight = false;
      canDown = false;
      Tile tile1 = Main.tile[i, j];
      Tile tile2 = Main.tile[i, j - 1];
      Tile tile3 = Main.tile[i, j + 1];
      Tile tile4 = Main.tile[i - 1, j];
      Tile tile5 = Main.tile[i + 1, j];
      Tile tile6 = Main.tile[i - 1, j + 1];
      Tile tile7 = Main.tile[i + 1, j + 1];
      Tile tile8 = Main.tile[i - 1, j - 1];
      Tile tile9 = Main.tile[i + 1, j - 1];
      int index1 = -1;
      int index2 = -1;
      int tree1 = -1;
      int tree2 = -1;
      int tree3 = -1;
      int tree4 = -1;
      int tree5 = -1;
      int tree6 = -1;
      if (tile2 != null && tile2.nactive() && !tile2.bottomSlope())
        index2 = (int) tile2.type;
      if (tile3 != null && tile3.nactive() && (!tile3.halfBrick() && !tile3.topSlope()))
        index1 = (int) tile3.type;
      if (tile4 != null && tile4.nactive() && (tile4.slope() == (byte) 0 || (int) tile4.slope() % 2 != 1))
        tree1 = (int) tile4.type;
      if (tile5 != null && tile5.nactive() && (tile5.slope() == (byte) 0 || (int) tile5.slope() % 2 != 0))
        tree2 = (int) tile5.type;
      if (tile6 != null && tile6.nactive())
        tree3 = (int) tile6.type;
      if (tile7 != null && tile7.nactive())
        tree4 = (int) tile7.type;
      if (tile8 != null && tile8.nactive())
        tree5 = (int) tile8.type;
      if (tile9 != null && tile9.nactive())
        tree6 = (int) tile9.type;
      if (index1 >= 0 && Main.tileSolid[index1] && (!Main.tileNoAttach[index1] || TileID.Sets.Platforms[index1]) && ((tile3.bottomSlope() || tile3.slope() == (byte) 0) && !tile3.halfBrick()))
        canDown = true;
      if (index2 >= 0 && Main.tileSolid[index2] && (!Main.tileNoAttach[index2] || TileID.Sets.Platforms[index2] && tile2.halfBrick()) && (tile2.topSlope() || tile2.slope() == (byte) 0 || tile2.halfBrick()))
        canUp = true;
      if (tree1 >= 0 && Main.tileSolid[tree1] && !Main.tileNoAttach[tree1] && ((tile4.leftSlope() || tile4.slope() == (byte) 0) && !tile4.halfBrick()) || (tree1 >= 0 && TileID.Sets.IsBeam[tree1] || WorldGen.IsTreeType(tree1) && WorldGen.IsTreeType(tree5) && WorldGen.IsTreeType(tree3)))
        canLeft = true;
      if ((tree2 < 0 || !Main.tileSolid[tree2] || Main.tileNoAttach[tree2] || (!tile5.rightSlope() && tile5.slope() != (byte) 0 || tile5.halfBrick())) && ((tree2 < 0 || !TileID.Sets.IsBeam[tree2]) && (!WorldGen.IsTreeType(tree2) || !WorldGen.IsTreeType(tree6) || !WorldGen.IsTreeType(tree4))))
        return;
      canRight = true;
    }

    public static bool IsTreeType(int tree)
    {
      return tree >= 0 && TileID.Sets.IsATreeTrunk[tree];
    }

    public static int CanPlaceProjectilePressurePad(
      int x,
      int y,
      int type = 442,
      int style = 0,
      int direction = 0,
      int alternate = 0)
    {
      bool canUp;
      bool canLeft;
      bool canRight;
      bool canDown;
      WorldGen.CheckProjectilePressurePad_GetPossiblePlacementDirections(x, y, out canUp, out canLeft, out canRight, out canDown);
      if (!canUp && !canDown && (!canLeft && !canRight))
        return -1;
      switch (alternate)
      {
        case 0:
          if (!canDown)
            return -1;
          break;
        case 1:
          if (!canUp)
            return -1;
          break;
        case 2:
          if (!canLeft)
            return -1;
          break;
        case 3:
          if (!canRight)
            return -1;
          break;
      }
      return style;
    }

    private static void CheckDoorOpen(int i, int j, Tile tileCache)
    {
      if (WorldGen.destroyObject)
        return;
      int num1 = 0;
      int index = i;
      int frameX = (int) tileCache.frameX;
      int frameY = (int) tileCache.frameY;
      int doorStyle = frameY / 54 + (int) tileCache.frameX / 72 * 36;
      int num2 = j - frameY % 54 / 18;
      bool flag = false;
      switch (frameX % 72)
      {
        case 0:
          index = i;
          num1 = 1;
          break;
        case 18:
          index = i - 1;
          num1 = 1;
          break;
        case 36:
          index = i + 1;
          num1 = -1;
          break;
        case 54:
          index = i;
          num1 = -1;
          break;
      }
      Tile testTile1 = Main.tile[index, num2 - 1];
      Tile testTile2 = Main.tile[index, num2 + 3];
      if (testTile1 == null)
      {
        testTile1 = new Tile();
        Main.tile[index, num2 - 1] = testTile1;
      }
      if (testTile2 == null)
      {
        testTile2 = new Tile();
        Main.tile[index, num2 + 3] = testTile2;
      }
      if (!WorldGen.SolidTile(testTile1) || !WorldGen.SolidTile(testTile2))
      {
        flag = true;
        WorldGen.destroyObject = true;
        WorldGen.DropDoorItem(i, j, doorStyle);
      }
      int num3 = index;
      if (num1 == -1)
        num3 = index - 1;
      for (int i1 = num3; i1 < num3 + 2; ++i1)
      {
        for (int j1 = num2; j1 < num2 + 3; ++j1)
        {
          if (!flag)
          {
            Tile tile = Main.tile[i1, j1];
            if (!tile.active() || tile.type != (ushort) 11)
            {
              WorldGen.destroyObject = true;
              WorldGen.DropDoorItem(i, j, doorStyle);
              flag = true;
              i1 = num3;
              j1 = num2;
            }
          }
          if (flag)
            WorldGen.KillTile(i1, j1, false, false, false);
        }
      }
      WorldGen.destroyObject = false;
    }

    private static void CheckDoorClosed(int i, int j, Tile tileCache, int type)
    {
      if (WorldGen.destroyObject)
        return;
      bool flag = false;
      int frameY = (int) tileCache.frameY;
      int doorStyle = frameY / 54 + (int) tileCache.frameX / 54 * 36;
      int j1 = j - frameY % 54 / 18;
      Tile testTile1 = Main.tile[i, j1 - 1];
      Tile tile1 = Main.tile[i, j1];
      Tile tile2 = Main.tile[i, j1 + 1];
      Tile tile3 = Main.tile[i, j1 + 2];
      Tile testTile2 = Main.tile[i, j1 + 3];
      if (testTile1 == null)
      {
        testTile1 = new Tile();
        Main.tile[i, j1 - 1] = testTile1;
      }
      if (tile1 == null)
      {
        tile1 = new Tile();
        Main.tile[i, j1] = tile1;
      }
      if (tile2 == null)
      {
        tile2 = new Tile();
        Main.tile[i, j1 + 1] = tile2;
      }
      if (tile3 == null)
      {
        tile3 = new Tile();
        Main.tile[i, j1 + 2] = tile3;
      }
      if (testTile2 == null)
      {
        testTile2 = new Tile();
        Main.tile[i, j1 + 3] = testTile2;
      }
      if (!WorldGen.SolidTile(testTile1))
        flag = true;
      if (!WorldGen.SolidTile(testTile2))
        flag = true;
      if (!tile1.active() || (int) tile1.type != type)
        flag = true;
      if (!tile2.active() || (int) tile2.type != type)
        flag = true;
      if (!tile3.active() || (int) tile3.type != type)
        flag = true;
      if (flag)
      {
        WorldGen.destroyObject = true;
        WorldGen.KillTile(i, j1, false, false, false);
        WorldGen.KillTile(i, j1 + 1, false, false, false);
        WorldGen.KillTile(i, j1 + 2, false, false, false);
        WorldGen.DropDoorItem(i, j, doorStyle);
      }
      WorldGen.destroyObject = false;
    }

    private static void GetSandfallProjData(int type, out int projType, out int dmg)
    {
      dmg = 10;
      switch (type)
      {
        case 59:
          projType = 39;
          break;
        case 112:
          projType = 56;
          break;
        case 116:
          projType = 67;
          break;
        case 123:
          projType = 71;
          break;
        case 224:
          projType = 179;
          break;
        case 234:
          projType = 241;
          break;
        case 330:
          projType = 411;
          dmg = 0;
          break;
        case 331:
          projType = 412;
          dmg = 0;
          break;
        case 332:
          projType = 413;
          dmg = 0;
          break;
        case 333:
          projType = 414;
          dmg = 0;
          break;
        case 495:
          projType = 812;
          break;
        default:
          projType = 31;
          break;
      }
    }

    public static bool AllowsSandfall(Tile tileTopCache)
    {
      bool flag = true;
      if (tileTopCache.active() && (TileID.Sets.BasicChest[(int) tileTopCache.type] || TileID.Sets.BasicChestFake[(int) tileTopCache.type] || (tileTopCache.type == (ushort) 323 || tileTopCache.type == (ushort) 88) || (tileTopCache.type == (ushort) 80 || tileTopCache.type == (ushort) 77 || (tileTopCache.type == (ushort) 26 || tileTopCache.type == (ushort) 475)) || (tileTopCache.type == (ushort) 470 || tileTopCache.type == (ushort) 597)))
        flag = false;
      return flag;
    }

    public static void TriggerLunarApocalypse()
    {
      List<int> intList = new List<int>()
      {
        517,
        422,
        507,
        493
      };
      int[] numArray = new int[4];
      for (int index = 0; index < 4; ++index)
      {
        numArray[index] = intList[Main.rand.Next(intList.Count)];
        intList.Remove(numArray[index]);
      }
      int num1 = Main.maxTilesX / 5;
      int worldSurface = (int) Main.worldSurface;
      for (int index1 = 0; index1 < 4; ++index1)
      {
        int num2 = num1 * (1 + index1);
        bool flag = false;
        for (int index2 = 0; index2 < 30; ++index2)
        {
          int num3 = Main.rand.Next(-100, 101);
          for (int y = worldSurface; y > 100; --y)
          {
            if (!Collision.SolidTiles(num2 + num3 - 10, num2 + num3 + 10, y - 20, y + 15) && !WorldGen.PlayerLOS(num2 + num3 - 10, y) && (!WorldGen.PlayerLOS(num2 + num3 + 10, y) && !WorldGen.PlayerLOS(num2 + num3 - 10, y - 20)) && !WorldGen.PlayerLOS(num2 + num3 + 10, y - 20))
            {
              int number = NPC.NewNPC((num2 + num3) * 16, y * 16, numArray[index1], 0, 0.0f, 0.0f, 0.0f, 0.0f, (int) byte.MaxValue);
              if (Main.netMode == 2 && number < 200)
                NetMessage.SendData(23, -1, -1, (NetworkText) null, number, 0.0f, 0.0f, 0.0f, 0, 0, 0);
              flag = true;
              break;
            }
          }
          if (flag)
            break;
        }
        if (!flag)
          NPC.NewNPC(num2 * 16, (worldSurface - 40) * 16, numArray[index1], 0, 0.0f, 0.0f, 0.0f, 0.0f, (int) byte.MaxValue);
      }
      int num4;
      NPC.TowerActiveStardust = (num4 = 1) != 0;
      NPC.TowerActiveSolar = num4 != 0;
      NPC.TowerActiveNebula = num4 != 0;
      NPC.TowerActiveVortex = num4 != 0;
      NPC.LunarApocalypseIsUp = true;
      int strengthTowerMax;
      NPC.ShieldStrengthTowerStardust = strengthTowerMax = NPC.ShieldStrengthTowerMax;
      NPC.ShieldStrengthTowerNebula = strengthTowerMax;
      NPC.ShieldStrengthTowerVortex = strengthTowerMax;
      NPC.ShieldStrengthTowerSolar = strengthTowerMax;
      NetMessage.SendData(101, -1, -1, (NetworkText) null, 0, 0.0f, 0.0f, 0.0f, 0, 0, 0);
      WorldGen.MessageLunarApocalypse();
    }

    public static void UpdateLunarApocalypse()
    {
      if (!NPC.LunarApocalypseIsUp)
        return;
      bool flag1 = false;
      bool flag2 = false;
      bool flag3 = false;
      bool flag4 = false;
      bool flag5 = false;
      for (int index = 0; index < 200; ++index)
      {
        if (Main.npc[index].active)
        {
          switch (Main.npc[index].type)
          {
            case 398:
              flag1 = true;
              continue;
            case 422:
              flag3 = true;
              continue;
            case 493:
              flag5 = true;
              continue;
            case 507:
              flag4 = true;
              continue;
            case 517:
              flag2 = true;
              continue;
            default:
              continue;
          }
        }
      }
      if (!flag2)
        NPC.TowerActiveSolar = false;
      if (!flag3)
        NPC.TowerActiveVortex = false;
      if (!flag4)
        NPC.TowerActiveNebula = false;
      if (!flag5)
        NPC.TowerActiveStardust = false;
      if (NPC.TowerActiveSolar || NPC.TowerActiveVortex || (NPC.TowerActiveNebula || NPC.TowerActiveStardust) || flag1)
        return;
      WorldGen.StartImpendingDoom();
    }

    public static void StartImpendingDoom()
    {
      NPC.LunarApocalypseIsUp = false;
      NPC.MoonLordCountdown = 3600;
      NetMessage.SendData(103, -1, -1, (NetworkText) null, NPC.MoonLordCountdown, 0.0f, 0.0f, 0.0f, 0, 0, 0);
      WorldGen.BroadcastText(NetworkText.FromKey(Lang.misc[52].Key), 50, (int) byte.MaxValue, 130);
      if (Main.netMode == 1)
        return;
      WorldGen.GetRidOfCultists();
    }

    public static void GetRidOfCultists()
    {
      for (int number = 0; number < 200; ++number)
      {
        if (Main.npc[number].active && (Main.npc[number].type == 437 || Main.npc[number].type == 438 || Main.npc[number].type == 379))
        {
          Main.npc[number].active = false;
          if (Main.netMode != 1)
            NetMessage.SendData(23, -1, -1, (NetworkText) null, number, 0.0f, 0.0f, 0.0f, 0, 0, 0);
        }
      }
    }

    public static void MessageLunarApocalypse()
    {
      if (!NPC.LunarApocalypseIsUp)
        return;
      int num = 0;
      if (!NPC.TowerActiveSolar)
        ++num;
      if (!NPC.TowerActiveVortex)
        ++num;
      if (!NPC.TowerActiveNebula)
        ++num;
      if (!NPC.TowerActiveStardust)
        ++num;
      WorldGen.BroadcastText(NetworkText.FromKey(Lang.misc[43 + num].Key), 175, 75, (int) byte.MaxValue);
    }

    public static void BroadcastText(NetworkText text, Vector4 color)
    {
      WorldGen.BroadcastText(text, new Color(color));
    }

    public static void BroadcastText(NetworkText text, Vector3 color)
    {
      WorldGen.BroadcastText(text, new Color(color));
    }

    public static void BroadcastText(NetworkText text, int r, int g, int b)
    {
      WorldGen.BroadcastText(text, new Color(r, g, b));
    }

    public static void BroadcastText(NetworkText text, byte r, byte g, byte b)
    {
      WorldGen.BroadcastText(text, new Color((int) r, (int) g, (int) b));
    }

    public static void BroadcastText(NetworkText text, Color color)
    {
      if (Main.netMode == 0)
      {
        Main.NewText(text.ToString(), color.R, color.G, color.B);
      }
      else
      {
        if (Main.netMode != 2)
          return;
        ChatHelper.BroadcastChatMessage(text, color, -1);
      }
    }

    public static bool CanCutTile(int x, int y, TileCuttingContext context)
    {
      if (Main.tile[x, y + 1] == null || Main.tile[x, y + 1].type == (ushort) 78 || (Main.tile[x, y + 1].type == (ushort) 380 || Main.tile[x, y + 1].type == (ushort) 579))
        return false;
      return Main.tile[x, y].type != (ushort) 254 || Main.tile[x, y].frameX >= (short) 144;
    }

    public static bool InAPlaceWithWind(Vector2 position, int width, int height)
    {
      Point tileCoordinates1 = position.ToTileCoordinates();
      Point tileCoordinates2 = (position + new Vector2((float) width, (float) height)).ToTileCoordinates();
      return WorldGen.InAPlaceWithWind(tileCoordinates1.X, tileCoordinates1.Y, 1 + tileCoordinates2.X - tileCoordinates1.X, 1 + tileCoordinates2.Y - tileCoordinates1.Y);
    }

    public static bool InAPlaceWithWind(int x, int y, int width, int height)
    {
      if ((double) y >= Main.worldSurface)
        return false;
      for (int index1 = 0; index1 < width; ++index1)
      {
        for (int index2 = 0; index2 < height; ++index2)
        {
          Tile tile = Main.tile[x + index1, y + index2];
          if (tile == null || tile.liquid > (byte) 0 || tile.wall > (ushort) 0 && !WallID.Sets.AllowsWind[(int) tile.wall])
            return false;
        }
      }
      return true;
    }

    public static int[] CountTileTypesInWorld(params int[] oreTypes)
    {
      int[] numArray = new int[oreTypes.Length];
      for (int index1 = 0; index1 < Main.maxTilesX; ++index1)
      {
        for (int index2 = 0; index2 < Main.maxTilesY; ++index2)
        {
          Tile tile = Main.tile[index1, index2];
          if (tile.active())
          {
            for (int index3 = 0; index3 < oreTypes.Length; ++index3)
            {
              if (oreTypes[index3] == (int) tile.type)
              {
                ++numArray[index3];
                break;
              }
            }
          }
        }
      }
      return numArray;
    }

    public static class SavedOreTiers
    {
      public static int Copper = 7;
      public static int Iron = 6;
      public static int Silver = 9;
      public static int Gold = 8;
      public static int Cobalt = 107;
      public static int Mythril = 108;
      public static int Adamantite = 111;
    }

    public static class Hooks
    {
      public static event WorldGen.Hooks.WorldGenConfigProcessEvent OnWorldGenConfigProcess;

      public static event Action OnWorldLoad;

      public static void Initialize()
      {
        Player.Hooks.OnEnterWorld += (Action<Player>) (player =>
        {
          if (player.whoAmI != Main.myPlayer)
            return;
          WorldGen.Hooks.WorldLoaded();
          if (Main.netMode == 1)
            return;
          Main.FixUIScale();
        });
        WorldGen.Hooks.OnWorldLoad += new Action(WorldGen.mysticLogsEvent.StartWorld);
        WorldGen.Hooks.OnWorldLoad += new Action(Main.checkHalloween);
        WorldGen.Hooks.OnWorldLoad += new Action(Main.checkXMas);
      }

      public static void WorldLoaded()
      {
        if (WorldGen.Hooks.OnWorldLoad == null)
          return;
        WorldGen.Hooks.OnWorldLoad();
      }

      public static void ClearWorld()
      {
        PressurePlateHelper.Reset();
        WorldGen.TownManager.Clear();
        NPC.ResetKillCount();
        Main.instance.ClearCachedTileDraws();
        MapHelper.ResetMapData();
      }

      public static void ProcessWorldGenConfig(ref WorldGenConfiguration config)
      {
        if (WorldGen.Hooks.OnWorldGenConfigProcess == null)
          return;
        WorldGen.Hooks.OnWorldGenConfigProcess(ref config);
      }

      public delegate void WorldGenConfigProcessEvent(ref WorldGenConfiguration config);
    }

    public static class Spread
    {
      public static void Wall(int x, int y, int wallType)
      {
        if (!WorldGen.InWorld(x, y, 0))
          return;
        ushort num = (ushort) wallType;
        List<Point> pointList1 = new List<Point>();
        List<Point> pointList2 = new List<Point>();
        HashSet<Point> pointSet = new HashSet<Point>();
        pointList2.Add(new Point(x, y));
        while (pointList2.Count > 0)
        {
          pointList1.Clear();
          pointList1.AddRange((IEnumerable<Point>) pointList2);
          pointList2.Clear();
          while (pointList1.Count > 0)
          {
            Point point1 = pointList1[0];
            if (!WorldGen.InWorld(point1.X, point1.Y, 1))
            {
              pointList1.Remove(point1);
            }
            else
            {
              pointSet.Add(point1);
              pointList1.Remove(point1);
              Tile tile = Main.tile[point1.X, point1.Y];
              if (WorldGen.SolidTile(point1.X, point1.Y, false) || tile.wall != (ushort) 0)
              {
                if (tile.active() && tile.wall == (ushort) 0)
                  tile.wall = num;
              }
              else
              {
                tile.wall = num;
                Point point2 = new Point(point1.X - 1, point1.Y);
                if (!pointSet.Contains(point2))
                  pointList2.Add(point2);
                point2 = new Point(point1.X + 1, point1.Y);
                if (!pointSet.Contains(point2))
                  pointList2.Add(point2);
                point2 = new Point(point1.X, point1.Y - 1);
                if (!pointSet.Contains(point2))
                  pointList2.Add(point2);
                point2 = new Point(point1.X, point1.Y + 1);
                if (!pointSet.Contains(point2))
                  pointList2.Add(point2);
              }
            }
          }
        }
      }

      public static void Wall2(int x, int y, int wallType)
      {
        if (!WorldGen.InWorld(x, y, 0))
          return;
        ushort num1 = (ushort) wallType;
        int num2 = 0;
        int maxWallOut2 = WorldGen.maxWallOut2;
        List<Point> pointList1 = new List<Point>();
        List<Point> pointList2 = new List<Point>();
        HashSet<Point> pointSet = new HashSet<Point>();
        pointList2.Add(new Point(x, y));
        while (pointList2.Count > 0)
        {
          pointList1.Clear();
          pointList1.AddRange((IEnumerable<Point>) pointList2);
          pointList2.Clear();
          while (pointList1.Count > 0)
          {
            Point point1 = pointList1[0];
            if (!WorldGen.InWorld(point1.X, point1.Y, 1))
            {
              pointList1.Remove(point1);
            }
            else
            {
              pointSet.Add(point1);
              pointList1.Remove(point1);
              Tile tile = Main.tile[point1.X, point1.Y];
              if (!WorldGen.SolidTile(point1.X, point1.Y, false) && (int) tile.wall != (int) num1 && (tile.wall != (ushort) 4 && tile.wall != (ushort) 40) && (tile.wall != (ushort) 3 && tile.wall != (ushort) 87 && tile.wall != (ushort) 34))
              {
                if (num1 == (ushort) 63 && tile.wall == (ushort) 0)
                {
                  pointList1.Remove(point1);
                }
                else
                {
                  ++num2;
                  if (num2 >= maxWallOut2)
                  {
                    pointList1.Remove(point1);
                  }
                  else
                  {
                    tile.wall = num1;
                    Point point2 = new Point(point1.X - 1, point1.Y);
                    if (!pointSet.Contains(point2))
                      pointList2.Add(point2);
                    point2 = new Point(point1.X + 1, point1.Y);
                    if (!pointSet.Contains(point2))
                      pointList2.Add(point2);
                    point2 = new Point(point1.X, point1.Y - 1);
                    if (!pointSet.Contains(point2))
                      pointList2.Add(point2);
                    point2 = new Point(point1.X, point1.Y + 1);
                    if (!pointSet.Contains(point2))
                      pointList2.Add(point2);
                    if (num1 == (ushort) 63)
                    {
                      point2 = new Point(point1.X - 1, point1.Y - 1);
                      if (!pointSet.Contains(point2))
                        pointList2.Add(point2);
                      point2 = new Point(point1.X + 1, point1.Y - 1);
                      if (!pointSet.Contains(point2))
                        pointList2.Add(point2);
                      point2 = new Point(point1.X - 1, point1.Y + 1);
                      if (!pointSet.Contains(point2))
                        pointList2.Add(point2);
                      point2 = new Point(point1.X + 1, point1.Y + 1);
                      if (!pointSet.Contains(point2))
                        pointList2.Add(point2);
                      point2 = new Point(point1.X - 2, point1.Y);
                      if (!pointSet.Contains(point2))
                        pointList2.Add(point2);
                      point2 = new Point(point1.X + 2, point1.Y);
                      if (!pointSet.Contains(point2))
                        pointList2.Add(point2);
                    }
                  }
                }
              }
              else if (tile.active() && (int) tile.wall != (int) num1 && (tile.wall != (ushort) 4 && tile.wall != (ushort) 40) && (tile.wall != (ushort) 3 && tile.wall != (ushort) 87 && tile.wall != (ushort) 34))
                tile.wall = num1;
            }
          }
        }
      }

      public static void Moss(int x, int y)
      {
        if (!WorldGen.InWorld(x, y, 0))
          return;
        ushort mossWall = WorldGen.mossWall;
        ushort mossTile = WorldGen.mossTile;
        List<Point> pointList1 = new List<Point>();
        List<Point> pointList2 = new List<Point>();
        HashSet<Point> pointSet = new HashSet<Point>();
        pointList2.Add(new Point(x, y));
        while (pointList2.Count > 0)
        {
          pointList1.Clear();
          pointList1.AddRange((IEnumerable<Point>) pointList2);
          pointList2.Clear();
          while (pointList1.Count > 0)
          {
            Point point1 = pointList1[0];
            if (!WorldGen.InWorld(point1.X, point1.Y, 1))
            {
              pointList1.Remove(point1);
            }
            else
            {
              pointSet.Add(point1);
              pointList1.Remove(point1);
              Tile tile = Main.tile[point1.X, point1.Y];
              if (WorldGen.SolidTile(point1.X, point1.Y, false) || tile.wall != (ushort) 0)
              {
                if (tile.active())
                {
                  if (tile.wall == (ushort) 0)
                    tile.wall = mossWall;
                  if (tile.type == (ushort) 1)
                    tile.type = mossTile;
                }
              }
              else
              {
                tile.wall = mossWall;
                Point point2 = new Point(point1.X - 1, point1.Y);
                if (!pointSet.Contains(point2))
                  pointList2.Add(point2);
                point2 = new Point(point1.X + 1, point1.Y);
                if (!pointSet.Contains(point2))
                  pointList2.Add(point2);
                point2 = new Point(point1.X, point1.Y - 1);
                if (!pointSet.Contains(point2))
                  pointList2.Add(point2);
                point2 = new Point(point1.X, point1.Y + 1);
                if (!pointSet.Contains(point2))
                  pointList2.Add(point2);
              }
            }
          }
        }
      }

      public static void Gem(int x, int y)
      {
        if (!WorldGen.InWorld(x, y, 0))
          return;
        List<Point> pointList1 = new List<Point>();
        List<Point> pointList2 = new List<Point>();
        HashSet<Point> pointSet = new HashSet<Point>();
        pointList2.Add(new Point(x, y));
        while (pointList2.Count > 0)
        {
          pointList1.Clear();
          pointList1.AddRange((IEnumerable<Point>) pointList2);
          pointList2.Clear();
          while (pointList1.Count > 0)
          {
            Point point1 = pointList1[0];
            if (!WorldGen.InWorld(point1.X, point1.Y, 1))
            {
              pointList1.Remove(point1);
            }
            else
            {
              pointSet.Add(point1);
              pointList1.Remove(point1);
              Tile tile1 = Main.tile[point1.X, point1.Y];
              if (WorldGen.SolidTile(point1.X, point1.Y, false) || tile1.wall != (ushort) 0)
              {
                if (tile1.active())
                {
                  if (WorldGen.Spread.Gemmable((int) tile1.type))
                    tile1.type = WorldGen.randGemTile();
                  Tile tile2 = Main.tile[point1.X - 1, point1.Y];
                  if (WorldGen.Spread.Gemmable((int) tile2.type))
                    tile2.type = WorldGen.randGemTile();
                  Tile tile3 = Main.tile[point1.X + 1, point1.Y];
                  if (WorldGen.Spread.Gemmable((int) tile3.type))
                    tile3.type = WorldGen.randGemTile();
                  Tile tile4 = Main.tile[point1.X, point1.Y - 1];
                  if (WorldGen.Spread.Gemmable((int) tile4.type))
                    tile4.type = WorldGen.randGemTile();
                  Tile tile5 = Main.tile[point1.X, point1.Y + 1];
                  if (WorldGen.Spread.Gemmable((int) tile5.type))
                    tile5.type = WorldGen.randGemTile();
                }
              }
              else
              {
                tile1.wall = (ushort) (48 + WorldGen.randGem());
                if (!tile1.active() && WorldGen.genRand.Next(2) == 0)
                  WorldGen.PlaceTile(point1.X, point1.Y, 178, true, false, -1, WorldGen.randGem());
                Point point2 = new Point(point1.X - 1, point1.Y);
                if (!pointSet.Contains(point2))
                  pointList2.Add(point2);
                point2 = new Point(point1.X + 1, point1.Y);
                if (!pointSet.Contains(point2))
                  pointList2.Add(point2);
                point2 = new Point(point1.X, point1.Y - 1);
                if (!pointSet.Contains(point2))
                  pointList2.Add(point2);
                point2 = new Point(point1.X, point1.Y + 1);
                if (!pointSet.Contains(point2))
                  pointList2.Add(point2);
              }
            }
          }
        }
      }

      public static void Spider(int x, int y)
      {
        if (!WorldGen.InWorld(x, y, 0))
          return;
        byte num = 62;
        List<Point> pointList1 = new List<Point>();
        List<Point> pointList2 = new List<Point>();
        HashSet<Point> pointSet = new HashSet<Point>();
        pointList2.Add(new Point(x, y));
        while (pointList2.Count > 0)
        {
          pointList1.Clear();
          pointList1.AddRange((IEnumerable<Point>) pointList2);
          pointList2.Clear();
          while (pointList1.Count > 0)
          {
            Point point1 = pointList1[0];
            if (!WorldGen.InWorld(point1.X, point1.Y, 1))
            {
              pointList1.Remove(point1);
            }
            else
            {
              pointSet.Add(point1);
              pointList1.Remove(point1);
              Tile tile = Main.tile[point1.X, point1.Y];
              if (WorldGen.SolidTile(point1.X, point1.Y, false) || tile.wall != (ushort) 0)
              {
                if (tile.active() && tile.wall == (ushort) 0)
                  tile.wall = (ushort) num;
              }
              else
              {
                tile.wall = (ushort) num;
                WorldGen.SquareWallFrame(point1.X, point1.Y, true);
                if (!tile.active())
                {
                  tile.liquid = (byte) 0;
                  tile.lava(false);
                  if (WorldGen.SolidTile(point1.X, point1.Y + 1, false) && WorldGen.genRand.Next(3) == 0)
                  {
                    if (WorldGen.genRand.Next(15) == 0)
                      WorldGen.AddBuriedChest(point1.X, point1.Y, 939, true, 15, false, (ushort) 0);
                    else
                      WorldGen.PlacePot(point1.X, point1.Y, (ushort) 28, WorldGen.genRand.Next(19, 21));
                  }
                  if (!tile.active())
                  {
                    if (WorldGen.SolidTile(point1.X, point1.Y - 1, false) && WorldGen.genRand.Next(3) == 0)
                      WorldGen.PlaceTight(point1.X, point1.Y, true);
                    else if (WorldGen.SolidTile(point1.X, point1.Y + 1, false))
                    {
                      WorldGen.PlaceTile(point1.X, point1.Y, 187, true, false, -1, 9 + WorldGen.genRand.Next(5));
                      if (WorldGen.genRand.Next(3) == 0)
                      {
                        if (!tile.active())
                          WorldGen.PlaceSmallPile(point1.X, point1.Y, 34 + WorldGen.genRand.Next(4), 1, (ushort) 185);
                        if (!tile.active())
                          WorldGen.PlaceSmallPile(point1.X, point1.Y, 48 + WorldGen.genRand.Next(6), 0, (ushort) 185);
                      }
                    }
                  }
                }
                Point point2 = new Point(point1.X - 1, point1.Y);
                if (!pointSet.Contains(point2))
                  pointList2.Add(point2);
                point2 = new Point(point1.X + 1, point1.Y);
                if (!pointSet.Contains(point2))
                  pointList2.Add(point2);
                point2 = new Point(point1.X, point1.Y - 1);
                if (!pointSet.Contains(point2))
                  pointList2.Add(point2);
                point2 = new Point(point1.X, point1.Y + 1);
                if (!pointSet.Contains(point2))
                  pointList2.Add(point2);
              }
            }
          }
        }
      }

      public static void WallDungeon(int x, int y, int wallType)
      {
        if (!WorldGen.InWorld(x, y, 0))
          return;
        ushort num = (ushort) wallType;
        List<Point> pointList1 = new List<Point>();
        List<Point> pointList2 = new List<Point>();
        HashSet<Point> pointSet = new HashSet<Point>();
        pointList2.Add(new Point(x, y));
        while (pointList2.Count > 0)
        {
          pointList1.Clear();
          pointList1.AddRange((IEnumerable<Point>) pointList2);
          pointList2.Clear();
          while (pointList1.Count > 0)
          {
            Point point1 = pointList1[0];
            if (!WorldGen.InWorld(point1.X, point1.Y, 1))
            {
              pointList1.Remove(point1);
            }
            else
            {
              pointSet.Add(point1);
              pointList1.Remove(point1);
              Tile tile = Main.tile[point1.X, point1.Y];
              if (!WorldGen.SolidTile(point1.X, point1.Y, false) && (int) tile.wall != (int) num && (tile.wall > (ushort) 0 && tile.wall != (ushort) 244))
              {
                tile.wall = num;
                Point point2 = new Point(point1.X - 1, point1.Y);
                if (!pointSet.Contains(point2))
                  pointList2.Add(point2);
                point2 = new Point(point1.X + 1, point1.Y);
                if (!pointSet.Contains(point2))
                  pointList2.Add(point2);
                point2 = new Point(point1.X, point1.Y - 1);
                if (!pointSet.Contains(point2))
                  pointList2.Add(point2);
                point2 = new Point(point1.X, point1.Y + 1);
                if (!pointSet.Contains(point2))
                  pointList2.Add(point2);
              }
              else if (tile.active())
                tile.wall = num;
            }
          }
        }
      }

      private static bool Gemmable(int type)
      {
        return type == 0 || type == 1 || (type == 40 || type == 59) || (type == 60 || type == 70 || type == 147) || type == 161;
      }
    }

    public struct GrowTreeSettings
    {
      public ushort TreeTileType;
      public int TreeHeightMin;
      public int TreeHeightMax;
      public int TreeTopPaddingNeeded;
      public WorldGen.GrowTreeSettings.IsTileFitForTreeGroundTest GroundTest;
      public WorldGen.GrowTreeSettings.IsWallTypeFitForTreeBack WallTest;
      public ushort SaplingTileType;

      public delegate bool IsTileFitForTreeGroundTest(int tileType);

      public delegate bool IsWallTypeFitForTreeBack(int wallType);

      public static class Profiles
      {
        public static WorldGen.GrowTreeSettings GemTree_Ruby = new WorldGen.GrowTreeSettings()
        {
          GroundTest = new WorldGen.GrowTreeSettings.IsTileFitForTreeGroundTest(WorldGen.GemTreeGroundTest),
          WallTest = new WorldGen.GrowTreeSettings.IsWallTypeFitForTreeBack(WorldGen.GemTreeWallTest),
          TreeHeightMax = 12,
          TreeHeightMin = 7,
          TreeTileType = 587,
          TreeTopPaddingNeeded = 4,
          SaplingTileType = 590
        };
        public static WorldGen.GrowTreeSettings GemTree_Diamond = new WorldGen.GrowTreeSettings()
        {
          GroundTest = new WorldGen.GrowTreeSettings.IsTileFitForTreeGroundTest(WorldGen.GemTreeGroundTest),
          WallTest = new WorldGen.GrowTreeSettings.IsWallTypeFitForTreeBack(WorldGen.GemTreeWallTest),
          TreeHeightMax = 12,
          TreeHeightMin = 7,
          TreeTileType = 588,
          TreeTopPaddingNeeded = 4,
          SaplingTileType = 590
        };
        public static WorldGen.GrowTreeSettings GemTree_Topaz = new WorldGen.GrowTreeSettings()
        {
          GroundTest = new WorldGen.GrowTreeSettings.IsTileFitForTreeGroundTest(WorldGen.GemTreeGroundTest),
          WallTest = new WorldGen.GrowTreeSettings.IsWallTypeFitForTreeBack(WorldGen.GemTreeWallTest),
          TreeHeightMax = 12,
          TreeHeightMin = 7,
          TreeTileType = 583,
          TreeTopPaddingNeeded = 4,
          SaplingTileType = 590
        };
        public static WorldGen.GrowTreeSettings GemTree_Amethyst = new WorldGen.GrowTreeSettings()
        {
          GroundTest = new WorldGen.GrowTreeSettings.IsTileFitForTreeGroundTest(WorldGen.GemTreeGroundTest),
          WallTest = new WorldGen.GrowTreeSettings.IsWallTypeFitForTreeBack(WorldGen.GemTreeWallTest),
          TreeHeightMax = 12,
          TreeHeightMin = 7,
          TreeTileType = 584,
          TreeTopPaddingNeeded = 4,
          SaplingTileType = 590
        };
        public static WorldGen.GrowTreeSettings GemTree_Sappphire = new WorldGen.GrowTreeSettings()
        {
          GroundTest = new WorldGen.GrowTreeSettings.IsTileFitForTreeGroundTest(WorldGen.GemTreeGroundTest),
          WallTest = new WorldGen.GrowTreeSettings.IsWallTypeFitForTreeBack(WorldGen.GemTreeWallTest),
          TreeHeightMax = 12,
          TreeHeightMin = 7,
          TreeTileType = 585,
          TreeTopPaddingNeeded = 4,
          SaplingTileType = 590
        };
        public static WorldGen.GrowTreeSettings GemTree_Emerald = new WorldGen.GrowTreeSettings()
        {
          GroundTest = new WorldGen.GrowTreeSettings.IsTileFitForTreeGroundTest(WorldGen.GemTreeGroundTest),
          WallTest = new WorldGen.GrowTreeSettings.IsWallTypeFitForTreeBack(WorldGen.GemTreeWallTest),
          TreeHeightMax = 12,
          TreeHeightMin = 7,
          TreeTileType = 586,
          TreeTopPaddingNeeded = 4,
          SaplingTileType = 590
        };
        public static WorldGen.GrowTreeSettings GemTree_Amber = new WorldGen.GrowTreeSettings()
        {
          GroundTest = new WorldGen.GrowTreeSettings.IsTileFitForTreeGroundTest(WorldGen.GemTreeGroundTest),
          WallTest = new WorldGen.GrowTreeSettings.IsWallTypeFitForTreeBack(WorldGen.GemTreeWallTest),
          TreeHeightMax = 12,
          TreeHeightMin = 7,
          TreeTileType = 589,
          TreeTopPaddingNeeded = 4,
          SaplingTileType = 590
        };
        public static WorldGen.GrowTreeSettings VanityTree_Sakura = new WorldGen.GrowTreeSettings()
        {
          GroundTest = new WorldGen.GrowTreeSettings.IsTileFitForTreeGroundTest(WorldGen.VanityTreeGroundTest),
          WallTest = new WorldGen.GrowTreeSettings.IsWallTypeFitForTreeBack(WorldGen.DefaultTreeWallTest),
          TreeHeightMax = 12,
          TreeHeightMin = 7,
          TreeTileType = 596,
          TreeTopPaddingNeeded = 4,
          SaplingTileType = 595
        };
        public static WorldGen.GrowTreeSettings VanityTree_Willow = new WorldGen.GrowTreeSettings()
        {
          GroundTest = new WorldGen.GrowTreeSettings.IsTileFitForTreeGroundTest(WorldGen.VanityTreeGroundTest),
          WallTest = new WorldGen.GrowTreeSettings.IsWallTypeFitForTreeBack(WorldGen.DefaultTreeWallTest),
          TreeHeightMax = 12,
          TreeHeightMin = 7,
          TreeTileType = 616,
          TreeTopPaddingNeeded = 4,
          SaplingTileType = 615
        };

        public static bool TryGetFromItemId(int itemType, out WorldGen.GrowTreeSettings profile)
        {
          switch (itemType)
          {
            case 4851:
              profile = WorldGen.GrowTreeSettings.Profiles.GemTree_Topaz;
              return true;
            case 4852:
              profile = WorldGen.GrowTreeSettings.Profiles.GemTree_Amethyst;
              return true;
            case 4853:
              profile = WorldGen.GrowTreeSettings.Profiles.GemTree_Sappphire;
              return true;
            case 4854:
              profile = WorldGen.GrowTreeSettings.Profiles.GemTree_Emerald;
              return true;
            case 4855:
              profile = WorldGen.GrowTreeSettings.Profiles.GemTree_Ruby;
              return true;
            case 4856:
              profile = WorldGen.GrowTreeSettings.Profiles.GemTree_Diamond;
              return true;
            case 4857:
              profile = WorldGen.GrowTreeSettings.Profiles.GemTree_Amber;
              return true;
            case 4871:
              profile = WorldGen.GrowTreeSettings.Profiles.VanityTree_Sakura;
              return true;
            case 4907:
              profile = WorldGen.GrowTreeSettings.Profiles.VanityTree_Willow;
              return true;
            default:
              profile = new WorldGen.GrowTreeSettings();
              return false;
          }
        }
      }
    }

    public struct CheckTreeSettings
    {
      public WorldGen.CheckTreeSettings.GroundValidTest IsGroundValid;

      public delegate bool GroundValidTest(int groundTileType);
    }

    public enum SpecialKillTileContext
    {
      None,
      MowingTheGrass,
    }

    public delegate bool GetTreeFoliageDataMethod(
      int i,
      int j,
      int xoffset,
      ref int treeFrame,
      ref int treeStyle,
      out int floorY,
      out int topTextureFrameWidth,
      out int topTextureFrameHeight);
  }
}
